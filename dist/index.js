//#region rolldown:runtime
var __create$1 = Object.create;
var __defProp$8 = Object.defineProperty;
var __getOwnPropDesc$8 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$8 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames$8(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$8 = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames$8(from), i$1 = 0, n = keys.length, key; i$1 < n; i$1++) {
		key = keys[i$1];
		if (!__hasOwnProp$8.call(to, key) && key !== except) __defProp$8(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc$8(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$8(isNodeMode || !mod || !mod.__esModule ? __defProp$8(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const fs = __toESM$1(require("fs"));

//#region node_modules/@actions/core/lib/utils.js
var require_utils$4 = __commonJS({ "node_modules/@actions/core/lib/utils.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toCommandProperties = exports.toCommandValue = void 0;
	/**
	* Sanitizes an input into a string so it can be passed into issueCommand safely
	* @param input input to sanitize into a string
	*/
	function toCommandValue(input) {
		if (input === null || input === void 0) return "";
		else if (typeof input === "string" || input instanceof String) return input;
		return JSON.stringify(input);
	}
	exports.toCommandValue = toCommandValue;
	/**
	*
	* @param annotationProperties
	* @returns The command properties to send with the actual annotation command
	* See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
	*/
	function toCommandProperties(annotationProperties) {
		if (!Object.keys(annotationProperties).length) return {};
		return {
			title: annotationProperties.title,
			file: annotationProperties.file,
			line: annotationProperties.startLine,
			endLine: annotationProperties.endLine,
			col: annotationProperties.startColumn,
			endColumn: annotationProperties.endColumn
		};
	}
	exports.toCommandProperties = toCommandProperties;
} });

//#endregion
//#region node_modules/@actions/core/lib/command.js
var require_command = __commonJS({ "node_modules/@actions/core/lib/command.js"(exports) {
	var __createBinding$20 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$17 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$17 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$20(result, mod, k);
		}
		__setModuleDefault$17(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.issue = exports.issueCommand = void 0;
	const os$5 = __importStar$17(require("os"));
	const utils_1$4 = require_utils$4();
	/**
	* Commands
	*
	* Command Format:
	*   ::name key=value,key=value::message
	*
	* Examples:
	*   ::warning::This is the message
	*   ::set-env name=MY_VAR::some value
	*/
	function issueCommand(command, properties, message) {
		const cmd = new Command(command, properties, message);
		process.stdout.write(cmd.toString() + os$5.EOL);
	}
	exports.issueCommand = issueCommand;
	function issue(name, message = "") {
		issueCommand(name, {}, message);
	}
	exports.issue = issue;
	const CMD_STRING = "::";
	var Command = class {
		constructor(command, properties, message) {
			if (!command) command = "missing.command";
			this.command = command;
			this.properties = properties;
			this.message = message;
		}
		toString() {
			let cmdStr = CMD_STRING + this.command;
			if (this.properties && Object.keys(this.properties).length > 0) {
				cmdStr += " ";
				let first = true;
				for (const key in this.properties) if (this.properties.hasOwnProperty(key)) {
					const val = this.properties[key];
					if (val) {
						if (first) first = false;
						else cmdStr += ",";
						cmdStr += `${key}=${escapeProperty(val)}`;
					}
				}
			}
			cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
			return cmdStr;
		}
	};
	function escapeData(s$1) {
		return (0, utils_1$4.toCommandValue)(s$1).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
	}
	function escapeProperty(s$1) {
		return (0, utils_1$4.toCommandValue)(s$1).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
	}
} });

//#endregion
//#region node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({ "node_modules/@actions/core/lib/file-command.js"(exports) {
	var __createBinding$19 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$16 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$16 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$19(result, mod, k);
		}
		__setModuleDefault$16(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
	const crypto$7 = __importStar$16(require("crypto"));
	const fs$8 = __importStar$16(require("fs"));
	const os$4 = __importStar$16(require("os"));
	const utils_1$3 = require_utils$4();
	function issueFileCommand(command, message) {
		const filePath = process.env[`GITHUB_${command}`];
		if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);
		if (!fs$8.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);
		fs$8.appendFileSync(filePath, `${(0, utils_1$3.toCommandValue)(message)}${os$4.EOL}`, { encoding: "utf8" });
	}
	exports.issueFileCommand = issueFileCommand;
	function prepareKeyValueMessage(key, value) {
		const delimiter = `ghadelimiter_${crypto$7.randomUUID()}`;
		const convertedValue = (0, utils_1$3.toCommandValue)(value);
		if (key.includes(delimiter)) throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
		if (convertedValue.includes(delimiter)) throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
		return `${key}<<${delimiter}${os$4.EOL}${convertedValue}${os$4.EOL}${delimiter}`;
	}
	exports.prepareKeyValueMessage = prepareKeyValueMessage;
} });

//#endregion
//#region node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({ "node_modules/@actions/http-client/lib/proxy.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkBypass = exports.getProxyUrl = void 0;
	function getProxyUrl$1(reqUrl) {
		const usingSsl = reqUrl.protocol === "https:";
		if (checkBypass(reqUrl)) return void 0;
		const proxyVar = (() => {
			if (usingSsl) return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
			else return process.env["http_proxy"] || process.env["HTTP_PROXY"];
		})();
		if (proxyVar) try {
			return new DecodedURL(proxyVar);
		} catch (_a$5) {
			if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://")) return new DecodedURL(`http://${proxyVar}`);
		}
		else return void 0;
	}
	exports.getProxyUrl = getProxyUrl$1;
	function checkBypass(reqUrl) {
		if (!reqUrl.hostname) return false;
		const reqHost = reqUrl.hostname;
		if (isLoopbackAddress(reqHost)) return true;
		const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
		if (!noProxy) return false;
		let reqPort;
		if (reqUrl.port) reqPort = Number(reqUrl.port);
		else if (reqUrl.protocol === "http:") reqPort = 80;
		else if (reqUrl.protocol === "https:") reqPort = 443;
		const upperReqHosts = [reqUrl.hostname.toUpperCase()];
		if (typeof reqPort === "number") upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
		for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) return true;
		return false;
	}
	exports.checkBypass = checkBypass;
	function isLoopbackAddress(host) {
		const hostLower = host.toLowerCase();
		return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
	}
	var DecodedURL = class extends URL {
		constructor(url, base) {
			super(url, base);
			this._decodedUsername = decodeURIComponent(super.username);
			this._decodedPassword = decodeURIComponent(super.password);
		}
		get username() {
			return this._decodedUsername;
		}
		get password() {
			return this._decodedPassword;
		}
	};
} });

//#endregion
//#region node_modules/tunnel/lib/tunnel.js
var require_tunnel$1 = __commonJS({ "node_modules/tunnel/lib/tunnel.js"(exports) {
	var net$6 = require("net");
	var tls$3 = require("tls");
	var http$7 = require("http");
	var https$4 = require("https");
	var events$1 = require("events");
	var assert$20 = require("assert");
	var util$23 = require("util");
	exports.httpOverHttp = httpOverHttp;
	exports.httpsOverHttp = httpsOverHttp;
	exports.httpOverHttps = httpOverHttps;
	exports.httpsOverHttps = httpsOverHttps;
	function httpOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$7.request;
		return agent;
	}
	function httpsOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$7.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function httpOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$4.request;
		return agent;
	}
	function httpsOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$4.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function TunnelingAgent(options) {
		var self$1 = this;
		self$1.options = options || {};
		self$1.proxyOptions = self$1.options.proxy || {};
		self$1.maxSockets = self$1.options.maxSockets || http$7.Agent.defaultMaxSockets;
		self$1.requests = [];
		self$1.sockets = [];
		self$1.on("free", function onFree(socket, host, port, localAddress) {
			var options$1 = toOptions(host, port, localAddress);
			for (var i$1 = 0, len$1 = self$1.requests.length; i$1 < len$1; ++i$1) {
				var pending = self$1.requests[i$1];
				if (pending.host === options$1.host && pending.port === options$1.port) {
					self$1.requests.splice(i$1, 1);
					pending.request.onSocket(socket);
					return;
				}
			}
			socket.destroy();
			self$1.removeSocket(socket);
		});
	}
	util$23.inherits(TunnelingAgent, events$1.EventEmitter);
	TunnelingAgent.prototype.addRequest = function addRequest(req$1, host, port, localAddress) {
		var self$1 = this;
		var options = mergeOptions({ request: req$1 }, self$1.options, toOptions(host, port, localAddress));
		if (self$1.sockets.length >= this.maxSockets) {
			self$1.requests.push(options);
			return;
		}
		self$1.createSocket(options, function(socket) {
			socket.on("free", onFree);
			socket.on("close", onCloseOrRemove);
			socket.on("agentRemove", onCloseOrRemove);
			req$1.onSocket(socket);
			function onFree() {
				self$1.emit("free", socket, options);
			}
			function onCloseOrRemove(err) {
				self$1.removeSocket(socket);
				socket.removeListener("free", onFree);
				socket.removeListener("close", onCloseOrRemove);
				socket.removeListener("agentRemove", onCloseOrRemove);
			}
		});
	};
	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
		var self$1 = this;
		var placeholder = {};
		self$1.sockets.push(placeholder);
		var connectOptions = mergeOptions({}, self$1.proxyOptions, {
			method: "CONNECT",
			path: options.host + ":" + options.port,
			agent: false,
			headers: { host: options.host + ":" + options.port }
		});
		if (options.localAddress) connectOptions.localAddress = options.localAddress;
		if (connectOptions.proxyAuth) {
			connectOptions.headers = connectOptions.headers || {};
			connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
		}
		debug$3("making CONNECT request");
		var connectReq = self$1.request(connectOptions);
		connectReq.useChunkedEncodingByDefault = false;
		connectReq.once("response", onResponse);
		connectReq.once("upgrade", onUpgrade);
		connectReq.once("connect", onConnect);
		connectReq.once("error", onError$2);
		connectReq.end();
		function onResponse(res) {
			res.upgrade = true;
		}
		function onUpgrade(res, socket, head) {
			process.nextTick(function() {
				onConnect(res, socket, head);
			});
		}
		function onConnect(res, socket, head) {
			connectReq.removeAllListeners();
			socket.removeAllListeners();
			if (res.statusCode !== 200) {
				debug$3("tunneling socket could not be established, statusCode=%d", res.statusCode);
				socket.destroy();
				var error$1 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
				error$1.code = "ECONNRESET";
				options.request.emit("error", error$1);
				self$1.removeSocket(placeholder);
				return;
			}
			if (head.length > 0) {
				debug$3("got illegal response body from proxy");
				socket.destroy();
				var error$1 = new Error("got illegal response body from proxy");
				error$1.code = "ECONNRESET";
				options.request.emit("error", error$1);
				self$1.removeSocket(placeholder);
				return;
			}
			debug$3("tunneling connection has established");
			self$1.sockets[self$1.sockets.indexOf(placeholder)] = socket;
			return cb(socket);
		}
		function onError$2(cause) {
			connectReq.removeAllListeners();
			debug$3("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
			var error$1 = new Error("tunneling socket could not be established, cause=" + cause.message);
			error$1.code = "ECONNRESET";
			options.request.emit("error", error$1);
			self$1.removeSocket(placeholder);
		}
	};
	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
		var pos = this.sockets.indexOf(socket);
		if (pos === -1) return;
		this.sockets.splice(pos, 1);
		var pending = this.requests.shift();
		if (pending) this.createSocket(pending, function(socket$1) {
			pending.request.onSocket(socket$1);
		});
	};
	function createSecureSocket(options, cb) {
		var self$1 = this;
		TunnelingAgent.prototype.createSocket.call(self$1, options, function(socket) {
			var hostHeader = options.request.getHeader("host");
			var tlsOptions = mergeOptions({}, self$1.options, {
				socket,
				servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
			});
			var secureSocket = tls$3.connect(0, tlsOptions);
			self$1.sockets[self$1.sockets.indexOf(socket)] = secureSocket;
			cb(secureSocket);
		});
	}
	function toOptions(host, port, localAddress) {
		if (typeof host === "string") return {
			host,
			port,
			localAddress
		};
		return host;
	}
	function mergeOptions(target) {
		for (var i$1 = 1, len$1 = arguments.length; i$1 < len$1; ++i$1) {
			var overrides = arguments[i$1];
			if (typeof overrides === "object") {
				var keys = Object.keys(overrides);
				for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
					var k = keys[j];
					if (overrides[k] !== void 0) target[k] = overrides[k];
				}
			}
		}
		return target;
	}
	var debug$3;
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) debug$3 = function() {
		var args = Array.prototype.slice.call(arguments);
		if (typeof args[0] === "string") args[0] = "TUNNEL: " + args[0];
		else args.unshift("TUNNEL:");
		console.error.apply(console, args);
	};
	else debug$3 = function() {};
	exports.debug = debug$3;
} });

//#endregion
//#region node_modules/tunnel/index.js
var require_tunnel = __commonJS({ "node_modules/tunnel/index.js"(exports, module) {
	module.exports = require_tunnel$1();
} });

//#endregion
//#region node_modules/undici/lib/core/symbols.js
var require_symbols$4 = __commonJS({ "node_modules/undici/lib/core/symbols.js"(exports, module) {
	module.exports = {
		kClose: Symbol("close"),
		kDestroy: Symbol("destroy"),
		kDispatch: Symbol("dispatch"),
		kUrl: Symbol("url"),
		kWriting: Symbol("writing"),
		kResuming: Symbol("resuming"),
		kQueue: Symbol("queue"),
		kConnect: Symbol("connect"),
		kConnecting: Symbol("connecting"),
		kHeadersList: Symbol("headers list"),
		kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
		kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
		kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
		kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
		kKeepAlive: Symbol("keep alive"),
		kHeadersTimeout: Symbol("headers timeout"),
		kBodyTimeout: Symbol("body timeout"),
		kServerName: Symbol("server name"),
		kLocalAddress: Symbol("local address"),
		kHost: Symbol("host"),
		kNoRef: Symbol("no ref"),
		kBodyUsed: Symbol("used"),
		kRunning: Symbol("running"),
		kBlocking: Symbol("blocking"),
		kPending: Symbol("pending"),
		kSize: Symbol("size"),
		kBusy: Symbol("busy"),
		kQueued: Symbol("queued"),
		kFree: Symbol("free"),
		kConnected: Symbol("connected"),
		kClosed: Symbol("closed"),
		kNeedDrain: Symbol("need drain"),
		kReset: Symbol("reset"),
		kDestroyed: Symbol.for("nodejs.stream.destroyed"),
		kMaxHeadersSize: Symbol("max headers size"),
		kRunningIdx: Symbol("running index"),
		kPendingIdx: Symbol("pending index"),
		kError: Symbol("error"),
		kClients: Symbol("clients"),
		kClient: Symbol("client"),
		kParser: Symbol("parser"),
		kOnDestroyed: Symbol("destroy callbacks"),
		kPipelining: Symbol("pipelining"),
		kSocket: Symbol("socket"),
		kHostHeader: Symbol("host header"),
		kConnector: Symbol("connector"),
		kStrictContentLength: Symbol("strict content length"),
		kMaxRedirections: Symbol("maxRedirections"),
		kMaxRequests: Symbol("maxRequestsPerClient"),
		kProxy: Symbol("proxy agent options"),
		kCounter: Symbol("socket request counter"),
		kInterceptors: Symbol("dispatch interceptors"),
		kMaxResponseSize: Symbol("max response size"),
		kHTTP2Session: Symbol("http2Session"),
		kHTTP2SessionState: Symbol("http2Session state"),
		kHTTP2BuildRequest: Symbol("http2 build request"),
		kHTTP1BuildRequest: Symbol("http1 build request"),
		kHTTP2CopyHeaders: Symbol("http2 copy headers"),
		kHTTPConnVersion: Symbol("http connection version"),
		kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
		kConstruct: Symbol("constructable")
	};
} });

//#endregion
//#region node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({ "node_modules/undici/lib/core/errors.js"(exports, module) {
	var UndiciError$2 = class extends Error {
		constructor(message) {
			super(message);
			this.name = "UndiciError";
			this.code = "UND_ERR";
		}
	};
	var ConnectTimeoutError$1 = class ConnectTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ConnectTimeoutError$1);
			this.name = "ConnectTimeoutError";
			this.message = message || "Connect Timeout Error";
			this.code = "UND_ERR_CONNECT_TIMEOUT";
		}
	};
	var HeadersTimeoutError$1 = class HeadersTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersTimeoutError$1);
			this.name = "HeadersTimeoutError";
			this.message = message || "Headers Timeout Error";
			this.code = "UND_ERR_HEADERS_TIMEOUT";
		}
	};
	var HeadersOverflowError$1 = class HeadersOverflowError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersOverflowError$1);
			this.name = "HeadersOverflowError";
			this.message = message || "Headers Overflow Error";
			this.code = "UND_ERR_HEADERS_OVERFLOW";
		}
	};
	var BodyTimeoutError$1 = class BodyTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, BodyTimeoutError$1);
			this.name = "BodyTimeoutError";
			this.message = message || "Body Timeout Error";
			this.code = "UND_ERR_BODY_TIMEOUT";
		}
	};
	var ResponseStatusCodeError$1 = class ResponseStatusCodeError$1 extends UndiciError$2 {
		constructor(message, statusCode, headers, body) {
			super(message);
			Error.captureStackTrace(this, ResponseStatusCodeError$1);
			this.name = "ResponseStatusCodeError";
			this.message = message || "Response Status Code Error";
			this.code = "UND_ERR_RESPONSE_STATUS_CODE";
			this.body = body;
			this.status = statusCode;
			this.statusCode = statusCode;
			this.headers = headers;
		}
	};
	var InvalidArgumentError$22 = class InvalidArgumentError$22 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidArgumentError$22);
			this.name = "InvalidArgumentError";
			this.message = message || "Invalid Argument Error";
			this.code = "UND_ERR_INVALID_ARG";
		}
	};
	var InvalidReturnValueError$2 = class InvalidReturnValueError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidReturnValueError$2);
			this.name = "InvalidReturnValueError";
			this.message = message || "Invalid Return Value Error";
			this.code = "UND_ERR_INVALID_RETURN_VALUE";
		}
	};
	var RequestAbortedError$9 = class RequestAbortedError$9 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestAbortedError$9);
			this.name = "AbortError";
			this.message = message || "Request aborted";
			this.code = "UND_ERR_ABORTED";
		}
	};
	var InformationalError$1 = class InformationalError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InformationalError$1);
			this.name = "InformationalError";
			this.message = message || "Request information";
			this.code = "UND_ERR_INFO";
		}
	};
	var RequestContentLengthMismatchError$1 = class RequestContentLengthMismatchError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestContentLengthMismatchError$1);
			this.name = "RequestContentLengthMismatchError";
			this.message = message || "Request body length does not match content-length header";
			this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ResponseContentLengthMismatchError$1 = class ResponseContentLengthMismatchError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ResponseContentLengthMismatchError$1);
			this.name = "ResponseContentLengthMismatchError";
			this.message = message || "Response body length does not match content-length header";
			this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ClientDestroyedError$2 = class ClientDestroyedError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientDestroyedError$2);
			this.name = "ClientDestroyedError";
			this.message = message || "The client is destroyed";
			this.code = "UND_ERR_DESTROYED";
		}
	};
	var ClientClosedError$1 = class ClientClosedError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientClosedError$1);
			this.name = "ClientClosedError";
			this.message = message || "The client is closed";
			this.code = "UND_ERR_CLOSED";
		}
	};
	var SocketError$3 = class SocketError$3 extends UndiciError$2 {
		constructor(message, socket) {
			super(message);
			Error.captureStackTrace(this, SocketError$3);
			this.name = "SocketError";
			this.message = message || "Socket error";
			this.code = "UND_ERR_SOCKET";
			this.socket = socket;
		}
	};
	var NotSupportedError$2 = class NotSupportedError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError$2);
			this.name = "NotSupportedError";
			this.message = message || "Not supported error";
			this.code = "UND_ERR_NOT_SUPPORTED";
		}
	};
	var BalancedPoolMissingUpstreamError$1 = class extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError$2);
			this.name = "MissingUpstreamError";
			this.message = message || "No upstream has been added to the BalancedPool";
			this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
		}
	};
	var HTTPParserError$1 = class HTTPParserError$1 extends Error {
		constructor(message, code$1, data) {
			super(message);
			Error.captureStackTrace(this, HTTPParserError$1);
			this.name = "HTTPParserError";
			this.code = code$1 ? `HPE_${code$1}` : void 0;
			this.data = data ? data.toString() : void 0;
		}
	};
	var ResponseExceededMaxSizeError$1 = class ResponseExceededMaxSizeError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ResponseExceededMaxSizeError$1);
			this.name = "ResponseExceededMaxSizeError";
			this.message = message || "Response content exceeded max size";
			this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
		}
	};
	var RequestRetryError$1 = class RequestRetryError$1 extends UndiciError$2 {
		constructor(message, code$1, { headers, data }) {
			super(message);
			Error.captureStackTrace(this, RequestRetryError$1);
			this.name = "RequestRetryError";
			this.message = message || "Request retry error";
			this.code = "UND_ERR_REQ_RETRY";
			this.statusCode = code$1;
			this.data = data;
			this.headers = headers;
		}
	};
	module.exports = {
		HTTPParserError: HTTPParserError$1,
		UndiciError: UndiciError$2,
		HeadersTimeoutError: HeadersTimeoutError$1,
		HeadersOverflowError: HeadersOverflowError$1,
		BodyTimeoutError: BodyTimeoutError$1,
		RequestContentLengthMismatchError: RequestContentLengthMismatchError$1,
		ConnectTimeoutError: ConnectTimeoutError$1,
		ResponseStatusCodeError: ResponseStatusCodeError$1,
		InvalidArgumentError: InvalidArgumentError$22,
		InvalidReturnValueError: InvalidReturnValueError$2,
		RequestAbortedError: RequestAbortedError$9,
		ClientDestroyedError: ClientDestroyedError$2,
		ClientClosedError: ClientClosedError$1,
		InformationalError: InformationalError$1,
		SocketError: SocketError$3,
		NotSupportedError: NotSupportedError$2,
		ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1,
		BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError$1,
		ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$1,
		RequestRetryError: RequestRetryError$1
	};
} });

//#endregion
//#region node_modules/undici/lib/core/constants.js
var require_constants$5 = __commonJS({ "node_modules/undici/lib/core/constants.js"(exports, module) {
	/** @type {Record<string, string | undefined>} */
	const headerNameLowerCasedRecord$1 = {};
	const wellknownHeaderNames = [
		"Accept",
		"Accept-Encoding",
		"Accept-Language",
		"Accept-Ranges",
		"Access-Control-Allow-Credentials",
		"Access-Control-Allow-Headers",
		"Access-Control-Allow-Methods",
		"Access-Control-Allow-Origin",
		"Access-Control-Expose-Headers",
		"Access-Control-Max-Age",
		"Access-Control-Request-Headers",
		"Access-Control-Request-Method",
		"Age",
		"Allow",
		"Alt-Svc",
		"Alt-Used",
		"Authorization",
		"Cache-Control",
		"Clear-Site-Data",
		"Connection",
		"Content-Disposition",
		"Content-Encoding",
		"Content-Language",
		"Content-Length",
		"Content-Location",
		"Content-Range",
		"Content-Security-Policy",
		"Content-Security-Policy-Report-Only",
		"Content-Type",
		"Cookie",
		"Cross-Origin-Embedder-Policy",
		"Cross-Origin-Opener-Policy",
		"Cross-Origin-Resource-Policy",
		"Date",
		"Device-Memory",
		"Downlink",
		"ECT",
		"ETag",
		"Expect",
		"Expect-CT",
		"Expires",
		"Forwarded",
		"From",
		"Host",
		"If-Match",
		"If-Modified-Since",
		"If-None-Match",
		"If-Range",
		"If-Unmodified-Since",
		"Keep-Alive",
		"Last-Modified",
		"Link",
		"Location",
		"Max-Forwards",
		"Origin",
		"Permissions-Policy",
		"Pragma",
		"Proxy-Authenticate",
		"Proxy-Authorization",
		"RTT",
		"Range",
		"Referer",
		"Referrer-Policy",
		"Refresh",
		"Retry-After",
		"Sec-WebSocket-Accept",
		"Sec-WebSocket-Extensions",
		"Sec-WebSocket-Key",
		"Sec-WebSocket-Protocol",
		"Sec-WebSocket-Version",
		"Server",
		"Server-Timing",
		"Service-Worker-Allowed",
		"Service-Worker-Navigation-Preload",
		"Set-Cookie",
		"SourceMap",
		"Strict-Transport-Security",
		"Supports-Loading-Mode",
		"TE",
		"Timing-Allow-Origin",
		"Trailer",
		"Transfer-Encoding",
		"Upgrade",
		"Upgrade-Insecure-Requests",
		"User-Agent",
		"Vary",
		"Via",
		"WWW-Authenticate",
		"X-Content-Type-Options",
		"X-DNS-Prefetch-Control",
		"X-Frame-Options",
		"X-Permitted-Cross-Domain-Policies",
		"X-Powered-By",
		"X-Requested-With",
		"X-XSS-Protection"
	];
	for (let i$1 = 0; i$1 < wellknownHeaderNames.length; ++i$1) {
		const key = wellknownHeaderNames[i$1];
		const lowerCasedKey = key.toLowerCase();
		headerNameLowerCasedRecord$1[key] = headerNameLowerCasedRecord$1[lowerCasedKey] = lowerCasedKey;
	}
	Object.setPrototypeOf(headerNameLowerCasedRecord$1, null);
	module.exports = {
		wellknownHeaderNames,
		headerNameLowerCasedRecord: headerNameLowerCasedRecord$1
	};
} });

//#endregion
//#region node_modules/undici/lib/core/util.js
var require_util$8 = __commonJS({ "node_modules/undici/lib/core/util.js"(exports, module) {
	const assert$19 = require("assert");
	const { kDestroyed: kDestroyed$1, kBodyUsed: kBodyUsed$2 } = require_symbols$4();
	const { IncomingMessage } = require("http");
	const stream$5 = require("stream");
	const net$5 = require("net");
	const { InvalidArgumentError: InvalidArgumentError$21 } = require_errors();
	const { Blob: Blob$6 } = require("buffer");
	const nodeUtil = require("util");
	const { stringify: stringify$3 } = require("querystring");
	const { headerNameLowerCasedRecord } = require_constants$5();
	const [nodeMajor$1, nodeMinor$1] = process.versions.node.split(".").map((v) => Number(v));
	function nop$1() {}
	function isStream$1(obj) {
		return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
	}
	function isBlobLike$7(object) {
		return Blob$6 && object instanceof Blob$6 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
	}
	function buildURL$2(url, queryParams) {
		if (url.includes("?") || url.includes("#")) throw new Error("Query params cannot be passed when url already contains \"?\" or \"#\".");
		const stringified = stringify$3(queryParams);
		if (stringified) url += "?" + stringified;
		return url;
	}
	function parseURL$1(url) {
		if (typeof url === "string") {
			url = new URL(url);
			if (!/^https?:/.test(url.origin || url.protocol)) throw new InvalidArgumentError$21("Invalid URL protocol: the URL must start with `http:` or `https:`.");
			return url;
		}
		if (!url || typeof url !== "object") throw new InvalidArgumentError$21("Invalid URL: The URL argument must be a non-null object.");
		if (!/^https?:/.test(url.origin || url.protocol)) throw new InvalidArgumentError$21("Invalid URL protocol: the URL must start with `http:` or `https:`.");
		if (!(url instanceof URL)) {
			if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) throw new InvalidArgumentError$21("Invalid URL: port must be a valid integer or a string representation of an integer.");
			if (url.path != null && typeof url.path !== "string") throw new InvalidArgumentError$21("Invalid URL path: the path must be a string or null/undefined.");
			if (url.pathname != null && typeof url.pathname !== "string") throw new InvalidArgumentError$21("Invalid URL pathname: the pathname must be a string or null/undefined.");
			if (url.hostname != null && typeof url.hostname !== "string") throw new InvalidArgumentError$21("Invalid URL hostname: the hostname must be a string or null/undefined.");
			if (url.origin != null && typeof url.origin !== "string") throw new InvalidArgumentError$21("Invalid URL origin: the origin must be a string or null/undefined.");
			const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
			let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
			let path$8 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
			if (origin.endsWith("/")) origin = origin.substring(0, origin.length - 1);
			if (path$8 && !path$8.startsWith("/")) path$8 = `/${path$8}`;
			url = new URL(origin + path$8);
		}
		return url;
	}
	function parseOrigin$1(url) {
		url = parseURL$1(url);
		if (url.pathname !== "/" || url.search || url.hash) throw new InvalidArgumentError$21("invalid url");
		return url;
	}
	function getHostname(host) {
		if (host[0] === "[") {
			const idx$1 = host.indexOf("]");
			assert$19(idx$1 !== -1);
			return host.substring(1, idx$1);
		}
		const idx = host.indexOf(":");
		if (idx === -1) return host;
		return host.substring(0, idx);
	}
	function getServerName(host) {
		if (!host) return null;
		assert$19.strictEqual(typeof host, "string");
		const servername = getHostname(host);
		if (net$5.isIP(servername)) return "";
		return servername;
	}
	function deepClone(obj) {
		return JSON.parse(JSON.stringify(obj));
	}
	function isAsyncIterable(obj) {
		return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
	}
	function isIterable(obj) {
		return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
	}
	function bodyLength(body) {
		if (body == null) return 0;
		else if (isStream$1(body)) {
			const state = body._readableState;
			return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
		} else if (isBlobLike$7(body)) return body.size != null ? body.size : null;
		else if (isBuffer(body)) return body.byteLength;
		return null;
	}
	function isDestroyed(stream$6) {
		return !stream$6 || !!(stream$6.destroyed || stream$6[kDestroyed$1]);
	}
	function isReadableAborted(stream$6) {
		const state = stream$6 && stream$6._readableState;
		return isDestroyed(stream$6) && state && !state.endEmitted;
	}
	function destroy(stream$6, err) {
		if (stream$6 == null || !isStream$1(stream$6) || isDestroyed(stream$6)) return;
		if (typeof stream$6.destroy === "function") {
			if (Object.getPrototypeOf(stream$6).constructor === IncomingMessage) stream$6.socket = null;
			stream$6.destroy(err);
		} else if (err) process.nextTick((stream$7, err$1) => {
			stream$7.emit("error", err$1);
		}, stream$6, err);
		if (stream$6.destroyed !== true) stream$6[kDestroyed$1] = true;
	}
	const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
	function parseKeepAliveTimeout(val) {
		const m$1 = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
		return m$1 ? parseInt(m$1[1], 10) * 1e3 : null;
	}
	/**
	* Retrieves a header name and returns its lowercase value.
	* @param {string | Buffer} value Header name
	* @returns {string}
	*/
	function headerNameToString(value) {
		return headerNameLowerCasedRecord[value] || value.toLowerCase();
	}
	function parseHeaders$1(headers, obj = {}) {
		if (!Array.isArray(headers)) return headers;
		for (let i$1 = 0; i$1 < headers.length; i$1 += 2) {
			const key = headers[i$1].toString().toLowerCase();
			let val = obj[key];
			if (!val) if (Array.isArray(headers[i$1 + 1])) obj[key] = headers[i$1 + 1].map((x) => x.toString("utf8"));
			else obj[key] = headers[i$1 + 1].toString("utf8");
			else {
				if (!Array.isArray(val)) {
					val = [val];
					obj[key] = val;
				}
				val.push(headers[i$1 + 1].toString("utf8"));
			}
		}
		if ("content-length" in obj && "content-disposition" in obj) obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
		return obj;
	}
	function parseRawHeaders(headers) {
		const ret = [];
		let hasContentLength = false;
		let contentDispositionIdx = -1;
		for (let n = 0; n < headers.length; n += 2) {
			const key = headers[n + 0].toString();
			const val = headers[n + 1].toString("utf8");
			if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
				ret.push(key, val);
				hasContentLength = true;
			} else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) contentDispositionIdx = ret.push(key, val) - 1;
			else ret.push(key, val);
		}
		if (hasContentLength && contentDispositionIdx !== -1) ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
		return ret;
	}
	function isBuffer(buffer$1) {
		return buffer$1 instanceof Uint8Array || Buffer.isBuffer(buffer$1);
	}
	function validateHandler(handler$1, method, upgrade$1) {
		if (!handler$1 || typeof handler$1 !== "object") throw new InvalidArgumentError$21("handler must be an object");
		if (typeof handler$1.onConnect !== "function") throw new InvalidArgumentError$21("invalid onConnect method");
		if (typeof handler$1.onError !== "function") throw new InvalidArgumentError$21("invalid onError method");
		if (typeof handler$1.onBodySent !== "function" && handler$1.onBodySent !== void 0) throw new InvalidArgumentError$21("invalid onBodySent method");
		if (upgrade$1 || method === "CONNECT") {
			if (typeof handler$1.onUpgrade !== "function") throw new InvalidArgumentError$21("invalid onUpgrade method");
		} else {
			if (typeof handler$1.onHeaders !== "function") throw new InvalidArgumentError$21("invalid onHeaders method");
			if (typeof handler$1.onData !== "function") throw new InvalidArgumentError$21("invalid onData method");
			if (typeof handler$1.onComplete !== "function") throw new InvalidArgumentError$21("invalid onComplete method");
		}
	}
	function isDisturbed$2(body) {
		return !!(body && (stream$5.isDisturbed ? stream$5.isDisturbed(body) || body[kBodyUsed$2] : body[kBodyUsed$2] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
	}
	function isErrored$2(body) {
		return !!(body && (stream$5.isErrored ? stream$5.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
	}
	function isReadable$1(body) {
		return !!(body && (stream$5.isReadable ? stream$5.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
	}
	function getSocketInfo(socket) {
		return {
			localAddress: socket.localAddress,
			localPort: socket.localPort,
			remoteAddress: socket.remoteAddress,
			remotePort: socket.remotePort,
			remoteFamily: socket.remoteFamily,
			timeout: socket.timeout,
			bytesWritten: socket.bytesWritten,
			bytesRead: socket.bytesRead
		};
	}
	async function* convertIterableToBuffer(iterable) {
		for await (const chunk of iterable) yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
	}
	let ReadableStream$5;
	function ReadableStreamFrom$3(iterable) {
		if (!ReadableStream$5) ReadableStream$5 = require("stream/web").ReadableStream;
		if (ReadableStream$5.from) return ReadableStream$5.from(convertIterableToBuffer(iterable));
		let iterator$1;
		return new ReadableStream$5({
			async start() {
				iterator$1 = iterable[Symbol.asyncIterator]();
			},
			async pull(controller) {
				const { done, value } = await iterator$1.next();
				if (done) queueMicrotask(() => {
					controller.close();
				});
				else {
					const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
					controller.enqueue(new Uint8Array(buf));
				}
				return controller.desiredSize > 0;
			},
			async cancel(reason) {
				await iterator$1.return();
			}
		}, 0);
	}
	function isFormDataLike(object) {
		return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
	}
	function throwIfAborted$1(signal) {
		if (!signal) return;
		if (typeof signal.throwIfAborted === "function") signal.throwIfAborted();
		else if (signal.aborted) {
			const err = new Error("The operation was aborted");
			err.name = "AbortError";
			throw err;
		}
	}
	function addAbortListener$2(signal, listener) {
		if ("addEventListener" in signal) {
			signal.addEventListener("abort", listener, { once: true });
			return () => signal.removeEventListener("abort", listener);
		}
		signal.addListener("abort", listener);
		return () => signal.removeListener("abort", listener);
	}
	const hasToWellFormed = !!String.prototype.toWellFormed;
	/**
	* @param {string} val
	*/
	function toUSVString$5(val) {
		if (hasToWellFormed) return `${val}`.toWellFormed();
		else if (nodeUtil.toUSVString) return nodeUtil.toUSVString(val);
		return `${val}`;
	}
	function parseRangeHeader$1(range) {
		if (range == null || range === "") return {
			start: 0,
			end: null,
			size: null
		};
		const m$1 = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
		return m$1 ? {
			start: parseInt(m$1[1]),
			end: m$1[2] ? parseInt(m$1[2]) : null,
			size: m$1[3] ? parseInt(m$1[3]) : null
		} : null;
	}
	const kEnumerableProperty$9 = Object.create(null);
	kEnumerableProperty$9.enumerable = true;
	module.exports = {
		kEnumerableProperty: kEnumerableProperty$9,
		nop: nop$1,
		isDisturbed: isDisturbed$2,
		isErrored: isErrored$2,
		isReadable: isReadable$1,
		toUSVString: toUSVString$5,
		isReadableAborted,
		isBlobLike: isBlobLike$7,
		parseOrigin: parseOrigin$1,
		parseURL: parseURL$1,
		getServerName,
		isStream: isStream$1,
		isIterable,
		isAsyncIterable,
		isDestroyed,
		headerNameToString,
		parseRawHeaders,
		parseHeaders: parseHeaders$1,
		parseKeepAliveTimeout,
		destroy,
		bodyLength,
		deepClone,
		ReadableStreamFrom: ReadableStreamFrom$3,
		isBuffer,
		validateHandler,
		getSocketInfo,
		isFormDataLike,
		buildURL: buildURL$2,
		throwIfAborted: throwIfAborted$1,
		addAbortListener: addAbortListener$2,
		parseRangeHeader: parseRangeHeader$1,
		nodeMajor: nodeMajor$1,
		nodeMinor: nodeMinor$1,
		nodeHasAutoSelectFamily: nodeMajor$1 > 18 || nodeMajor$1 === 18 && nodeMinor$1 >= 13,
		safeHTTPMethods: [
			"GET",
			"HEAD",
			"OPTIONS",
			"TRACE"
		]
	};
} });

//#endregion
//#region node_modules/undici/lib/timers.js
var require_timers = __commonJS({ "node_modules/undici/lib/timers.js"(exports, module) {
	let fastNow = Date.now();
	let fastNowTimeout;
	const fastTimers = [];
	function onTimeout() {
		fastNow = Date.now();
		let len$1 = fastTimers.length;
		let idx = 0;
		while (idx < len$1) {
			const timer = fastTimers[idx];
			if (timer.state === 0) timer.state = fastNow + timer.delay;
			else if (timer.state > 0 && fastNow >= timer.state) {
				timer.state = -1;
				timer.callback(timer.opaque);
			}
			if (timer.state === -1) {
				timer.state = -2;
				if (idx !== len$1 - 1) fastTimers[idx] = fastTimers.pop();
				else fastTimers.pop();
				len$1 -= 1;
			} else idx += 1;
		}
		if (fastTimers.length > 0) refreshTimeout();
	}
	function refreshTimeout() {
		if (fastNowTimeout && fastNowTimeout.refresh) fastNowTimeout.refresh();
		else {
			clearTimeout(fastNowTimeout);
			fastNowTimeout = setTimeout(onTimeout, 1e3);
			if (fastNowTimeout.unref) fastNowTimeout.unref();
		}
	}
	var Timeout = class {
		constructor(callback, delay, opaque) {
			this.callback = callback;
			this.delay = delay;
			this.opaque = opaque;
			this.state = -2;
			this.refresh();
		}
		refresh() {
			if (this.state === -2) {
				fastTimers.push(this);
				if (!fastNowTimeout || fastTimers.length === 1) refreshTimeout();
			}
			this.state = 0;
		}
		clear() {
			this.state = -1;
		}
	};
	module.exports = {
		setTimeout(callback, delay, opaque) {
			return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
		},
		clearTimeout(timeout) {
			if (timeout instanceof Timeout) timeout.clear();
			else clearTimeout(timeout);
		}
	};
} });

//#endregion
//#region node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({ "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports, module) {
	/**
	* Copyright Brian White. All rights reserved.
	*
	* @see https://github.com/mscdex/streamsearch
	*
	* Permission is hereby granted, free of charge, to any person obtaining a copy
	* of this software and associated documentation files (the "Software"), to
	* deal in the Software without restriction, including without limitation the
	* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	* sell copies of the Software, and to permit persons to whom the Software is
	* furnished to do so, subject to the following conditions:
	*
	* The above copyright notice and this permission notice shall be included in
	* all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	* IN THE SOFTWARE.
	*
	* Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
	* by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
	*/
	const EventEmitter$4 = require("node:events").EventEmitter;
	const inherits$5 = require("node:util").inherits;
	function SBMH(needle) {
		if (typeof needle === "string") needle = Buffer.from(needle);
		if (!Buffer.isBuffer(needle)) throw new TypeError("The needle has to be a String or a Buffer.");
		const needleLength = needle.length;
		if (needleLength === 0) throw new Error("The needle cannot be an empty String/Buffer.");
		if (needleLength > 256) throw new Error("The needle cannot have a length bigger than 256.");
		this.maxMatches = Infinity;
		this.matches = 0;
		this._occ = new Array(256).fill(needleLength);
		this._lookbehind_size = 0;
		this._needle = needle;
		this._bufpos = 0;
		this._lookbehind = Buffer.alloc(needleLength);
		for (var i$1 = 0; i$1 < needleLength - 1; ++i$1) this._occ[needle[i$1]] = needleLength - 1 - i$1;
	}
	inherits$5(SBMH, EventEmitter$4);
	SBMH.prototype.reset = function() {
		this._lookbehind_size = 0;
		this.matches = 0;
		this._bufpos = 0;
	};
	SBMH.prototype.push = function(chunk, pos) {
		if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, "binary");
		const chlen = chunk.length;
		this._bufpos = pos || 0;
		let r;
		while (r !== chlen && this.matches < this.maxMatches) r = this._sbmh_feed(chunk);
		return r;
	};
	SBMH.prototype._sbmh_feed = function(data) {
		const len$1 = data.length;
		const needle = this._needle;
		const needleLength = needle.length;
		const lastNeedleChar = needle[needleLength - 1];
		let pos = -this._lookbehind_size;
		let ch;
		if (pos < 0) {
			while (pos < 0 && pos <= len$1 - needleLength) {
				ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
				if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
					this._lookbehind_size = 0;
					++this.matches;
					this.emit("info", true);
					return this._bufpos = pos + needleLength;
				}
				pos += this._occ[ch];
			}
			if (pos < 0) while (pos < 0 && !this._sbmh_memcmp(data, pos, len$1 - pos)) ++pos;
			if (pos >= 0) {
				this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
				this._lookbehind_size = 0;
			} else {
				const bytesToCutOff = this._lookbehind_size + pos;
				if (bytesToCutOff > 0) this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
				this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
				this._lookbehind_size -= bytesToCutOff;
				data.copy(this._lookbehind, this._lookbehind_size);
				this._lookbehind_size += len$1;
				this._bufpos = len$1;
				return len$1;
			}
		}
		pos += (pos >= 0) * this._bufpos;
		if (data.indexOf(needle, pos) !== -1) {
			pos = data.indexOf(needle, pos);
			++this.matches;
			if (pos > 0) this.emit("info", true, data, this._bufpos, pos);
			else this.emit("info", true);
			return this._bufpos = pos + needleLength;
		} else pos = len$1 - needleLength;
		while (pos < len$1 && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len$1 - pos), needle.subarray(0, len$1 - pos)) !== 0)) ++pos;
		if (pos < len$1) {
			data.copy(this._lookbehind, 0, pos, pos + (len$1 - pos));
			this._lookbehind_size = len$1 - pos;
		}
		if (pos > 0) this.emit("info", false, data, this._bufpos, pos < len$1 ? pos : len$1);
		this._bufpos = len$1;
		return len$1;
	};
	SBMH.prototype._sbmh_lookup_char = function(data, pos) {
		return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
	};
	SBMH.prototype._sbmh_memcmp = function(data, pos, len$1) {
		for (var i$1 = 0; i$1 < len$1; ++i$1) if (this._sbmh_lookup_char(data, pos + i$1) !== this._needle[i$1]) return false;
		return true;
	};
	module.exports = SBMH;
} });

//#endregion
//#region node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({ "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports, module) {
	const inherits$4 = require("node:util").inherits;
	const ReadableStream$4 = require("node:stream").Readable;
	function PartStream$1(opts) {
		ReadableStream$4.call(this, opts);
	}
	inherits$4(PartStream$1, ReadableStream$4);
	PartStream$1.prototype._read = function(n) {};
	module.exports = PartStream$1;
} });

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({ "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports, module) {
	module.exports = function getLimit$3(limits, name, defaultLimit) {
		if (!limits || limits[name] === void 0 || limits[name] === null) return defaultLimit;
		if (typeof limits[name] !== "number" || isNaN(limits[name])) throw new TypeError("Limit " + name + " is not a valid number");
		return limits[name];
	};
} });

//#endregion
//#region node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({ "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports, module) {
	const EventEmitter$3 = require("node:events").EventEmitter;
	const inherits$3 = require("node:util").inherits;
	const getLimit$2 = require_getLimit();
	const StreamSearch$1 = require_sbmh();
	const B_DCRLF = Buffer.from("\r\n\r\n");
	const RE_CRLF = /\r\n/g;
	const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
	function HeaderParser$1(cfg) {
		EventEmitter$3.call(this);
		cfg = cfg || {};
		const self$1 = this;
		this.nread = 0;
		this.maxed = false;
		this.npairs = 0;
		this.maxHeaderPairs = getLimit$2(cfg, "maxHeaderPairs", 2e3);
		this.maxHeaderSize = getLimit$2(cfg, "maxHeaderSize", 80 * 1024);
		this.buffer = "";
		this.header = {};
		this.finished = false;
		this.ss = new StreamSearch$1(B_DCRLF);
		this.ss.on("info", function(isMatch, data, start, end) {
			if (data && !self$1.maxed) {
				if (self$1.nread + end - start >= self$1.maxHeaderSize) {
					end = self$1.maxHeaderSize - self$1.nread + start;
					self$1.nread = self$1.maxHeaderSize;
					self$1.maxed = true;
				} else self$1.nread += end - start;
				self$1.buffer += data.toString("binary", start, end);
			}
			if (isMatch) self$1._finish();
		});
	}
	inherits$3(HeaderParser$1, EventEmitter$3);
	HeaderParser$1.prototype.push = function(data) {
		const r = this.ss.push(data);
		if (this.finished) return r;
	};
	HeaderParser$1.prototype.reset = function() {
		this.finished = false;
		this.buffer = "";
		this.header = {};
		this.ss.reset();
	};
	HeaderParser$1.prototype._finish = function() {
		if (this.buffer) this._parseHeader();
		this.ss.matches = this.ss.maxMatches;
		const header = this.header;
		this.header = {};
		this.buffer = "";
		this.finished = true;
		this.nread = this.npairs = 0;
		this.maxed = false;
		this.emit("header", header);
	};
	HeaderParser$1.prototype._parseHeader = function() {
		if (this.npairs === this.maxHeaderPairs) return;
		const lines = this.buffer.split(RE_CRLF);
		const len$1 = lines.length;
		let m$1, h$1;
		for (var i$1 = 0; i$1 < len$1; ++i$1) {
			if (lines[i$1].length === 0) continue;
			if (lines[i$1][0] === "	" || lines[i$1][0] === " ") {
				if (h$1) {
					this.header[h$1][this.header[h$1].length - 1] += lines[i$1];
					continue;
				}
			}
			const posColon = lines[i$1].indexOf(":");
			if (posColon === -1 || posColon === 0) return;
			m$1 = RE_HDR.exec(lines[i$1]);
			h$1 = m$1[1].toLowerCase();
			this.header[h$1] = this.header[h$1] || [];
			this.header[h$1].push(m$1[2] || "");
			if (++this.npairs === this.maxHeaderPairs) break;
		}
	};
	module.exports = HeaderParser$1;
} });

//#endregion
//#region node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({ "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports, module) {
	const WritableStream$1 = require("node:stream").Writable;
	const inherits$2 = require("node:util").inherits;
	const StreamSearch = require_sbmh();
	const PartStream = require_PartStream();
	const HeaderParser = require_HeaderParser();
	const DASH = 45;
	const B_ONEDASH = Buffer.from("-");
	const B_CRLF = Buffer.from("\r\n");
	const EMPTY_FN = function() {};
	function Dicer$2(cfg) {
		if (!(this instanceof Dicer$2)) return new Dicer$2(cfg);
		WritableStream$1.call(this, cfg);
		if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") throw new TypeError("Boundary required");
		if (typeof cfg.boundary === "string") this.setBoundary(cfg.boundary);
		else this._bparser = void 0;
		this._headerFirst = cfg.headerFirst;
		this._dashes = 0;
		this._parts = 0;
		this._finished = false;
		this._realFinish = false;
		this._isPreamble = true;
		this._justMatched = false;
		this._firstWrite = true;
		this._inHeader = true;
		this._part = void 0;
		this._cb = void 0;
		this._ignoreData = false;
		this._partOpts = { highWaterMark: cfg.partHwm };
		this._pause = false;
		const self$1 = this;
		this._hparser = new HeaderParser(cfg);
		this._hparser.on("header", function(header) {
			self$1._inHeader = false;
			self$1._part.emit("header", header);
		});
	}
	inherits$2(Dicer$2, WritableStream$1);
	Dicer$2.prototype.emit = function(ev) {
		if (ev === "finish" && !this._realFinish) {
			if (!this._finished) {
				const self$1 = this;
				process.nextTick(function() {
					self$1.emit("error", new Error("Unexpected end of multipart data"));
					if (self$1._part && !self$1._ignoreData) {
						const type = self$1._isPreamble ? "Preamble" : "Part";
						self$1._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
						self$1._part.push(null);
						process.nextTick(function() {
							self$1._realFinish = true;
							self$1.emit("finish");
							self$1._realFinish = false;
						});
						return;
					}
					self$1._realFinish = true;
					self$1.emit("finish");
					self$1._realFinish = false;
				});
			}
		} else WritableStream$1.prototype.emit.apply(this, arguments);
	};
	Dicer$2.prototype._write = function(data, encoding, cb) {
		if (!this._hparser && !this._bparser) return cb();
		if (this._headerFirst && this._isPreamble) {
			if (!this._part) {
				this._part = new PartStream(this._partOpts);
				if (this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
				else this._ignore();
			}
			const r = this._hparser.push(data);
			if (!this._inHeader && r !== void 0 && r < data.length) data = data.slice(r);
			else return cb();
		}
		if (this._firstWrite) {
			this._bparser.push(B_CRLF);
			this._firstWrite = false;
		}
		this._bparser.push(data);
		if (this._pause) this._cb = cb;
		else cb();
	};
	Dicer$2.prototype.reset = function() {
		this._part = void 0;
		this._bparser = void 0;
		this._hparser = void 0;
	};
	Dicer$2.prototype.setBoundary = function(boundary) {
		const self$1 = this;
		this._bparser = new StreamSearch("\r\n--" + boundary);
		this._bparser.on("info", function(isMatch, data, start, end) {
			self$1._oninfo(isMatch, data, start, end);
		});
	};
	Dicer$2.prototype._ignore = function() {
		if (this._part && !this._ignoreData) {
			this._ignoreData = true;
			this._part.on("error", EMPTY_FN);
			this._part.resume();
		}
	};
	Dicer$2.prototype._oninfo = function(isMatch, data, start, end) {
		let buf;
		const self$1 = this;
		let i$1 = 0;
		let r;
		let shouldWriteMore = true;
		if (!this._part && this._justMatched && data) {
			while (this._dashes < 2 && start + i$1 < end) if (data[start + i$1] === DASH) {
				++i$1;
				++this._dashes;
			} else {
				if (this._dashes) buf = B_ONEDASH;
				this._dashes = 0;
				break;
			}
			if (this._dashes === 2) {
				if (start + i$1 < end && this.listenerCount("trailer") !== 0) this.emit("trailer", data.slice(start + i$1, end));
				this.reset();
				this._finished = true;
				if (self$1._parts === 0) {
					self$1._realFinish = true;
					self$1.emit("finish");
					self$1._realFinish = false;
				}
			}
			if (this._dashes) return;
		}
		if (this._justMatched) this._justMatched = false;
		if (!this._part) {
			this._part = new PartStream(this._partOpts);
			this._part._read = function(n) {
				self$1._unpause();
			};
			if (this._isPreamble && this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
			else if (this._isPreamble !== true && this.listenerCount("part") !== 0) this.emit("part", this._part);
			else this._ignore();
			if (!this._isPreamble) this._inHeader = true;
		}
		if (data && start < end && !this._ignoreData) {
			if (this._isPreamble || !this._inHeader) {
				if (buf) shouldWriteMore = this._part.push(buf);
				shouldWriteMore = this._part.push(data.slice(start, end));
				if (!shouldWriteMore) this._pause = true;
			} else if (!this._isPreamble && this._inHeader) {
				if (buf) this._hparser.push(buf);
				r = this._hparser.push(data.slice(start, end));
				if (!this._inHeader && r !== void 0 && r < end) this._oninfo(false, data, start + r, end);
			}
		}
		if (isMatch) {
			this._hparser.reset();
			if (this._isPreamble) this._isPreamble = false;
			else if (start !== end) {
				++this._parts;
				this._part.on("end", function() {
					if (--self$1._parts === 0) if (self$1._finished) {
						self$1._realFinish = true;
						self$1.emit("finish");
						self$1._realFinish = false;
					} else self$1._unpause();
				});
			}
			this._part.push(null);
			this._part = void 0;
			this._ignoreData = false;
			this._justMatched = true;
			this._dashes = 0;
		}
	};
	Dicer$2.prototype._unpause = function() {
		if (!this._pause) return;
		this._pause = false;
		if (this._cb) {
			const cb = this._cb;
			this._cb = void 0;
			cb();
		}
	};
	module.exports = Dicer$2;
} });

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({ "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports, module) {
	const utf8Decoder = new TextDecoder("utf-8");
	const textDecoders = new Map([["utf-8", utf8Decoder], ["utf8", utf8Decoder]]);
	function getDecoder(charset) {
		let lc;
		while (true) switch (charset) {
			case "utf-8":
			case "utf8": return decoders.utf8;
			case "latin1":
			case "ascii":
			case "us-ascii":
			case "iso-8859-1":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "windows-1252":
			case "iso_8859-1:1987":
			case "cp1252":
			case "x-cp1252": return decoders.latin1;
			case "utf16le":
			case "utf-16le":
			case "ucs2":
			case "ucs-2": return decoders.utf16le;
			case "base64": return decoders.base64;
			default:
				if (lc === void 0) {
					lc = true;
					charset = charset.toLowerCase();
					continue;
				}
				return decoders.other.bind(charset);
		}
	}
	const decoders = {
		utf8: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.utf8Slice(0, data.length);
		},
		latin1: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") return data;
			return data.latin1Slice(0, data.length);
		},
		utf16le: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.ucs2Slice(0, data.length);
		},
		base64: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			return data.base64Slice(0, data.length);
		},
		other: (data, sourceEncoding) => {
			if (data.length === 0) return "";
			if (typeof data === "string") data = Buffer.from(data, sourceEncoding);
			if (textDecoders.has(exports.toString())) try {
				return textDecoders.get(exports).decode(data);
			} catch {}
			return typeof data === "string" ? data : data.toString();
		}
	};
	function decodeText$3(text, sourceEncoding, destEncoding) {
		if (text) return getDecoder(destEncoding)(text, sourceEncoding);
		return text;
	}
	module.exports = decodeText$3;
} });

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({ "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports, module) {
	const decodeText$2 = require_decodeText();
	const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
	const EncodedLookup = {
		"%00": "\0",
		"%01": "",
		"%02": "",
		"%03": "",
		"%04": "",
		"%05": "",
		"%06": "",
		"%07": "\x07",
		"%08": "\b",
		"%09": "	",
		"%0a": "\n",
		"%0A": "\n",
		"%0b": "\v",
		"%0B": "\v",
		"%0c": "\f",
		"%0C": "\f",
		"%0d": "\r",
		"%0D": "\r",
		"%0e": "",
		"%0E": "",
		"%0f": "",
		"%0F": "",
		"%10": "",
		"%11": "",
		"%12": "",
		"%13": "",
		"%14": "",
		"%15": "",
		"%16": "",
		"%17": "",
		"%18": "",
		"%19": "",
		"%1a": "",
		"%1A": "",
		"%1b": "\x1B",
		"%1B": "\x1B",
		"%1c": "",
		"%1C": "",
		"%1d": "",
		"%1D": "",
		"%1e": "",
		"%1E": "",
		"%1f": "",
		"%1F": "",
		"%20": " ",
		"%21": "!",
		"%22": "\"",
		"%23": "#",
		"%24": "$",
		"%25": "%",
		"%26": "&",
		"%27": "'",
		"%28": "(",
		"%29": ")",
		"%2a": "*",
		"%2A": "*",
		"%2b": "+",
		"%2B": "+",
		"%2c": ",",
		"%2C": ",",
		"%2d": "-",
		"%2D": "-",
		"%2e": ".",
		"%2E": ".",
		"%2f": "/",
		"%2F": "/",
		"%30": "0",
		"%31": "1",
		"%32": "2",
		"%33": "3",
		"%34": "4",
		"%35": "5",
		"%36": "6",
		"%37": "7",
		"%38": "8",
		"%39": "9",
		"%3a": ":",
		"%3A": ":",
		"%3b": ";",
		"%3B": ";",
		"%3c": "<",
		"%3C": "<",
		"%3d": "=",
		"%3D": "=",
		"%3e": ">",
		"%3E": ">",
		"%3f": "?",
		"%3F": "?",
		"%40": "@",
		"%41": "A",
		"%42": "B",
		"%43": "C",
		"%44": "D",
		"%45": "E",
		"%46": "F",
		"%47": "G",
		"%48": "H",
		"%49": "I",
		"%4a": "J",
		"%4A": "J",
		"%4b": "K",
		"%4B": "K",
		"%4c": "L",
		"%4C": "L",
		"%4d": "M",
		"%4D": "M",
		"%4e": "N",
		"%4E": "N",
		"%4f": "O",
		"%4F": "O",
		"%50": "P",
		"%51": "Q",
		"%52": "R",
		"%53": "S",
		"%54": "T",
		"%55": "U",
		"%56": "V",
		"%57": "W",
		"%58": "X",
		"%59": "Y",
		"%5a": "Z",
		"%5A": "Z",
		"%5b": "[",
		"%5B": "[",
		"%5c": "\\",
		"%5C": "\\",
		"%5d": "]",
		"%5D": "]",
		"%5e": "^",
		"%5E": "^",
		"%5f": "_",
		"%5F": "_",
		"%60": "`",
		"%61": "a",
		"%62": "b",
		"%63": "c",
		"%64": "d",
		"%65": "e",
		"%66": "f",
		"%67": "g",
		"%68": "h",
		"%69": "i",
		"%6a": "j",
		"%6A": "j",
		"%6b": "k",
		"%6B": "k",
		"%6c": "l",
		"%6C": "l",
		"%6d": "m",
		"%6D": "m",
		"%6e": "n",
		"%6E": "n",
		"%6f": "o",
		"%6F": "o",
		"%70": "p",
		"%71": "q",
		"%72": "r",
		"%73": "s",
		"%74": "t",
		"%75": "u",
		"%76": "v",
		"%77": "w",
		"%78": "x",
		"%79": "y",
		"%7a": "z",
		"%7A": "z",
		"%7b": "{",
		"%7B": "{",
		"%7c": "|",
		"%7C": "|",
		"%7d": "}",
		"%7D": "}",
		"%7e": "~",
		"%7E": "~",
		"%7f": "",
		"%7F": "",
		"%80": "",
		"%81": "",
		"%82": "",
		"%83": "",
		"%84": "",
		"%85": "",
		"%86": "",
		"%87": "",
		"%88": "",
		"%89": "",
		"%8a": "",
		"%8A": "",
		"%8b": "",
		"%8B": "",
		"%8c": "",
		"%8C": "",
		"%8d": "",
		"%8D": "",
		"%8e": "",
		"%8E": "",
		"%8f": "",
		"%8F": "",
		"%90": "",
		"%91": "",
		"%92": "",
		"%93": "",
		"%94": "",
		"%95": "",
		"%96": "",
		"%97": "",
		"%98": "",
		"%99": "",
		"%9a": "",
		"%9A": "",
		"%9b": "",
		"%9B": "",
		"%9c": "",
		"%9C": "",
		"%9d": "",
		"%9D": "",
		"%9e": "",
		"%9E": "",
		"%9f": "",
		"%9F": "",
		"%a0": "\xA0",
		"%A0": "\xA0",
		"%a1": "",
		"%A1": "",
		"%a2": "",
		"%A2": "",
		"%a3": "",
		"%A3": "",
		"%a4": "",
		"%A4": "",
		"%a5": "",
		"%A5": "",
		"%a6": "",
		"%A6": "",
		"%a7": "",
		"%A7": "",
		"%a8": "",
		"%A8": "",
		"%a9": "",
		"%A9": "",
		"%aa": "",
		"%Aa": "",
		"%aA": "",
		"%AA": "",
		"%ab": "",
		"%Ab": "",
		"%aB": "",
		"%AB": "",
		"%ac": "",
		"%Ac": "",
		"%aC": "",
		"%AC": "",
		"%ad": "",
		"%Ad": "",
		"%aD": "",
		"%AD": "",
		"%ae": "",
		"%Ae": "",
		"%aE": "",
		"%AE": "",
		"%af": "",
		"%Af": "",
		"%aF": "",
		"%AF": "",
		"%b0": "",
		"%B0": "",
		"%b1": "",
		"%B1": "",
		"%b2": "",
		"%B2": "",
		"%b3": "",
		"%B3": "",
		"%b4": "",
		"%B4": "",
		"%b5": "",
		"%B5": "",
		"%b6": "",
		"%B6": "",
		"%b7": "",
		"%B7": "",
		"%b8": "",
		"%B8": "",
		"%b9": "",
		"%B9": "",
		"%ba": "",
		"%Ba": "",
		"%bA": "",
		"%BA": "",
		"%bb": "",
		"%Bb": "",
		"%bB": "",
		"%BB": "",
		"%bc": "",
		"%Bc": "",
		"%bC": "",
		"%BC": "",
		"%bd": "",
		"%Bd": "",
		"%bD": "",
		"%BD": "",
		"%be": "",
		"%Be": "",
		"%bE": "",
		"%BE": "",
		"%bf": "",
		"%Bf": "",
		"%bF": "",
		"%BF": "",
		"%c0": "",
		"%C0": "",
		"%c1": "",
		"%C1": "",
		"%c2": "",
		"%C2": "",
		"%c3": "",
		"%C3": "",
		"%c4": "",
		"%C4": "",
		"%c5": "",
		"%C5": "",
		"%c6": "",
		"%C6": "",
		"%c7": "",
		"%C7": "",
		"%c8": "",
		"%C8": "",
		"%c9": "",
		"%C9": "",
		"%ca": "",
		"%Ca": "",
		"%cA": "",
		"%CA": "",
		"%cb": "",
		"%Cb": "",
		"%cB": "",
		"%CB": "",
		"%cc": "",
		"%Cc": "",
		"%cC": "",
		"%CC": "",
		"%cd": "",
		"%Cd": "",
		"%cD": "",
		"%CD": "",
		"%ce": "",
		"%Ce": "",
		"%cE": "",
		"%CE": "",
		"%cf": "",
		"%Cf": "",
		"%cF": "",
		"%CF": "",
		"%d0": "",
		"%D0": "",
		"%d1": "",
		"%D1": "",
		"%d2": "",
		"%D2": "",
		"%d3": "",
		"%D3": "",
		"%d4": "",
		"%D4": "",
		"%d5": "",
		"%D5": "",
		"%d6": "",
		"%D6": "",
		"%d7": "",
		"%D7": "",
		"%d8": "",
		"%D8": "",
		"%d9": "",
		"%D9": "",
		"%da": "",
		"%Da": "",
		"%dA": "",
		"%DA": "",
		"%db": "",
		"%Db": "",
		"%dB": "",
		"%DB": "",
		"%dc": "",
		"%Dc": "",
		"%dC": "",
		"%DC": "",
		"%dd": "",
		"%Dd": "",
		"%dD": "",
		"%DD": "",
		"%de": "",
		"%De": "",
		"%dE": "",
		"%DE": "",
		"%df": "",
		"%Df": "",
		"%dF": "",
		"%DF": "",
		"%e0": "",
		"%E0": "",
		"%e1": "",
		"%E1": "",
		"%e2": "",
		"%E2": "",
		"%e3": "",
		"%E3": "",
		"%e4": "",
		"%E4": "",
		"%e5": "",
		"%E5": "",
		"%e6": "",
		"%E6": "",
		"%e7": "",
		"%E7": "",
		"%e8": "",
		"%E8": "",
		"%e9": "",
		"%E9": "",
		"%ea": "",
		"%Ea": "",
		"%eA": "",
		"%EA": "",
		"%eb": "",
		"%Eb": "",
		"%eB": "",
		"%EB": "",
		"%ec": "",
		"%Ec": "",
		"%eC": "",
		"%EC": "",
		"%ed": "",
		"%Ed": "",
		"%eD": "",
		"%ED": "",
		"%ee": "",
		"%Ee": "",
		"%eE": "",
		"%EE": "",
		"%ef": "",
		"%Ef": "",
		"%eF": "",
		"%EF": "",
		"%f0": "",
		"%F0": "",
		"%f1": "",
		"%F1": "",
		"%f2": "",
		"%F2": "",
		"%f3": "",
		"%F3": "",
		"%f4": "",
		"%F4": "",
		"%f5": "",
		"%F5": "",
		"%f6": "",
		"%F6": "",
		"%f7": "",
		"%F7": "",
		"%f8": "",
		"%F8": "",
		"%f9": "",
		"%F9": "",
		"%fa": "",
		"%Fa": "",
		"%fA": "",
		"%FA": "",
		"%fb": "",
		"%Fb": "",
		"%fB": "",
		"%FB": "",
		"%fc": "",
		"%Fc": "",
		"%fC": "",
		"%FC": "",
		"%fd": "",
		"%Fd": "",
		"%fD": "",
		"%FD": "",
		"%fe": "",
		"%Fe": "",
		"%fE": "",
		"%FE": "",
		"%ff": "",
		"%Ff": "",
		"%fF": "",
		"%FF": ""
	};
	function encodedReplacer(match) {
		return EncodedLookup[match];
	}
	const STATE_KEY = 0;
	const STATE_VALUE = 1;
	const STATE_CHARSET = 2;
	const STATE_LANG = 3;
	function parseParams$2(str) {
		const res = [];
		let state = STATE_KEY;
		let charset = "";
		let inquote = false;
		let escaping = false;
		let p = 0;
		let tmp = "";
		const len$1 = str.length;
		for (var i$1 = 0; i$1 < len$1; ++i$1) {
			const char = str[i$1];
			if (char === "\\" && inquote) if (escaping) escaping = false;
			else {
				escaping = true;
				continue;
			}
			else if (char === "\"") if (!escaping) {
				if (inquote) {
					inquote = false;
					state = STATE_KEY;
				} else inquote = true;
				continue;
			} else escaping = false;
			else {
				if (escaping && inquote) tmp += "\\";
				escaping = false;
				if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
					if (state === STATE_CHARSET) {
						state = STATE_LANG;
						charset = tmp.substring(1);
					} else state = STATE_VALUE;
					tmp = "";
					continue;
				} else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
					state = char === "*" ? STATE_CHARSET : STATE_VALUE;
					res[p] = [tmp, void 0];
					tmp = "";
					continue;
				} else if (!inquote && char === ";") {
					state = STATE_KEY;
					if (charset) {
						if (tmp.length) tmp = decodeText$2(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
						charset = "";
					} else if (tmp.length) tmp = decodeText$2(tmp, "binary", "utf8");
					if (res[p] === void 0) res[p] = tmp;
					else res[p][1] = tmp;
					tmp = "";
					++p;
					continue;
				} else if (!inquote && (char === " " || char === "	")) continue;
			}
			tmp += char;
		}
		if (charset && tmp.length) tmp = decodeText$2(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
		else if (tmp) tmp = decodeText$2(tmp, "binary", "utf8");
		if (res[p] === void 0) {
			if (tmp) res[p] = tmp;
		} else res[p][1] = tmp;
		return res;
	}
	module.exports = parseParams$2;
} });

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({ "node_modules/@fastify/busboy/lib/utils/basename.js"(exports, module) {
	module.exports = function basename$1(path$8) {
		if (typeof path$8 !== "string") return "";
		for (var i$1 = path$8.length - 1; i$1 >= 0; --i$1) switch (path$8.charCodeAt(i$1)) {
			case 47:
			case 92:
				path$8 = path$8.slice(i$1 + 1);
				return path$8 === ".." || path$8 === "." ? "" : path$8;
		}
		return path$8 === ".." || path$8 === "." ? "" : path$8;
	};
} });

//#endregion
//#region node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({ "node_modules/@fastify/busboy/lib/types/multipart.js"(exports, module) {
	const { Readable: Readable$6 } = require("node:stream");
	const { inherits: inherits$1 } = require("node:util");
	const Dicer$1 = require_Dicer();
	const parseParams$1 = require_parseParams();
	const decodeText$1 = require_decodeText();
	const basename = require_basename();
	const getLimit$1 = require_getLimit();
	const RE_BOUNDARY = /^boundary$/i;
	const RE_FIELD = /^form-data$/i;
	const RE_CHARSET$1 = /^charset$/i;
	const RE_FILENAME = /^filename$/i;
	const RE_NAME = /^name$/i;
	Multipart.detect = /^multipart\/form-data/i;
	function Multipart(boy, cfg) {
		let i$1;
		let len$1;
		const self$1 = this;
		let boundary;
		const limits = cfg.limits;
		const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
		const parsedConType = cfg.parsedConType || [];
		const defCharset = cfg.defCharset || "utf8";
		const preservePath = cfg.preservePath;
		const fileOpts = { highWaterMark: cfg.fileHwm };
		for (i$1 = 0, len$1 = parsedConType.length; i$1 < len$1; ++i$1) if (Array.isArray(parsedConType[i$1]) && RE_BOUNDARY.test(parsedConType[i$1][0])) {
			boundary = parsedConType[i$1][1];
			break;
		}
		function checkFinished() {
			if (nends === 0 && finished$1 && !boy._done) {
				finished$1 = false;
				self$1.end();
			}
		}
		if (typeof boundary !== "string") throw new Error("Multipart: Boundary not found");
		const fieldSizeLimit = getLimit$1(limits, "fieldSize", 1 * 1024 * 1024);
		const fileSizeLimit = getLimit$1(limits, "fileSize", Infinity);
		const filesLimit = getLimit$1(limits, "files", Infinity);
		const fieldsLimit = getLimit$1(limits, "fields", Infinity);
		const partsLimit = getLimit$1(limits, "parts", Infinity);
		const headerPairsLimit = getLimit$1(limits, "headerPairs", 2e3);
		const headerSizeLimit = getLimit$1(limits, "headerSize", 80 * 1024);
		let nfiles = 0;
		let nfields = 0;
		let nends = 0;
		let curFile;
		let curField;
		let finished$1 = false;
		this._needDrain = false;
		this._pause = false;
		this._cb = void 0;
		this._nparts = 0;
		this._boy = boy;
		const parserCfg = {
			boundary,
			maxHeaderPairs: headerPairsLimit,
			maxHeaderSize: headerSizeLimit,
			partHwm: fileOpts.highWaterMark,
			highWaterMark: cfg.highWaterMark
		};
		this.parser = new Dicer$1(parserCfg);
		this.parser.on("drain", function() {
			self$1._needDrain = false;
			if (self$1._cb && !self$1._pause) {
				const cb = self$1._cb;
				self$1._cb = void 0;
				cb();
			}
		}).on("part", function onPart(part) {
			if (++self$1._nparts > partsLimit) {
				self$1.parser.removeListener("part", onPart);
				self$1.parser.on("part", skipPart);
				boy.hitPartsLimit = true;
				boy.emit("partsLimit");
				return skipPart(part);
			}
			if (curField) {
				const field = curField;
				field.emit("end");
				field.removeAllListeners("end");
			}
			part.on("header", function(header) {
				let contype;
				let fieldname;
				let parsed;
				let charset;
				let encoding;
				let filename;
				let nsize = 0;
				if (header["content-type"]) {
					parsed = parseParams$1(header["content-type"][0]);
					if (parsed[0]) {
						contype = parsed[0].toLowerCase();
						for (i$1 = 0, len$1 = parsed.length; i$1 < len$1; ++i$1) if (RE_CHARSET$1.test(parsed[i$1][0])) {
							charset = parsed[i$1][1].toLowerCase();
							break;
						}
					}
				}
				if (contype === void 0) contype = "text/plain";
				if (charset === void 0) charset = defCharset;
				if (header["content-disposition"]) {
					parsed = parseParams$1(header["content-disposition"][0]);
					if (!RE_FIELD.test(parsed[0])) return skipPart(part);
					for (i$1 = 0, len$1 = parsed.length; i$1 < len$1; ++i$1) if (RE_NAME.test(parsed[i$1][0])) fieldname = parsed[i$1][1];
					else if (RE_FILENAME.test(parsed[i$1][0])) {
						filename = parsed[i$1][1];
						if (!preservePath) filename = basename(filename);
					}
				} else return skipPart(part);
				if (header["content-transfer-encoding"]) encoding = header["content-transfer-encoding"][0].toLowerCase();
				else encoding = "7bit";
				let onData, onEnd;
				if (isPartAFile(fieldname, contype, filename)) {
					if (nfiles === filesLimit) {
						if (!boy.hitFilesLimit) {
							boy.hitFilesLimit = true;
							boy.emit("filesLimit");
						}
						return skipPart(part);
					}
					++nfiles;
					if (boy.listenerCount("file") === 0) {
						self$1.parser._ignore();
						return;
					}
					++nends;
					const file = new FileStream(fileOpts);
					curFile = file;
					file.on("end", function() {
						--nends;
						self$1._pause = false;
						checkFinished();
						if (self$1._cb && !self$1._needDrain) {
							const cb = self$1._cb;
							self$1._cb = void 0;
							cb();
						}
					});
					file._read = function(n) {
						if (!self$1._pause) return;
						self$1._pause = false;
						if (self$1._cb && !self$1._needDrain) {
							const cb = self$1._cb;
							self$1._cb = void 0;
							cb();
						}
					};
					boy.emit("file", fieldname, file, filename, encoding, contype);
					onData = function(data) {
						if ((nsize += data.length) > fileSizeLimit) {
							const extralen = fileSizeLimit - nsize + data.length;
							if (extralen > 0) file.push(data.slice(0, extralen));
							file.truncated = true;
							file.bytesRead = fileSizeLimit;
							part.removeAllListeners("data");
							file.emit("limit");
							return;
						} else if (!file.push(data)) self$1._pause = true;
						file.bytesRead = nsize;
					};
					onEnd = function() {
						curFile = void 0;
						file.push(null);
					};
				} else {
					if (nfields === fieldsLimit) {
						if (!boy.hitFieldsLimit) {
							boy.hitFieldsLimit = true;
							boy.emit("fieldsLimit");
						}
						return skipPart(part);
					}
					++nfields;
					++nends;
					let buffer$1 = "";
					let truncated = false;
					curField = part;
					onData = function(data) {
						if ((nsize += data.length) > fieldSizeLimit) {
							const extralen = fieldSizeLimit - (nsize - data.length);
							buffer$1 += data.toString("binary", 0, extralen);
							truncated = true;
							part.removeAllListeners("data");
						} else buffer$1 += data.toString("binary");
					};
					onEnd = function() {
						curField = void 0;
						if (buffer$1.length) buffer$1 = decodeText$1(buffer$1, "binary", charset);
						boy.emit("field", fieldname, buffer$1, false, truncated, encoding, contype);
						--nends;
						checkFinished();
					};
				}
				part._readableState.sync = false;
				part.on("data", onData);
				part.on("end", onEnd);
			}).on("error", function(err) {
				if (curFile) curFile.emit("error", err);
			});
		}).on("error", function(err) {
			boy.emit("error", err);
		}).on("finish", function() {
			finished$1 = true;
			checkFinished();
		});
	}
	Multipart.prototype.write = function(chunk, cb) {
		const r = this.parser.write(chunk);
		if (r && !this._pause) cb();
		else {
			this._needDrain = !r;
			this._cb = cb;
		}
	};
	Multipart.prototype.end = function() {
		const self$1 = this;
		if (self$1.parser.writable) self$1.parser.end();
		else if (!self$1._boy._done) process.nextTick(function() {
			self$1._boy._done = true;
			self$1._boy.emit("finish");
		});
	};
	function skipPart(part) {
		part.resume();
	}
	function FileStream(opts) {
		Readable$6.call(this, opts);
		this.bytesRead = 0;
		this.truncated = false;
	}
	inherits$1(FileStream, Readable$6);
	FileStream.prototype._read = function(n) {};
	module.exports = Multipart;
} });

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({ "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports, module) {
	const RE_PLUS = /\+/g;
	const HEX = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	];
	function Decoder$1() {
		this.buffer = void 0;
	}
	Decoder$1.prototype.write = function(str) {
		str = str.replace(RE_PLUS, " ");
		let res = "";
		let i$1 = 0;
		let p = 0;
		const len$1 = str.length;
		for (; i$1 < len$1; ++i$1) if (this.buffer !== void 0) if (!HEX[str.charCodeAt(i$1)]) {
			res += "%" + this.buffer;
			this.buffer = void 0;
			--i$1;
		} else {
			this.buffer += str[i$1];
			++p;
			if (this.buffer.length === 2) {
				res += String.fromCharCode(parseInt(this.buffer, 16));
				this.buffer = void 0;
			}
		}
		else if (str[i$1] === "%") {
			if (i$1 > p) {
				res += str.substring(p, i$1);
				p = i$1;
			}
			this.buffer = "";
			++p;
		}
		if (p < len$1 && this.buffer === void 0) res += str.substring(p);
		return res;
	};
	Decoder$1.prototype.reset = function() {
		this.buffer = void 0;
	};
	module.exports = Decoder$1;
} });

//#endregion
//#region node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({ "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports, module) {
	const Decoder = require_Decoder();
	const decodeText = require_decodeText();
	const getLimit = require_getLimit();
	const RE_CHARSET = /^charset$/i;
	UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
	function UrlEncoded(boy, cfg) {
		const limits = cfg.limits;
		const parsedConType = cfg.parsedConType;
		this.boy = boy;
		this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
		this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
		this.fieldsLimit = getLimit(limits, "fields", Infinity);
		let charset;
		for (var i$1 = 0, len$1 = parsedConType.length; i$1 < len$1; ++i$1) if (Array.isArray(parsedConType[i$1]) && RE_CHARSET.test(parsedConType[i$1][0])) {
			charset = parsedConType[i$1][1].toLowerCase();
			break;
		}
		if (charset === void 0) charset = cfg.defCharset || "utf8";
		this.decoder = new Decoder();
		this.charset = charset;
		this._fields = 0;
		this._state = "key";
		this._checkingBytes = true;
		this._bytesKey = 0;
		this._bytesVal = 0;
		this._key = "";
		this._val = "";
		this._keyTrunc = false;
		this._valTrunc = false;
		this._hitLimit = false;
	}
	UrlEncoded.prototype.write = function(data, cb) {
		if (this._fields === this.fieldsLimit) {
			if (!this.boy.hitFieldsLimit) {
				this.boy.hitFieldsLimit = true;
				this.boy.emit("fieldsLimit");
			}
			return cb();
		}
		let idxeq;
		let idxamp;
		let i$1;
		let p = 0;
		const len$1 = data.length;
		while (p < len$1) if (this._state === "key") {
			idxeq = idxamp = void 0;
			for (i$1 = p; i$1 < len$1; ++i$1) {
				if (!this._checkingBytes) ++p;
				if (data[i$1] === 61) {
					idxeq = i$1;
					break;
				} else if (data[i$1] === 38) {
					idxamp = i$1;
					break;
				}
				if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesKey;
			}
			if (idxeq !== void 0) {
				if (idxeq > p) this._key += this.decoder.write(data.toString("binary", p, idxeq));
				this._state = "val";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._val = "";
				this._bytesVal = 0;
				this._valTrunc = false;
				this.decoder.reset();
				p = idxeq + 1;
			} else if (idxamp !== void 0) {
				++this._fields;
				let key;
				const keyTrunc = this._keyTrunc;
				if (idxamp > p) key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
				else key = this._key;
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				if (key.length) this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);
				p = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i$1 > p) this._key += this.decoder.write(data.toString("binary", p, i$1));
				p = i$1;
				if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
					this._checkingBytes = false;
					this._keyTrunc = true;
				}
			} else {
				if (p < len$1) this._key += this.decoder.write(data.toString("binary", p));
				p = len$1;
			}
		} else {
			idxamp = void 0;
			for (i$1 = p; i$1 < len$1; ++i$1) {
				if (!this._checkingBytes) ++p;
				if (data[i$1] === 38) {
					idxamp = i$1;
					break;
				}
				if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesVal;
			}
			if (idxamp !== void 0) {
				++this._fields;
				if (idxamp > p) this._val += this.decoder.write(data.toString("binary", p, idxamp));
				this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
				this._state = "key";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				p = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i$1 > p) this._val += this.decoder.write(data.toString("binary", p, i$1));
				p = i$1;
				if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
					this._checkingBytes = false;
					this._valTrunc = true;
				}
			} else {
				if (p < len$1) this._val += this.decoder.write(data.toString("binary", p));
				p = len$1;
			}
		}
		cb();
	};
	UrlEncoded.prototype.end = function() {
		if (this.boy._done) return;
		if (this._state === "key" && this._key.length > 0) this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);
		else if (this._state === "val") this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
		this.boy._done = true;
		this.boy.emit("finish");
	};
	module.exports = UrlEncoded;
} });

//#endregion
//#region node_modules/@fastify/busboy/lib/main.js
var require_main$1 = __commonJS({ "node_modules/@fastify/busboy/lib/main.js"(exports, module) {
	const WritableStream = require("node:stream").Writable;
	const { inherits } = require("node:util");
	const Dicer = require_Dicer();
	const MultipartParser = require_multipart();
	const UrlencodedParser = require_urlencoded();
	const parseParams = require_parseParams();
	function Busboy$1(opts) {
		if (!(this instanceof Busboy$1)) return new Busboy$1(opts);
		if (typeof opts !== "object") throw new TypeError("Busboy expected an options-Object.");
		if (typeof opts.headers !== "object") throw new TypeError("Busboy expected an options-Object with headers-attribute.");
		if (typeof opts.headers["content-type"] !== "string") throw new TypeError("Missing Content-Type-header.");
		const { headers,...streamOptions } = opts;
		this.opts = {
			autoDestroy: false,
			...streamOptions
		};
		WritableStream.call(this, this.opts);
		this._done = false;
		this._parser = this.getParserByHeaders(headers);
		this._finished = false;
	}
	inherits(Busboy$1, WritableStream);
	Busboy$1.prototype.emit = function(ev) {
		if (ev === "finish") {
			if (!this._done) {
				this._parser?.end();
				return;
			} else if (this._finished) return;
			this._finished = true;
		}
		WritableStream.prototype.emit.apply(this, arguments);
	};
	Busboy$1.prototype.getParserByHeaders = function(headers) {
		const parsed = parseParams(headers["content-type"]);
		const cfg = {
			defCharset: this.opts.defCharset,
			fileHwm: this.opts.fileHwm,
			headers,
			highWaterMark: this.opts.highWaterMark,
			isPartAFile: this.opts.isPartAFile,
			limits: this.opts.limits,
			parsedConType: parsed,
			preservePath: this.opts.preservePath
		};
		if (MultipartParser.detect.test(parsed[0])) return new MultipartParser(this, cfg);
		if (UrlencodedParser.detect.test(parsed[0])) return new UrlencodedParser(this, cfg);
		throw new Error("Unsupported Content-Type.");
	};
	Busboy$1.prototype._write = function(chunk, encoding, cb) {
		this._parser.write(chunk, cb);
	};
	module.exports = Busboy$1;
	module.exports.default = Busboy$1;
	module.exports.Busboy = Busboy$1;
	module.exports.Dicer = Dicer;
} });

//#endregion
//#region node_modules/undici/lib/fetch/constants.js
var require_constants$4 = __commonJS({ "node_modules/undici/lib/fetch/constants.js"(exports, module) {
	const { MessageChannel, receiveMessageOnPort } = require("worker_threads");
	const corsSafeListedMethods = [
		"GET",
		"HEAD",
		"POST"
	];
	const corsSafeListedMethodsSet$1 = new Set(corsSafeListedMethods);
	const nullBodyStatus$2 = [
		101,
		204,
		205,
		304
	];
	const redirectStatus = [
		301,
		302,
		303,
		307,
		308
	];
	const redirectStatusSet$3 = new Set(redirectStatus);
	const badPorts = [
		"1",
		"7",
		"9",
		"11",
		"13",
		"15",
		"17",
		"19",
		"20",
		"21",
		"22",
		"23",
		"25",
		"37",
		"42",
		"43",
		"53",
		"69",
		"77",
		"79",
		"87",
		"95",
		"101",
		"102",
		"103",
		"104",
		"109",
		"110",
		"111",
		"113",
		"115",
		"117",
		"119",
		"123",
		"135",
		"137",
		"139",
		"143",
		"161",
		"179",
		"389",
		"427",
		"465",
		"512",
		"513",
		"514",
		"515",
		"526",
		"530",
		"531",
		"532",
		"540",
		"548",
		"554",
		"556",
		"563",
		"587",
		"601",
		"636",
		"989",
		"990",
		"993",
		"995",
		"1719",
		"1720",
		"1723",
		"2049",
		"3659",
		"4045",
		"5060",
		"5061",
		"6000",
		"6566",
		"6665",
		"6666",
		"6667",
		"6668",
		"6669",
		"6697",
		"10080"
	];
	const badPortsSet$1 = new Set(badPorts);
	const referrerPolicy$1 = [
		"",
		"no-referrer",
		"no-referrer-when-downgrade",
		"same-origin",
		"origin",
		"strict-origin",
		"origin-when-cross-origin",
		"strict-origin-when-cross-origin",
		"unsafe-url"
	];
	const referrerPolicySet = new Set(referrerPolicy$1);
	const requestRedirect$1 = [
		"follow",
		"manual",
		"error"
	];
	const safeMethods = [
		"GET",
		"HEAD",
		"OPTIONS",
		"TRACE"
	];
	const safeMethodsSet$1 = new Set(safeMethods);
	const requestMode$1 = [
		"navigate",
		"same-origin",
		"no-cors",
		"cors"
	];
	const requestCredentials$1 = [
		"omit",
		"same-origin",
		"include"
	];
	const requestCache$1 = [
		"default",
		"no-store",
		"reload",
		"no-cache",
		"force-cache",
		"only-if-cached"
	];
	const requestBodyHeader$1 = [
		"content-encoding",
		"content-language",
		"content-location",
		"content-type",
		"content-length"
	];
	const requestDuplex$1 = ["half"];
	const forbiddenMethods = [
		"CONNECT",
		"TRACE",
		"TRACK"
	];
	const forbiddenMethodsSet$1 = new Set(forbiddenMethods);
	const subresource = [
		"audio",
		"audioworklet",
		"font",
		"image",
		"manifest",
		"paintworklet",
		"script",
		"style",
		"track",
		"video",
		"xslt",
		""
	];
	const subresourceSet$1 = new Set(subresource);
	/** @type {globalThis['DOMException']} */
	const DOMException$6 = globalThis.DOMException ?? (() => {
		try {
			atob("~");
		} catch (err) {
			return Object.getPrototypeOf(err).constructor;
		}
	})();
	let channel;
	/** @type {globalThis['structuredClone']} */
	const structuredClone$1 = globalThis.structuredClone ?? function structuredClone$2(value, options = void 0) {
		if (arguments.length === 0) throw new TypeError("missing argument");
		if (!channel) channel = new MessageChannel();
		channel.port1.unref();
		channel.port2.unref();
		channel.port1.postMessage(value, options?.transfer);
		return receiveMessageOnPort(channel.port2).message;
	};
	module.exports = {
		DOMException: DOMException$6,
		structuredClone: structuredClone$1,
		subresource,
		forbiddenMethods,
		requestBodyHeader: requestBodyHeader$1,
		referrerPolicy: referrerPolicy$1,
		requestRedirect: requestRedirect$1,
		requestMode: requestMode$1,
		requestCredentials: requestCredentials$1,
		requestCache: requestCache$1,
		redirectStatus,
		corsSafeListedMethods,
		nullBodyStatus: nullBodyStatus$2,
		safeMethods,
		badPorts,
		requestDuplex: requestDuplex$1,
		subresourceSet: subresourceSet$1,
		badPortsSet: badPortsSet$1,
		redirectStatusSet: redirectStatusSet$3,
		corsSafeListedMethodsSet: corsSafeListedMethodsSet$1,
		safeMethodsSet: safeMethodsSet$1,
		forbiddenMethodsSet: forbiddenMethodsSet$1,
		referrerPolicySet
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/global.js
var require_global$1 = __commonJS({ "node_modules/undici/lib/fetch/global.js"(exports, module) {
	const globalOrigin = Symbol.for("undici.globalOrigin.1");
	function getGlobalOrigin$4() {
		return globalThis[globalOrigin];
	}
	function setGlobalOrigin(newOrigin) {
		if (newOrigin === void 0) {
			Object.defineProperty(globalThis, globalOrigin, {
				value: void 0,
				writable: true,
				enumerable: false,
				configurable: false
			});
			return;
		}
		const parsedURL = new URL(newOrigin);
		if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
		Object.defineProperty(globalThis, globalOrigin, {
			value: parsedURL,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	module.exports = {
		getGlobalOrigin: getGlobalOrigin$4,
		setGlobalOrigin
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/util.js
var require_util$7 = __commonJS({ "node_modules/undici/lib/fetch/util.js"(exports, module) {
	const { redirectStatusSet: redirectStatusSet$2, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants$4();
	const { getGlobalOrigin: getGlobalOrigin$3 } = require_global$1();
	const { performance: performance$1 } = require("perf_hooks");
	const { isBlobLike: isBlobLike$6, toUSVString: toUSVString$4, ReadableStreamFrom: ReadableStreamFrom$2 } = require_util$8();
	const assert$18 = require("assert");
	const { isUint8Array: isUint8Array$1 } = require("util/types");
	let supportedHashes = [];
	/** @type {import('crypto')|undefined} */
	let crypto$6;
	try {
		crypto$6 = require("crypto");
		const possibleRelevantHashes = [
			"sha256",
			"sha384",
			"sha512"
		];
		supportedHashes = crypto$6.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
	} catch {}
	function responseURL(response) {
		const urlList = response.urlList;
		const length = urlList.length;
		return length === 0 ? null : urlList[length - 1].toString();
	}
	function responseLocationURL$1(response, requestFragment) {
		if (!redirectStatusSet$2.has(response.status)) return null;
		let location = response.headersList.get("location");
		if (location !== null && isValidHeaderValue$1(location)) location = new URL(location, responseURL(response));
		if (location && !location.hash) location.hash = requestFragment;
		return location;
	}
	/** @returns {URL} */
	function requestCurrentURL$1(request$3) {
		return request$3.urlList[request$3.urlList.length - 1];
	}
	function requestBadPort$1(request$3) {
		const url = requestCurrentURL$1(request$3);
		if (urlIsHttpHttpsScheme$2(url) && badPortsSet.has(url.port)) return "blocked";
		return "allowed";
	}
	function isErrorLike$2(object) {
		return object instanceof Error || object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException";
	}
	function isValidReasonPhrase$1(statusText) {
		for (let i$1 = 0; i$1 < statusText.length; ++i$1) {
			const c = statusText.charCodeAt(i$1);
			if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) return false;
		}
		return true;
	}
	/**
	* @see https://tools.ietf.org/html/rfc7230#section-3.2.6
	* @param {number} c
	*/
	function isTokenCharCode(c) {
		switch (c) {
			case 34:
			case 40:
			case 41:
			case 44:
			case 47:
			case 58:
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 91:
			case 92:
			case 93:
			case 123:
			case 125: return false;
			default: return c >= 33 && c <= 126;
		}
	}
	/**
	* @param {string} characters
	*/
	function isValidHTTPToken$1(characters) {
		if (characters.length === 0) return false;
		for (let i$1 = 0; i$1 < characters.length; ++i$1) if (!isTokenCharCode(characters.charCodeAt(i$1))) return false;
		return true;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-name
	* @param {string} potentialValue
	*/
	function isValidHeaderName$2(potentialValue) {
		return isValidHTTPToken$1(potentialValue);
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-value
	* @param {string} potentialValue
	*/
	function isValidHeaderValue$1(potentialValue) {
		if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) return false;
		if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) return false;
		return true;
	}
	function setRequestReferrerPolicyOnRedirect$1(request$3, actualResponse) {
		const { headersList } = actualResponse;
		const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
		let policy = "";
		if (policyHeader.length > 0) for (let i$1 = policyHeader.length; i$1 !== 0; i$1--) {
			const token = policyHeader[i$1 - 1].trim();
			if (referrerPolicyTokens.has(token)) {
				policy = token;
				break;
			}
		}
		if (policy !== "") request$3.referrerPolicy = policy;
	}
	function crossOriginResourcePolicyCheck$1() {
		return "allowed";
	}
	function corsCheck$1() {
		return "success";
	}
	function TAOCheck$1() {
		return "success";
	}
	function appendFetchMetadata$1(httpRequest) {
		let header = null;
		header = httpRequest.mode;
		httpRequest.headersList.set("sec-fetch-mode", header);
	}
	function appendRequestOriginHeader$1(request$3) {
		let serializedOrigin = request$3.origin;
		if (request$3.responseTainting === "cors" || request$3.mode === "websocket") {
			if (serializedOrigin) request$3.headersList.append("origin", serializedOrigin);
		} else if (request$3.method !== "GET" && request$3.method !== "HEAD") {
			switch (request$3.referrerPolicy) {
				case "no-referrer":
					serializedOrigin = null;
					break;
				case "no-referrer-when-downgrade":
				case "strict-origin":
				case "strict-origin-when-cross-origin":
					if (request$3.origin && urlHasHttpsScheme$1(request$3.origin) && !urlHasHttpsScheme$1(requestCurrentURL$1(request$3))) serializedOrigin = null;
					break;
				case "same-origin":
					if (!sameOrigin$2(request$3, requestCurrentURL$1(request$3))) serializedOrigin = null;
					break;
				default:
			}
			if (serializedOrigin) request$3.headersList.append("origin", serializedOrigin);
		}
	}
	function coarsenedSharedCurrentTime$1(crossOriginIsolatedCapability) {
		return performance$1.now();
	}
	function createOpaqueTimingInfo$1(timingInfo) {
		return {
			startTime: timingInfo.startTime ?? 0,
			redirectStartTime: 0,
			redirectEndTime: 0,
			postRedirectStartTime: timingInfo.startTime ?? 0,
			finalServiceWorkerStartTime: 0,
			finalNetworkResponseStartTime: 0,
			finalNetworkRequestStartTime: 0,
			endTime: 0,
			encodedBodySize: 0,
			decodedBodySize: 0,
			finalConnectionTimingInfo: null
		};
	}
	function makePolicyContainer$2() {
		return { referrerPolicy: "strict-origin-when-cross-origin" };
	}
	function clonePolicyContainer$1(policyContainer) {
		return { referrerPolicy: policyContainer.referrerPolicy };
	}
	function determineRequestsReferrer$1(request$3) {
		const policy = request$3.referrerPolicy;
		assert$18(policy);
		let referrerSource = null;
		if (request$3.referrer === "client") {
			const globalOrigin$1 = getGlobalOrigin$3();
			if (!globalOrigin$1 || globalOrigin$1.origin === "null") return "no-referrer";
			referrerSource = new URL(globalOrigin$1);
		} else if (request$3.referrer instanceof URL) referrerSource = request$3.referrer;
		let referrerURL = stripURLForReferrer(referrerSource);
		const referrerOrigin = stripURLForReferrer(referrerSource, true);
		if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
		const areSameOrigin = sameOrigin$2(request$3, referrerURL);
		const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request$3.url);
		switch (policy) {
			case "origin": return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
			case "unsafe-url": return referrerURL;
			case "same-origin": return areSameOrigin ? referrerOrigin : "no-referrer";
			case "origin-when-cross-origin": return areSameOrigin ? referrerURL : referrerOrigin;
			case "strict-origin-when-cross-origin": {
				const currentURL = requestCurrentURL$1(request$3);
				if (sameOrigin$2(referrerURL, currentURL)) return referrerURL;
				if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) return "no-referrer";
				return referrerOrigin;
			}
			case "strict-origin":
			case "no-referrer-when-downgrade":
			default: return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
	* @param {URL} url
	* @param {boolean|undefined} originOnly
	*/
	function stripURLForReferrer(url, originOnly) {
		assert$18(url instanceof URL);
		if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") return "no-referrer";
		url.username = "";
		url.password = "";
		url.hash = "";
		if (originOnly) {
			url.pathname = "";
			url.search = "";
		}
		return url;
	}
	function isURLPotentiallyTrustworthy(url) {
		if (!(url instanceof URL)) return false;
		if (url.href === "about:blank" || url.href === "about:srcdoc") return true;
		if (url.protocol === "data:") return true;
		if (url.protocol === "file:") return true;
		return isOriginPotentiallyTrustworthy(url.origin);
		function isOriginPotentiallyTrustworthy(origin) {
			if (origin == null || origin === "null") return false;
			const originAsURL = new URL(origin);
			if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") return true;
			if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.") || originAsURL.hostname.endsWith(".localhost")) return true;
			return false;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
	* @param {Uint8Array} bytes
	* @param {string} metadataList
	*/
	function bytesMatch$1(bytes, metadataList) {
		/* istanbul ignore if: only if node is built with --without-ssl */
		if (crypto$6 === void 0) return true;
		const parsedMetadata = parseMetadata(metadataList);
		if (parsedMetadata === "no metadata") return true;
		if (parsedMetadata.length === 0) return true;
		const strongest = getStrongestMetadata(parsedMetadata);
		const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
		for (const item of metadata) {
			const algorithm = item.algo;
			const expectedValue = item.hash;
			let actualValue = crypto$6.createHash(algorithm).update(bytes).digest("base64");
			if (actualValue[actualValue.length - 1] === "=") if (actualValue[actualValue.length - 2] === "=") actualValue = actualValue.slice(0, -2);
			else actualValue = actualValue.slice(0, -1);
			if (compareBase64Mixed(actualValue, expectedValue)) return true;
		}
		return false;
	}
	const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
	* @param {string} metadata
	*/
	function parseMetadata(metadata) {
		/** @type {{ algo: string, hash: string }[]} */
		const result = [];
		let empty = true;
		for (const token of metadata.split(" ")) {
			empty = false;
			const parsedToken = parseHashWithOptions.exec(token);
			if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) continue;
			const algorithm = parsedToken.groups.algo.toLowerCase();
			if (supportedHashes.includes(algorithm)) result.push(parsedToken.groups);
		}
		if (empty === true) return "no metadata";
		return result;
	}
	/**
	* @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
	*/
	function getStrongestMetadata(metadataList) {
		let algorithm = metadataList[0].algo;
		if (algorithm[3] === "5") return algorithm;
		for (let i$1 = 1; i$1 < metadataList.length; ++i$1) {
			const metadata = metadataList[i$1];
			if (metadata.algo[3] === "5") {
				algorithm = "sha512";
				break;
			} else if (algorithm[3] === "3") continue;
			else if (metadata.algo[3] === "3") algorithm = "sha384";
		}
		return algorithm;
	}
	function filterMetadataListByAlgorithm(metadataList, algorithm) {
		if (metadataList.length === 1) return metadataList;
		let pos = 0;
		for (let i$1 = 0; i$1 < metadataList.length; ++i$1) if (metadataList[i$1].algo === algorithm) metadataList[pos++] = metadataList[i$1];
		metadataList.length = pos;
		return metadataList;
	}
	/**
	* Compares two base64 strings, allowing for base64url
	* in the second string.
	*
	* @param {string} actualValue always base64
	* @param {string} expectedValue base64 or base64url
	* @returns {boolean}
	*/
	function compareBase64Mixed(actualValue, expectedValue) {
		if (actualValue.length !== expectedValue.length) return false;
		for (let i$1 = 0; i$1 < actualValue.length; ++i$1) if (actualValue[i$1] !== expectedValue[i$1]) {
			if (actualValue[i$1] === "+" && expectedValue[i$1] === "-" || actualValue[i$1] === "/" && expectedValue[i$1] === "_") continue;
			return false;
		}
		return true;
	}
	function tryUpgradeRequestToAPotentiallyTrustworthyURL$1(request$3) {}
	/**
	* @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
	* @param {URL} A
	* @param {URL} B
	*/
	function sameOrigin$2(A, B) {
		if (A.origin === B.origin && A.origin === "null") return true;
		if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) return true;
		return false;
	}
	function createDeferredPromise$3() {
		let res;
		let rej;
		const promise = new Promise((resolve, reject) => {
			res = resolve;
			rej = reject;
		});
		return {
			promise,
			resolve: res,
			reject: rej
		};
	}
	function isAborted$2(fetchParams) {
		return fetchParams.controller.state === "aborted";
	}
	function isCancelled$2(fetchParams) {
		return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
	}
	const normalizeMethodRecord$1 = {
		delete: "DELETE",
		DELETE: "DELETE",
		get: "GET",
		GET: "GET",
		head: "HEAD",
		HEAD: "HEAD",
		options: "OPTIONS",
		OPTIONS: "OPTIONS",
		post: "POST",
		POST: "POST",
		put: "PUT",
		PUT: "PUT"
	};
	Object.setPrototypeOf(normalizeMethodRecord$1, null);
	/**
	* @see https://fetch.spec.whatwg.org/#concept-method-normalize
	* @param {string} method
	*/
	function normalizeMethod$1(method) {
		return normalizeMethodRecord$1[method.toLowerCase()] ?? method;
	}
	function serializeJavascriptValueToJSONString$1(value) {
		const result = JSON.stringify(value);
		if (result === void 0) throw new TypeError("Value is not JSON serializable");
		assert$18(typeof result === "string");
		return result;
	}
	const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
	/**
	* @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
	* @param {() => unknown[]} iterator
	* @param {string} name name of the instance
	* @param {'key'|'value'|'key+value'} kind
	*/
	function makeIterator$2(iterator$1, name, kind) {
		const object = {
			index: 0,
			kind,
			target: iterator$1
		};
		const i$1 = {
			next() {
				if (Object.getPrototypeOf(this) !== i$1) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
				const { index, kind: kind$1, target } = object;
				const values = target();
				const len$1 = values.length;
				if (index >= len$1) return {
					value: void 0,
					done: true
				};
				const pair = values[index];
				object.index = index + 1;
				return iteratorResult(pair, kind$1);
			},
			[Symbol.toStringTag]: `${name} Iterator`
		};
		Object.setPrototypeOf(i$1, esIteratorPrototype);
		return Object.setPrototypeOf({}, i$1);
	}
	function iteratorResult(pair, kind) {
		let result;
		switch (kind) {
			case "key": {
				result = pair[0];
				break;
			}
			case "value": {
				result = pair[1];
				break;
			}
			case "key+value": {
				result = pair;
				break;
			}
		}
		return {
			value: result,
			done: false
		};
	}
	/**
	* @see https://fetch.spec.whatwg.org/#body-fully-read
	*/
	async function fullyReadBody$2(body, processBody, processBodyError) {
		const successSteps = processBody;
		const errorSteps = processBodyError;
		let reader;
		try {
			reader = body.stream.getReader();
		} catch (e) {
			errorSteps(e);
			return;
		}
		try {
			const result = await readAllBytes$1(reader);
			successSteps(result);
		} catch (e) {
			errorSteps(e);
		}
	}
	/** @type {ReadableStream} */
	let ReadableStream$3 = globalThis.ReadableStream;
	function isReadableStreamLike$1(stream$6) {
		if (!ReadableStream$3) ReadableStream$3 = require("stream/web").ReadableStream;
		return stream$6 instanceof ReadableStream$3 || stream$6[Symbol.toStringTag] === "ReadableStream" && typeof stream$6.tee === "function";
	}
	const MAXIMUM_ARGUMENT_LENGTH = 65535;
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-decode
	* @param {number[]|Uint8Array} input
	*/
	function isomorphicDecode$1(input) {
		if (input.length < MAXIMUM_ARGUMENT_LENGTH) return String.fromCharCode(...input);
		return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
	}
	/**
	* @param {ReadableStreamController<Uint8Array>} controller
	*/
	function readableStreamClose$2(controller) {
		try {
			controller.close();
		} catch (err) {
			if (!err.message.includes("Controller is already closed")) throw err;
		}
	}
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-encode
	* @param {string} input
	*/
	function isomorphicEncode$2(input) {
		for (let i$1 = 0; i$1 < input.length; i$1++) assert$18(input.charCodeAt(i$1) <= 255);
		return input;
	}
	/**
	* @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
	* @see https://streams.spec.whatwg.org/#read-loop
	* @param {ReadableStreamDefaultReader} reader
	*/
	async function readAllBytes$1(reader) {
		const bytes = [];
		let byteLength$1 = 0;
		while (true) {
			const { done, value: chunk } = await reader.read();
			if (done) return Buffer.concat(bytes, byteLength$1);
			if (!isUint8Array$1(chunk)) throw new TypeError("Received non-Uint8Array chunk");
			bytes.push(chunk);
			byteLength$1 += chunk.length;
		}
	}
	/**
	* @see https://fetch.spec.whatwg.org/#is-local
	* @param {URL} url
	*/
	function urlIsLocal$1(url) {
		assert$18("protocol" in url);
		const protocol = url.protocol;
		return protocol === "about:" || protocol === "blob:" || protocol === "data:";
	}
	/**
	* @param {string|URL} url
	*/
	function urlHasHttpsScheme$1(url) {
		if (typeof url === "string") return url.startsWith("https:");
		return url.protocol === "https:";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-scheme
	* @param {URL} url
	*/
	function urlIsHttpHttpsScheme$2(url) {
		assert$18("protocol" in url);
		const protocol = url.protocol;
		return protocol === "http:" || protocol === "https:";
	}
	/**
	* Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
	*/
	const hasOwn$2 = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
	module.exports = {
		isAborted: isAborted$2,
		isCancelled: isCancelled$2,
		createDeferredPromise: createDeferredPromise$3,
		ReadableStreamFrom: ReadableStreamFrom$2,
		toUSVString: toUSVString$4,
		tryUpgradeRequestToAPotentiallyTrustworthyURL: tryUpgradeRequestToAPotentiallyTrustworthyURL$1,
		coarsenedSharedCurrentTime: coarsenedSharedCurrentTime$1,
		determineRequestsReferrer: determineRequestsReferrer$1,
		makePolicyContainer: makePolicyContainer$2,
		clonePolicyContainer: clonePolicyContainer$1,
		appendFetchMetadata: appendFetchMetadata$1,
		appendRequestOriginHeader: appendRequestOriginHeader$1,
		TAOCheck: TAOCheck$1,
		corsCheck: corsCheck$1,
		crossOriginResourcePolicyCheck: crossOriginResourcePolicyCheck$1,
		createOpaqueTimingInfo: createOpaqueTimingInfo$1,
		setRequestReferrerPolicyOnRedirect: setRequestReferrerPolicyOnRedirect$1,
		isValidHTTPToken: isValidHTTPToken$1,
		requestBadPort: requestBadPort$1,
		requestCurrentURL: requestCurrentURL$1,
		responseURL,
		responseLocationURL: responseLocationURL$1,
		isBlobLike: isBlobLike$6,
		isURLPotentiallyTrustworthy,
		isValidReasonPhrase: isValidReasonPhrase$1,
		sameOrigin: sameOrigin$2,
		normalizeMethod: normalizeMethod$1,
		serializeJavascriptValueToJSONString: serializeJavascriptValueToJSONString$1,
		makeIterator: makeIterator$2,
		isValidHeaderName: isValidHeaderName$2,
		isValidHeaderValue: isValidHeaderValue$1,
		hasOwn: hasOwn$2,
		isErrorLike: isErrorLike$2,
		fullyReadBody: fullyReadBody$2,
		bytesMatch: bytesMatch$1,
		isReadableStreamLike: isReadableStreamLike$1,
		readableStreamClose: readableStreamClose$2,
		isomorphicEncode: isomorphicEncode$2,
		isomorphicDecode: isomorphicDecode$1,
		urlIsLocal: urlIsLocal$1,
		urlHasHttpsScheme: urlHasHttpsScheme$1,
		urlIsHttpHttpsScheme: urlIsHttpHttpsScheme$2,
		readAllBytes: readAllBytes$1,
		normalizeMethodRecord: normalizeMethodRecord$1,
		parseMetadata
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/symbols.js
var require_symbols$3 = __commonJS({ "node_modules/undici/lib/fetch/symbols.js"(exports, module) {
	module.exports = {
		kUrl: Symbol("url"),
		kHeaders: Symbol("headers"),
		kSignal: Symbol("signal"),
		kState: Symbol("state"),
		kGuard: Symbol("guard"),
		kRealm: Symbol("realm")
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({ "node_modules/undici/lib/fetch/webidl.js"(exports, module) {
	const { types: types$4 } = require("util");
	const { hasOwn: hasOwn$1, toUSVString: toUSVString$3 } = require_util$7();
	/** @type {import('../../types/webidl').Webidl} */
	const webidl$14 = {};
	webidl$14.converters = {};
	webidl$14.util = {};
	webidl$14.errors = {};
	webidl$14.errors.exception = function(message) {
		return new TypeError(`${message.header}: ${message.message}`);
	};
	webidl$14.errors.conversionFailed = function(context) {
		const plural$1 = context.types.length === 1 ? "" : " one of";
		const message = `${context.argument} could not be converted to${plural$1}: ${context.types.join(", ")}.`;
		return webidl$14.errors.exception({
			header: context.prefix,
			message
		});
	};
	webidl$14.errors.invalidArgument = function(context) {
		return webidl$14.errors.exception({
			header: context.prefix,
			message: `"${context.value}" is an invalid ${context.type}.`
		});
	};
	webidl$14.brandCheck = function(V, I, opts = void 0) {
		if (opts?.strict !== false && !(V instanceof I)) throw new TypeError("Illegal invocation");
		else return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
	};
	webidl$14.argumentLengthCheck = function({ length }, min, ctx) {
		if (length < min) throw webidl$14.errors.exception({
			message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
			...ctx
		});
	};
	webidl$14.illegalConstructor = function() {
		throw webidl$14.errors.exception({
			header: "TypeError",
			message: "Illegal constructor"
		});
	};
	webidl$14.util.Type = function(V) {
		switch (typeof V) {
			case "undefined": return "Undefined";
			case "boolean": return "Boolean";
			case "string": return "String";
			case "symbol": return "Symbol";
			case "number": return "Number";
			case "bigint": return "BigInt";
			case "function":
			case "object": {
				if (V === null) return "Null";
				return "Object";
			}
		}
	};
	webidl$14.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
		let upperBound;
		let lowerBound;
		if (bitLength === 64) {
			upperBound = Math.pow(2, 53) - 1;
			if (signedness === "unsigned") lowerBound = 0;
			else lowerBound = Math.pow(-2, 53) + 1;
		} else if (signedness === "unsigned") {
			lowerBound = 0;
			upperBound = Math.pow(2, bitLength) - 1;
		} else {
			lowerBound = Math.pow(-2, bitLength) - 1;
			upperBound = Math.pow(2, bitLength - 1) - 1;
		}
		let x = Number(V);
		if (x === 0) x = 0;
		if (opts.enforceRange === true) {
			if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) throw webidl$14.errors.exception({
				header: "Integer conversion",
				message: `Could not convert ${V} to an integer.`
			});
			x = webidl$14.util.IntegerPart(x);
			if (x < lowerBound || x > upperBound) throw webidl$14.errors.exception({
				header: "Integer conversion",
				message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
			});
			return x;
		}
		if (!Number.isNaN(x) && opts.clamp === true) {
			x = Math.min(Math.max(x, lowerBound), upperBound);
			if (Math.floor(x) % 2 === 0) x = Math.floor(x);
			else x = Math.ceil(x);
			return x;
		}
		if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) return 0;
		x = webidl$14.util.IntegerPart(x);
		x = x % Math.pow(2, bitLength);
		if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) return x - Math.pow(2, bitLength);
		return x;
	};
	webidl$14.util.IntegerPart = function(n) {
		const r = Math.floor(Math.abs(n));
		if (n < 0) return -1 * r;
		return r;
	};
	webidl$14.sequenceConverter = function(converter) {
		return (V) => {
			if (webidl$14.util.Type(V) !== "Object") throw webidl$14.errors.exception({
				header: "Sequence",
				message: `Value of type ${webidl$14.util.Type(V)} is not an Object.`
			});
			/** @type {Generator} */
			const method = V?.[Symbol.iterator]?.();
			const seq = [];
			if (method === void 0 || typeof method.next !== "function") throw webidl$14.errors.exception({
				header: "Sequence",
				message: "Object is not an iterator."
			});
			while (true) {
				const { done, value } = method.next();
				if (done) break;
				seq.push(converter(value));
			}
			return seq;
		};
	};
	webidl$14.recordConverter = function(keyConverter, valueConverter) {
		return (O) => {
			if (webidl$14.util.Type(O) !== "Object") throw webidl$14.errors.exception({
				header: "Record",
				message: `Value of type ${webidl$14.util.Type(O)} is not an Object.`
			});
			const result = {};
			if (!types$4.isProxy(O)) {
				const keys$1 = Object.keys(O);
				for (const key of keys$1) {
					const typedKey = keyConverter(key);
					const typedValue = valueConverter(O[key]);
					result[typedKey] = typedValue;
				}
				return result;
			}
			const keys = Reflect.ownKeys(O);
			for (const key of keys) {
				const desc = Reflect.getOwnPropertyDescriptor(O, key);
				if (desc?.enumerable) {
					const typedKey = keyConverter(key);
					const typedValue = valueConverter(O[key]);
					result[typedKey] = typedValue;
				}
			}
			return result;
		};
	};
	webidl$14.interfaceConverter = function(i$1) {
		return (V, opts = {}) => {
			if (opts.strict !== false && !(V instanceof i$1)) throw webidl$14.errors.exception({
				header: i$1.name,
				message: `Expected ${V} to be an instance of ${i$1.name}.`
			});
			return V;
		};
	};
	webidl$14.dictionaryConverter = function(converters) {
		return (dictionary) => {
			const type = webidl$14.util.Type(dictionary);
			const dict = {};
			if (type === "Null" || type === "Undefined") return dict;
			else if (type !== "Object") throw webidl$14.errors.exception({
				header: "Dictionary",
				message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
			});
			for (const options of converters) {
				const { key, defaultValue, required, converter } = options;
				if (required === true) {
					if (!hasOwn$1(dictionary, key)) throw webidl$14.errors.exception({
						header: "Dictionary",
						message: `Missing required key "${key}".`
					});
				}
				let value = dictionary[key];
				const hasDefault = hasOwn$1(options, "defaultValue");
				if (hasDefault && value !== null) value = value ?? defaultValue;
				if (required || hasDefault || value !== void 0) {
					value = converter(value);
					if (options.allowedValues && !options.allowedValues.includes(value)) throw webidl$14.errors.exception({
						header: "Dictionary",
						message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
					});
					dict[key] = value;
				}
			}
			return dict;
		};
	};
	webidl$14.nullableConverter = function(converter) {
		return (V) => {
			if (V === null) return V;
			return converter(V);
		};
	};
	webidl$14.converters.DOMString = function(V, opts = {}) {
		if (V === null && opts.legacyNullToEmptyString) return "";
		if (typeof V === "symbol") throw new TypeError("Could not convert argument of type symbol to string.");
		return String(V);
	};
	webidl$14.converters.ByteString = function(V) {
		const x = webidl$14.converters.DOMString(V);
		for (let index = 0; index < x.length; index++) if (x.charCodeAt(index) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
		return x;
	};
	webidl$14.converters.USVString = toUSVString$3;
	webidl$14.converters.boolean = function(V) {
		const x = Boolean(V);
		return x;
	};
	webidl$14.converters.any = function(V) {
		return V;
	};
	webidl$14.converters["long long"] = function(V) {
		const x = webidl$14.util.ConvertToInt(V, 64, "signed");
		return x;
	};
	webidl$14.converters["unsigned long long"] = function(V) {
		const x = webidl$14.util.ConvertToInt(V, 64, "unsigned");
		return x;
	};
	webidl$14.converters["unsigned long"] = function(V) {
		const x = webidl$14.util.ConvertToInt(V, 32, "unsigned");
		return x;
	};
	webidl$14.converters["unsigned short"] = function(V, opts) {
		const x = webidl$14.util.ConvertToInt(V, 16, "unsigned", opts);
		return x;
	};
	webidl$14.converters.ArrayBuffer = function(V, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$4.isAnyArrayBuffer(V)) throw webidl$14.errors.conversionFailed({
			prefix: `${V}`,
			argument: `${V}`,
			types: ["ArrayBuffer"]
		});
		if (opts.allowShared === false && types$4.isSharedArrayBuffer(V)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.TypedArray = function(V, T, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$4.isTypedArray(V) || V.constructor.name !== T.name) throw webidl$14.errors.conversionFailed({
			prefix: `${T.name}`,
			argument: `${V}`,
			types: [T.name]
		});
		if (opts.allowShared === false && types$4.isSharedArrayBuffer(V.buffer)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.DataView = function(V, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$4.isDataView(V)) throw webidl$14.errors.exception({
			header: "DataView",
			message: "Object is not a DataView."
		});
		if (opts.allowShared === false && types$4.isSharedArrayBuffer(V.buffer)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.BufferSource = function(V, opts = {}) {
		if (types$4.isAnyArrayBuffer(V)) return webidl$14.converters.ArrayBuffer(V, opts);
		if (types$4.isTypedArray(V)) return webidl$14.converters.TypedArray(V, V.constructor);
		if (types$4.isDataView(V)) return webidl$14.converters.DataView(V, opts);
		throw new TypeError(`Could not convert ${V} to a BufferSource.`);
	};
	webidl$14.converters["sequence<ByteString>"] = webidl$14.sequenceConverter(webidl$14.converters.ByteString);
	webidl$14.converters["sequence<sequence<ByteString>>"] = webidl$14.sequenceConverter(webidl$14.converters["sequence<ByteString>"]);
	webidl$14.converters["record<ByteString, ByteString>"] = webidl$14.recordConverter(webidl$14.converters.ByteString, webidl$14.converters.ByteString);
	module.exports = { webidl: webidl$14 };
} });

//#endregion
//#region node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({ "node_modules/undici/lib/fetch/dataURL.js"(exports, module) {
	const assert$17 = require("assert");
	const { atob: atob$1 } = require("buffer");
	const { isomorphicDecode } = require_util$7();
	const encoder$1 = new TextEncoder();
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-token-code-point
	*/
	const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
	const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
	*/
	const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
	/** @param {URL} dataURL */
	function dataURLProcessor$1(dataURL) {
		assert$17(dataURL.protocol === "data:");
		let input = URLSerializer$4(dataURL, true);
		input = input.slice(5);
		const position = { position: 0 };
		let mimeType = collectASequenceOfCodePointsFast$1(",", input, position);
		const mimeTypeLength = mimeType.length;
		mimeType = removeASCIIWhitespace(mimeType, true, true);
		if (position.position >= input.length) return "failure";
		position.position++;
		const encodedBody = input.slice(mimeTypeLength + 1);
		let body = stringPercentDecode(encodedBody);
		if (/;(\u0020){0,}base64$/i.test(mimeType)) {
			const stringBody = isomorphicDecode(body);
			body = forgivingBase64(stringBody);
			if (body === "failure") return "failure";
			mimeType = mimeType.slice(0, -6);
			mimeType = mimeType.replace(/(\u0020)+$/, "");
			mimeType = mimeType.slice(0, -1);
		}
		if (mimeType.startsWith(";")) mimeType = "text/plain" + mimeType;
		let mimeTypeRecord = parseMIMEType$3(mimeType);
		if (mimeTypeRecord === "failure") mimeTypeRecord = parseMIMEType$3("text/plain;charset=US-ASCII");
		return {
			mimeType: mimeTypeRecord,
			body
		};
	}
	/**
	* @param {URL} url
	* @param {boolean} excludeFragment
	*/
	function URLSerializer$4(url, excludeFragment = false) {
		if (!excludeFragment) return url.href;
		const href = url.href;
		const hashLength = url.hash.length;
		return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
	}
	/**
	* @param {(char: string) => boolean} condition
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePoints(condition, input, position) {
		let result = "";
		while (position.position < input.length && condition(input[position.position])) {
			result += input[position.position];
			position.position++;
		}
		return result;
	}
	/**
	* A faster collectASequenceOfCodePoints that only works when comparing a single character.
	* @param {string} char
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePointsFast$1(char, input, position) {
		const idx = input.indexOf(char, position.position);
		const start = position.position;
		if (idx === -1) {
			position.position = input.length;
			return input.slice(start);
		}
		position.position = idx;
		return input.slice(start, position.position);
	}
	/** @param {string} input */
	function stringPercentDecode(input) {
		const bytes = encoder$1.encode(input);
		return percentDecode(bytes);
	}
	/** @param {Uint8Array} input */
	function percentDecode(input) {
		/** @type {number[]} */
		const output = [];
		for (let i$1 = 0; i$1 < input.length; i$1++) {
			const byte = input[i$1];
			if (byte !== 37) output.push(byte);
			else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i$1 + 1], input[i$1 + 2]))) output.push(37);
			else {
				const nextTwoBytes = String.fromCharCode(input[i$1 + 1], input[i$1 + 2]);
				const bytePoint = Number.parseInt(nextTwoBytes, 16);
				output.push(bytePoint);
				i$1 += 2;
			}
		}
		return Uint8Array.from(output);
	}
	/** @param {string} input */
	function parseMIMEType$3(input) {
		input = removeHTTPWhitespace(input, true, true);
		const position = { position: 0 };
		const type = collectASequenceOfCodePointsFast$1("/", input, position);
		if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) return "failure";
		if (position.position > input.length) return "failure";
		position.position++;
		let subtype = collectASequenceOfCodePointsFast$1(";", input, position);
		subtype = removeHTTPWhitespace(subtype, false, true);
		if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) return "failure";
		const typeLowercase = type.toLowerCase();
		const subtypeLowercase = subtype.toLowerCase();
		const mimeType = {
			type: typeLowercase,
			subtype: subtypeLowercase,
			parameters: new Map(),
			essence: `${typeLowercase}/${subtypeLowercase}`
		};
		while (position.position < input.length) {
			position.position++;
			collectASequenceOfCodePoints(
				// https://fetch.spec.whatwg.org/#http-whitespace
				(char) => HTTP_WHITESPACE_REGEX.test(char),
				input,
				position
);
			let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
			parameterName = parameterName.toLowerCase();
			if (position.position < input.length) {
				if (input[position.position] === ";") continue;
				position.position++;
			}
			if (position.position > input.length) break;
			let parameterValue = null;
			if (input[position.position] === "\"") {
				parameterValue = collectAnHTTPQuotedString(input, position, true);
				collectASequenceOfCodePointsFast$1(";", input, position);
			} else {
				parameterValue = collectASequenceOfCodePointsFast$1(";", input, position);
				parameterValue = removeHTTPWhitespace(parameterValue, false, true);
				if (parameterValue.length === 0) continue;
			}
			if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) mimeType.parameters.set(parameterName, parameterValue);
		}
		return mimeType;
	}
	/** @param {string} data */
	function forgivingBase64(data) {
		data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
		if (data.length % 4 === 0) data = data.replace(/=?=$/, "");
		if (data.length % 4 === 1) return "failure";
		if (/[^+/0-9A-Za-z]/.test(data)) return "failure";
		const binary = atob$1(data);
		const bytes = new Uint8Array(binary.length);
		for (let byte = 0; byte < binary.length; byte++) bytes[byte] = binary.charCodeAt(byte);
		return bytes;
	}
	/**
	* @param {string} input
	* @param {{ position: number }} position
	* @param {boolean?} extractValue
	*/
	function collectAnHTTPQuotedString(input, position, extractValue) {
		const positionStart = position.position;
		let value = "";
		assert$17(input[position.position] === "\"");
		position.position++;
		while (true) {
			value += collectASequenceOfCodePoints((char) => char !== "\"" && char !== "\\", input, position);
			if (position.position >= input.length) break;
			const quoteOrBackslash = input[position.position];
			position.position++;
			if (quoteOrBackslash === "\\") {
				if (position.position >= input.length) {
					value += "\\";
					break;
				}
				value += input[position.position];
				position.position++;
			} else {
				assert$17(quoteOrBackslash === "\"");
				break;
			}
		}
		if (extractValue) return value;
		return input.slice(positionStart, position.position);
	}
	/**
	* @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
	*/
	function serializeAMimeType$4(mimeType) {
		assert$17(mimeType !== "failure");
		const { parameters, essence } = mimeType;
		let serialization = essence;
		for (let [name, value] of parameters.entries()) {
			serialization += ";";
			serialization += name;
			serialization += "=";
			if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
				value = value.replace(/(\\|")/g, "\\$1");
				value = "\"" + value;
				value += "\"";
			}
			serialization += value;
		}
		return serialization;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {string} char
	*/
	function isHTTPWhiteSpace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === " ";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {string} str
	*/
	function removeHTTPWhitespace(str, leading = true, trailing = true) {
		let lead = 0;
		let trail = str.length - 1;
		if (leading) for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
		if (trailing) for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
		return str.slice(lead, trail + 1);
	}
	/**
	* @see https://infra.spec.whatwg.org/#ascii-whitespace
	* @param {string} char
	*/
	function isASCIIWhitespace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
	}
	/**
	* @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
	*/
	function removeASCIIWhitespace(str, leading = true, trailing = true) {
		let lead = 0;
		let trail = str.length - 1;
		if (leading) for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
		if (trailing) for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
		return str.slice(lead, trail + 1);
	}
	module.exports = {
		dataURLProcessor: dataURLProcessor$1,
		URLSerializer: URLSerializer$4,
		collectASequenceOfCodePoints,
		collectASequenceOfCodePointsFast: collectASequenceOfCodePointsFast$1,
		stringPercentDecode,
		parseMIMEType: parseMIMEType$3,
		collectAnHTTPQuotedString,
		serializeAMimeType: serializeAMimeType$4
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({ "node_modules/undici/lib/fetch/file.js"(exports, module) {
	const { Blob: Blob$5, File: NativeFile$2 } = require("buffer");
	const { types: types$3 } = require("util");
	const { kState: kState$9 } = require_symbols$3();
	const { isBlobLike: isBlobLike$5 } = require_util$7();
	const { webidl: webidl$13 } = require_webidl();
	const { parseMIMEType: parseMIMEType$2, serializeAMimeType: serializeAMimeType$3 } = require_dataURL();
	const { kEnumerableProperty: kEnumerableProperty$8 } = require_util$8();
	const encoder = new TextEncoder();
	var File$2 = class File$2 extends Blob$5 {
		constructor(fileBits, fileName, options = {}) {
			webidl$13.argumentLengthCheck(arguments, 2, { header: "File constructor" });
			fileBits = webidl$13.converters["sequence<BlobPart>"](fileBits);
			fileName = webidl$13.converters.USVString(fileName);
			options = webidl$13.converters.FilePropertyBag(options);
			const n = fileName;
			let t = options.type;
			let d$1;
			substep: {
				if (t) {
					t = parseMIMEType$2(t);
					if (t === "failure") {
						t = "";
						break substep;
					}
					t = serializeAMimeType$3(t).toLowerCase();
				}
				d$1 = options.lastModified;
			}
			super(processBlobParts(fileBits, options), { type: t });
			this[kState$9] = {
				name: n,
				lastModified: d$1,
				type: t
			};
		}
		get name() {
			webidl$13.brandCheck(this, File$2);
			return this[kState$9].name;
		}
		get lastModified() {
			webidl$13.brandCheck(this, File$2);
			return this[kState$9].lastModified;
		}
		get type() {
			webidl$13.brandCheck(this, File$2);
			return this[kState$9].type;
		}
	};
	var FileLike$1 = class FileLike$1 {
		constructor(blobLike, fileName, options = {}) {
			const n = fileName;
			const t = options.type;
			const d$1 = options.lastModified ?? Date.now();
			this[kState$9] = {
				blobLike,
				name: n,
				type: t,
				lastModified: d$1
			};
		}
		stream(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.stream(...args);
		}
		arrayBuffer(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.arrayBuffer(...args);
		}
		slice(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.slice(...args);
		}
		text(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.text(...args);
		}
		get size() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.size;
		}
		get type() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.type;
		}
		get name() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].name;
		}
		get lastModified() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].lastModified;
		}
		get [Symbol.toStringTag]() {
			return "File";
		}
	};
	Object.defineProperties(File$2.prototype, {
		[Symbol.toStringTag]: {
			value: "File",
			configurable: true
		},
		name: kEnumerableProperty$8,
		lastModified: kEnumerableProperty$8
	});
	webidl$13.converters.Blob = webidl$13.interfaceConverter(Blob$5);
	webidl$13.converters.BlobPart = function(V, opts) {
		if (webidl$13.util.Type(V) === "Object") {
			if (isBlobLike$5(V)) return webidl$13.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types$3.isAnyArrayBuffer(V)) return webidl$13.converters.BufferSource(V, opts);
		}
		return webidl$13.converters.USVString(V, opts);
	};
	webidl$13.converters["sequence<BlobPart>"] = webidl$13.sequenceConverter(webidl$13.converters.BlobPart);
	webidl$13.converters.FilePropertyBag = webidl$13.dictionaryConverter([
		{
			key: "lastModified",
			converter: webidl$13.converters["long long"],
			get defaultValue() {
				return Date.now();
			}
		},
		{
			key: "type",
			converter: webidl$13.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "endings",
			converter: (value) => {
				value = webidl$13.converters.DOMString(value);
				value = value.toLowerCase();
				if (value !== "native") value = "transparent";
				return value;
			},
			defaultValue: "transparent"
		}
	]);
	/**
	* @see https://www.w3.org/TR/FileAPI/#process-blob-parts
	* @param {(NodeJS.TypedArray|Blob|string)[]} parts
	* @param {{ type: string, endings: string }} options
	*/
	function processBlobParts(parts, options) {
		/** @type {NodeJS.TypedArray[]} */
		const bytes = [];
		for (const element of parts) if (typeof element === "string") {
			let s$1 = element;
			if (options.endings === "native") s$1 = convertLineEndingsNative(s$1);
			bytes.push(encoder.encode(s$1));
		} else if (types$3.isAnyArrayBuffer(element) || types$3.isTypedArray(element)) if (!element.buffer) bytes.push(new Uint8Array(element));
		else bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
		else if (isBlobLike$5(element)) bytes.push(element);
		return bytes;
	}
	/**
	* @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
	* @param {string} s
	*/
	function convertLineEndingsNative(s$1) {
		let nativeLineEnding = "\n";
		if (process.platform === "win32") nativeLineEnding = "\r\n";
		return s$1.replace(/\r?\n/g, nativeLineEnding);
	}
	function isFileLike$1(object) {
		return NativeFile$2 && object instanceof NativeFile$2 || object instanceof File$2 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
	}
	module.exports = {
		File: File$2,
		FileLike: FileLike$1,
		isFileLike: isFileLike$1
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({ "node_modules/undici/lib/fetch/formdata.js"(exports, module) {
	const { isBlobLike: isBlobLike$4, toUSVString: toUSVString$2, makeIterator: makeIterator$1 } = require_util$7();
	const { kState: kState$8 } = require_symbols$3();
	const { File: UndiciFile$1, FileLike, isFileLike } = require_file();
	const { webidl: webidl$12 } = require_webidl();
	const { Blob: Blob$4, File: NativeFile$1 } = require("buffer");
	/** @type {globalThis['File']} */
	const File$1 = NativeFile$1 ?? UndiciFile$1;
	var FormData$3 = class FormData$3 {
		constructor(form) {
			if (form !== void 0) throw webidl$12.errors.conversionFailed({
				prefix: "FormData constructor",
				argument: "Argument 1",
				types: ["undefined"]
			});
			this[kState$8] = [];
		}
		append(name, value, filename = void 0) {
			webidl$12.brandCheck(this, FormData$3);
			webidl$12.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
			if (arguments.length === 3 && !isBlobLike$4(value)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl$12.converters.USVString(name);
			value = isBlobLike$4(value) ? webidl$12.converters.Blob(value, { strict: false }) : webidl$12.converters.USVString(value);
			filename = arguments.length === 3 ? webidl$12.converters.USVString(filename) : void 0;
			const entry = makeEntry(name, value, filename);
			this[kState$8].push(entry);
		}
		delete(name) {
			webidl$12.brandCheck(this, FormData$3);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
			name = webidl$12.converters.USVString(name);
			this[kState$8] = this[kState$8].filter((entry) => entry.name !== name);
		}
		get(name) {
			webidl$12.brandCheck(this, FormData$3);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
			name = webidl$12.converters.USVString(name);
			const idx = this[kState$8].findIndex((entry) => entry.name === name);
			if (idx === -1) return null;
			return this[kState$8][idx].value;
		}
		getAll(name) {
			webidl$12.brandCheck(this, FormData$3);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
			name = webidl$12.converters.USVString(name);
			return this[kState$8].filter((entry) => entry.name === name).map((entry) => entry.value);
		}
		has(name) {
			webidl$12.brandCheck(this, FormData$3);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
			name = webidl$12.converters.USVString(name);
			return this[kState$8].findIndex((entry) => entry.name === name) !== -1;
		}
		set(name, value, filename = void 0) {
			webidl$12.brandCheck(this, FormData$3);
			webidl$12.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
			if (arguments.length === 3 && !isBlobLike$4(value)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl$12.converters.USVString(name);
			value = isBlobLike$4(value) ? webidl$12.converters.Blob(value, { strict: false }) : webidl$12.converters.USVString(value);
			filename = arguments.length === 3 ? toUSVString$2(filename) : void 0;
			const entry = makeEntry(name, value, filename);
			const idx = this[kState$8].findIndex((entry$1) => entry$1.name === name);
			if (idx !== -1) this[kState$8] = [
				...this[kState$8].slice(0, idx),
				entry,
				...this[kState$8].slice(idx + 1).filter((entry$1) => entry$1.name !== name)
			];
			else this[kState$8].push(entry);
		}
		entries() {
			webidl$12.brandCheck(this, FormData$3);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
		}
		keys() {
			webidl$12.brandCheck(this, FormData$3);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "key");
		}
		values() {
			webidl$12.brandCheck(this, FormData$3);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "value");
		}
		/**
		* @param {(value: string, key: string, self: FormData) => void} callbackFn
		* @param {unknown} thisArg
		*/
		forEach(callbackFn, thisArg = globalThis) {
			webidl$12.brandCheck(this, FormData$3);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
			for (const [key, value] of this) callbackFn.apply(thisArg, [
				value,
				key,
				this
			]);
		}
	};
	FormData$3.prototype[Symbol.iterator] = FormData$3.prototype.entries;
	Object.defineProperties(FormData$3.prototype, { [Symbol.toStringTag]: {
		value: "FormData",
		configurable: true
	} });
	/**
	* @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
	* @param {string} name
	* @param {string|Blob} value
	* @param {?string} filename
	* @returns
	*/
	function makeEntry(name, value, filename) {
		name = Buffer.from(name).toString("utf8");
		if (typeof value === "string") value = Buffer.from(value).toString("utf8");
		else {
			if (!isFileLike(value)) value = value instanceof Blob$4 ? new File$1([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
			if (filename !== void 0) {
				/** @type {FilePropertyBag} */
				const options = {
					type: value.type,
					lastModified: value.lastModified
				};
				value = NativeFile$1 && value instanceof NativeFile$1 || value instanceof UndiciFile$1 ? new File$1([value], filename, options) : new FileLike(value, filename, options);
			}
		}
		return {
			name,
			value
		};
	}
	module.exports = { FormData: FormData$3 };
} });

//#endregion
//#region node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({ "node_modules/undici/lib/fetch/body.js"(exports, module) {
	const Busboy = require_main$1();
	const util$22 = require_util$8();
	const { ReadableStreamFrom: ReadableStreamFrom$1, isBlobLike: isBlobLike$3, isReadableStreamLike, readableStreamClose: readableStreamClose$1, createDeferredPromise: createDeferredPromise$2, fullyReadBody: fullyReadBody$1 } = require_util$7();
	const { FormData: FormData$2 } = require_formdata();
	const { kState: kState$7 } = require_symbols$3();
	const { webidl: webidl$11 } = require_webidl();
	const { DOMException: DOMException$5, structuredClone } = require_constants$4();
	const { Blob: Blob$3, File: NativeFile } = require("buffer");
	const { kBodyUsed: kBodyUsed$1 } = require_symbols$4();
	const assert$16 = require("assert");
	const { isErrored: isErrored$1 } = require_util$8();
	const { isUint8Array, isArrayBuffer } = require("util/types");
	const { File: UndiciFile } = require_file();
	const { parseMIMEType: parseMIMEType$1, serializeAMimeType: serializeAMimeType$2 } = require_dataURL();
	let random;
	try {
		const crypto$8 = require("node:crypto");
		random = (max) => crypto$8.randomInt(0, max);
	} catch {
		random = (max) => Math.floor(Math.random(max));
	}
	let ReadableStream$2 = globalThis.ReadableStream;
	/** @type {globalThis['File']} */
	const File = NativeFile ?? UndiciFile;
	const textEncoder$1 = new TextEncoder();
	const textDecoder = new TextDecoder();
	function extractBody$3(object, keepalive = false) {
		if (!ReadableStream$2) ReadableStream$2 = require("stream/web").ReadableStream;
		let stream$6 = null;
		if (object instanceof ReadableStream$2) stream$6 = object;
		else if (isBlobLike$3(object)) stream$6 = object.stream();
		else stream$6 = new ReadableStream$2({
			async pull(controller) {
				controller.enqueue(typeof source === "string" ? textEncoder$1.encode(source) : source);
				queueMicrotask(() => readableStreamClose$1(controller));
			},
			start() {},
			type: void 0
		});
		assert$16(isReadableStreamLike(stream$6));
		let action = null;
		let source = null;
		let length = null;
		let type = null;
		if (typeof object === "string") {
			source = object;
			type = "text/plain;charset=UTF-8";
		} else if (object instanceof URLSearchParams) {
			source = object.toString();
			type = "application/x-www-form-urlencoded;charset=UTF-8";
		} else if (isArrayBuffer(object)) source = new Uint8Array(object.slice());
		else if (ArrayBuffer.isView(object)) source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
		else if (util$22.isFormDataLike(object)) {
			const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
			const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
			/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
			const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
			const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
			const blobParts = [];
			const rn = new Uint8Array([13, 10]);
			length = 0;
			let hasUnknownSizeValue = false;
			for (const [name, value] of object) if (typeof value === "string") {
				const chunk$1 = textEncoder$1.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
				blobParts.push(chunk$1);
				length += chunk$1.byteLength;
			} else {
				const chunk$1 = textEncoder$1.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`);
				blobParts.push(chunk$1, value, rn);
				if (typeof value.size === "number") length += chunk$1.byteLength + value.size + rn.byteLength;
				else hasUnknownSizeValue = true;
			}
			const chunk = textEncoder$1.encode(`--${boundary}--`);
			blobParts.push(chunk);
			length += chunk.byteLength;
			if (hasUnknownSizeValue) length = null;
			source = object;
			action = async function* () {
				for (const part of blobParts) if (part.stream) yield* part.stream();
				else yield part;
			};
			type = "multipart/form-data; boundary=" + boundary;
		} else if (isBlobLike$3(object)) {
			source = object;
			length = object.size;
			if (object.type) type = object.type;
		} else if (typeof object[Symbol.asyncIterator] === "function") {
			if (keepalive) throw new TypeError("keepalive");
			if (util$22.isDisturbed(object) || object.locked) throw new TypeError("Response body object should not be disturbed or locked");
			stream$6 = object instanceof ReadableStream$2 ? object : ReadableStreamFrom$1(object);
		}
		if (typeof source === "string" || util$22.isBuffer(source)) length = Buffer.byteLength(source);
		if (action != null) {
			let iterator$1;
			stream$6 = new ReadableStream$2({
				async start() {
					iterator$1 = action(object)[Symbol.asyncIterator]();
				},
				async pull(controller) {
					const { value, done } = await iterator$1.next();
					if (done) queueMicrotask(() => {
						controller.close();
					});
					else if (!isErrored$1(stream$6)) controller.enqueue(new Uint8Array(value));
					return controller.desiredSize > 0;
				},
				async cancel(reason) {
					await iterator$1.return();
				},
				type: void 0
			});
		}
		const body = {
			stream: stream$6,
			source,
			length
		};
		return [body, type];
	}
	function safelyExtractBody$1(object, keepalive = false) {
		if (!ReadableStream$2)
 // istanbul ignore next
		ReadableStream$2 = require("stream/web").ReadableStream;
		if (object instanceof ReadableStream$2) {
			// istanbul ignore next
			assert$16(!util$22.isDisturbed(object), "The body has already been consumed.");
			// istanbul ignore next
			assert$16(!object.locked, "The stream is locked.");
		}
		return extractBody$3(object, keepalive);
	}
	function cloneBody$2(body) {
		const [out1, out2] = body.stream.tee();
		const out2Clone = structuredClone(out2, { transfer: [out2] });
		const [, finalClone] = out2Clone.tee();
		body.stream = out1;
		return {
			stream: finalClone,
			length: body.length,
			source: body.source
		};
	}
	async function* consumeBody$1(body) {
		if (body) if (isUint8Array(body)) yield body;
		else {
			const stream$6 = body.stream;
			if (util$22.isDisturbed(stream$6)) throw new TypeError("The body has already been consumed.");
			if (stream$6.locked) throw new TypeError("The stream is locked.");
			stream$6[kBodyUsed$1] = true;
			yield* stream$6;
		}
	}
	function throwIfAborted(state) {
		if (state.aborted) throw new DOMException$5("The operation was aborted.", "AbortError");
	}
	function bodyMixinMethods(instance$1) {
		const methods = {
			blob() {
				return specConsumeBody(this, (bytes) => {
					let mimeType = bodyMimeType(this);
					if (mimeType === "failure") mimeType = "";
					else if (mimeType) mimeType = serializeAMimeType$2(mimeType);
					return new Blob$3([bytes], { type: mimeType });
				}, instance$1);
			},
			arrayBuffer() {
				return specConsumeBody(this, (bytes) => {
					return new Uint8Array(bytes).buffer;
				}, instance$1);
			},
			text() {
				return specConsumeBody(this, utf8DecodeBytes, instance$1);
			},
			json() {
				return specConsumeBody(this, parseJSONFromBytes, instance$1);
			},
			async formData() {
				webidl$11.brandCheck(this, instance$1);
				throwIfAborted(this[kState$7]);
				const contentType = this.headers.get("Content-Type");
				if (/multipart\/form-data/.test(contentType)) {
					const headers = {};
					for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
					const responseFormData = new FormData$2();
					let busboy;
					try {
						busboy = new Busboy({
							headers,
							preservePath: true
						});
					} catch (err) {
						throw new DOMException$5(`${err}`, "AbortError");
					}
					busboy.on("field", (name, value) => {
						responseFormData.append(name, value);
					});
					busboy.on("file", (name, value, filename, encoding, mimeType) => {
						const chunks = [];
						if (encoding === "base64" || encoding.toLowerCase() === "base64") {
							let base64chunk = "";
							value.on("data", (chunk) => {
								base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
								const end = base64chunk.length - base64chunk.length % 4;
								chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
								base64chunk = base64chunk.slice(end);
							});
							value.on("end", () => {
								chunks.push(Buffer.from(base64chunk, "base64"));
								responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
							});
						} else {
							value.on("data", (chunk) => {
								chunks.push(chunk);
							});
							value.on("end", () => {
								responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
							});
						}
					});
					const busboyResolve = new Promise((resolve, reject) => {
						busboy.on("finish", resolve);
						busboy.on("error", (err) => reject(new TypeError(err)));
					});
					if (this.body !== null) for await (const chunk of consumeBody$1(this[kState$7].body)) busboy.write(chunk);
					busboy.end();
					await busboyResolve;
					return responseFormData;
				} else if (/application\/x-www-form-urlencoded/.test(contentType)) {
					let entries;
					try {
						let text = "";
						const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
						for await (const chunk of consumeBody$1(this[kState$7].body)) {
							if (!isUint8Array(chunk)) throw new TypeError("Expected Uint8Array chunk");
							text += streamingDecoder.decode(chunk, { stream: true });
						}
						text += streamingDecoder.decode();
						entries = new URLSearchParams(text);
					} catch (err) {
						// istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
						throw Object.assign(new TypeError(), { cause: err });
					}
					const formData = new FormData$2();
					for (const [name, value] of entries) formData.append(name, value);
					return formData;
				} else {
					await Promise.resolve();
					throwIfAborted(this[kState$7]);
					throw webidl$11.errors.exception({
						header: `${instance$1.name}.formData`,
						message: "Could not parse content as FormData."
					});
				}
			}
		};
		return methods;
	}
	function mixinBody$2(prototype) {
		Object.assign(prototype.prototype, bodyMixinMethods(prototype));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-consume-body
	* @param {Response|Request} object
	* @param {(value: unknown) => unknown} convertBytesToJSValue
	* @param {Response|Request} instance
	*/
	async function specConsumeBody(object, convertBytesToJSValue, instance$1) {
		webidl$11.brandCheck(object, instance$1);
		throwIfAborted(object[kState$7]);
		if (bodyUnusable(object[kState$7].body)) throw new TypeError("Body is unusable");
		const promise = createDeferredPromise$2();
		const errorSteps = (error$1) => promise.reject(error$1);
		const successSteps = (data) => {
			try {
				promise.resolve(convertBytesToJSValue(data));
			} catch (e) {
				errorSteps(e);
			}
		};
		if (object[kState$7].body == null) {
			successSteps(new Uint8Array());
			return promise.promise;
		}
		await fullyReadBody$1(object[kState$7].body, successSteps, errorSteps);
		return promise.promise;
	}
	function bodyUnusable(body) {
		return body != null && (body.stream.locked || util$22.isDisturbed(body.stream));
	}
	/**
	* @see https://encoding.spec.whatwg.org/#utf-8-decode
	* @param {Buffer} buffer
	*/
	function utf8DecodeBytes(buffer$1) {
		if (buffer$1.length === 0) return "";
		if (buffer$1[0] === 239 && buffer$1[1] === 187 && buffer$1[2] === 191) buffer$1 = buffer$1.subarray(3);
		const output = textDecoder.decode(buffer$1);
		return output;
	}
	/**
	* @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
	* @param {Uint8Array} bytes
	*/
	function parseJSONFromBytes(bytes) {
		return JSON.parse(utf8DecodeBytes(bytes));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-mime-type
	* @param {import('./response').Response|import('./request').Request} object
	*/
	function bodyMimeType(object) {
		const { headersList } = object[kState$7];
		const contentType = headersList.get("content-type");
		if (contentType === null) return "failure";
		return parseMIMEType$1(contentType);
	}
	module.exports = {
		extractBody: extractBody$3,
		safelyExtractBody: safelyExtractBody$1,
		cloneBody: cloneBody$2,
		mixinBody: mixinBody$2
	};
} });

//#endregion
//#region node_modules/undici/lib/core/request.js
var require_request$1 = __commonJS({ "node_modules/undici/lib/core/request.js"(exports, module) {
	const { InvalidArgumentError: InvalidArgumentError$20, NotSupportedError: NotSupportedError$1 } = require_errors();
	const assert$15 = require("assert");
	const { kHTTP2BuildRequest: kHTTP2BuildRequest$1, kHTTP2CopyHeaders: kHTTP2CopyHeaders$1, kHTTP1BuildRequest: kHTTP1BuildRequest$1 } = require_symbols$4();
	const util$21 = require_util$8();
	/**
	* Verifies that the given val is a valid HTTP token
	* per the rules defined in RFC 7230
	* See https://tools.ietf.org/html/rfc7230#section-3.2.6
	*/
	const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
	/**
	* Matches if val contains an invalid field-vchar
	*  field-value    = *( field-content / obs-fold )
	*  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	*  field-vchar    = VCHAR / obs-text
	*/
	const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
	const invalidPathRegex = /[^\u0021-\u00ff]/;
	const kHandler = Symbol("handler");
	const channels$3 = {};
	let extractBody$2;
	try {
		const diagnosticsChannel$2 = require("diagnostics_channel");
		channels$3.create = diagnosticsChannel$2.channel("undici:request:create");
		channels$3.bodySent = diagnosticsChannel$2.channel("undici:request:bodySent");
		channels$3.headers = diagnosticsChannel$2.channel("undici:request:headers");
		channels$3.trailers = diagnosticsChannel$2.channel("undici:request:trailers");
		channels$3.error = diagnosticsChannel$2.channel("undici:request:error");
	} catch {
		channels$3.create = { hasSubscribers: false };
		channels$3.bodySent = { hasSubscribers: false };
		channels$3.headers = { hasSubscribers: false };
		channels$3.trailers = { hasSubscribers: false };
		channels$3.error = { hasSubscribers: false };
	}
	var Request$5 = class Request$5 {
		constructor(origin, { path: path$8, method, body, headers, query, idempotent, blocking, upgrade: upgrade$1, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue }, handler$1) {
			if (typeof path$8 !== "string") throw new InvalidArgumentError$20("path must be a string");
			else if (path$8[0] !== "/" && !(path$8.startsWith("http://") || path$8.startsWith("https://")) && method !== "CONNECT") throw new InvalidArgumentError$20("path must be an absolute URL or start with a slash");
			else if (invalidPathRegex.exec(path$8) !== null) throw new InvalidArgumentError$20("invalid request path");
			if (typeof method !== "string") throw new InvalidArgumentError$20("method must be a string");
			else if (tokenRegExp.exec(method) === null) throw new InvalidArgumentError$20("invalid request method");
			if (upgrade$1 && typeof upgrade$1 !== "string") throw new InvalidArgumentError$20("upgrade must be a string");
			if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$20("invalid headersTimeout");
			if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$20("invalid bodyTimeout");
			if (reset != null && typeof reset !== "boolean") throw new InvalidArgumentError$20("invalid reset");
			if (expectContinue != null && typeof expectContinue !== "boolean") throw new InvalidArgumentError$20("invalid expectContinue");
			this.headersTimeout = headersTimeout;
			this.bodyTimeout = bodyTimeout;
			this.throwOnError = throwOnError === true;
			this.method = method;
			this.abort = null;
			if (body == null) this.body = null;
			else if (util$21.isStream(body)) {
				this.body = body;
				const rState = this.body._readableState;
				if (!rState || !rState.autoDestroy) {
					this.endHandler = function autoDestroy() {
						util$21.destroy(this);
					};
					this.body.on("end", this.endHandler);
				}
				this.errorHandler = (err) => {
					if (this.abort) this.abort(err);
					else this.error = err;
				};
				this.body.on("error", this.errorHandler);
			} else if (util$21.isBuffer(body)) this.body = body.byteLength ? body : null;
			else if (ArrayBuffer.isView(body)) this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
			else if (body instanceof ArrayBuffer) this.body = body.byteLength ? Buffer.from(body) : null;
			else if (typeof body === "string") this.body = body.length ? Buffer.from(body) : null;
			else if (util$21.isFormDataLike(body) || util$21.isIterable(body) || util$21.isBlobLike(body)) this.body = body;
			else throw new InvalidArgumentError$20("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
			this.completed = false;
			this.aborted = false;
			this.upgrade = upgrade$1 || null;
			this.path = query ? util$21.buildURL(path$8, query) : path$8;
			this.origin = origin;
			this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
			this.blocking = blocking == null ? false : blocking;
			this.reset = reset == null ? null : reset;
			this.host = null;
			this.contentLength = null;
			this.contentType = null;
			this.headers = "";
			this.expectContinue = expectContinue != null ? expectContinue : false;
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError$20("headers array must be even");
				for (let i$1 = 0; i$1 < headers.length; i$1 += 2) processHeader(this, headers[i$1], headers[i$1 + 1]);
			} else if (headers && typeof headers === "object") {
				const keys = Object.keys(headers);
				for (let i$1 = 0; i$1 < keys.length; i$1++) {
					const key = keys[i$1];
					processHeader(this, key, headers[key]);
				}
			} else if (headers != null) throw new InvalidArgumentError$20("headers must be an object or an array");
			if (util$21.isFormDataLike(this.body)) {
				if (util$21.nodeMajor < 16 || util$21.nodeMajor === 16 && util$21.nodeMinor < 8) throw new InvalidArgumentError$20("Form-Data bodies are only supported in node v16.8 and newer.");
				if (!extractBody$2) extractBody$2 = require_body().extractBody;
				const [bodyStream, contentType] = extractBody$2(body);
				if (this.contentType == null) {
					this.contentType = contentType;
					this.headers += `content-type: ${contentType}\r\n`;
				}
				this.body = bodyStream.stream;
				this.contentLength = bodyStream.length;
			} else if (util$21.isBlobLike(body) && this.contentType == null && body.type) {
				this.contentType = body.type;
				this.headers += `content-type: ${body.type}\r\n`;
			}
			util$21.validateHandler(handler$1, method, upgrade$1);
			this.servername = util$21.getServerName(this.host);
			this[kHandler] = handler$1;
			if (channels$3.create.hasSubscribers) channels$3.create.publish({ request: this });
		}
		onBodySent(chunk) {
			if (this[kHandler].onBodySent) try {
				return this[kHandler].onBodySent(chunk);
			} catch (err) {
				this.abort(err);
			}
		}
		onRequestSent() {
			if (channels$3.bodySent.hasSubscribers) channels$3.bodySent.publish({ request: this });
			if (this[kHandler].onRequestSent) try {
				return this[kHandler].onRequestSent();
			} catch (err) {
				this.abort(err);
			}
		}
		onConnect(abort$1) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			if (this.error) abort$1(this.error);
			else {
				this.abort = abort$1;
				return this[kHandler].onConnect(abort$1);
			}
		}
		onHeaders(statusCode, headers, resume$3, statusText) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			if (channels$3.headers.hasSubscribers) channels$3.headers.publish({
				request: this,
				response: {
					statusCode,
					headers,
					statusText
				}
			});
			try {
				return this[kHandler].onHeaders(statusCode, headers, resume$3, statusText);
			} catch (err) {
				this.abort(err);
			}
		}
		onData(chunk) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			try {
				return this[kHandler].onData(chunk);
			} catch (err) {
				this.abort(err);
				return false;
			}
		}
		onUpgrade(statusCode, headers, socket) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			return this[kHandler].onUpgrade(statusCode, headers, socket);
		}
		onComplete(trailers) {
			this.onFinally();
			assert$15(!this.aborted);
			this.completed = true;
			if (channels$3.trailers.hasSubscribers) channels$3.trailers.publish({
				request: this,
				trailers
			});
			try {
				return this[kHandler].onComplete(trailers);
			} catch (err) {
				this.onError(err);
			}
		}
		onError(error$1) {
			this.onFinally();
			if (channels$3.error.hasSubscribers) channels$3.error.publish({
				request: this,
				error: error$1
			});
			if (this.aborted) return;
			this.aborted = true;
			return this[kHandler].onError(error$1);
		}
		onFinally() {
			if (this.errorHandler) {
				this.body.off("error", this.errorHandler);
				this.errorHandler = null;
			}
			if (this.endHandler) {
				this.body.off("end", this.endHandler);
				this.endHandler = null;
			}
		}
		addHeader(key, value) {
			processHeader(this, key, value);
			return this;
		}
		static [kHTTP1BuildRequest$1](origin, opts, handler$1) {
			return new Request$5(origin, opts, handler$1);
		}
		static [kHTTP2BuildRequest$1](origin, opts, handler$1) {
			const headers = opts.headers;
			opts = {
				...opts,
				headers: null
			};
			const request$3 = new Request$5(origin, opts, handler$1);
			request$3.headers = {};
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError$20("headers array must be even");
				for (let i$1 = 0; i$1 < headers.length; i$1 += 2) processHeader(request$3, headers[i$1], headers[i$1 + 1], true);
			} else if (headers && typeof headers === "object") {
				const keys = Object.keys(headers);
				for (let i$1 = 0; i$1 < keys.length; i$1++) {
					const key = keys[i$1];
					processHeader(request$3, key, headers[key], true);
				}
			} else if (headers != null) throw new InvalidArgumentError$20("headers must be an object or an array");
			return request$3;
		}
		static [kHTTP2CopyHeaders$1](raw) {
			const rawHeaders = raw.split("\r\n");
			const headers = {};
			for (const header of rawHeaders) {
				const [key, value] = header.split(": ");
				if (value == null || value.length === 0) continue;
				if (headers[key]) headers[key] += `,${value}`;
				else headers[key] = value;
			}
			return headers;
		}
	};
	function processHeaderValue(key, val, skipAppend) {
		if (val && typeof val === "object") throw new InvalidArgumentError$20(`invalid ${key} header`);
		val = val != null ? `${val}` : "";
		if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError$20(`invalid ${key} header`);
		return skipAppend ? val : `${key}: ${val}\r\n`;
	}
	function processHeader(request$3, key, val, skipAppend = false) {
		if (val && typeof val === "object" && !Array.isArray(val)) throw new InvalidArgumentError$20(`invalid ${key} header`);
		else if (val === void 0) return;
		if (request$3.host === null && key.length === 4 && key.toLowerCase() === "host") {
			if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError$20(`invalid ${key} header`);
			request$3.host = val;
		} else if (request$3.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
			request$3.contentLength = parseInt(val, 10);
			if (!Number.isFinite(request$3.contentLength)) throw new InvalidArgumentError$20("invalid content-length header");
		} else if (request$3.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
			request$3.contentType = val;
			if (skipAppend) request$3.headers[key] = processHeaderValue(key, val, skipAppend);
			else request$3.headers += processHeaderValue(key, val);
		} else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") throw new InvalidArgumentError$20("invalid transfer-encoding header");
		else if (key.length === 10 && key.toLowerCase() === "connection") {
			const value = typeof val === "string" ? val.toLowerCase() : null;
			if (value !== "close" && value !== "keep-alive") throw new InvalidArgumentError$20("invalid connection header");
			else if (value === "close") request$3.reset = true;
		} else if (key.length === 10 && key.toLowerCase() === "keep-alive") throw new InvalidArgumentError$20("invalid keep-alive header");
		else if (key.length === 7 && key.toLowerCase() === "upgrade") throw new InvalidArgumentError$20("invalid upgrade header");
		else if (key.length === 6 && key.toLowerCase() === "expect") throw new NotSupportedError$1("expect header not supported");
		else if (tokenRegExp.exec(key) === null) throw new InvalidArgumentError$20("invalid header key");
		else if (Array.isArray(val)) for (let i$1 = 0; i$1 < val.length; i$1++) if (skipAppend) if (request$3.headers[key]) request$3.headers[key] += `,${processHeaderValue(key, val[i$1], skipAppend)}`;
		else request$3.headers[key] = processHeaderValue(key, val[i$1], skipAppend);
		else request$3.headers += processHeaderValue(key, val[i$1]);
		else if (skipAppend) request$3.headers[key] = processHeaderValue(key, val, skipAppend);
		else request$3.headers += processHeaderValue(key, val);
	}
	module.exports = Request$5;
} });

//#endregion
//#region node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({ "node_modules/undici/lib/dispatcher.js"(exports, module) {
	const EventEmitter$2 = require("events");
	var Dispatcher$3 = class extends EventEmitter$2 {
		dispatch() {
			throw new Error("not implemented");
		}
		close() {
			throw new Error("not implemented");
		}
		destroy() {
			throw new Error("not implemented");
		}
	};
	module.exports = Dispatcher$3;
} });

//#endregion
//#region node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({ "node_modules/undici/lib/dispatcher-base.js"(exports, module) {
	const Dispatcher$2 = require_dispatcher();
	const { ClientDestroyedError: ClientDestroyedError$1, ClientClosedError, InvalidArgumentError: InvalidArgumentError$19 } = require_errors();
	const { kDestroy: kDestroy$4, kClose: kClose$6, kDispatch: kDispatch$3, kInterceptors: kInterceptors$5 } = require_symbols$4();
	const kDestroyed = Symbol("destroyed");
	const kClosed = Symbol("closed");
	const kOnDestroyed = Symbol("onDestroyed");
	const kOnClosed = Symbol("onClosed");
	const kInterceptedDispatch = Symbol("Intercepted Dispatch");
	var DispatcherBase$4 = class extends Dispatcher$2 {
		constructor() {
			super();
			this[kDestroyed] = false;
			this[kOnDestroyed] = null;
			this[kClosed] = false;
			this[kOnClosed] = [];
		}
		get destroyed() {
			return this[kDestroyed];
		}
		get closed() {
			return this[kClosed];
		}
		get interceptors() {
			return this[kInterceptors$5];
		}
		set interceptors(newInterceptors) {
			if (newInterceptors) for (let i$1 = newInterceptors.length - 1; i$1 >= 0; i$1--) {
				const interceptor = this[kInterceptors$5][i$1];
				if (typeof interceptor !== "function") throw new InvalidArgumentError$19("interceptor must be an function");
			}
			this[kInterceptors$5] = newInterceptors;
		}
		close(callback) {
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.close((err, data) => {
					return err ? reject(err) : resolve(data);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError$19("invalid callback");
			if (this[kDestroyed]) {
				queueMicrotask(() => callback(new ClientDestroyedError$1(), null));
				return;
			}
			if (this[kClosed]) {
				if (this[kOnClosed]) this[kOnClosed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			this[kClosed] = true;
			this[kOnClosed].push(callback);
			const onClosed = () => {
				const callbacks = this[kOnClosed];
				this[kOnClosed] = null;
				for (let i$1 = 0; i$1 < callbacks.length; i$1++) callbacks[i$1](null, null);
			};
			this[kClose$6]().then(() => this.destroy()).then(() => {
				queueMicrotask(onClosed);
			});
		}
		destroy(err, callback) {
			if (typeof err === "function") {
				callback = err;
				err = null;
			}
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.destroy(err, (err$1, data) => {
					return err$1 ? reject(err$1) : resolve(data);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError$19("invalid callback");
			if (this[kDestroyed]) {
				if (this[kOnDestroyed]) this[kOnDestroyed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			if (!err) err = new ClientDestroyedError$1();
			this[kDestroyed] = true;
			this[kOnDestroyed] = this[kOnDestroyed] || [];
			this[kOnDestroyed].push(callback);
			const onDestroyed = () => {
				const callbacks = this[kOnDestroyed];
				this[kOnDestroyed] = null;
				for (let i$1 = 0; i$1 < callbacks.length; i$1++) callbacks[i$1](null, null);
			};
			this[kDestroy$4](err).then(() => {
				queueMicrotask(onDestroyed);
			});
		}
		[kInterceptedDispatch](opts, handler$1) {
			if (!this[kInterceptors$5] || this[kInterceptors$5].length === 0) {
				this[kInterceptedDispatch] = this[kDispatch$3];
				return this[kDispatch$3](opts, handler$1);
			}
			let dispatch = this[kDispatch$3].bind(this);
			for (let i$1 = this[kInterceptors$5].length - 1; i$1 >= 0; i$1--) dispatch = this[kInterceptors$5][i$1](dispatch);
			this[kInterceptedDispatch] = dispatch;
			return dispatch(opts, handler$1);
		}
		dispatch(opts, handler$1) {
			if (!handler$1 || typeof handler$1 !== "object") throw new InvalidArgumentError$19("handler must be an object");
			try {
				if (!opts || typeof opts !== "object") throw new InvalidArgumentError$19("opts must be an object.");
				if (this[kDestroyed] || this[kOnDestroyed]) throw new ClientDestroyedError$1();
				if (this[kClosed]) throw new ClientClosedError();
				return this[kInterceptedDispatch](opts, handler$1);
			} catch (err) {
				if (typeof handler$1.onError !== "function") throw new InvalidArgumentError$19("invalid onError method");
				handler$1.onError(err);
				return false;
			}
		}
	};
	module.exports = DispatcherBase$4;
} });

//#endregion
//#region node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({ "node_modules/undici/lib/core/connect.js"(exports, module) {
	const net$4 = require("net");
	const assert$14 = require("assert");
	const util$20 = require_util$8();
	const { InvalidArgumentError: InvalidArgumentError$18, ConnectTimeoutError } = require_errors();
	let tls$2;
	let SessionCache;
	if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) SessionCache = class WeakSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = new Map();
			this._sessionRegistry = new global.FinalizationRegistry((key) => {
				if (this._sessionCache.size < this._maxCachedSessions) return;
				const ref = this._sessionCache.get(key);
				if (ref !== void 0 && ref.deref() === void 0) this._sessionCache.delete(key);
			});
		}
		get(sessionKey) {
			const ref = this._sessionCache.get(sessionKey);
			return ref ? ref.deref() : null;
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			this._sessionCache.set(sessionKey, new WeakRef(session));
			this._sessionRegistry.register(session, sessionKey);
		}
	};
	else SessionCache = class SimpleSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = new Map();
		}
		get(sessionKey) {
			return this._sessionCache.get(sessionKey);
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			if (this._sessionCache.size >= this._maxCachedSessions) {
				const { value: oldestKey } = this._sessionCache.keys().next();
				this._sessionCache.delete(oldestKey);
			}
			this._sessionCache.set(sessionKey, session);
		}
	};
	function buildConnector$4({ allowH2, maxCachedSessions, socketPath, timeout,...opts }) {
		if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new InvalidArgumentError$18("maxCachedSessions must be a positive integer or zero");
		const options = {
			path: socketPath,
			...opts
		};
		const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
		timeout = timeout == null ? 1e4 : timeout;
		allowH2 = allowH2 != null ? allowH2 : false;
		return function connect$2({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
			let socket;
			if (protocol === "https:") {
				if (!tls$2) tls$2 = require("tls");
				servername = servername || options.servername || util$20.getServerName(host) || null;
				const sessionKey = servername || hostname;
				const session = sessionCache.get(sessionKey) || null;
				assert$14(sessionKey);
				socket = tls$2.connect({
					highWaterMark: 16384,
					...options,
					servername,
					session,
					localAddress,
					ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
					socket: httpSocket,
					port: port || 443,
					host: hostname
				});
				socket.on("session", function(session$1) {
					sessionCache.set(sessionKey, session$1);
				});
			} else {
				assert$14(!httpSocket, "httpSocket can only be sent on TLS update");
				socket = net$4.connect({
					highWaterMark: 64 * 1024,
					...options,
					localAddress,
					port: port || 80,
					host: hostname
				});
			}
			if (options.keepAlive == null || options.keepAlive) {
				const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
				socket.setKeepAlive(true, keepAliveInitialDelay);
			}
			const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
			socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(null, this);
				}
			}).on("error", function(err) {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(err);
				}
			});
			return socket;
		};
	}
	function setupTimeout(onConnectTimeout$1, timeout) {
		if (!timeout) return () => {};
		let s1 = null;
		let s2 = null;
		const timeoutId = setTimeout(() => {
			s1 = setImmediate(() => {
				if (process.platform === "win32") s2 = setImmediate(() => onConnectTimeout$1());
				else onConnectTimeout$1();
			});
		}, timeout);
		return () => {
			clearTimeout(timeoutId);
			clearImmediate(s1);
			clearImmediate(s2);
		};
	}
	function onConnectTimeout(socket) {
		util$20.destroy(socket, new ConnectTimeoutError());
	}
	module.exports = buildConnector$4;
} });

//#endregion
//#region node_modules/undici/lib/llhttp/utils.js
var require_utils$3 = __commonJS({ "node_modules/undici/lib/llhttp/utils.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.enumToMap = void 0;
	function enumToMap(obj) {
		const res = {};
		Object.keys(obj).forEach((key) => {
			const value = obj[key];
			if (typeof value === "number") res[key] = value;
		});
		return res;
	}
	exports.enumToMap = enumToMap;
} });

//#endregion
//#region node_modules/undici/lib/llhttp/constants.js
var require_constants$3 = __commonJS({ "node_modules/undici/lib/llhttp/constants.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
	const utils_1$2 = require_utils$3();
	var ERROR;
	(function(ERROR$1) {
		ERROR$1[ERROR$1["OK"] = 0] = "OK";
		ERROR$1[ERROR$1["INTERNAL"] = 1] = "INTERNAL";
		ERROR$1[ERROR$1["STRICT"] = 2] = "STRICT";
		ERROR$1[ERROR$1["LF_EXPECTED"] = 3] = "LF_EXPECTED";
		ERROR$1[ERROR$1["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
		ERROR$1[ERROR$1["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
		ERROR$1[ERROR$1["INVALID_METHOD"] = 6] = "INVALID_METHOD";
		ERROR$1[ERROR$1["INVALID_URL"] = 7] = "INVALID_URL";
		ERROR$1[ERROR$1["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
		ERROR$1[ERROR$1["INVALID_VERSION"] = 9] = "INVALID_VERSION";
		ERROR$1[ERROR$1["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
		ERROR$1[ERROR$1["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
		ERROR$1[ERROR$1["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
		ERROR$1[ERROR$1["INVALID_STATUS"] = 13] = "INVALID_STATUS";
		ERROR$1[ERROR$1["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
		ERROR$1[ERROR$1["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
		ERROR$1[ERROR$1["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
		ERROR$1[ERROR$1["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
		ERROR$1[ERROR$1["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
		ERROR$1[ERROR$1["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
		ERROR$1[ERROR$1["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
		ERROR$1[ERROR$1["PAUSED"] = 21] = "PAUSED";
		ERROR$1[ERROR$1["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
		ERROR$1[ERROR$1["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
		ERROR$1[ERROR$1["USER"] = 24] = "USER";
	})(ERROR = exports.ERROR || (exports.ERROR = {}));
	var TYPE$1;
	(function(TYPE$2) {
		TYPE$2[TYPE$2["BOTH"] = 0] = "BOTH";
		TYPE$2[TYPE$2["REQUEST"] = 1] = "REQUEST";
		TYPE$2[TYPE$2["RESPONSE"] = 2] = "RESPONSE";
	})(TYPE$1 = exports.TYPE || (exports.TYPE = {}));
	var FLAGS;
	(function(FLAGS$1) {
		FLAGS$1[FLAGS$1["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
		FLAGS$1[FLAGS$1["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
		FLAGS$1[FLAGS$1["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
		FLAGS$1[FLAGS$1["CHUNKED"] = 8] = "CHUNKED";
		FLAGS$1[FLAGS$1["UPGRADE"] = 16] = "UPGRADE";
		FLAGS$1[FLAGS$1["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
		FLAGS$1[FLAGS$1["SKIPBODY"] = 64] = "SKIPBODY";
		FLAGS$1[FLAGS$1["TRAILING"] = 128] = "TRAILING";
		FLAGS$1[FLAGS$1["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
	})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
	var LENIENT_FLAGS;
	(function(LENIENT_FLAGS$1) {
		LENIENT_FLAGS$1[LENIENT_FLAGS$1["HEADERS"] = 1] = "HEADERS";
		LENIENT_FLAGS$1[LENIENT_FLAGS$1["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
		LENIENT_FLAGS$1[LENIENT_FLAGS$1["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
	})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
	var METHODS;
	(function(METHODS$1) {
		METHODS$1[METHODS$1["DELETE"] = 0] = "DELETE";
		METHODS$1[METHODS$1["GET"] = 1] = "GET";
		METHODS$1[METHODS$1["HEAD"] = 2] = "HEAD";
		METHODS$1[METHODS$1["POST"] = 3] = "POST";
		METHODS$1[METHODS$1["PUT"] = 4] = "PUT";
		METHODS$1[METHODS$1["CONNECT"] = 5] = "CONNECT";
		METHODS$1[METHODS$1["OPTIONS"] = 6] = "OPTIONS";
		METHODS$1[METHODS$1["TRACE"] = 7] = "TRACE";
		METHODS$1[METHODS$1["COPY"] = 8] = "COPY";
		METHODS$1[METHODS$1["LOCK"] = 9] = "LOCK";
		METHODS$1[METHODS$1["MKCOL"] = 10] = "MKCOL";
		METHODS$1[METHODS$1["MOVE"] = 11] = "MOVE";
		METHODS$1[METHODS$1["PROPFIND"] = 12] = "PROPFIND";
		METHODS$1[METHODS$1["PROPPATCH"] = 13] = "PROPPATCH";
		METHODS$1[METHODS$1["SEARCH"] = 14] = "SEARCH";
		METHODS$1[METHODS$1["UNLOCK"] = 15] = "UNLOCK";
		METHODS$1[METHODS$1["BIND"] = 16] = "BIND";
		METHODS$1[METHODS$1["REBIND"] = 17] = "REBIND";
		METHODS$1[METHODS$1["UNBIND"] = 18] = "UNBIND";
		METHODS$1[METHODS$1["ACL"] = 19] = "ACL";
		METHODS$1[METHODS$1["REPORT"] = 20] = "REPORT";
		METHODS$1[METHODS$1["MKACTIVITY"] = 21] = "MKACTIVITY";
		METHODS$1[METHODS$1["CHECKOUT"] = 22] = "CHECKOUT";
		METHODS$1[METHODS$1["MERGE"] = 23] = "MERGE";
		METHODS$1[METHODS$1["M-SEARCH"] = 24] = "M-SEARCH";
		METHODS$1[METHODS$1["NOTIFY"] = 25] = "NOTIFY";
		METHODS$1[METHODS$1["SUBSCRIBE"] = 26] = "SUBSCRIBE";
		METHODS$1[METHODS$1["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
		METHODS$1[METHODS$1["PATCH"] = 28] = "PATCH";
		METHODS$1[METHODS$1["PURGE"] = 29] = "PURGE";
		METHODS$1[METHODS$1["MKCALENDAR"] = 30] = "MKCALENDAR";
		METHODS$1[METHODS$1["LINK"] = 31] = "LINK";
		METHODS$1[METHODS$1["UNLINK"] = 32] = "UNLINK";
		METHODS$1[METHODS$1["SOURCE"] = 33] = "SOURCE";
		METHODS$1[METHODS$1["PRI"] = 34] = "PRI";
		METHODS$1[METHODS$1["DESCRIBE"] = 35] = "DESCRIBE";
		METHODS$1[METHODS$1["ANNOUNCE"] = 36] = "ANNOUNCE";
		METHODS$1[METHODS$1["SETUP"] = 37] = "SETUP";
		METHODS$1[METHODS$1["PLAY"] = 38] = "PLAY";
		METHODS$1[METHODS$1["PAUSE"] = 39] = "PAUSE";
		METHODS$1[METHODS$1["TEARDOWN"] = 40] = "TEARDOWN";
		METHODS$1[METHODS$1["GET_PARAMETER"] = 41] = "GET_PARAMETER";
		METHODS$1[METHODS$1["SET_PARAMETER"] = 42] = "SET_PARAMETER";
		METHODS$1[METHODS$1["REDIRECT"] = 43] = "REDIRECT";
		METHODS$1[METHODS$1["RECORD"] = 44] = "RECORD";
		METHODS$1[METHODS$1["FLUSH"] = 45] = "FLUSH";
	})(METHODS = exports.METHODS || (exports.METHODS = {}));
	exports.METHODS_HTTP = [
		METHODS.DELETE,
		METHODS.GET,
		METHODS.HEAD,
		METHODS.POST,
		METHODS.PUT,
		METHODS.CONNECT,
		METHODS.OPTIONS,
		METHODS.TRACE,
		METHODS.COPY,
		METHODS.LOCK,
		METHODS.MKCOL,
		METHODS.MOVE,
		METHODS.PROPFIND,
		METHODS.PROPPATCH,
		METHODS.SEARCH,
		METHODS.UNLOCK,
		METHODS.BIND,
		METHODS.REBIND,
		METHODS.UNBIND,
		METHODS.ACL,
		METHODS.REPORT,
		METHODS.MKACTIVITY,
		METHODS.CHECKOUT,
		METHODS.MERGE,
		METHODS["M-SEARCH"],
		METHODS.NOTIFY,
		METHODS.SUBSCRIBE,
		METHODS.UNSUBSCRIBE,
		METHODS.PATCH,
		METHODS.PURGE,
		METHODS.MKCALENDAR,
		METHODS.LINK,
		METHODS.UNLINK,
		METHODS.PRI,
		METHODS.SOURCE
	];
	exports.METHODS_ICE = [METHODS.SOURCE];
	exports.METHODS_RTSP = [
		METHODS.OPTIONS,
		METHODS.DESCRIBE,
		METHODS.ANNOUNCE,
		METHODS.SETUP,
		METHODS.PLAY,
		METHODS.PAUSE,
		METHODS.TEARDOWN,
		METHODS.GET_PARAMETER,
		METHODS.SET_PARAMETER,
		METHODS.REDIRECT,
		METHODS.RECORD,
		METHODS.FLUSH,
		METHODS.GET,
		METHODS.POST
	];
	exports.METHOD_MAP = utils_1$2.enumToMap(METHODS);
	exports.H_METHOD_MAP = {};
	Object.keys(exports.METHOD_MAP).forEach((key) => {
		if (/^H/.test(key)) exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
	});
	var FINISH;
	(function(FINISH$1) {
		FINISH$1[FINISH$1["SAFE"] = 0] = "SAFE";
		FINISH$1[FINISH$1["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
		FINISH$1[FINISH$1["UNSAFE"] = 2] = "UNSAFE";
	})(FINISH = exports.FINISH || (exports.FINISH = {}));
	exports.ALPHA = [];
	for (let i$1 = "A".charCodeAt(0); i$1 <= "Z".charCodeAt(0); i$1++) {
		exports.ALPHA.push(String.fromCharCode(i$1));
		exports.ALPHA.push(String.fromCharCode(i$1 + 32));
	}
	exports.NUM_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9
	};
	exports.HEX_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15
	};
	exports.NUM = [
		"0",
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9"
	];
	exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
	exports.MARK = [
		"-",
		"_",
		".",
		"!",
		"~",
		"*",
		"'",
		"(",
		")"
	];
	exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([
		"%",
		";",
		":",
		"&",
		"=",
		"+",
		"$",
		","
	]);
	exports.STRICT_URL_CHAR = [
		"!",
		"\"",
		"$",
		"%",
		"&",
		"'",
		"(",
		")",
		"*",
		"+",
		",",
		"-",
		".",
		"/",
		":",
		";",
		"<",
		"=",
		">",
		"@",
		"[",
		"\\",
		"]",
		"^",
		"_",
		"`",
		"{",
		"|",
		"}",
		"~"
	].concat(exports.ALPHANUM);
	exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
	for (let i$1 = 128; i$1 <= 255; i$1++) exports.URL_CHAR.push(i$1);
	exports.HEX = exports.NUM.concat([
		"a",
		"b",
		"c",
		"d",
		"e",
		"f",
		"A",
		"B",
		"C",
		"D",
		"E",
		"F"
	]);
	exports.STRICT_TOKEN = [
		"!",
		"#",
		"$",
		"%",
		"&",
		"'",
		"*",
		"+",
		"-",
		".",
		"^",
		"_",
		"`",
		"|",
		"~"
	].concat(exports.ALPHANUM);
	exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
	exports.HEADER_CHARS = ["	"];
	for (let i$1 = 32; i$1 <= 255; i$1++) if (i$1 !== 127) exports.HEADER_CHARS.push(i$1);
	exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
	exports.MAJOR = exports.NUM_MAP;
	exports.MINOR = exports.MAJOR;
	var HEADER_STATE;
	(function(HEADER_STATE$1) {
		HEADER_STATE$1[HEADER_STATE$1["GENERAL"] = 0] = "GENERAL";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION"] = 1] = "CONNECTION";
		HEADER_STATE$1[HEADER_STATE$1["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
		HEADER_STATE$1[HEADER_STATE$1["UPGRADE"] = 4] = "UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
	})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
	exports.SPECIAL_HEADERS = {
		"connection": HEADER_STATE.CONNECTION,
		"content-length": HEADER_STATE.CONTENT_LENGTH,
		"proxy-connection": HEADER_STATE.CONNECTION,
		"transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
		"upgrade": HEADER_STATE.UPGRADE
	};
} });

//#endregion
//#region node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({ "node_modules/undici/lib/handler/RedirectHandler.js"(exports, module) {
	const util$19 = require_util$8();
	const { kBodyUsed } = require_symbols$4();
	const assert$13 = require("assert");
	const { InvalidArgumentError: InvalidArgumentError$17 } = require_errors();
	const EE$1 = require("events");
	const redirectableStatusCodes = [
		300,
		301,
		302,
		303,
		307,
		308
	];
	const kBody$1 = Symbol("body");
	var BodyAsyncIterable = class {
		constructor(body) {
			this[kBody$1] = body;
			this[kBodyUsed] = false;
		}
		async *[Symbol.asyncIterator]() {
			assert$13(!this[kBodyUsed], "disturbed");
			this[kBodyUsed] = true;
			yield* this[kBody$1];
		}
	};
	var RedirectHandler$2 = class {
		constructor(dispatch, maxRedirections, opts, handler$1) {
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$17("maxRedirections must be a positive number");
			util$19.validateHandler(handler$1, opts.method, opts.upgrade);
			this.dispatch = dispatch;
			this.location = null;
			this.abort = null;
			this.opts = {
				...opts,
				maxRedirections: 0
			};
			this.maxRedirections = maxRedirections;
			this.handler = handler$1;
			this.history = [];
			if (util$19.isStream(this.opts.body)) {
				if (util$19.bodyLength(this.opts.body) === 0) this.opts.body.on("data", function() {
					assert$13(false);
				});
				if (typeof this.opts.body.readableDidRead !== "boolean") {
					this.opts.body[kBodyUsed] = false;
					EE$1.prototype.on.call(this.opts.body, "data", function() {
						this[kBodyUsed] = true;
					});
				}
			} else if (this.opts.body && typeof this.opts.body.pipeTo === "function") this.opts.body = new BodyAsyncIterable(this.opts.body);
			else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util$19.isIterable(this.opts.body)) this.opts.body = new BodyAsyncIterable(this.opts.body);
		}
		onConnect(abort$1) {
			this.abort = abort$1;
			this.handler.onConnect(abort$1, { history: this.history });
		}
		onUpgrade(statusCode, headers, socket) {
			this.handler.onUpgrade(statusCode, headers, socket);
		}
		onError(error$1) {
			this.handler.onError(error$1);
		}
		onHeaders(statusCode, headers, resume$3, statusText) {
			this.location = this.history.length >= this.maxRedirections || util$19.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
			if (this.opts.origin) this.history.push(new URL(this.opts.path, this.opts.origin));
			if (!this.location) return this.handler.onHeaders(statusCode, headers, resume$3, statusText);
			const { origin, pathname, search } = util$19.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
			const path$8 = search ? `${pathname}${search}` : pathname;
			this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
			this.opts.path = path$8;
			this.opts.origin = origin;
			this.opts.maxRedirections = 0;
			this.opts.query = null;
			if (statusCode === 303 && this.opts.method !== "HEAD") {
				this.opts.method = "GET";
				this.opts.body = null;
			}
		}
		onData(chunk) {
			if (this.location) {} else return this.handler.onData(chunk);
		}
		onComplete(trailers) {
			if (this.location) {
				this.location = null;
				this.abort = null;
				this.dispatch(this.opts, this);
			} else this.handler.onComplete(trailers);
		}
		onBodySent(chunk) {
			if (this.handler.onBodySent) this.handler.onBodySent(chunk);
		}
	};
	function parseLocation(statusCode, headers) {
		if (redirectableStatusCodes.indexOf(statusCode) === -1) return null;
		for (let i$1 = 0; i$1 < headers.length; i$1 += 2) if (headers[i$1].toString().toLowerCase() === "location") return headers[i$1 + 1];
	}
	function shouldRemoveHeader(header, removeContent, unknownOrigin) {
		if (header.length === 4) return util$19.headerNameToString(header) === "host";
		if (removeContent && util$19.headerNameToString(header).startsWith("content-")) return true;
		if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
			const name = util$19.headerNameToString(header);
			return name === "authorization" || name === "cookie" || name === "proxy-authorization";
		}
		return false;
	}
	function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
		const ret = [];
		if (Array.isArray(headers)) {
			for (let i$1 = 0; i$1 < headers.length; i$1 += 2) if (!shouldRemoveHeader(headers[i$1], removeContent, unknownOrigin)) ret.push(headers[i$1], headers[i$1 + 1]);
		} else if (headers && typeof headers === "object") {
			for (const key of Object.keys(headers)) if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) ret.push(key, headers[key]);
		} else assert$13(headers == null, "headers must be an object or an array");
		return ret;
	}
	module.exports = RedirectHandler$2;
} });

//#endregion
//#region node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({ "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports, module) {
	const RedirectHandler$1 = require_RedirectHandler();
	function createRedirectInterceptor$3({ maxRedirections: defaultMaxRedirections }) {
		return (dispatch) => {
			return function Intercept(opts, handler$1) {
				const { maxRedirections = defaultMaxRedirections } = opts;
				if (!maxRedirections) return dispatch(opts, handler$1);
				const redirectHandler = new RedirectHandler$1(dispatch, maxRedirections, opts, handler$1);
				opts = {
					...opts,
					maxRedirections: 0
				};
				return dispatch(opts, redirectHandler);
			};
		};
	}
	module.exports = createRedirectInterceptor$3;
} });

//#endregion
//#region node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({ "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports, module) {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
} });

//#endregion
//#region node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({ "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports, module) {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
} });

//#endregion
//#region node_modules/undici/lib/client.js
var require_client = __commonJS({ "node_modules/undici/lib/client.js"(exports, module) {
	const assert$12 = require("assert");
	const net$3 = require("net");
	const http$6 = require("http");
	const { pipeline: pipeline$2 } = require("stream");
	const util$18 = require_util$8();
	const timers = require_timers();
	const Request$4 = require_request$1();
	const DispatcherBase$3 = require_dispatcher_base();
	const { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, InvalidArgumentError: InvalidArgumentError$16, RequestAbortedError: RequestAbortedError$8, HeadersTimeoutError, HeadersOverflowError, SocketError: SocketError$2, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError, ClientDestroyedError } = require_errors();
	const buildConnector$3 = require_connect();
	const { kUrl: kUrl$3, kReset, kServerName, kClient: kClient$1, kBusy: kBusy$1, kParser, kConnect, kBlocking, kResuming, kRunning: kRunning$3, kPending: kPending$2, kSize: kSize$4, kWriting, kQueue: kQueue$1, kConnected: kConnected$5, kConnecting, kNeedDrain: kNeedDrain$3, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError: kError$4, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections: kMaxRedirections$1, kMaxRequests, kCounter, kClose: kClose$5, kDestroy: kDestroy$3, kDispatch: kDispatch$2, kInterceptors: kInterceptors$4, kLocalAddress, kMaxResponseSize, kHTTPConnVersion, kHost, kHTTP2Session, kHTTP2SessionState, kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols$4();
	/** @type {import('http2')} */
	let http2;
	try {
		http2 = require("http2");
	} catch {
		http2 = { constants: {} };
	}
	const { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2;
	let h2ExperimentalWarned = false;
	const FastBuffer$3 = Buffer[Symbol.species];
	const kClosedResolve$1 = Symbol("kClosedResolve");
	const channels$2 = {};
	try {
		const diagnosticsChannel$2 = require("diagnostics_channel");
		channels$2.sendHeaders = diagnosticsChannel$2.channel("undici:client:sendHeaders");
		channels$2.beforeConnect = diagnosticsChannel$2.channel("undici:client:beforeConnect");
		channels$2.connectError = diagnosticsChannel$2.channel("undici:client:connectError");
		channels$2.connected = diagnosticsChannel$2.channel("undici:client:connected");
	} catch {
		channels$2.sendHeaders = { hasSubscribers: false };
		channels$2.beforeConnect = { hasSubscribers: false };
		channels$2.connectError = { hasSubscribers: false };
		channels$2.connected = { hasSubscribers: false };
	}
	/**
	* @type {import('../types/client').default}
	*/
	var Client$4 = class extends DispatcherBase$3 {
		/**
		*
		* @param {string|URL} url
		* @param {import('../types/client').Client.Options} options
		*/
		constructor(url, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout: requestTimeout$1, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls: tls$4, strictContentLength, maxCachedSessions, maxRedirections, connect: connect$2, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, maxConcurrentStreams } = {}) {
			super();
			if (keepAlive !== void 0) throw new InvalidArgumentError$16("unsupported keepAlive, use pipelining=0 instead");
			if (socketTimeout !== void 0) throw new InvalidArgumentError$16("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
			if (requestTimeout$1 !== void 0) throw new InvalidArgumentError$16("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
			if (idleTimeout !== void 0) throw new InvalidArgumentError$16("unsupported idleTimeout, use keepAliveTimeout instead");
			if (maxKeepAliveTimeout !== void 0) throw new InvalidArgumentError$16("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
			if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) throw new InvalidArgumentError$16("invalid maxHeaderSize");
			if (socketPath != null && typeof socketPath !== "string") throw new InvalidArgumentError$16("invalid socketPath");
			if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new InvalidArgumentError$16("invalid connectTimeout");
			if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new InvalidArgumentError$16("invalid keepAliveTimeout");
			if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new InvalidArgumentError$16("invalid keepAliveMaxTimeout");
			if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) throw new InvalidArgumentError$16("invalid keepAliveTimeoutThreshold");
			if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$16("headersTimeout must be a positive integer or zero");
			if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$16("bodyTimeout must be a positive integer or zero");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$16("connect must be a function or an object");
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$16("maxRedirections must be a positive number");
			if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new InvalidArgumentError$16("maxRequestsPerClient must be a positive number");
			if (localAddress != null && (typeof localAddress !== "string" || net$3.isIP(localAddress) === 0)) throw new InvalidArgumentError$16("localAddress must be valid string IP address");
			if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new InvalidArgumentError$16("maxResponseSize must be a positive number");
			if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new InvalidArgumentError$16("autoSelectFamilyAttemptTimeout must be a positive number");
			if (allowH2 != null && typeof allowH2 !== "boolean") throw new InvalidArgumentError$16("allowH2 must be a valid boolean value");
			if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) throw new InvalidArgumentError$16("maxConcurrentStreams must be a possitive integer, greater than 0");
			if (typeof connect$2 !== "function") connect$2 = buildConnector$3({
				...tls$4,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util$18.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect$2
			});
			this[kInterceptors$4] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor$2({ maxRedirections })];
			this[kUrl$3] = util$18.parseOrigin(url);
			this[kConnector] = connect$2;
			this[kSocket] = null;
			this[kPipelining] = pipelining != null ? pipelining : 1;
			this[kMaxHeadersSize] = maxHeaderSize || http$6.maxHeaderSize;
			this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
			this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
			this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
			this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
			this[kServerName] = null;
			this[kLocalAddress] = localAddress != null ? localAddress : null;
			this[kResuming] = 0;
			this[kNeedDrain$3] = 0;
			this[kHostHeader] = `host: ${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}\r\n`;
			this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
			this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
			this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
			this[kMaxRedirections$1] = maxRedirections;
			this[kMaxRequests] = maxRequestsPerClient;
			this[kClosedResolve$1] = null;
			this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
			this[kHTTPConnVersion] = "h1";
			this[kHTTP2Session] = null;
			this[kHTTP2SessionState] = !allowH2 ? null : {
				openStreams: 0,
				maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
			};
			this[kHost] = `${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}`;
			this[kQueue$1] = [];
			this[kRunningIdx] = 0;
			this[kPendingIdx] = 0;
		}
		get pipelining() {
			return this[kPipelining];
		}
		set pipelining(value) {
			this[kPipelining] = value;
			resume$2(this, true);
		}
		get [kPending$2]() {
			return this[kQueue$1].length - this[kPendingIdx];
		}
		get [kRunning$3]() {
			return this[kPendingIdx] - this[kRunningIdx];
		}
		get [kSize$4]() {
			return this[kQueue$1].length - this[kRunningIdx];
		}
		get [kConnected$5]() {
			return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
		}
		get [kBusy$1]() {
			const socket = this[kSocket];
			return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize$4] >= (this[kPipelining] || 1) || this[kPending$2] > 0;
		}
		/* istanbul ignore: only used for test */
		[kConnect](cb) {
			connect$1(this);
			this.once("connect", cb);
		}
		[kDispatch$2](opts, handler$1) {
			const origin = opts.origin || this[kUrl$3].origin;
			const request$3 = this[kHTTPConnVersion] === "h2" ? Request$4[kHTTP2BuildRequest](origin, opts, handler$1) : Request$4[kHTTP1BuildRequest](origin, opts, handler$1);
			this[kQueue$1].push(request$3);
			if (this[kResuming]) {} else if (util$18.bodyLength(request$3.body) == null && util$18.isIterable(request$3.body)) {
				this[kResuming] = 1;
				process.nextTick(resume$2, this);
			} else resume$2(this, true);
			if (this[kResuming] && this[kNeedDrain$3] !== 2 && this[kBusy$1]) this[kNeedDrain$3] = 2;
			return this[kNeedDrain$3] < 2;
		}
		async [kClose$5]() {
			return new Promise((resolve) => {
				if (!this[kSize$4]) resolve(null);
				else this[kClosedResolve$1] = resolve;
			});
		}
		async [kDestroy$3](err) {
			return new Promise((resolve) => {
				const requests = this[kQueue$1].splice(this[kPendingIdx]);
				for (let i$1 = 0; i$1 < requests.length; i$1++) {
					const request$3 = requests[i$1];
					errorRequest(this, request$3, err);
				}
				const callback = () => {
					if (this[kClosedResolve$1]) {
						this[kClosedResolve$1]();
						this[kClosedResolve$1] = null;
					}
					resolve();
				};
				if (this[kHTTP2Session] != null) {
					util$18.destroy(this[kHTTP2Session], err);
					this[kHTTP2Session] = null;
					this[kHTTP2SessionState] = null;
				}
				if (!this[kSocket]) queueMicrotask(callback);
				else util$18.destroy(this[kSocket].on("close", callback), err);
				resume$2(this);
			});
		}
	};
	function onHttp2SessionError(err) {
		assert$12(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		this[kSocket][kError$4] = err;
		onError$1(this[kClient$1], err);
	}
	function onHttp2FrameError(type, code$1, id) {
		const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code$1}`);
		if (id === 0) {
			this[kSocket][kError$4] = err;
			onError$1(this[kClient$1], err);
		}
	}
	function onHttp2SessionEnd() {
		util$18.destroy(this, new SocketError$2("other side closed"));
		util$18.destroy(this[kSocket], new SocketError$2("other side closed"));
	}
	function onHTTP2GoAway(code$1) {
		const client = this[kClient$1];
		const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code$1}`);
		client[kSocket] = null;
		client[kHTTP2Session] = null;
		if (client.destroyed) {
			assert$12(this[kPending$2] === 0);
			const requests = client[kQueue$1].splice(client[kRunningIdx]);
			for (let i$1 = 0; i$1 < requests.length; i$1++) {
				const request$3 = requests[i$1];
				errorRequest(this, request$3, err);
			}
		} else if (client[kRunning$3] > 0) {
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			client[kQueue$1][client[kRunningIdx]++] = null;
			errorRequest(client, request$3, err);
		}
		client[kPendingIdx] = client[kRunningIdx];
		assert$12(client[kRunning$3] === 0);
		client.emit("disconnect", client[kUrl$3], [client], err);
		resume$2(client);
	}
	const constants = require_constants$3();
	const createRedirectInterceptor$2 = require_redirectInterceptor();
	const EMPTY_BUF = Buffer.alloc(0);
	async function lazyllhttp() {
		const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
		let mod;
		try {
			mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
		} catch (e) {
			/* istanbul ignore next */
			mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
		}
		return await WebAssembly.instantiate(mod, { env: {
			wasm_on_url: (p, at$1, len$1) => {
				/* istanbul ignore next */
				return 0;
			},
			wasm_on_status: (p, at$1, len$1) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start = at$1 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onStatus(new FastBuffer$3(currentBufferRef.buffer, start, len$1)) || 0;
			},
			wasm_on_message_begin: (p) => {
				assert$12.strictEqual(currentParser.ptr, p);
				return currentParser.onMessageBegin() || 0;
			},
			wasm_on_header_field: (p, at$1, len$1) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start = at$1 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderField(new FastBuffer$3(currentBufferRef.buffer, start, len$1)) || 0;
			},
			wasm_on_header_value: (p, at$1, len$1) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start = at$1 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderValue(new FastBuffer$3(currentBufferRef.buffer, start, len$1)) || 0;
			},
			wasm_on_headers_complete: (p, statusCode, upgrade$1, shouldKeepAlive) => {
				assert$12.strictEqual(currentParser.ptr, p);
				return currentParser.onHeadersComplete(statusCode, Boolean(upgrade$1), Boolean(shouldKeepAlive)) || 0;
			},
			wasm_on_body: (p, at$1, len$1) => {
				assert$12.strictEqual(currentParser.ptr, p);
				const start = at$1 - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onBody(new FastBuffer$3(currentBufferRef.buffer, start, len$1)) || 0;
			},
			wasm_on_message_complete: (p) => {
				assert$12.strictEqual(currentParser.ptr, p);
				return currentParser.onMessageComplete() || 0;
			}
		} });
	}
	let llhttpInstance = null;
	let llhttpPromise = lazyllhttp();
	llhttpPromise.catch();
	let currentParser = null;
	let currentBufferRef = null;
	let currentBufferSize = 0;
	let currentBufferPtr = null;
	const TIMEOUT_HEADERS = 1;
	const TIMEOUT_BODY = 2;
	const TIMEOUT_IDLE = 3;
	var Parser = class {
		constructor(client, socket, { exports: exports$1 }) {
			assert$12(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
			this.llhttp = exports$1;
			this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
			this.client = client;
			this.socket = socket;
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.statusCode = null;
			this.statusText = "";
			this.upgrade = false;
			this.headers = [];
			this.headersSize = 0;
			this.headersMaxSize = client[kMaxHeadersSize];
			this.shouldKeepAlive = false;
			this.paused = false;
			this.resume = this.resume.bind(this);
			this.bytesRead = 0;
			this.keepAlive = "";
			this.contentLength = "";
			this.connection = "";
			this.maxResponseSize = client[kMaxResponseSize];
		}
		setTimeout(value, type) {
			this.timeoutType = type;
			if (value !== this.timeoutValue) {
				timers.clearTimeout(this.timeout);
				if (value) {
					this.timeout = timers.setTimeout(onParserTimeout, value, this);
					// istanbul ignore else: only for jest
					if (this.timeout.unref) this.timeout.unref();
				} else this.timeout = null;
				this.timeoutValue = value;
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
		}
		resume() {
			if (this.socket.destroyed || !this.paused) return;
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			this.llhttp.llhttp_resume(this.ptr);
			assert$12(this.timeoutType === TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			this.paused = false;
			this.execute(this.socket.read() || EMPTY_BUF);
			this.readMore();
		}
		readMore() {
			while (!this.paused && this.ptr) {
				const chunk = this.socket.read();
				if (chunk === null) break;
				this.execute(chunk);
			}
		}
		execute(data) {
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			assert$12(!this.paused);
			const { socket, llhttp } = this;
			if (data.length > currentBufferSize) {
				if (currentBufferPtr) llhttp.free(currentBufferPtr);
				currentBufferSize = Math.ceil(data.length / 4096) * 4096;
				currentBufferPtr = llhttp.malloc(currentBufferSize);
			}
			new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
			try {
				let ret;
				try {
					currentBufferRef = data;
					currentParser = this;
					ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
				} catch (err) {
					/* istanbul ignore next: difficult to make a test case for */
					throw err;
				} finally {
					currentParser = null;
					currentBufferRef = null;
				}
				const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
				if (ret === constants.ERROR.PAUSED_UPGRADE) this.onUpgrade(data.slice(offset));
				else if (ret === constants.ERROR.PAUSED) {
					this.paused = true;
					socket.unshift(data.slice(offset));
				} else if (ret !== constants.ERROR.OK) {
					const ptr = llhttp.llhttp_get_error_reason(this.ptr);
					let message = "";
					/* istanbul ignore else: difficult to make a test case for */
					if (ptr) {
						const len$1 = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
						message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len$1).toString() + ")";
					}
					throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
				}
			} catch (err) {
				util$18.destroy(socket, err);
			}
		}
		destroy() {
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			this.llhttp.llhttp_free(this.ptr);
			this.ptr = null;
			timers.clearTimeout(this.timeout);
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.paused = false;
		}
		onStatus(buf) {
			this.statusText = buf.toString();
		}
		onMessageBegin() {
			const { socket, client } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			if (!request$3) return -1;
		}
		onHeaderField(buf) {
			const len$1 = this.headers.length;
			if ((len$1 & 1) === 0) this.headers.push(buf);
			else this.headers[len$1 - 1] = Buffer.concat([this.headers[len$1 - 1], buf]);
			this.trackHeader(buf.length);
		}
		onHeaderValue(buf) {
			let len$1 = this.headers.length;
			if ((len$1 & 1) === 1) {
				this.headers.push(buf);
				len$1 += 1;
			} else this.headers[len$1 - 1] = Buffer.concat([this.headers[len$1 - 1], buf]);
			const key = this.headers[len$1 - 2];
			if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") this.keepAlive += buf.toString();
			else if (key.length === 10 && key.toString().toLowerCase() === "connection") this.connection += buf.toString();
			else if (key.length === 14 && key.toString().toLowerCase() === "content-length") this.contentLength += buf.toString();
			this.trackHeader(buf.length);
		}
		trackHeader(len$1) {
			this.headersSize += len$1;
			if (this.headersSize >= this.headersMaxSize) util$18.destroy(this.socket, new HeadersOverflowError());
		}
		onUpgrade(head) {
			const { upgrade: upgrade$1, client, socket, headers, statusCode } = this;
			assert$12(upgrade$1);
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			assert$12(request$3);
			assert$12(!socket.destroyed);
			assert$12(socket === client[kSocket]);
			assert$12(!this.paused);
			assert$12(request$3.upgrade || request$3.method === "CONNECT");
			this.statusCode = null;
			this.statusText = "";
			this.shouldKeepAlive = null;
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			socket.unshift(head);
			socket[kParser].destroy();
			socket[kParser] = null;
			socket[kClient$1] = null;
			socket[kError$4] = null;
			socket.removeListener("error", onSocketError$1).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose$1);
			client[kSocket] = null;
			client[kQueue$1][client[kRunningIdx]++] = null;
			client.emit("disconnect", client[kUrl$3], [client], new InformationalError("upgrade"));
			try {
				request$3.onUpgrade(statusCode, headers, socket);
			} catch (err) {
				util$18.destroy(socket, err);
			}
			resume$2(client);
		}
		onHeadersComplete(statusCode, upgrade$1, shouldKeepAlive) {
			const { client, socket, headers, statusText } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			/* istanbul ignore next: difficult to make a test case for */
			if (!request$3) return -1;
			assert$12(!this.upgrade);
			assert$12(this.statusCode < 200);
			if (statusCode === 100) {
				util$18.destroy(socket, new SocketError$2("bad response", util$18.getSocketInfo(socket)));
				return -1;
			}
			if (upgrade$1 && !request$3.upgrade) {
				util$18.destroy(socket, new SocketError$2("bad upgrade", util$18.getSocketInfo(socket)));
				return -1;
			}
			assert$12.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
			this.statusCode = statusCode;
			this.shouldKeepAlive = shouldKeepAlive || request$3.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
			if (this.statusCode >= 200) {
				const bodyTimeout = request$3.bodyTimeout != null ? request$3.bodyTimeout : client[kBodyTimeout];
				this.setTimeout(bodyTimeout, TIMEOUT_BODY);
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			if (request$3.method === "CONNECT") {
				assert$12(client[kRunning$3] === 1);
				this.upgrade = true;
				return 2;
			}
			if (upgrade$1) {
				assert$12(client[kRunning$3] === 1);
				this.upgrade = true;
				return 2;
			}
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (this.shouldKeepAlive && client[kPipelining]) {
				const keepAliveTimeout = this.keepAlive ? util$18.parseKeepAliveTimeout(this.keepAlive) : null;
				if (keepAliveTimeout != null) {
					const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
					if (timeout <= 0) socket[kReset] = true;
					else client[kKeepAliveTimeoutValue] = timeout;
				} else client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
			} else socket[kReset] = true;
			const pause = request$3.onHeaders(statusCode, headers, this.resume, statusText) === false;
			if (request$3.aborted) return -1;
			if (request$3.method === "HEAD") return 1;
			if (statusCode < 200) return 1;
			if (socket[kBlocking]) {
				socket[kBlocking] = false;
				resume$2(client);
			}
			return pause ? constants.ERROR.PAUSED : 0;
		}
		onBody(buf) {
			const { client, socket, statusCode, maxResponseSize } = this;
			if (socket.destroyed) return -1;
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			assert$12(request$3);
			assert$12.strictEqual(this.timeoutType, TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			assert$12(statusCode >= 200);
			if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
				util$18.destroy(socket, new ResponseExceededMaxSizeError());
				return -1;
			}
			this.bytesRead += buf.length;
			if (request$3.onData(buf) === false) return constants.ERROR.PAUSED;
		}
		onMessageComplete() {
			const { client, socket, statusCode, upgrade: upgrade$1, headers, contentLength, bytesRead, shouldKeepAlive } = this;
			if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;
			if (upgrade$1) return;
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			assert$12(request$3);
			assert$12(statusCode >= 100);
			this.statusCode = null;
			this.statusText = "";
			this.bytesRead = 0;
			this.contentLength = "";
			this.keepAlive = "";
			this.connection = "";
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (statusCode < 200) return;
			/* istanbul ignore next: should be handled by llhttp? */
			if (request$3.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
				util$18.destroy(socket, new ResponseContentLengthMismatchError());
				return -1;
			}
			request$3.onComplete(headers);
			client[kQueue$1][client[kRunningIdx]++] = null;
			if (socket[kWriting]) {
				assert$12.strictEqual(client[kRunning$3], 0);
				util$18.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (!shouldKeepAlive) {
				util$18.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (socket[kReset] && client[kRunning$3] === 0) {
				util$18.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (client[kPipelining] === 1) setImmediate(resume$2, client);
			else resume$2(client);
		}
	};
	function onParserTimeout(parser) {
		const { socket, timeoutType, client } = parser;
		/* istanbul ignore else */
		if (timeoutType === TIMEOUT_HEADERS) {
			if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning$3] > 1) {
				assert$12(!parser.paused, "cannot be paused while waiting for headers");
				util$18.destroy(socket, new HeadersTimeoutError());
			}
		} else if (timeoutType === TIMEOUT_BODY) {
			if (!parser.paused) util$18.destroy(socket, new BodyTimeoutError());
		} else if (timeoutType === TIMEOUT_IDLE) {
			assert$12(client[kRunning$3] === 0 && client[kKeepAliveTimeoutValue]);
			util$18.destroy(socket, new InformationalError("socket idle timeout"));
		}
	}
	function onSocketReadable() {
		const { [kParser]: parser } = this;
		if (parser) parser.readMore();
	}
	function onSocketError$1(err) {
		const { [kClient$1]: client, [kParser]: parser } = this;
		assert$12(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		if (client[kHTTPConnVersion] !== "h2") {
			if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
				parser.onMessageComplete();
				return;
			}
		}
		this[kError$4] = err;
		onError$1(this[kClient$1], err);
	}
	function onError$1(client, err) {
		if (client[kRunning$3] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
			assert$12(client[kPendingIdx] === client[kRunningIdx]);
			const requests = client[kQueue$1].splice(client[kRunningIdx]);
			for (let i$1 = 0; i$1 < requests.length; i$1++) {
				const request$3 = requests[i$1];
				errorRequest(client, request$3, err);
			}
			assert$12(client[kSize$4] === 0);
		}
	}
	function onSocketEnd() {
		const { [kParser]: parser, [kClient$1]: client } = this;
		if (client[kHTTPConnVersion] !== "h2") {
			if (parser.statusCode && !parser.shouldKeepAlive) {
				parser.onMessageComplete();
				return;
			}
		}
		util$18.destroy(this, new SocketError$2("other side closed", util$18.getSocketInfo(this)));
	}
	function onSocketClose$1() {
		const { [kClient$1]: client, [kParser]: parser } = this;
		if (client[kHTTPConnVersion] === "h1" && parser) {
			if (!this[kError$4] && parser.statusCode && !parser.shouldKeepAlive) parser.onMessageComplete();
			this[kParser].destroy();
			this[kParser] = null;
		}
		const err = this[kError$4] || new SocketError$2("closed", util$18.getSocketInfo(this));
		client[kSocket] = null;
		if (client.destroyed) {
			assert$12(client[kPending$2] === 0);
			const requests = client[kQueue$1].splice(client[kRunningIdx]);
			for (let i$1 = 0; i$1 < requests.length; i$1++) {
				const request$3 = requests[i$1];
				errorRequest(client, request$3, err);
			}
		} else if (client[kRunning$3] > 0 && err.code !== "UND_ERR_INFO") {
			const request$3 = client[kQueue$1][client[kRunningIdx]];
			client[kQueue$1][client[kRunningIdx]++] = null;
			errorRequest(client, request$3, err);
		}
		client[kPendingIdx] = client[kRunningIdx];
		assert$12(client[kRunning$3] === 0);
		client.emit("disconnect", client[kUrl$3], [client], err);
		resume$2(client);
	}
	async function connect$1(client) {
		assert$12(!client[kConnecting]);
		assert$12(!client[kSocket]);
		let { host, hostname, protocol, port } = client[kUrl$3];
		if (hostname[0] === "[") {
			const idx = hostname.indexOf("]");
			assert$12(idx !== -1);
			const ip = hostname.substring(1, idx);
			assert$12(net$3.isIP(ip));
			hostname = ip;
		}
		client[kConnecting] = true;
		if (channels$2.beforeConnect.hasSubscribers) channels$2.beforeConnect.publish({
			connectParams: {
				host,
				hostname,
				protocol,
				port,
				servername: client[kServerName],
				localAddress: client[kLocalAddress]
			},
			connector: client[kConnector]
		});
		try {
			const socket = await new Promise((resolve, reject) => {
				client[kConnector]({
					host,
					hostname,
					protocol,
					port,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				}, (err, socket$1) => {
					if (err) reject(err);
					else resolve(socket$1);
				});
			});
			if (client.destroyed) {
				util$18.destroy(socket.on("error", () => {}), new ClientDestroyedError());
				return;
			}
			client[kConnecting] = false;
			assert$12(socket);
			const isH2 = socket.alpnProtocol === "h2";
			if (isH2) {
				if (!h2ExperimentalWarned) {
					h2ExperimentalWarned = true;
					process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" });
				}
				const session = http2.connect(client[kUrl$3], {
					createConnection: () => socket,
					peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
				});
				client[kHTTPConnVersion] = "h2";
				session[kClient$1] = client;
				session[kSocket] = socket;
				session.on("error", onHttp2SessionError);
				session.on("frameError", onHttp2FrameError);
				session.on("end", onHttp2SessionEnd);
				session.on("goaway", onHTTP2GoAway);
				session.on("close", onSocketClose$1);
				session.unref();
				client[kHTTP2Session] = session;
				socket[kHTTP2Session] = session;
			} else {
				if (!llhttpInstance) {
					llhttpInstance = await llhttpPromise;
					llhttpPromise = null;
				}
				socket[kNoRef] = false;
				socket[kWriting] = false;
				socket[kReset] = false;
				socket[kBlocking] = false;
				socket[kParser] = new Parser(client, socket, llhttpInstance);
			}
			socket[kCounter] = 0;
			socket[kMaxRequests] = client[kMaxRequests];
			socket[kClient$1] = client;
			socket[kError$4] = null;
			socket.on("error", onSocketError$1).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose$1);
			client[kSocket] = socket;
			if (channels$2.connected.hasSubscribers) channels$2.connected.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				},
				connector: client[kConnector],
				socket
			});
			client.emit("connect", client[kUrl$3], [client]);
		} catch (err) {
			if (client.destroyed) return;
			client[kConnecting] = false;
			if (channels$2.connectError.hasSubscribers) channels$2.connectError.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client[kServerName],
					localAddress: client[kLocalAddress]
				},
				connector: client[kConnector],
				error: err
			});
			if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
				assert$12(client[kRunning$3] === 0);
				while (client[kPending$2] > 0 && client[kQueue$1][client[kPendingIdx]].servername === client[kServerName]) {
					const request$3 = client[kQueue$1][client[kPendingIdx]++];
					errorRequest(client, request$3, err);
				}
			} else onError$1(client, err);
			client.emit("connectionError", client[kUrl$3], [client], err);
		}
		resume$2(client);
	}
	function emitDrain(client) {
		client[kNeedDrain$3] = 0;
		client.emit("drain", client[kUrl$3], [client]);
	}
	function resume$2(client, sync) {
		if (client[kResuming] === 2) return;
		client[kResuming] = 2;
		_resume(client, sync);
		client[kResuming] = 0;
		if (client[kRunningIdx] > 256) {
			client[kQueue$1].splice(0, client[kRunningIdx]);
			client[kPendingIdx] -= client[kRunningIdx];
			client[kRunningIdx] = 0;
		}
	}
	function _resume(client, sync) {
		while (true) {
			if (client.destroyed) {
				assert$12(client[kPending$2] === 0);
				return;
			}
			if (client[kClosedResolve$1] && !client[kSize$4]) {
				client[kClosedResolve$1]();
				client[kClosedResolve$1] = null;
				return;
			}
			const socket = client[kSocket];
			if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
				if (client[kSize$4] === 0) {
					if (!socket[kNoRef] && socket.unref) {
						socket.unref();
						socket[kNoRef] = true;
					}
				} else if (socket[kNoRef] && socket.ref) {
					socket.ref();
					socket[kNoRef] = false;
				}
				if (client[kSize$4] === 0) {
					if (socket[kParser].timeoutType !== TIMEOUT_IDLE) socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
				} else if (client[kRunning$3] > 0 && socket[kParser].statusCode < 200) {
					if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
						const request$4 = client[kQueue$1][client[kRunningIdx]];
						const headersTimeout = request$4.headersTimeout != null ? request$4.headersTimeout : client[kHeadersTimeout];
						socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
					}
				}
			}
			if (client[kBusy$1]) client[kNeedDrain$3] = 2;
			else if (client[kNeedDrain$3] === 2) {
				if (sync) {
					client[kNeedDrain$3] = 1;
					process.nextTick(emitDrain, client);
				} else emitDrain(client);
				continue;
			}
			if (client[kPending$2] === 0) return;
			if (client[kRunning$3] >= (client[kPipelining] || 1)) return;
			const request$3 = client[kQueue$1][client[kPendingIdx]];
			if (client[kUrl$3].protocol === "https:" && client[kServerName] !== request$3.servername) {
				if (client[kRunning$3] > 0) return;
				client[kServerName] = request$3.servername;
				if (socket && socket.servername !== request$3.servername) {
					util$18.destroy(socket, new InformationalError("servername changed"));
					return;
				}
			}
			if (client[kConnecting]) return;
			if (!socket && !client[kHTTP2Session]) {
				connect$1(client);
				return;
			}
			if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) return;
			if (client[kRunning$3] > 0 && !request$3.idempotent) return;
			if (client[kRunning$3] > 0 && (request$3.upgrade || request$3.method === "CONNECT")) return;
			if (client[kRunning$3] > 0 && util$18.bodyLength(request$3.body) !== 0 && (util$18.isStream(request$3.body) || util$18.isAsyncIterable(request$3.body))) return;
			if (!request$3.aborted && write(client, request$3)) client[kPendingIdx]++;
			else client[kQueue$1].splice(client[kPendingIdx], 1);
		}
	}
	function shouldSendContentLength(method) {
		return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
	}
	function write(client, request$3) {
		if (client[kHTTPConnVersion] === "h2") {
			writeH2(client, client[kHTTP2Session], request$3);
			return;
		}
		const { body, method, path: path$8, host, upgrade: upgrade$1, headers, blocking, reset } = request$3;
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		const bodyLength$1 = util$18.bodyLength(body);
		let contentLength = bodyLength$1;
		if (contentLength === null) contentLength = request$3.contentLength;
		if (contentLength === 0 && !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$3.contentLength !== null && request$3.contentLength !== contentLength) {
			if (client[kStrictContentLength]) {
				errorRequest(client, request$3, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		const socket = client[kSocket];
		try {
			request$3.onConnect((err) => {
				if (request$3.aborted || request$3.completed) return;
				errorRequest(client, request$3, err || new RequestAbortedError$8());
				util$18.destroy(socket, new InformationalError("aborted"));
			});
		} catch (err) {
			errorRequest(client, request$3, err);
		}
		if (request$3.aborted) return false;
		if (method === "HEAD") socket[kReset] = true;
		if (upgrade$1 || method === "CONNECT") socket[kReset] = true;
		if (reset != null) socket[kReset] = reset;
		if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) socket[kReset] = true;
		if (blocking) socket[kBlocking] = true;
		let header = `${method} ${path$8} HTTP/1.1\r\n`;
		if (typeof host === "string") header += `host: ${host}\r\n`;
		else header += client[kHostHeader];
		if (upgrade$1) header += `connection: upgrade\r\nupgrade: ${upgrade$1}\r\n`;
		else if (client[kPipelining] && !socket[kReset]) header += "connection: keep-alive\r\n";
		else header += "connection: close\r\n";
		if (headers) header += headers;
		if (channels$2.sendHeaders.hasSubscribers) channels$2.sendHeaders.publish({
			request: request$3,
			headers: header,
			socket
		});
		/* istanbul ignore else: assertion */
		if (!body || bodyLength$1 === 0) {
			if (contentLength === 0) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else {
				assert$12(contentLength === null, "no body must not have content length");
				socket.write(`${header}\r\n`, "latin1");
			}
			request$3.onRequestSent();
		} else if (util$18.isBuffer(body)) {
			assert$12(contentLength === body.byteLength, "buffer body must have content length");
			socket.cork();
			socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			socket.write(body);
			socket.uncork();
			request$3.onBodySent(body);
			request$3.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
		} else if (util$18.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
			body: body.stream(),
			client,
			request: request$3,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else writeBlob({
			body,
			client,
			request: request$3,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util$18.isStream(body)) writeStream({
			body,
			client,
			request: request$3,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util$18.isIterable(body)) writeIterable({
			body,
			client,
			request: request$3,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else assert$12(false);
		return true;
	}
	function writeH2(client, session, request$3) {
		const { body, method, path: path$8, host, upgrade: upgrade$1, expectContinue, signal, headers: reqHeaders } = request$3;
		let headers;
		if (typeof reqHeaders === "string") headers = Request$4[kHTTP2CopyHeaders](reqHeaders.trim());
		else headers = reqHeaders;
		if (upgrade$1) {
			errorRequest(client, request$3, new Error("Upgrade not supported for H2"));
			return false;
		}
		try {
			request$3.onConnect((err) => {
				if (request$3.aborted || request$3.completed) return;
				errorRequest(client, request$3, err || new RequestAbortedError$8());
			});
		} catch (err) {
			errorRequest(client, request$3, err);
		}
		if (request$3.aborted) return false;
		/** @type {import('node:http2').ClientHttp2Stream} */
		let stream$6;
		const h2State = client[kHTTP2SessionState];
		headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
		headers[HTTP2_HEADER_METHOD] = method;
		if (method === "CONNECT") {
			session.ref();
			stream$6 = session.request(headers, {
				endStream: false,
				signal
			});
			if (stream$6.id && !stream$6.pending) {
				request$3.onUpgrade(null, null, stream$6);
				++h2State.openStreams;
			} else stream$6.once("ready", () => {
				request$3.onUpgrade(null, null, stream$6);
				++h2State.openStreams;
			});
			stream$6.once("close", () => {
				h2State.openStreams -= 1;
				if (h2State.openStreams === 0) session.unref();
			});
			return true;
		}
		headers[HTTP2_HEADER_PATH] = path$8;
		headers[HTTP2_HEADER_SCHEME] = "https";
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		let contentLength = util$18.bodyLength(body);
		if (contentLength == null) contentLength = request$3.contentLength;
		if (contentLength === 0 || !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$3.contentLength != null && request$3.contentLength !== contentLength) {
			if (client[kStrictContentLength]) {
				errorRequest(client, request$3, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		if (contentLength != null) {
			assert$12(body, "no body must not have content length");
			headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
		}
		session.ref();
		const shouldEndStream = method === "GET" || method === "HEAD";
		if (expectContinue) {
			headers[HTTP2_HEADER_EXPECT] = "100-continue";
			stream$6 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			stream$6.once("continue", writeBodyH2);
		} else {
			stream$6 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			writeBodyH2();
		}
		++h2State.openStreams;
		stream$6.once("response", (headers$1) => {
			const { [HTTP2_HEADER_STATUS]: statusCode,...realHeaders } = headers$1;
			if (request$3.onHeaders(Number(statusCode), realHeaders, stream$6.resume.bind(stream$6), "") === false) stream$6.pause();
		});
		stream$6.once("end", () => {
			request$3.onComplete([]);
		});
		stream$6.on("data", (chunk) => {
			if (request$3.onData(chunk) === false) stream$6.pause();
		});
		stream$6.once("close", () => {
			h2State.openStreams -= 1;
			if (h2State.openStreams === 0) session.unref();
		});
		stream$6.once("error", function(err) {
			if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util$18.destroy(stream$6, err);
			}
		});
		stream$6.once("frameError", (type, code$1) => {
			const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code$1}`);
			errorRequest(client, request$3, err);
			if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util$18.destroy(stream$6, err);
			}
		});
		return true;
		function writeBodyH2() {
			/* istanbul ignore else: assertion */
			if (!body) request$3.onRequestSent();
			else if (util$18.isBuffer(body)) {
				assert$12(contentLength === body.byteLength, "buffer body must have content length");
				stream$6.cork();
				stream$6.write(body);
				stream$6.uncork();
				stream$6.end();
				request$3.onBodySent(body);
				request$3.onRequestSent();
			} else if (util$18.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
				client,
				request: request$3,
				contentLength,
				h2stream: stream$6,
				expectsPayload,
				body: body.stream(),
				socket: client[kSocket],
				header: ""
			});
			else writeBlob({
				body,
				client,
				request: request$3,
				contentLength,
				expectsPayload,
				h2stream: stream$6,
				header: "",
				socket: client[kSocket]
			});
			else if (util$18.isStream(body)) writeStream({
				body,
				client,
				request: request$3,
				contentLength,
				expectsPayload,
				socket: client[kSocket],
				h2stream: stream$6,
				header: ""
			});
			else if (util$18.isIterable(body)) writeIterable({
				body,
				client,
				request: request$3,
				contentLength,
				expectsPayload,
				header: "",
				h2stream: stream$6,
				socket: client[kSocket]
			});
			else assert$12(false);
		}
	}
	function writeStream({ h2stream, body, client, request: request$3, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength !== 0 || client[kRunning$3] === 0, "stream body cannot be pipelined");
		if (client[kHTTPConnVersion] === "h2") {
			const pipe = pipeline$2(body, h2stream, (err) => {
				if (err) {
					util$18.destroy(body, err);
					util$18.destroy(h2stream, err);
				} else request$3.onRequestSent();
			});
			pipe.on("data", onPipeData);
			pipe.once("end", () => {
				pipe.removeListener("data", onPipeData);
				util$18.destroy(pipe);
			});
			function onPipeData(chunk) {
				request$3.onBodySent(chunk);
			}
			return;
		}
		let finished$1 = false;
		const writer = new AsyncWriter({
			socket,
			request: request$3,
			contentLength,
			client,
			expectsPayload,
			header
		});
		const onData = function(chunk) {
			if (finished$1) return;
			try {
				if (!writer.write(chunk) && this.pause) this.pause();
			} catch (err) {
				util$18.destroy(this, err);
			}
		};
		const onDrain = function() {
			if (finished$1) return;
			if (body.resume) body.resume();
		};
		const onAbort = function() {
			if (finished$1) return;
			const err = new RequestAbortedError$8();
			queueMicrotask(() => onFinished(err));
		};
		const onFinished = function(err) {
			if (finished$1) return;
			finished$1 = true;
			assert$12(socket.destroyed || socket[kWriting] && client[kRunning$3] <= 1);
			socket.off("drain", onDrain).off("error", onFinished);
			body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
			if (!err) try {
				writer.end();
			} catch (er) {
				err = er;
			}
			writer.destroy(err);
			if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) util$18.destroy(body, err);
			else util$18.destroy(body);
		};
		body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
		if (body.resume) body.resume();
		socket.on("drain", onDrain).on("error", onFinished);
	}
	async function writeBlob({ h2stream, body, client, request: request$3, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength === body.size, "blob body must have content length");
		const isH2 = client[kHTTPConnVersion] === "h2";
		try {
			if (contentLength != null && contentLength !== body.size) throw new RequestContentLengthMismatchError();
			const buffer$1 = Buffer.from(await body.arrayBuffer());
			if (isH2) {
				h2stream.cork();
				h2stream.write(buffer$1);
				h2stream.uncork();
			} else {
				socket.cork();
				socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
				socket.write(buffer$1);
				socket.uncork();
			}
			request$3.onBodySent(buffer$1);
			request$3.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
			resume$2(client);
		} catch (err) {
			util$18.destroy(isH2 ? h2stream : socket, err);
		}
	}
	async function writeIterable({ h2stream, body, client, request: request$3, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength !== 0 || client[kRunning$3] === 0, "iterator body cannot be pipelined");
		let callback = null;
		function onDrain() {
			if (callback) {
				const cb = callback;
				callback = null;
				cb();
			}
		}
		const waitForDrain = () => new Promise((resolve, reject) => {
			assert$12(callback === null);
			if (socket[kError$4]) reject(socket[kError$4]);
			else callback = resolve;
		});
		if (client[kHTTPConnVersion] === "h2") {
			h2stream.on("close", onDrain).on("drain", onDrain);
			try {
				for await (const chunk of body) {
					if (socket[kError$4]) throw socket[kError$4];
					const res = h2stream.write(chunk);
					request$3.onBodySent(chunk);
					if (!res) await waitForDrain();
				}
			} catch (err) {
				h2stream.destroy(err);
			} finally {
				request$3.onRequestSent();
				h2stream.end();
				h2stream.off("close", onDrain).off("drain", onDrain);
			}
			return;
		}
		socket.on("close", onDrain).on("drain", onDrain);
		const writer = new AsyncWriter({
			socket,
			request: request$3,
			contentLength,
			client,
			expectsPayload,
			header
		});
		try {
			for await (const chunk of body) {
				if (socket[kError$4]) throw socket[kError$4];
				if (!writer.write(chunk)) await waitForDrain();
			}
			writer.end();
		} catch (err) {
			writer.destroy(err);
		} finally {
			socket.off("close", onDrain).off("drain", onDrain);
		}
	}
	var AsyncWriter = class {
		constructor({ socket, request: request$3, contentLength, client, expectsPayload, header }) {
			this.socket = socket;
			this.request = request$3;
			this.contentLength = contentLength;
			this.client = client;
			this.bytesWritten = 0;
			this.expectsPayload = expectsPayload;
			this.header = header;
			socket[kWriting] = true;
		}
		write(chunk) {
			const { socket, request: request$3, contentLength, client, bytesWritten, expectsPayload, header } = this;
			if (socket[kError$4]) throw socket[kError$4];
			if (socket.destroyed) return false;
			const len$1 = Buffer.byteLength(chunk);
			if (!len$1) return true;
			if (contentLength !== null && bytesWritten + len$1 > contentLength) {
				if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
				process.emitWarning(new RequestContentLengthMismatchError());
			}
			socket.cork();
			if (bytesWritten === 0) {
				if (!expectsPayload) socket[kReset] = true;
				if (contentLength === null) socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
				else socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			}
			if (contentLength === null) socket.write(`\r\n${len$1.toString(16)}\r\n`, "latin1");
			this.bytesWritten += len$1;
			const ret = socket.write(chunk);
			socket.uncork();
			request$3.onBodySent(chunk);
			if (!ret) {
				if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
					// istanbul ignore else: only for jest
					if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
				}
			}
			return ret;
		}
		end() {
			const { socket, contentLength, client, bytesWritten, expectsPayload, header, request: request$3 } = this;
			request$3.onRequestSent();
			socket[kWriting] = false;
			if (socket[kError$4]) throw socket[kError$4];
			if (socket.destroyed) return;
			if (bytesWritten === 0) if (expectsPayload) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else socket.write(`${header}\r\n`, "latin1");
			else if (contentLength === null) socket.write("\r\n0\r\n\r\n", "latin1");
			if (contentLength !== null && bytesWritten !== contentLength) if (client[kStrictContentLength]) throw new RequestContentLengthMismatchError();
			else process.emitWarning(new RequestContentLengthMismatchError());
			if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
				// istanbul ignore else: only for jest
				if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
			}
			resume$2(client);
		}
		destroy(err) {
			const { socket, client } = this;
			socket[kWriting] = false;
			if (err) {
				assert$12(client[kRunning$3] <= 1, "pipeline should only contain this request");
				util$18.destroy(socket, err);
			}
		}
	};
	function errorRequest(client, request$3, err) {
		try {
			request$3.onError(err);
			assert$12(request$3.aborted);
		} catch (err$1) {
			client.emit("error", err$1);
		}
	}
	module.exports = Client$4;
} });

//#endregion
//#region node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({ "node_modules/undici/lib/node/fixed-queue.js"(exports, module) {
	const kSize$3 = 2048;
	const kMask = kSize$3 - 1;
	var FixedCircularBuffer = class {
		constructor() {
			this.bottom = 0;
			this.top = 0;
			this.list = new Array(kSize$3);
			this.next = null;
		}
		isEmpty() {
			return this.top === this.bottom;
		}
		isFull() {
			return (this.top + 1 & kMask) === this.bottom;
		}
		push(data) {
			this.list[this.top] = data;
			this.top = this.top + 1 & kMask;
		}
		shift() {
			const nextItem = this.list[this.bottom];
			if (nextItem === void 0) return null;
			this.list[this.bottom] = void 0;
			this.bottom = this.bottom + 1 & kMask;
			return nextItem;
		}
	};
	module.exports = class FixedQueue$1 {
		constructor() {
			this.head = this.tail = new FixedCircularBuffer();
		}
		isEmpty() {
			return this.head.isEmpty();
		}
		push(data) {
			if (this.head.isFull()) this.head = this.head.next = new FixedCircularBuffer();
			this.head.push(data);
		}
		shift() {
			const tail = this.tail;
			const next = tail.shift();
			if (tail.isEmpty() && tail.next !== null) this.tail = tail.next;
			return next;
		}
	};
} });

//#endregion
//#region node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({ "node_modules/undici/lib/pool-stats.js"(exports, module) {
	const { kFree: kFree$1, kConnected: kConnected$4, kPending: kPending$1, kQueued: kQueued$1, kRunning: kRunning$2, kSize: kSize$2 } = require_symbols$4();
	const kPool = Symbol("pool");
	var PoolStats$1 = class {
		constructor(pool) {
			this[kPool] = pool;
		}
		get connected() {
			return this[kPool][kConnected$4];
		}
		get free() {
			return this[kPool][kFree$1];
		}
		get pending() {
			return this[kPool][kPending$1];
		}
		get queued() {
			return this[kPool][kQueued$1];
		}
		get running() {
			return this[kPool][kRunning$2];
		}
		get size() {
			return this[kPool][kSize$2];
		}
	};
	module.exports = PoolStats$1;
} });

//#endregion
//#region node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({ "node_modules/undici/lib/pool-base.js"(exports, module) {
	const DispatcherBase$2 = require_dispatcher_base();
	const FixedQueue = require_fixed_queue();
	const { kConnected: kConnected$3, kSize: kSize$1, kRunning: kRunning$1, kPending, kQueued, kBusy, kFree, kUrl: kUrl$2, kClose: kClose$4, kDestroy: kDestroy$2, kDispatch: kDispatch$1 } = require_symbols$4();
	const PoolStats = require_pool_stats();
	const kClients$4 = Symbol("clients");
	const kNeedDrain$2 = Symbol("needDrain");
	const kQueue = Symbol("queue");
	const kClosedResolve = Symbol("closed resolve");
	const kOnDrain$1 = Symbol("onDrain");
	const kOnConnect$1 = Symbol("onConnect");
	const kOnDisconnect$1 = Symbol("onDisconnect");
	const kOnConnectionError$1 = Symbol("onConnectionError");
	const kGetDispatcher$2 = Symbol("get dispatcher");
	const kAddClient$2 = Symbol("add client");
	const kRemoveClient$1 = Symbol("remove client");
	const kStats = Symbol("stats");
	var PoolBase$2 = class extends DispatcherBase$2 {
		constructor() {
			super();
			this[kQueue] = new FixedQueue();
			this[kClients$4] = [];
			this[kQueued] = 0;
			const pool = this;
			this[kOnDrain$1] = function onDrain(origin, targets) {
				const queue = pool[kQueue];
				let needDrain = false;
				while (!needDrain) {
					const item = queue.shift();
					if (!item) break;
					pool[kQueued]--;
					needDrain = !this.dispatch(item.opts, item.handler);
				}
				this[kNeedDrain$2] = needDrain;
				if (!this[kNeedDrain$2] && pool[kNeedDrain$2]) {
					pool[kNeedDrain$2] = false;
					pool.emit("drain", origin, [pool, ...targets]);
				}
				if (pool[kClosedResolve] && queue.isEmpty()) Promise.all(pool[kClients$4].map((c) => c.close())).then(pool[kClosedResolve]);
			};
			this[kOnConnect$1] = (origin, targets) => {
				pool.emit("connect", origin, [pool, ...targets]);
			};
			this[kOnDisconnect$1] = (origin, targets, err) => {
				pool.emit("disconnect", origin, [pool, ...targets], err);
			};
			this[kOnConnectionError$1] = (origin, targets, err) => {
				pool.emit("connectionError", origin, [pool, ...targets], err);
			};
			this[kStats] = new PoolStats(this);
		}
		get [kBusy]() {
			return this[kNeedDrain$2];
		}
		get [kConnected$3]() {
			return this[kClients$4].filter((client) => client[kConnected$3]).length;
		}
		get [kFree]() {
			return this[kClients$4].filter((client) => client[kConnected$3] && !client[kNeedDrain$2]).length;
		}
		get [kPending]() {
			let ret = this[kQueued];
			for (const { [kPending]: pending } of this[kClients$4]) ret += pending;
			return ret;
		}
		get [kRunning$1]() {
			let ret = 0;
			for (const { [kRunning$1]: running } of this[kClients$4]) ret += running;
			return ret;
		}
		get [kSize$1]() {
			let ret = this[kQueued];
			for (const { [kSize$1]: size } of this[kClients$4]) ret += size;
			return ret;
		}
		get stats() {
			return this[kStats];
		}
		async [kClose$4]() {
			if (this[kQueue].isEmpty()) return Promise.all(this[kClients$4].map((c) => c.close()));
			else return new Promise((resolve) => {
				this[kClosedResolve] = resolve;
			});
		}
		async [kDestroy$2](err) {
			while (true) {
				const item = this[kQueue].shift();
				if (!item) break;
				item.handler.onError(err);
			}
			return Promise.all(this[kClients$4].map((c) => c.destroy(err)));
		}
		[kDispatch$1](opts, handler$1) {
			const dispatcher = this[kGetDispatcher$2]();
			if (!dispatcher) {
				this[kNeedDrain$2] = true;
				this[kQueue].push({
					opts,
					handler: handler$1
				});
				this[kQueued]++;
			} else if (!dispatcher.dispatch(opts, handler$1)) {
				dispatcher[kNeedDrain$2] = true;
				this[kNeedDrain$2] = !this[kGetDispatcher$2]();
			}
			return !this[kNeedDrain$2];
		}
		[kAddClient$2](client) {
			client.on("drain", this[kOnDrain$1]).on("connect", this[kOnConnect$1]).on("disconnect", this[kOnDisconnect$1]).on("connectionError", this[kOnConnectionError$1]);
			this[kClients$4].push(client);
			if (this[kNeedDrain$2]) process.nextTick(() => {
				if (this[kNeedDrain$2]) this[kOnDrain$1](client[kUrl$2], [this, client]);
			});
			return this;
		}
		[kRemoveClient$1](client) {
			client.close(() => {
				const idx = this[kClients$4].indexOf(client);
				if (idx !== -1) this[kClients$4].splice(idx, 1);
			});
			this[kNeedDrain$2] = this[kClients$4].some((dispatcher) => !dispatcher[kNeedDrain$2] && dispatcher.closed !== true && dispatcher.destroyed !== true);
		}
	};
	module.exports = {
		PoolBase: PoolBase$2,
		kClients: kClients$4,
		kNeedDrain: kNeedDrain$2,
		kAddClient: kAddClient$2,
		kRemoveClient: kRemoveClient$1,
		kGetDispatcher: kGetDispatcher$2
	};
} });

//#endregion
//#region node_modules/undici/lib/pool.js
var require_pool = __commonJS({ "node_modules/undici/lib/pool.js"(exports, module) {
	const { PoolBase: PoolBase$1, kClients: kClients$3, kNeedDrain: kNeedDrain$1, kAddClient: kAddClient$1, kGetDispatcher: kGetDispatcher$1 } = require_pool_base();
	const Client$3 = require_client();
	const { InvalidArgumentError: InvalidArgumentError$15 } = require_errors();
	const util$17 = require_util$8();
	const { kUrl: kUrl$1, kInterceptors: kInterceptors$3 } = require_symbols$4();
	const buildConnector$2 = require_connect();
	const kOptions$3 = Symbol("options");
	const kConnections = Symbol("connections");
	const kFactory$3 = Symbol("factory");
	function defaultFactory$3(origin, opts) {
		return new Client$3(origin, opts);
	}
	var Pool$5 = class extends PoolBase$1 {
		constructor(origin, { connections, factory = defaultFactory$3, connect: connect$2, connectTimeout, tls: tls$4, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2,...options } = {}) {
			super();
			if (connections != null && (!Number.isFinite(connections) || connections < 0)) throw new InvalidArgumentError$15("invalid connections");
			if (typeof factory !== "function") throw new InvalidArgumentError$15("factory must be a function.");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$15("connect must be a function or an object");
			if (typeof connect$2 !== "function") connect$2 = buildConnector$2({
				...tls$4,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util$17.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect$2
			});
			this[kInterceptors$3] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
			this[kConnections] = connections || null;
			this[kUrl$1] = util$17.parseOrigin(origin);
			this[kOptions$3] = {
				...util$17.deepClone(options),
				connect: connect$2,
				allowH2
			};
			this[kOptions$3].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kFactory$3] = factory;
			this.on("connectionError", (origin$1, targets, error$1) => {
				for (const target of targets) {
					const idx = this[kClients$3].indexOf(target);
					if (idx !== -1) this[kClients$3].splice(idx, 1);
				}
			});
		}
		[kGetDispatcher$1]() {
			let dispatcher = this[kClients$3].find((dispatcher$1) => !dispatcher$1[kNeedDrain$1]);
			if (dispatcher) return dispatcher;
			if (!this[kConnections] || this[kClients$3].length < this[kConnections]) {
				dispatcher = this[kFactory$3](this[kUrl$1], this[kOptions$3]);
				this[kAddClient$1](dispatcher);
			}
			return dispatcher;
		}
	};
	module.exports = Pool$5;
} });

//#endregion
//#region node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({ "node_modules/undici/lib/balanced-pool.js"(exports, module) {
	const { BalancedPoolMissingUpstreamError, InvalidArgumentError: InvalidArgumentError$14 } = require_errors();
	const { PoolBase, kClients: kClients$2, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = require_pool_base();
	const Pool$4 = require_pool();
	const { kUrl, kInterceptors: kInterceptors$2 } = require_symbols$4();
	const { parseOrigin } = require_util$8();
	const kFactory$2 = Symbol("factory");
	const kOptions$2 = Symbol("options");
	const kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
	const kCurrentWeight = Symbol("kCurrentWeight");
	const kIndex = Symbol("kIndex");
	const kWeight = Symbol("kWeight");
	const kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
	const kErrorPenalty = Symbol("kErrorPenalty");
	function getGreatestCommonDivisor(a$1, b) {
		if (b === 0) return a$1;
		return getGreatestCommonDivisor(b, a$1 % b);
	}
	function defaultFactory$2(origin, opts) {
		return new Pool$4(origin, opts);
	}
	var BalancedPool$1 = class extends PoolBase {
		constructor(upstreams = [], { factory = defaultFactory$2,...opts } = {}) {
			super();
			this[kOptions$2] = opts;
			this[kIndex] = -1;
			this[kCurrentWeight] = 0;
			this[kMaxWeightPerServer] = this[kOptions$2].maxWeightPerServer || 100;
			this[kErrorPenalty] = this[kOptions$2].errorPenalty || 15;
			if (!Array.isArray(upstreams)) upstreams = [upstreams];
			if (typeof factory !== "function") throw new InvalidArgumentError$14("factory must be a function.");
			this[kInterceptors$2] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
			this[kFactory$2] = factory;
			for (const upstream of upstreams) this.addUpstream(upstream);
			this._updateBalancedPoolStats();
		}
		addUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			if (this[kClients$2].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true)) return this;
			const pool = this[kFactory$2](upstreamOrigin, Object.assign({}, this[kOptions$2]));
			this[kAddClient](pool);
			pool.on("connect", () => {
				pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
			});
			pool.on("connectionError", () => {
				pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
				this._updateBalancedPoolStats();
			});
			pool.on("disconnect", (...args) => {
				const err = args[2];
				if (err && err.code === "UND_ERR_SOCKET") {
					pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
					this._updateBalancedPoolStats();
				}
			});
			for (const client of this[kClients$2]) client[kWeight] = this[kMaxWeightPerServer];
			this._updateBalancedPoolStats();
			return this;
		}
		_updateBalancedPoolStats() {
			this[kGreatestCommonDivisor] = this[kClients$2].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
		}
		removeUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			const pool = this[kClients$2].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true);
			if (pool) this[kRemoveClient](pool);
			return this;
		}
		get upstreams() {
			return this[kClients$2].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
		}
		[kGetDispatcher]() {
			if (this[kClients$2].length === 0) throw new BalancedPoolMissingUpstreamError();
			const dispatcher = this[kClients$2].find((dispatcher$1) => !dispatcher$1[kNeedDrain] && dispatcher$1.closed !== true && dispatcher$1.destroyed !== true);
			if (!dispatcher) return;
			const allClientsBusy = this[kClients$2].map((pool) => pool[kNeedDrain]).reduce((a$1, b) => a$1 && b, true);
			if (allClientsBusy) return;
			let counter = 0;
			let maxWeightIndex = this[kClients$2].findIndex((pool) => !pool[kNeedDrain]);
			while (counter++ < this[kClients$2].length) {
				this[kIndex] = (this[kIndex] + 1) % this[kClients$2].length;
				const pool = this[kClients$2][this[kIndex]];
				if (pool[kWeight] > this[kClients$2][maxWeightIndex][kWeight] && !pool[kNeedDrain]) maxWeightIndex = this[kIndex];
				if (this[kIndex] === 0) {
					this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
					if (this[kCurrentWeight] <= 0) this[kCurrentWeight] = this[kMaxWeightPerServer];
				}
				if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) return pool;
			}
			this[kCurrentWeight] = this[kClients$2][maxWeightIndex][kWeight];
			this[kIndex] = maxWeightIndex;
			return this[kClients$2][maxWeightIndex];
		}
	};
	module.exports = BalancedPool$1;
} });

//#endregion
//#region node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({ "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports, module) {
	/* istanbul ignore file: only for Node 12 */
	const { kConnected: kConnected$2, kSize } = require_symbols$4();
	var CompatWeakRef = class {
		constructor(value) {
			this.value = value;
		}
		deref() {
			return this.value[kConnected$2] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
		}
	};
	var CompatFinalizer = class {
		constructor(finalizer) {
			this.finalizer = finalizer;
		}
		register(dispatcher, key) {
			if (dispatcher.on) dispatcher.on("disconnect", () => {
				if (dispatcher[kConnected$2] === 0 && dispatcher[kSize] === 0) this.finalizer(key);
			});
		}
	};
	module.exports = function() {
		if (process.env.NODE_V8_COVERAGE) return {
			WeakRef: CompatWeakRef,
			FinalizationRegistry: CompatFinalizer
		};
		return {
			WeakRef: global.WeakRef || CompatWeakRef,
			FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
		};
	};
} });

//#endregion
//#region node_modules/undici/lib/agent.js
var require_agent = __commonJS({ "node_modules/undici/lib/agent.js"(exports, module) {
	const { InvalidArgumentError: InvalidArgumentError$13 } = require_errors();
	const { kClients: kClients$1, kRunning, kClose: kClose$3, kDestroy: kDestroy$1, kDispatch, kInterceptors: kInterceptors$1 } = require_symbols$4();
	const DispatcherBase$1 = require_dispatcher_base();
	const Pool$3 = require_pool();
	const Client$2 = require_client();
	const util$16 = require_util$8();
	const createRedirectInterceptor$1 = require_redirectInterceptor();
	const { WeakRef: WeakRef$1, FinalizationRegistry: FinalizationRegistry$1 } = require_dispatcher_weakref()();
	const kOnConnect = Symbol("onConnect");
	const kOnDisconnect = Symbol("onDisconnect");
	const kOnConnectionError = Symbol("onConnectionError");
	const kMaxRedirections = Symbol("maxRedirections");
	const kOnDrain = Symbol("onDrain");
	const kFactory$1 = Symbol("factory");
	const kFinalizer = Symbol("finalizer");
	const kOptions$1 = Symbol("options");
	function defaultFactory$1(origin, opts) {
		return opts && opts.connections === 1 ? new Client$2(origin, opts) : new Pool$3(origin, opts);
	}
	var Agent$5 = class extends DispatcherBase$1 {
		constructor({ factory = defaultFactory$1, maxRedirections = 0, connect: connect$2,...options } = {}) {
			super();
			if (typeof factory !== "function") throw new InvalidArgumentError$13("factory must be a function.");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$13("connect must be a function or an object");
			if (!Number.isInteger(maxRedirections) || maxRedirections < 0) throw new InvalidArgumentError$13("maxRedirections must be a positive number");
			if (connect$2 && typeof connect$2 !== "function") connect$2 = { ...connect$2 };
			this[kInterceptors$1] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor$1({ maxRedirections })];
			this[kOptions$1] = {
				...util$16.deepClone(options),
				connect: connect$2
			};
			this[kOptions$1].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kMaxRedirections] = maxRedirections;
			this[kFactory$1] = factory;
			this[kClients$1] = new Map();
			this[kFinalizer] = new FinalizationRegistry$1(
				/* istanbul ignore next: gc is undeterministic */
				(key) => {
					const ref = this[kClients$1].get(key);
					if (ref !== void 0 && ref.deref() === void 0) this[kClients$1].delete(key);
				}
);
			const agent = this;
			this[kOnDrain] = (origin, targets) => {
				agent.emit("drain", origin, [agent, ...targets]);
			};
			this[kOnConnect] = (origin, targets) => {
				agent.emit("connect", origin, [agent, ...targets]);
			};
			this[kOnDisconnect] = (origin, targets, err) => {
				agent.emit("disconnect", origin, [agent, ...targets], err);
			};
			this[kOnConnectionError] = (origin, targets, err) => {
				agent.emit("connectionError", origin, [agent, ...targets], err);
			};
		}
		get [kRunning]() {
			let ret = 0;
			for (const ref of this[kClients$1].values()) {
				const client = ref.deref();
				/* istanbul ignore next: gc is undeterministic */
				if (client) ret += client[kRunning];
			}
			return ret;
		}
		[kDispatch](opts, handler$1) {
			let key;
			if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) key = String(opts.origin);
			else throw new InvalidArgumentError$13("opts.origin must be a non-empty string or URL.");
			const ref = this[kClients$1].get(key);
			let dispatcher = ref ? ref.deref() : null;
			if (!dispatcher) {
				dispatcher = this[kFactory$1](opts.origin, this[kOptions$1]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
				this[kClients$1].set(key, new WeakRef$1(dispatcher));
				this[kFinalizer].register(dispatcher, key);
			}
			return dispatcher.dispatch(opts, handler$1);
		}
		async [kClose$3]() {
			const closePromises = [];
			for (const ref of this[kClients$1].values()) {
				const client = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client) closePromises.push(client.close());
			}
			await Promise.all(closePromises);
		}
		async [kDestroy$1](err) {
			const destroyPromises = [];
			for (const ref of this[kClients$1].values()) {
				const client = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client) destroyPromises.push(client.destroy(err));
			}
			await Promise.all(destroyPromises);
		}
	};
	module.exports = Agent$5;
} });

//#endregion
//#region node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({ "node_modules/undici/lib/api/readable.js"(exports, module) {
	const assert$11 = require("assert");
	const { Readable: Readable$5 } = require("stream");
	const { RequestAbortedError: RequestAbortedError$7, NotSupportedError, InvalidArgumentError: InvalidArgumentError$12 } = require_errors();
	const util$15 = require_util$8();
	const { ReadableStreamFrom, toUSVString: toUSVString$1 } = require_util$8();
	let Blob$2;
	const kConsume = Symbol("kConsume");
	const kReading = Symbol("kReading");
	const kBody = Symbol("kBody");
	const kAbort = Symbol("abort");
	const kContentType = Symbol("kContentType");
	const noop$1 = () => {};
	module.exports = class BodyReadable extends Readable$5 {
		constructor({ resume: resume$3, abort: abort$1, contentType = "", highWaterMark = 64 * 1024 }) {
			super({
				autoDestroy: true,
				read: resume$3,
				highWaterMark
			});
			this._readableState.dataEmitted = false;
			this[kAbort] = abort$1;
			this[kConsume] = null;
			this[kBody] = null;
			this[kContentType] = contentType;
			this[kReading] = false;
		}
		destroy(err) {
			if (this.destroyed) return this;
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$7();
			if (err) this[kAbort]();
			return super.destroy(err);
		}
		emit(ev, ...args) {
			if (ev === "data") this._readableState.dataEmitted = true;
			else if (ev === "error") this._readableState.errorEmitted = true;
			return super.emit(ev, ...args);
		}
		on(ev, ...args) {
			if (ev === "data" || ev === "readable") this[kReading] = true;
			return super.on(ev, ...args);
		}
		addListener(ev, ...args) {
			return this.on(ev, ...args);
		}
		off(ev, ...args) {
			const ret = super.off(ev, ...args);
			if (ev === "data" || ev === "readable") this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
			return ret;
		}
		removeListener(ev, ...args) {
			return this.off(ev, ...args);
		}
		push(chunk) {
			if (this[kConsume] && chunk !== null && this.readableLength === 0) {
				consumePush(this[kConsume], chunk);
				return this[kReading] ? super.push(chunk) : true;
			}
			return super.push(chunk);
		}
		async text() {
			return consume(this, "text");
		}
		async json() {
			return consume(this, "json");
		}
		async blob() {
			return consume(this, "blob");
		}
		async arrayBuffer() {
			return consume(this, "arrayBuffer");
		}
		async formData() {
			throw new NotSupportedError();
		}
		get bodyUsed() {
			return util$15.isDisturbed(this);
		}
		get body() {
			if (!this[kBody]) {
				this[kBody] = ReadableStreamFrom(this);
				if (this[kConsume]) {
					this[kBody].getReader();
					assert$11(this[kBody].locked);
				}
			}
			return this[kBody];
		}
		dump(opts) {
			let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
			const signal = opts && opts.signal;
			if (signal) try {
				if (typeof signal !== "object" || !("aborted" in signal)) throw new InvalidArgumentError$12("signal must be an AbortSignal");
				util$15.throwIfAborted(signal);
			} catch (err) {
				return Promise.reject(err);
			}
			if (this.closed) return Promise.resolve(null);
			return new Promise((resolve, reject) => {
				const signalListenerCleanup = signal ? util$15.addAbortListener(signal, () => {
					this.destroy();
				}) : noop$1;
				this.on("close", function() {
					signalListenerCleanup();
					if (signal && signal.aborted) reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
					else resolve(null);
				}).on("error", noop$1).on("data", function(chunk) {
					limit -= chunk.length;
					if (limit <= 0) this.destroy();
				}).resume();
			});
		}
	};
	function isLocked(self$1) {
		return self$1[kBody] && self$1[kBody].locked === true || self$1[kConsume];
	}
	function isUnusable(self$1) {
		return util$15.isDisturbed(self$1) || isLocked(self$1);
	}
	async function consume(stream$6, type) {
		if (isUnusable(stream$6)) throw new TypeError("unusable");
		assert$11(!stream$6[kConsume]);
		return new Promise((resolve, reject) => {
			stream$6[kConsume] = {
				type,
				stream: stream$6,
				resolve,
				reject,
				length: 0,
				body: []
			};
			stream$6.on("error", function(err) {
				consumeFinish(this[kConsume], err);
			}).on("close", function() {
				if (this[kConsume].body !== null) consumeFinish(this[kConsume], new RequestAbortedError$7());
			});
			process.nextTick(consumeStart, stream$6[kConsume]);
		});
	}
	function consumeStart(consume$1) {
		if (consume$1.body === null) return;
		const { _readableState: state } = consume$1.stream;
		for (const chunk of state.buffer) consumePush(consume$1, chunk);
		if (state.endEmitted) consumeEnd(this[kConsume]);
		else consume$1.stream.on("end", function() {
			consumeEnd(this[kConsume]);
		});
		consume$1.stream.resume();
		while (consume$1.stream.read() != null);
	}
	function consumeEnd(consume$1) {
		const { type, body, resolve, stream: stream$6, length } = consume$1;
		try {
			if (type === "text") resolve(toUSVString$1(Buffer.concat(body)));
			else if (type === "json") resolve(JSON.parse(Buffer.concat(body)));
			else if (type === "arrayBuffer") {
				const dst = new Uint8Array(length);
				let pos = 0;
				for (const buf of body) {
					dst.set(buf, pos);
					pos += buf.byteLength;
				}
				resolve(dst.buffer);
			} else if (type === "blob") {
				if (!Blob$2) Blob$2 = require("buffer").Blob;
				resolve(new Blob$2(body, { type: stream$6[kContentType] }));
			}
			consumeFinish(consume$1);
		} catch (err) {
			stream$6.destroy(err);
		}
	}
	function consumePush(consume$1, chunk) {
		consume$1.length += chunk.length;
		consume$1.body.push(chunk);
	}
	function consumeFinish(consume$1, err) {
		if (consume$1.body === null) return;
		if (err) consume$1.reject(err);
		else consume$1.resolve();
		consume$1.type = null;
		consume$1.stream = null;
		consume$1.resolve = null;
		consume$1.reject = null;
		consume$1.length = 0;
		consume$1.body = null;
	}
} });

//#endregion
//#region node_modules/undici/lib/api/util.js
var require_util$6 = __commonJS({ "node_modules/undici/lib/api/util.js"(exports, module) {
	const assert$10 = require("assert");
	const { ResponseStatusCodeError } = require_errors();
	const { toUSVString } = require_util$8();
	async function getResolveErrorBodyCallback$2({ callback, body, contentType, statusCode, statusMessage, headers }) {
		assert$10(body);
		let chunks = [];
		let limit = 0;
		for await (const chunk of body) {
			chunks.push(chunk);
			limit += chunk.length;
			if (limit > 128 * 1024) {
				chunks = null;
				break;
			}
		}
		if (statusCode === 204 || !contentType || !chunks) {
			process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
			return;
		}
		try {
			if (contentType.startsWith("application/json")) {
				const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
				return;
			}
			if (contentType.startsWith("text/")) {
				const payload = toUSVString(Buffer.concat(chunks));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
				return;
			}
		} catch (err) {}
		process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
	}
	module.exports = { getResolveErrorBodyCallback: getResolveErrorBodyCallback$2 };
} });

//#endregion
//#region node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({ "node_modules/undici/lib/api/abort-signal.js"(exports, module) {
	const { addAbortListener: addAbortListener$1 } = require_util$8();
	const { RequestAbortedError: RequestAbortedError$6 } = require_errors();
	const kListener$2 = Symbol("kListener");
	const kSignal$1 = Symbol("kSignal");
	function abort(self$1) {
		if (self$1.abort) self$1.abort();
		else self$1.onError(new RequestAbortedError$6());
	}
	function addSignal$5(self$1, signal) {
		self$1[kSignal$1] = null;
		self$1[kListener$2] = null;
		if (!signal) return;
		if (signal.aborted) {
			abort(self$1);
			return;
		}
		self$1[kSignal$1] = signal;
		self$1[kListener$2] = () => {
			abort(self$1);
		};
		addAbortListener$1(self$1[kSignal$1], self$1[kListener$2]);
	}
	function removeSignal$5(self$1) {
		if (!self$1[kSignal$1]) return;
		if ("removeEventListener" in self$1[kSignal$1]) self$1[kSignal$1].removeEventListener("abort", self$1[kListener$2]);
		else self$1[kSignal$1].removeListener("abort", self$1[kListener$2]);
		self$1[kSignal$1] = null;
		self$1[kListener$2] = null;
	}
	module.exports = {
		addSignal: addSignal$5,
		removeSignal: removeSignal$5
	};
} });

//#endregion
//#region node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({ "node_modules/undici/lib/api/api-request.js"(exports, module) {
	const Readable$4 = require_readable();
	const { InvalidArgumentError: InvalidArgumentError$11, RequestAbortedError: RequestAbortedError$5 } = require_errors();
	const util$14 = require_util$8();
	const { getResolveErrorBodyCallback: getResolveErrorBodyCallback$1 } = require_util$6();
	const { AsyncResource: AsyncResource$4 } = require("async_hooks");
	const { addSignal: addSignal$4, removeSignal: removeSignal$4 } = require_abort_signal();
	var RequestHandler = class extends AsyncResource$4 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$11("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError$11("invalid callback");
				if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) throw new InvalidArgumentError$11("invalid highWaterMark");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$11("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError$11("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$11("invalid onInfo callback");
				super("UNDICI_REQUEST");
			} catch (err) {
				if (util$14.isStream(body)) util$14.destroy(body.on("error", util$14.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.body = body;
			this.trailers = {};
			this.context = null;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError;
			this.highWaterMark = highWaterMark;
			if (util$14.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal$4(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$5();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders(statusCode, rawHeaders, resume$3, statusMessage) {
			const { callback, opaque, abort: abort$1, context, responseHeaders, highWaterMark } = this;
			const headers = responseHeaders === "raw" ? util$14.parseRawHeaders(rawHeaders) : util$14.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			const parsedHeaders = responseHeaders === "raw" ? util$14.parseHeaders(rawHeaders) : headers;
			const contentType = parsedHeaders["content-type"];
			const body = new Readable$4({
				resume: resume$3,
				abort: abort$1,
				contentType,
				highWaterMark
			});
			this.callback = null;
			this.res = body;
			if (callback !== null) if (this.throwOnError && statusCode >= 400) this.runInAsyncScope(getResolveErrorBodyCallback$1, null, {
				callback,
				body,
				contentType,
				statusCode,
				statusMessage,
				headers
			});
			else this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				trailers: this.trailers,
				opaque,
				body,
				context
			});
		}
		onData(chunk) {
			const { res } = this;
			return res.push(chunk);
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal$4(this);
			util$14.parseHeaders(trailers, this.trailers);
			res.push(null);
		}
		onError(err) {
			const { res, callback, body, opaque } = this;
			removeSignal$4(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (res) {
				this.res = null;
				queueMicrotask(() => {
					util$14.destroy(res, err);
				});
			}
			if (body) {
				this.body = null;
				util$14.destroy(body, err);
			}
		}
	};
	function request$2(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			request$2.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			this.dispatch(opts, new RequestHandler(opts, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = request$2;
	module.exports.RequestHandler = RequestHandler;
} });

//#endregion
//#region node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({ "node_modules/undici/lib/api/api-stream.js"(exports, module) {
	const { finished, PassThrough: PassThrough$3 } = require("stream");
	const { InvalidArgumentError: InvalidArgumentError$10, InvalidReturnValueError: InvalidReturnValueError$1, RequestAbortedError: RequestAbortedError$4 } = require_errors();
	const util$13 = require_util$8();
	const { getResolveErrorBodyCallback } = require_util$6();
	const { AsyncResource: AsyncResource$3 } = require("async_hooks");
	const { addSignal: addSignal$3, removeSignal: removeSignal$3 } = require_abort_signal();
	var StreamHandler = class extends AsyncResource$3 {
		constructor(opts, factory, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$10("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError$10("invalid callback");
				if (typeof factory !== "function") throw new InvalidArgumentError$10("invalid factory");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$10("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError$10("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$10("invalid onInfo callback");
				super("UNDICI_STREAM");
			} catch (err) {
				if (util$13.isStream(body)) util$13.destroy(body.on("error", util$13.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.factory = factory;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.context = null;
			this.trailers = null;
			this.body = body;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError || false;
			if (util$13.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal$3(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$4();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders(statusCode, rawHeaders, resume$3, statusMessage) {
			const { factory, opaque, context, callback, responseHeaders } = this;
			const headers = responseHeaders === "raw" ? util$13.parseRawHeaders(rawHeaders) : util$13.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			this.factory = null;
			let res;
			if (this.throwOnError && statusCode >= 400) {
				const parsedHeaders = responseHeaders === "raw" ? util$13.parseHeaders(rawHeaders) : headers;
				const contentType = parsedHeaders["content-type"];
				res = new PassThrough$3();
				this.callback = null;
				this.runInAsyncScope(getResolveErrorBodyCallback, null, {
					callback,
					body: res,
					contentType,
					statusCode,
					statusMessage,
					headers
				});
			} else {
				if (factory === null) return;
				res = this.runInAsyncScope(factory, null, {
					statusCode,
					headers,
					opaque,
					context
				});
				if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") throw new InvalidReturnValueError$1("expected Writable");
				finished(res, { readable: false }, (err) => {
					const { callback: callback$1, res: res$1, opaque: opaque$1, trailers, abort: abort$1 } = this;
					this.res = null;
					if (err || !res$1.readable) util$13.destroy(res$1, err);
					this.callback = null;
					this.runInAsyncScope(callback$1, null, err || null, {
						opaque: opaque$1,
						trailers
					});
					if (err) abort$1();
				});
			}
			res.on("drain", resume$3);
			this.res = res;
			const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
			return needDrain !== true;
		}
		onData(chunk) {
			const { res } = this;
			return res ? res.write(chunk) : true;
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal$3(this);
			if (!res) return;
			this.trailers = util$13.parseHeaders(trailers);
			res.end();
		}
		onError(err) {
			const { res, callback, opaque, body } = this;
			removeSignal$3(this);
			this.factory = null;
			if (res) {
				this.res = null;
				util$13.destroy(res, err);
			} else if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (body) {
				this.body = null;
				util$13.destroy(body, err);
			}
		}
	};
	function stream$4(opts, factory, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			stream$4.call(this, opts, factory, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			this.dispatch(opts, new StreamHandler(opts, factory, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = stream$4;
} });

//#endregion
//#region node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({ "node_modules/undici/lib/api/api-pipeline.js"(exports, module) {
	const { Readable: Readable$3, Duplex: Duplex$4, PassThrough: PassThrough$2 } = require("stream");
	const { InvalidArgumentError: InvalidArgumentError$9, InvalidReturnValueError, RequestAbortedError: RequestAbortedError$3 } = require_errors();
	const util$12 = require_util$8();
	const { AsyncResource: AsyncResource$2 } = require("async_hooks");
	const { addSignal: addSignal$2, removeSignal: removeSignal$2 } = require_abort_signal();
	const assert$9 = require("assert");
	const kResume = Symbol("resume");
	var PipelineRequest = class extends Readable$3 {
		constructor() {
			super({ autoDestroy: true });
			this[kResume] = null;
		}
		_read() {
			const { [kResume]: resume$3 } = this;
			if (resume$3) {
				this[kResume] = null;
				resume$3();
			}
		}
		_destroy(err, callback) {
			this._read();
			callback(err);
		}
	};
	var PipelineResponse = class extends Readable$3 {
		constructor(resume$3) {
			super({ autoDestroy: true });
			this[kResume] = resume$3;
		}
		_read() {
			this[kResume]();
		}
		_destroy(err, callback) {
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$3();
			callback(err);
		}
	};
	var PipelineHandler = class extends AsyncResource$2 {
		constructor(opts, handler$1) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$9("invalid opts");
			if (typeof handler$1 !== "function") throw new InvalidArgumentError$9("invalid handler");
			const { signal, method, opaque, onInfo, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$9("signal must be an EventEmitter or EventTarget");
			if (method === "CONNECT") throw new InvalidArgumentError$9("invalid method");
			if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$9("invalid onInfo callback");
			super("UNDICI_PIPELINE");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.handler = handler$1;
			this.abort = null;
			this.context = null;
			this.onInfo = onInfo || null;
			this.req = new PipelineRequest().on("error", util$12.nop);
			this.ret = new Duplex$4({
				readableObjectMode: opts.objectMode,
				autoDestroy: true,
				read: () => {
					const { body } = this;
					if (body && body.resume) body.resume();
				},
				write: (chunk, encoding, callback) => {
					const { req: req$1 } = this;
					if (req$1.push(chunk, encoding) || req$1._readableState.destroyed) callback();
					else req$1[kResume] = callback;
				},
				destroy: (err, callback) => {
					const { body, req: req$1, res, ret, abort: abort$1 } = this;
					if (!err && !ret._readableState.endEmitted) err = new RequestAbortedError$3();
					if (abort$1 && err) abort$1();
					util$12.destroy(body, err);
					util$12.destroy(req$1, err);
					util$12.destroy(res, err);
					removeSignal$2(this);
					callback(err);
				}
			}).on("prefinish", () => {
				const { req: req$1 } = this;
				req$1.push(null);
			});
			this.res = null;
			addSignal$2(this, signal);
		}
		onConnect(abort$1, context) {
			const { ret, res } = this;
			assert$9(!res, "pipeline cannot be retried");
			if (ret.destroyed) throw new RequestAbortedError$3();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders(statusCode, rawHeaders, resume$3) {
			const { opaque, handler: handler$1, context } = this;
			if (statusCode < 200) {
				if (this.onInfo) {
					const headers = this.responseHeaders === "raw" ? util$12.parseRawHeaders(rawHeaders) : util$12.parseHeaders(rawHeaders);
					this.onInfo({
						statusCode,
						headers
					});
				}
				return;
			}
			this.res = new PipelineResponse(resume$3);
			let body;
			try {
				this.handler = null;
				const headers = this.responseHeaders === "raw" ? util$12.parseRawHeaders(rawHeaders) : util$12.parseHeaders(rawHeaders);
				body = this.runInAsyncScope(handler$1, null, {
					statusCode,
					headers,
					opaque,
					body: this.res,
					context
				});
			} catch (err) {
				this.res.on("error", util$12.nop);
				throw err;
			}
			if (!body || typeof body.on !== "function") throw new InvalidReturnValueError("expected Readable");
			body.on("data", (chunk) => {
				const { ret, body: body$1 } = this;
				if (!ret.push(chunk) && body$1.pause) body$1.pause();
			}).on("error", (err) => {
				const { ret } = this;
				util$12.destroy(ret, err);
			}).on("end", () => {
				const { ret } = this;
				ret.push(null);
			}).on("close", () => {
				const { ret } = this;
				if (!ret._readableState.ended) util$12.destroy(ret, new RequestAbortedError$3());
			});
			this.body = body;
		}
		onData(chunk) {
			const { res } = this;
			return res.push(chunk);
		}
		onComplete(trailers) {
			const { res } = this;
			res.push(null);
		}
		onError(err) {
			const { ret } = this;
			this.handler = null;
			util$12.destroy(ret, err);
		}
	};
	function pipeline$1(opts, handler$1) {
		try {
			const pipelineHandler = new PipelineHandler(opts, handler$1);
			this.dispatch({
				...opts,
				body: pipelineHandler.req
			}, pipelineHandler);
			return pipelineHandler.ret;
		} catch (err) {
			return new PassThrough$2().destroy(err);
		}
	}
	module.exports = pipeline$1;
} });

//#endregion
//#region node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({ "node_modules/undici/lib/api/api-upgrade.js"(exports, module) {
	const { InvalidArgumentError: InvalidArgumentError$8, RequestAbortedError: RequestAbortedError$2, SocketError: SocketError$1 } = require_errors();
	const { AsyncResource: AsyncResource$1 } = require("async_hooks");
	const util$11 = require_util$8();
	const { addSignal: addSignal$1, removeSignal: removeSignal$1 } = require_abort_signal();
	const assert$8 = require("assert");
	var UpgradeHandler = class extends AsyncResource$1 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$8("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError$8("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$8("signal must be an EventEmitter or EventTarget");
			super("UNDICI_UPGRADE");
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.abort = null;
			this.context = null;
			addSignal$1(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$2();
			this.abort = abort$1;
			this.context = null;
		}
		onHeaders() {
			throw new SocketError$1("bad upgrade", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context } = this;
			assert$8.strictEqual(statusCode, 101);
			removeSignal$1(this);
			this.callback = null;
			const headers = this.responseHeaders === "raw" ? util$11.parseRawHeaders(rawHeaders) : util$11.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				headers,
				socket,
				opaque,
				context
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal$1(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function upgrade(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			upgrade.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			const upgradeHandler = new UpgradeHandler(opts, callback);
			this.dispatch({
				...opts,
				method: opts.method || "GET",
				upgrade: opts.protocol || "Websocket"
			}, upgradeHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = upgrade;
} });

//#endregion
//#region node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({ "node_modules/undici/lib/api/api-connect.js"(exports, module) {
	const { AsyncResource } = require("async_hooks");
	const { InvalidArgumentError: InvalidArgumentError$7, RequestAbortedError: RequestAbortedError$1, SocketError } = require_errors();
	const util$10 = require_util$8();
	const { addSignal, removeSignal } = require_abort_signal();
	var ConnectHandler = class extends AsyncResource {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$7("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError$7("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$7("signal must be an EventEmitter or EventTarget");
			super("UNDICI_CONNECT");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.callback = callback;
			this.abort = null;
			addSignal(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$1();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders() {
			throw new SocketError("bad connect", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context } = this;
			removeSignal(this);
			this.callback = null;
			let headers = rawHeaders;
			if (headers != null) headers = this.responseHeaders === "raw" ? util$10.parseRawHeaders(rawHeaders) : util$10.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				socket,
				opaque,
				context
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function connect(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			connect.call(this, opts, (err, data) => {
				return err ? reject(err) : resolve(data);
			});
		});
		try {
			const connectHandler = new ConnectHandler(opts, callback);
			this.dispatch({
				...opts,
				method: "CONNECT"
			}, connectHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = connect;
} });

//#endregion
//#region node_modules/undici/lib/api/index.js
var require_api = __commonJS({ "node_modules/undici/lib/api/index.js"(exports, module) {
	module.exports.request = require_api_request();
	module.exports.stream = require_api_stream();
	module.exports.pipeline = require_api_pipeline();
	module.exports.upgrade = require_api_upgrade();
	module.exports.connect = require_api_connect();
} });

//#endregion
//#region node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({ "node_modules/undici/lib/mock/mock-errors.js"(exports, module) {
	const { UndiciError: UndiciError$1 } = require_errors();
	var MockNotMatchedError$1 = class MockNotMatchedError$1 extends UndiciError$1 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, MockNotMatchedError$1);
			this.name = "MockNotMatchedError";
			this.message = message || "The request does not match any registered mock dispatches";
			this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
		}
	};
	module.exports = { MockNotMatchedError: MockNotMatchedError$1 };
} });

//#endregion
//#region node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({ "node_modules/undici/lib/mock/mock-symbols.js"(exports, module) {
	module.exports = {
		kAgent: Symbol("agent"),
		kOptions: Symbol("options"),
		kFactory: Symbol("factory"),
		kDispatches: Symbol("dispatches"),
		kDispatchKey: Symbol("dispatch key"),
		kDefaultHeaders: Symbol("default headers"),
		kDefaultTrailers: Symbol("default trailers"),
		kContentLength: Symbol("content length"),
		kMockAgent: Symbol("mock agent"),
		kMockAgentSet: Symbol("mock agent set"),
		kMockAgentGet: Symbol("mock agent get"),
		kMockDispatch: Symbol("mock dispatch"),
		kClose: Symbol("close"),
		kOriginalClose: Symbol("original agent close"),
		kOrigin: Symbol("origin"),
		kIsMockActive: Symbol("is mock active"),
		kNetConnect: Symbol("net connect"),
		kGetNetConnect: Symbol("get net connect"),
		kConnected: Symbol("connected")
	};
} });

//#endregion
//#region node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({ "node_modules/undici/lib/mock/mock-utils.js"(exports, module) {
	const { MockNotMatchedError } = require_mock_errors();
	const { kDispatches: kDispatches$4, kMockAgent: kMockAgent$2, kOriginalDispatch: kOriginalDispatch$2, kOrigin: kOrigin$2, kGetNetConnect: kGetNetConnect$1 } = require_mock_symbols();
	const { buildURL: buildURL$1, nop } = require_util$8();
	const { STATUS_CODES: STATUS_CODES$2 } = require("http");
	const { types: { isPromise } } = require("util");
	function matchValue$1(match, value) {
		if (typeof match === "string") return match === value;
		if (match instanceof RegExp) return match.test(value);
		if (typeof match === "function") return match(value) === true;
		return false;
	}
	function lowerCaseEntries(headers) {
		return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
			return [headerName.toLocaleLowerCase(), headerValue];
		}));
	}
	/**
	* @param {import('../../index').Headers|string[]|Record<string, string>} headers
	* @param {string} key
	*/
	function getHeaderByName(headers, key) {
		if (Array.isArray(headers)) {
			for (let i$1 = 0; i$1 < headers.length; i$1 += 2) if (headers[i$1].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers[i$1 + 1];
			return void 0;
		} else if (typeof headers.get === "function") return headers.get(key);
		else return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
	}
	/** @param {string[]} headers */
	function buildHeadersFromArray(headers) {
		const clone$1 = headers.slice();
		const entries = [];
		for (let index = 0; index < clone$1.length; index += 2) entries.push([clone$1[index], clone$1[index + 1]]);
		return Object.fromEntries(entries);
	}
	function matchHeaders(mockDispatch$1, headers) {
		if (typeof mockDispatch$1.headers === "function") {
			if (Array.isArray(headers)) headers = buildHeadersFromArray(headers);
			return mockDispatch$1.headers(headers ? lowerCaseEntries(headers) : {});
		}
		if (typeof mockDispatch$1.headers === "undefined") return true;
		if (typeof headers !== "object" || typeof mockDispatch$1.headers !== "object") return false;
		for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch$1.headers)) {
			const headerValue = getHeaderByName(headers, matchHeaderName);
			if (!matchValue$1(matchHeaderValue, headerValue)) return false;
		}
		return true;
	}
	function safeUrl(path$8) {
		if (typeof path$8 !== "string") return path$8;
		const pathSegments = path$8.split("?");
		if (pathSegments.length !== 2) return path$8;
		const qp = new URLSearchParams(pathSegments.pop());
		qp.sort();
		return [...pathSegments, qp.toString()].join("?");
	}
	function matchKey(mockDispatch$1, { path: path$8, method, body, headers }) {
		const pathMatch = matchValue$1(mockDispatch$1.path, path$8);
		const methodMatch = matchValue$1(mockDispatch$1.method, method);
		const bodyMatch = typeof mockDispatch$1.body !== "undefined" ? matchValue$1(mockDispatch$1.body, body) : true;
		const headersMatch = matchHeaders(mockDispatch$1, headers);
		return pathMatch && methodMatch && bodyMatch && headersMatch;
	}
	function getResponseData$2(data) {
		if (Buffer.isBuffer(data)) return data;
		else if (typeof data === "object") return JSON.stringify(data);
		else return data.toString();
	}
	function getMockDispatch(mockDispatches, key) {
		const basePath = key.query ? buildURL$1(key.path, key.query) : key.path;
		const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
		let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path$8 }) => matchValue$1(safeUrl(path$8), resolvedPath));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue$1(method, key.method));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue$1(body, key.body) : true);
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
		matchedMockDispatches = matchedMockDispatches.filter((mockDispatch$1) => matchHeaders(mockDispatch$1, key.headers));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
		return matchedMockDispatches[0];
	}
	function addMockDispatch$1(mockDispatches, key, data) {
		const baseData = {
			timesInvoked: 0,
			times: 1,
			persist: false,
			consumed: false
		};
		const replyData = typeof data === "function" ? { callback: data } : { ...data };
		const newMockDispatch = {
			...baseData,
			...key,
			pending: true,
			data: {
				error: null,
				...replyData
			}
		};
		mockDispatches.push(newMockDispatch);
		return newMockDispatch;
	}
	function deleteMockDispatch(mockDispatches, key) {
		const index = mockDispatches.findIndex((dispatch) => {
			if (!dispatch.consumed) return false;
			return matchKey(dispatch, key);
		});
		if (index !== -1) mockDispatches.splice(index, 1);
	}
	function buildKey$1(opts) {
		const { path: path$8, method, body, headers, query } = opts;
		return {
			path: path$8,
			method,
			body,
			headers,
			query
		};
	}
	function generateKeyValues(data) {
		return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
			...keyValuePairs,
			Buffer.from(`${key}`),
			Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
		], []);
	}
	/**
	* @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
	* @param {number} statusCode
	*/
	function getStatusText(statusCode) {
		return STATUS_CODES$2[statusCode] || "unknown";
	}
	async function getResponse(body) {
		const buffers = [];
		for await (const data of body) buffers.push(data);
		return Buffer.concat(buffers).toString("utf8");
	}
	/**
	* Mock dispatch function used to simulate undici dispatches
	*/
	function mockDispatch(opts, handler$1) {
		const key = buildKey$1(opts);
		const mockDispatch$1 = getMockDispatch(this[kDispatches$4], key);
		mockDispatch$1.timesInvoked++;
		if (mockDispatch$1.data.callback) mockDispatch$1.data = {
			...mockDispatch$1.data,
			...mockDispatch$1.data.callback(opts)
		};
		const { data: { statusCode, data, headers, trailers, error: error$1 }, delay, persist } = mockDispatch$1;
		const { timesInvoked, times } = mockDispatch$1;
		mockDispatch$1.consumed = !persist && timesInvoked >= times;
		mockDispatch$1.pending = timesInvoked < times;
		if (error$1 !== null) {
			deleteMockDispatch(this[kDispatches$4], key);
			handler$1.onError(error$1);
			return true;
		}
		if (typeof delay === "number" && delay > 0) setTimeout(() => {
			handleReply(this[kDispatches$4]);
		}, delay);
		else handleReply(this[kDispatches$4]);
		function handleReply(mockDispatches, _data = data) {
			const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
			const body = typeof _data === "function" ? _data({
				...opts,
				headers: optsHeaders
			}) : _data;
			if (isPromise(body)) {
				body.then((newData) => handleReply(mockDispatches, newData));
				return;
			}
			const responseData = getResponseData$2(body);
			const responseHeaders = generateKeyValues(headers);
			const responseTrailers = generateKeyValues(trailers);
			handler$1.abort = nop;
			handler$1.onHeaders(statusCode, responseHeaders, resume$3, getStatusText(statusCode));
			handler$1.onData(Buffer.from(responseData));
			handler$1.onComplete(responseTrailers);
			deleteMockDispatch(mockDispatches, key);
		}
		function resume$3() {}
		return true;
	}
	function buildMockDispatch$2() {
		const agent = this[kMockAgent$2];
		const origin = this[kOrigin$2];
		const originalDispatch = this[kOriginalDispatch$2];
		return function dispatch(opts, handler$1) {
			if (agent.isMockActive) try {
				mockDispatch.call(this, opts, handler$1);
			} catch (error$1) {
				if (error$1 instanceof MockNotMatchedError) {
					const netConnect$1 = agent[kGetNetConnect$1]();
					if (netConnect$1 === false) throw new MockNotMatchedError(`${error$1.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
					if (checkNetConnect(netConnect$1, origin)) originalDispatch.call(this, opts, handler$1);
					else throw new MockNotMatchedError(`${error$1.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
				} else throw error$1;
			}
			else originalDispatch.call(this, opts, handler$1);
		};
	}
	function checkNetConnect(netConnect$1, origin) {
		const url = new URL(origin);
		if (netConnect$1 === true) return true;
		else if (Array.isArray(netConnect$1) && netConnect$1.some((matcher) => matchValue$1(matcher, url.host))) return true;
		return false;
	}
	function buildMockOptions$1(opts) {
		if (opts) {
			const { agent,...mockOptions } = opts;
			return mockOptions;
		}
	}
	module.exports = {
		getResponseData: getResponseData$2,
		getMockDispatch,
		addMockDispatch: addMockDispatch$1,
		deleteMockDispatch,
		buildKey: buildKey$1,
		generateKeyValues,
		matchValue: matchValue$1,
		getResponse,
		getStatusText,
		mockDispatch,
		buildMockDispatch: buildMockDispatch$2,
		checkNetConnect,
		buildMockOptions: buildMockOptions$1,
		getHeaderByName
	};
} });

//#endregion
//#region node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({ "node_modules/undici/lib/mock/mock-interceptor.js"(exports, module) {
	const { getResponseData: getResponseData$1, buildKey, addMockDispatch } = require_mock_utils();
	const { kDispatches: kDispatches$3, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = require_mock_symbols();
	const { InvalidArgumentError: InvalidArgumentError$6 } = require_errors();
	const { buildURL } = require_util$8();
	/**
	* Defines the scope API for an interceptor reply
	*/
	var MockScope = class {
		constructor(mockDispatch$1) {
			this[kMockDispatch] = mockDispatch$1;
		}
		/**
		* Delay a reply by a set amount in ms.
		*/
		delay(waitInMs) {
			if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) throw new InvalidArgumentError$6("waitInMs must be a valid integer > 0");
			this[kMockDispatch].delay = waitInMs;
			return this;
		}
		/**
		* For a defined reply, never mark as consumed.
		*/
		persist() {
			this[kMockDispatch].persist = true;
			return this;
		}
		/**
		* Allow one to define a reply for a set amount of matching requests.
		*/
		times(repeatTimes) {
			if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) throw new InvalidArgumentError$6("repeatTimes must be a valid integer > 0");
			this[kMockDispatch].times = repeatTimes;
			return this;
		}
	};
	/**
	* Defines an interceptor for a Mock
	*/
	var MockInterceptor$2 = class {
		constructor(opts, mockDispatches) {
			if (typeof opts !== "object") throw new InvalidArgumentError$6("opts must be an object");
			if (typeof opts.path === "undefined") throw new InvalidArgumentError$6("opts.path must be defined");
			if (typeof opts.method === "undefined") opts.method = "GET";
			if (typeof opts.path === "string") if (opts.query) opts.path = buildURL(opts.path, opts.query);
			else {
				const parsedURL = new URL(opts.path, "data://");
				opts.path = parsedURL.pathname + parsedURL.search;
			}
			if (typeof opts.method === "string") opts.method = opts.method.toUpperCase();
			this[kDispatchKey] = buildKey(opts);
			this[kDispatches$3] = mockDispatches;
			this[kDefaultHeaders] = {};
			this[kDefaultTrailers] = {};
			this[kContentLength] = false;
		}
		createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
			const responseData = getResponseData$1(data);
			const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
			const headers = {
				...this[kDefaultHeaders],
				...contentLength,
				...responseOptions.headers
			};
			const trailers = {
				...this[kDefaultTrailers],
				...responseOptions.trailers
			};
			return {
				statusCode,
				data,
				headers,
				trailers
			};
		}
		validateReplyParameters(statusCode, data, responseOptions) {
			if (typeof statusCode === "undefined") throw new InvalidArgumentError$6("statusCode must be defined");
			if (typeof data === "undefined") throw new InvalidArgumentError$6("data must be defined");
			if (typeof responseOptions !== "object") throw new InvalidArgumentError$6("responseOptions must be an object");
		}
		/**
		* Mock an undici request with a defined reply.
		*/
		reply(replyData) {
			if (typeof replyData === "function") {
				const wrappedDefaultsCallback = (opts) => {
					const resolvedData = replyData(opts);
					if (typeof resolvedData !== "object") throw new InvalidArgumentError$6("reply options callback must return an object");
					const { statusCode: statusCode$1, data: data$1 = "", responseOptions: responseOptions$1 = {} } = resolvedData;
					this.validateReplyParameters(statusCode$1, data$1, responseOptions$1);
					return { ...this.createMockScopeDispatchData(statusCode$1, data$1, responseOptions$1) };
				};
				const newMockDispatch$1 = addMockDispatch(this[kDispatches$3], this[kDispatchKey], wrappedDefaultsCallback);
				return new MockScope(newMockDispatch$1);
			}
			const [statusCode, data = "", responseOptions = {}] = [...arguments];
			this.validateReplyParameters(statusCode, data, responseOptions);
			const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
			const newMockDispatch = addMockDispatch(this[kDispatches$3], this[kDispatchKey], dispatchData);
			return new MockScope(newMockDispatch);
		}
		/**
		* Mock an undici request with a defined error.
		*/
		replyWithError(error$1) {
			if (typeof error$1 === "undefined") throw new InvalidArgumentError$6("error must be defined");
			const newMockDispatch = addMockDispatch(this[kDispatches$3], this[kDispatchKey], { error: error$1 });
			return new MockScope(newMockDispatch);
		}
		/**
		* Set default reply headers on the interceptor for subsequent replies
		*/
		defaultReplyHeaders(headers) {
			if (typeof headers === "undefined") throw new InvalidArgumentError$6("headers must be defined");
			this[kDefaultHeaders] = headers;
			return this;
		}
		/**
		* Set default reply trailers on the interceptor for subsequent replies
		*/
		defaultReplyTrailers(trailers) {
			if (typeof trailers === "undefined") throw new InvalidArgumentError$6("trailers must be defined");
			this[kDefaultTrailers] = trailers;
			return this;
		}
		/**
		* Set reply content length header for replies on the interceptor
		*/
		replyContentLength() {
			this[kContentLength] = true;
			return this;
		}
	};
	module.exports.MockInterceptor = MockInterceptor$2;
	module.exports.MockScope = MockScope;
} });

//#endregion
//#region node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({ "node_modules/undici/lib/mock/mock-client.js"(exports, module) {
	const { promisify: promisify$1 } = require("util");
	const Client$1 = require_client();
	const { buildMockDispatch: buildMockDispatch$1 } = require_mock_utils();
	const { kDispatches: kDispatches$2, kMockAgent: kMockAgent$1, kClose: kClose$2, kOriginalClose: kOriginalClose$1, kOrigin: kOrigin$1, kOriginalDispatch: kOriginalDispatch$1, kConnected: kConnected$1 } = require_mock_symbols();
	const { MockInterceptor: MockInterceptor$1 } = require_mock_interceptor();
	const Symbols$1 = require_symbols$4();
	const { InvalidArgumentError: InvalidArgumentError$5 } = require_errors();
	/**
	* MockClient provides an API that extends the Client to influence the mockDispatches.
	*/
	var MockClient$2 = class extends Client$1 {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$5("Argument opts.agent must implement Agent");
			this[kMockAgent$1] = opts.agent;
			this[kOrigin$1] = origin;
			this[kDispatches$2] = [];
			this[kConnected$1] = 1;
			this[kOriginalDispatch$1] = this.dispatch;
			this[kOriginalClose$1] = this.close.bind(this);
			this.dispatch = buildMockDispatch$1.call(this);
			this.close = this[kClose$2];
		}
		get [Symbols$1.kConnected]() {
			return this[kConnected$1];
		}
		/**
		* Sets up the base interceptor for mocking replies from undici.
		*/
		intercept(opts) {
			return new MockInterceptor$1(opts, this[kDispatches$2]);
		}
		async [kClose$2]() {
			await promisify$1(this[kOriginalClose$1])();
			this[kConnected$1] = 0;
			this[kMockAgent$1][Symbols$1.kClients].delete(this[kOrigin$1]);
		}
	};
	module.exports = MockClient$2;
} });

//#endregion
//#region node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({ "node_modules/undici/lib/mock/mock-pool.js"(exports, module) {
	const { promisify } = require("util");
	const Pool$2 = require_pool();
	const { buildMockDispatch } = require_mock_utils();
	const { kDispatches: kDispatches$1, kMockAgent, kClose: kClose$1, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = require_mock_symbols();
	const { MockInterceptor } = require_mock_interceptor();
	const Symbols = require_symbols$4();
	const { InvalidArgumentError: InvalidArgumentError$4 } = require_errors();
	/**
	* MockPool provides an API that extends the Pool to influence the mockDispatches.
	*/
	var MockPool$2 = class extends Pool$2 {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$4("Argument opts.agent must implement Agent");
			this[kMockAgent] = opts.agent;
			this[kOrigin] = origin;
			this[kDispatches$1] = [];
			this[kConnected] = 1;
			this[kOriginalDispatch] = this.dispatch;
			this[kOriginalClose] = this.close.bind(this);
			this.dispatch = buildMockDispatch.call(this);
			this.close = this[kClose$1];
		}
		get [Symbols.kConnected]() {
			return this[kConnected];
		}
		/**
		* Sets up the base interceptor for mocking replies from undici.
		*/
		intercept(opts) {
			return new MockInterceptor(opts, this[kDispatches$1]);
		}
		async [kClose$1]() {
			await promisify(this[kOriginalClose])();
			this[kConnected] = 0;
			this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
		}
	};
	module.exports = MockPool$2;
} });

//#endregion
//#region node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({ "node_modules/undici/lib/mock/pluralizer.js"(exports, module) {
	const singulars = {
		pronoun: "it",
		is: "is",
		was: "was",
		this: "this"
	};
	const plurals = {
		pronoun: "they",
		is: "are",
		was: "were",
		this: "these"
	};
	module.exports = class Pluralizer$1 {
		constructor(singular, plural$1) {
			this.singular = singular;
			this.plural = plural$1;
		}
		pluralize(count) {
			const one = count === 1;
			const keys = one ? singulars : plurals;
			const noun = one ? this.singular : this.plural;
			return {
				...keys,
				count,
				noun
			};
		}
	};
} });

//#endregion
//#region node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({ "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports, module) {
	const { Transform } = require("stream");
	const { Console } = require("console");
	/**
	* Gets the output of `console.table()` as a string.
	*/
	module.exports = class PendingInterceptorsFormatter$1 {
		constructor({ disableColors } = {}) {
			this.transform = new Transform({ transform(chunk, _enc, cb) {
				cb(null, chunk);
			} });
			this.logger = new Console({
				stdout: this.transform,
				inspectOptions: { colors: !disableColors && !process.env.CI }
			});
		}
		format(pendingInterceptors) {
			const withPrettyHeaders = pendingInterceptors.map(({ method, path: path$8, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
				Method: method,
				Origin: origin,
				Path: path$8,
				"Status code": statusCode,
				Persistent: persist ? "" : "",
				Invocations: timesInvoked,
				Remaining: persist ? Infinity : times - timesInvoked
			}));
			this.logger.table(withPrettyHeaders);
			return this.transform.read().toString();
		}
	};
} });

//#endregion
//#region node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({ "node_modules/undici/lib/mock/mock-agent.js"(exports, module) {
	const { kClients } = require_symbols$4();
	const Agent$4 = require_agent();
	const { kAgent: kAgent$1, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = require_mock_symbols();
	const MockClient$1 = require_mock_client();
	const MockPool$1 = require_mock_pool();
	const { matchValue, buildMockOptions } = require_mock_utils();
	const { InvalidArgumentError: InvalidArgumentError$3, UndiciError } = require_errors();
	const Dispatcher$1 = require_dispatcher();
	const Pluralizer = require_pluralizer();
	const PendingInterceptorsFormatter = require_pending_interceptors_formatter();
	var FakeWeakRef = class {
		constructor(value) {
			this.value = value;
		}
		deref() {
			return this.value;
		}
	};
	var MockAgent$1 = class extends Dispatcher$1 {
		constructor(opts) {
			super(opts);
			this[kNetConnect] = true;
			this[kIsMockActive] = true;
			if (opts && opts.agent && typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$3("Argument opts.agent must implement Agent");
			const agent = opts && opts.agent ? opts.agent : new Agent$4(opts);
			this[kAgent$1] = agent;
			this[kClients] = agent[kClients];
			this[kOptions] = buildMockOptions(opts);
		}
		get(origin) {
			let dispatcher = this[kMockAgentGet](origin);
			if (!dispatcher) {
				dispatcher = this[kFactory](origin);
				this[kMockAgentSet](origin, dispatcher);
			}
			return dispatcher;
		}
		dispatch(opts, handler$1) {
			this.get(opts.origin);
			return this[kAgent$1].dispatch(opts, handler$1);
		}
		async close() {
			await this[kAgent$1].close();
			this[kClients].clear();
		}
		deactivate() {
			this[kIsMockActive] = false;
		}
		activate() {
			this[kIsMockActive] = true;
		}
		enableNetConnect(matcher) {
			if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) if (Array.isArray(this[kNetConnect])) this[kNetConnect].push(matcher);
			else this[kNetConnect] = [matcher];
			else if (typeof matcher === "undefined") this[kNetConnect] = true;
			else throw new InvalidArgumentError$3("Unsupported matcher. Must be one of String|Function|RegExp.");
		}
		disableNetConnect() {
			this[kNetConnect] = false;
		}
		get isMockActive() {
			return this[kIsMockActive];
		}
		[kMockAgentSet](origin, dispatcher) {
			this[kClients].set(origin, new FakeWeakRef(dispatcher));
		}
		[kFactory](origin) {
			const mockOptions = Object.assign({ agent: this }, this[kOptions]);
			return this[kOptions] && this[kOptions].connections === 1 ? new MockClient$1(origin, mockOptions) : new MockPool$1(origin, mockOptions);
		}
		[kMockAgentGet](origin) {
			const ref = this[kClients].get(origin);
			if (ref) return ref.deref();
			if (typeof origin !== "string") {
				const dispatcher = this[kFactory]("http://localhost:9999");
				this[kMockAgentSet](origin, dispatcher);
				return dispatcher;
			}
			for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
				const nonExplicitDispatcher = nonExplicitRef.deref();
				if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
					const dispatcher = this[kFactory](origin);
					this[kMockAgentSet](origin, dispatcher);
					dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
					return dispatcher;
				}
			}
		}
		[kGetNetConnect]() {
			return this[kNetConnect];
		}
		pendingInterceptors() {
			const mockAgentClients = this[kClients];
			return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({
				...dispatch,
				origin
			}))).filter(({ pending }) => pending);
		}
		assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
			const pending = this.pendingInterceptors();
			if (pending.length === 0) return;
			const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
			throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
		}
	};
	module.exports = MockAgent$1;
} });

//#endregion
//#region node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({ "node_modules/undici/lib/proxy-agent.js"(exports, module) {
	const { kProxy, kClose, kDestroy, kInterceptors } = require_symbols$4();
	const { URL: URL$5 } = require("url");
	const Agent$3 = require_agent();
	const Pool$1 = require_pool();
	const DispatcherBase = require_dispatcher_base();
	const { InvalidArgumentError: InvalidArgumentError$2, RequestAbortedError } = require_errors();
	const buildConnector$1 = require_connect();
	const kAgent = Symbol("proxy agent");
	const kClient = Symbol("proxy client");
	const kProxyHeaders = Symbol("proxy headers");
	const kRequestTls = Symbol("request tls settings");
	const kProxyTls = Symbol("proxy tls settings");
	const kConnectEndpoint = Symbol("connect endpoint function");
	function defaultProtocolPort(protocol) {
		return protocol === "https:" ? 443 : 80;
	}
	function buildProxyOptions(opts) {
		if (typeof opts === "string") opts = { uri: opts };
		if (!opts || !opts.uri) throw new InvalidArgumentError$2("Proxy opts.uri is mandatory");
		return {
			uri: opts.uri,
			protocol: opts.protocol || "https"
		};
	}
	function defaultFactory(origin, opts) {
		return new Pool$1(origin, opts);
	}
	var ProxyAgent$1 = class extends DispatcherBase {
		constructor(opts) {
			super(opts);
			this[kProxy] = buildProxyOptions(opts);
			this[kAgent] = new Agent$3(opts);
			this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
			if (typeof opts === "string") opts = { uri: opts };
			if (!opts || !opts.uri) throw new InvalidArgumentError$2("Proxy opts.uri is mandatory");
			const { clientFactory = defaultFactory } = opts;
			if (typeof clientFactory !== "function") throw new InvalidArgumentError$2("Proxy opts.clientFactory must be a function.");
			this[kRequestTls] = opts.requestTls;
			this[kProxyTls] = opts.proxyTls;
			this[kProxyHeaders] = opts.headers || {};
			const resolvedUrl = new URL$5(opts.uri);
			const { origin, port, host, username, password } = resolvedUrl;
			if (opts.auth && opts.token) throw new InvalidArgumentError$2("opts.auth cannot be used in combination with opts.token");
			else if (opts.auth) this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
			else if (opts.token) this[kProxyHeaders]["proxy-authorization"] = opts.token;
			else if (username && password) this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
			const connect$2 = buildConnector$1({ ...opts.proxyTls });
			this[kConnectEndpoint] = buildConnector$1({ ...opts.requestTls });
			this[kClient] = clientFactory(resolvedUrl, { connect: connect$2 });
			this[kAgent] = new Agent$3({
				...opts,
				connect: async (opts$1, callback) => {
					let requestedHost = opts$1.host;
					if (!opts$1.port) requestedHost += `:${defaultProtocolPort(opts$1.protocol)}`;
					try {
						const { socket, statusCode } = await this[kClient].connect({
							origin,
							port,
							path: requestedHost,
							signal: opts$1.signal,
							headers: {
								...this[kProxyHeaders],
								host
							}
						});
						if (statusCode !== 200) {
							socket.on("error", () => {}).destroy();
							callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
						}
						if (opts$1.protocol !== "https:") {
							callback(null, socket);
							return;
						}
						let servername;
						if (this[kRequestTls]) servername = this[kRequestTls].servername;
						else servername = opts$1.servername;
						this[kConnectEndpoint]({
							...opts$1,
							servername,
							httpSocket: socket
						}, callback);
					} catch (err) {
						callback(err);
					}
				}
			});
		}
		dispatch(opts, handler$1) {
			const { host } = new URL$5(opts.origin);
			const headers = buildHeaders(opts.headers);
			throwIfProxyAuthIsSent(headers);
			return this[kAgent].dispatch({
				...opts,
				headers: {
					...headers,
					host
				}
			}, handler$1);
		}
		async [kClose]() {
			await this[kAgent].close();
			await this[kClient].close();
		}
		async [kDestroy]() {
			await this[kAgent].destroy();
			await this[kClient].destroy();
		}
	};
	/**
	* @param {string[] | Record<string, string>} headers
	* @returns {Record<string, string>}
	*/
	function buildHeaders(headers) {
		if (Array.isArray(headers)) {
			/** @type {Record<string, string>} */
			const headersPair = {};
			for (let i$1 = 0; i$1 < headers.length; i$1 += 2) headersPair[headers[i$1]] = headers[i$1 + 1];
			return headersPair;
		}
		return headers;
	}
	/**
	* @param {Record<string, string>} headers
	*
	* Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
	* Nevertheless, it was changed and to avoid a security vulnerability by end users
	* this check was created.
	* It should be removed in the next major version for performance reasons
	*/
	function throwIfProxyAuthIsSent(headers) {
		const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
		if (existProxyAuth) throw new InvalidArgumentError$2("Proxy-Authorization should be sent in ProxyAgent constructor");
	}
	module.exports = ProxyAgent$1;
} });

//#endregion
//#region node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({ "node_modules/undici/lib/handler/RetryHandler.js"(exports, module) {
	const assert$7 = require("assert");
	const { kRetryHandlerDefaultRetry } = require_symbols$4();
	const { RequestRetryError } = require_errors();
	const { isDisturbed: isDisturbed$1, parseHeaders, parseRangeHeader } = require_util$8();
	function calculateRetryAfterHeader(retryAfter) {
		const current = Date.now();
		const diff = new Date(retryAfter).getTime() - current;
		return diff;
	}
	var RetryHandler$1 = class RetryHandler$1 {
		constructor(opts, handlers) {
			const { retryOptions,...dispatchOpts } = opts;
			const { retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};
			this.dispatch = handlers.dispatch;
			this.handler = handlers.handler;
			this.opts = dispatchOpts;
			this.abort = null;
			this.aborted = false;
			this.retryOpts = {
				retry: retryFn ?? RetryHandler$1[kRetryHandlerDefaultRetry],
				retryAfter: retryAfter ?? true,
				maxTimeout: maxTimeout ?? 30 * 1e3,
				timeout: minTimeout ?? 500,
				timeoutFactor: timeoutFactor ?? 2,
				maxRetries: maxRetries ?? 5,
				methods: methods ?? [
					"GET",
					"HEAD",
					"OPTIONS",
					"PUT",
					"DELETE",
					"TRACE"
				],
				statusCodes: statusCodes ?? [
					500,
					502,
					503,
					504,
					429
				],
				errorCodes: errorCodes ?? [
					"ECONNRESET",
					"ECONNREFUSED",
					"ENOTFOUND",
					"ENETDOWN",
					"ENETUNREACH",
					"EHOSTDOWN",
					"EHOSTUNREACH",
					"EPIPE"
				]
			};
			this.retryCount = 0;
			this.start = 0;
			this.end = null;
			this.etag = null;
			this.resume = null;
			this.handler.onConnect((reason) => {
				this.aborted = true;
				if (this.abort) this.abort(reason);
				else this.reason = reason;
			});
		}
		onRequestSent() {
			if (this.handler.onRequestSent) this.handler.onRequestSent();
		}
		onUpgrade(statusCode, headers, socket) {
			if (this.handler.onUpgrade) this.handler.onUpgrade(statusCode, headers, socket);
		}
		onConnect(abort$1) {
			if (this.aborted) abort$1(this.reason);
			else this.abort = abort$1;
		}
		onBodySent(chunk) {
			if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
		}
		static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
			const { statusCode, code: code$1, headers } = err;
			const { method, retryOptions } = opts;
			const { maxRetries, timeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;
			let { counter, currentTimeout } = state;
			currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
			if (code$1 && code$1 !== "UND_ERR_REQ_RETRY" && code$1 !== "UND_ERR_SOCKET" && !errorCodes.includes(code$1)) {
				cb(err);
				return;
			}
			if (Array.isArray(methods) && !methods.includes(method)) {
				cb(err);
				return;
			}
			if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
				cb(err);
				return;
			}
			if (counter > maxRetries) {
				cb(err);
				return;
			}
			let retryAfterHeader = headers != null && headers["retry-after"];
			if (retryAfterHeader) {
				retryAfterHeader = Number(retryAfterHeader);
				retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
			}
			const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
			state.currentTimeout = retryTimeout;
			setTimeout(() => cb(null), retryTimeout);
		}
		onHeaders(statusCode, rawHeaders, resume$3, statusMessage) {
			const headers = parseHeaders(rawHeaders);
			this.retryCount += 1;
			if (statusCode >= 300) {
				this.abort(new RequestRetryError("Request failed", statusCode, {
					headers,
					count: this.retryCount
				}));
				return false;
			}
			if (this.resume != null) {
				this.resume = null;
				if (statusCode !== 206) return true;
				const contentRange = parseRangeHeader(headers["content-range"]);
				if (!contentRange) {
					this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				if (this.etag != null && this.etag !== headers.etag) {
					this.abort(new RequestRetryError("ETag mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				const { start, size, end = size } = contentRange;
				assert$7(this.start === start, "content-range mismatch");
				assert$7(this.end == null || this.end === end, "content-range mismatch");
				this.resume = resume$3;
				return true;
			}
			if (this.end == null) {
				if (statusCode === 206) {
					const range = parseRangeHeader(headers["content-range"]);
					if (range == null) return this.handler.onHeaders(statusCode, rawHeaders, resume$3, statusMessage);
					const { start, size, end = size } = range;
					assert$7(start != null && Number.isFinite(start) && this.start !== start, "content-range mismatch");
					assert$7(Number.isFinite(start));
					assert$7(end != null && Number.isFinite(end) && this.end !== end, "invalid content-length");
					this.start = start;
					this.end = end;
				}
				if (this.end == null) {
					const contentLength = headers["content-length"];
					this.end = contentLength != null ? Number(contentLength) : null;
				}
				assert$7(Number.isFinite(this.start));
				assert$7(this.end == null || Number.isFinite(this.end), "invalid content-length");
				this.resume = resume$3;
				this.etag = headers.etag != null ? headers.etag : null;
				return this.handler.onHeaders(statusCode, rawHeaders, resume$3, statusMessage);
			}
			const err = new RequestRetryError("Request failed", statusCode, {
				headers,
				count: this.retryCount
			});
			this.abort(err);
			return false;
		}
		onData(chunk) {
			this.start += chunk.length;
			return this.handler.onData(chunk);
		}
		onComplete(rawTrailers) {
			this.retryCount = 0;
			return this.handler.onComplete(rawTrailers);
		}
		onError(err) {
			if (this.aborted || isDisturbed$1(this.opts.body)) return this.handler.onError(err);
			this.retryOpts.retry(err, {
				state: {
					counter: this.retryCount++,
					currentTimeout: this.retryAfter
				},
				opts: {
					retryOptions: this.retryOpts,
					...this.opts
				}
			}, onRetry.bind(this));
			function onRetry(err$1) {
				if (err$1 != null || this.aborted || isDisturbed$1(this.opts.body)) return this.handler.onError(err$1);
				if (this.start !== 0) this.opts = {
					...this.opts,
					headers: {
						...this.opts.headers,
						range: `bytes=${this.start}-${this.end ?? ""}`
					}
				};
				try {
					this.dispatch(this.opts, this);
				} catch (err$2) {
					this.handler.onError(err$2);
				}
			}
		}
	};
	module.exports = RetryHandler$1;
} });

//#endregion
//#region node_modules/undici/lib/global.js
var require_global = __commonJS({ "node_modules/undici/lib/global.js"(exports, module) {
	const globalDispatcher = Symbol.for("undici.globalDispatcher.1");
	const { InvalidArgumentError: InvalidArgumentError$1 } = require_errors();
	const Agent$2 = require_agent();
	if (getGlobalDispatcher$5() === void 0) setGlobalDispatcher$1(new Agent$2());
	function setGlobalDispatcher$1(agent) {
		if (!agent || typeof agent.dispatch !== "function") throw new InvalidArgumentError$1("Argument agent must implement Agent");
		Object.defineProperty(globalThis, globalDispatcher, {
			value: agent,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	function getGlobalDispatcher$5() {
		return globalThis[globalDispatcher];
	}
	module.exports = {
		setGlobalDispatcher: setGlobalDispatcher$1,
		getGlobalDispatcher: getGlobalDispatcher$5
	};
} });

//#endregion
//#region node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({ "node_modules/undici/lib/handler/DecoratorHandler.js"(exports, module) {
	module.exports = class DecoratorHandler$1 {
		constructor(handler$1) {
			this.handler = handler$1;
		}
		onConnect(...args) {
			return this.handler.onConnect(...args);
		}
		onError(...args) {
			return this.handler.onError(...args);
		}
		onUpgrade(...args) {
			return this.handler.onUpgrade(...args);
		}
		onHeaders(...args) {
			return this.handler.onHeaders(...args);
		}
		onData(...args) {
			return this.handler.onData(...args);
		}
		onComplete(...args) {
			return this.handler.onComplete(...args);
		}
		onBodySent(...args) {
			return this.handler.onBodySent(...args);
		}
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({ "node_modules/undici/lib/fetch/headers.js"(exports, module) {
	const { kHeadersList: kHeadersList$5, kConstruct: kConstruct$4 } = require_symbols$4();
	const { kGuard: kGuard$4 } = require_symbols$3();
	const { kEnumerableProperty: kEnumerableProperty$7 } = require_util$8();
	const { makeIterator, isValidHeaderName: isValidHeaderName$1, isValidHeaderValue } = require_util$7();
	const util$9 = require("util");
	const { webidl: webidl$10 } = require_webidl();
	const assert$6 = require("assert");
	const kHeadersMap = Symbol("headers map");
	const kHeadersSortedMap = Symbol("headers map sorted");
	/**
	* @param {number} code
	*/
	function isHTTPWhiteSpaceCharCode(code$1) {
		return code$1 === 10 || code$1 === 13 || code$1 === 9 || code$1 === 32;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
	* @param {string} potentialValue
	*/
	function headerValueNormalize(potentialValue) {
		let i$1 = 0;
		let j = potentialValue.length;
		while (j > i$1 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
		while (j > i$1 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i$1))) ++i$1;
		return i$1 === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i$1, j);
	}
	function fill$1(headers, object) {
		if (Array.isArray(object)) for (let i$1 = 0; i$1 < object.length; ++i$1) {
			const header = object[i$1];
			if (header.length !== 2) throw webidl$10.errors.exception({
				header: "Headers constructor",
				message: `expected name/value pair to be length 2, found ${header.length}.`
			});
			appendHeader(headers, header[0], header[1]);
		}
		else if (typeof object === "object" && object !== null) {
			const keys = Object.keys(object);
			for (let i$1 = 0; i$1 < keys.length; ++i$1) appendHeader(headers, keys[i$1], object[keys[i$1]]);
		} else throw webidl$10.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-headers-append
	*/
	function appendHeader(headers, name, value) {
		value = headerValueNormalize(value);
		if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
			prefix: "Headers.append",
			value: name,
			type: "header name"
		});
		else if (!isValidHeaderValue(value)) throw webidl$10.errors.invalidArgument({
			prefix: "Headers.append",
			value,
			type: "header value"
		});
		if (headers[kGuard$4] === "immutable") throw new TypeError("immutable");
		else if (headers[kGuard$4] === "request-no-cors") {}
		return headers[kHeadersList$5].append(name, value);
	}
	var HeadersList$2 = class HeadersList$2 {
		/** @type {[string, string][]|null} */
		cookies = null;
		constructor(init$1) {
			if (init$1 instanceof HeadersList$2) {
				this[kHeadersMap] = new Map(init$1[kHeadersMap]);
				this[kHeadersSortedMap] = init$1[kHeadersSortedMap];
				this.cookies = init$1.cookies === null ? null : [...init$1.cookies];
			} else {
				this[kHeadersMap] = new Map(init$1);
				this[kHeadersSortedMap] = null;
			}
		}
		contains(name) {
			name = name.toLowerCase();
			return this[kHeadersMap].has(name);
		}
		clear() {
			this[kHeadersMap].clear();
			this[kHeadersSortedMap] = null;
			this.cookies = null;
		}
		append(name, value) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			const exists$1 = this[kHeadersMap].get(lowercaseName);
			if (exists$1) {
				const delimiter = lowercaseName === "cookie" ? "; " : ", ";
				this[kHeadersMap].set(lowercaseName, {
					name: exists$1.name,
					value: `${exists$1.value}${delimiter}${value}`
				});
			} else this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
			if (lowercaseName === "set-cookie") {
				this.cookies ??= [];
				this.cookies.push(value);
			}
		}
		set(name, value) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			if (lowercaseName === "set-cookie") this.cookies = [value];
			this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
		}
		delete(name) {
			this[kHeadersSortedMap] = null;
			name = name.toLowerCase();
			if (name === "set-cookie") this.cookies = null;
			this[kHeadersMap].delete(name);
		}
		get(name) {
			const value = this[kHeadersMap].get(name.toLowerCase());
			return value === void 0 ? null : value.value;
		}
		*[Symbol.iterator]() {
			for (const [name, { value }] of this[kHeadersMap]) yield [name, value];
		}
		get entries() {
			const headers = {};
			if (this[kHeadersMap].size) for (const { name, value } of this[kHeadersMap].values()) headers[name] = value;
			return headers;
		}
	};
	var Headers$8 = class Headers$8 {
		constructor(init$1 = void 0) {
			if (init$1 === kConstruct$4) return;
			this[kHeadersList$5] = new HeadersList$2();
			this[kGuard$4] = "none";
			if (init$1 !== void 0) {
				init$1 = webidl$10.converters.HeadersInit(init$1);
				fill$1(this, init$1);
			}
		}
		append(name, value) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
			name = webidl$10.converters.ByteString(name);
			value = webidl$10.converters.ByteString(value);
			return appendHeader(this, name, value);
		}
		delete(name) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.delete",
				value: name,
				type: "header name"
			});
			if (this[kGuard$4] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard$4] === "request-no-cors") {}
			if (!this[kHeadersList$5].contains(name)) return;
			this[kHeadersList$5].delete(name);
		}
		get(name) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.get",
				value: name,
				type: "header name"
			});
			return this[kHeadersList$5].get(name);
		}
		has(name) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.has",
				value: name,
				type: "header name"
			});
			return this[kHeadersList$5].contains(name);
		}
		set(name, value) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
			name = webidl$10.converters.ByteString(name);
			value = webidl$10.converters.ByteString(value);
			value = headerValueNormalize(value);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.set",
				value: name,
				type: "header name"
			});
			else if (!isValidHeaderValue(value)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.set",
				value,
				type: "header value"
			});
			if (this[kGuard$4] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard$4] === "request-no-cors") {}
			this[kHeadersList$5].set(name, value);
		}
		getSetCookie() {
			webidl$10.brandCheck(this, Headers$8);
			const list = this[kHeadersList$5].cookies;
			if (list) return [...list];
			return [];
		}
		get [kHeadersSortedMap]() {
			if (this[kHeadersList$5][kHeadersSortedMap]) return this[kHeadersList$5][kHeadersSortedMap];
			const headers = [];
			const names = [...this[kHeadersList$5]].sort((a$1, b) => a$1[0] < b[0] ? -1 : 1);
			const cookies = this[kHeadersList$5].cookies;
			for (let i$1 = 0; i$1 < names.length; ++i$1) {
				const [name, value] = names[i$1];
				if (name === "set-cookie") for (let j = 0; j < cookies.length; ++j) headers.push([name, cookies[j]]);
				else {
					assert$6(value !== null);
					headers.push([name, value]);
				}
			}
			this[kHeadersList$5][kHeadersSortedMap] = headers;
			return headers;
		}
		keys() {
			webidl$10.brandCheck(this, Headers$8);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "key");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
		}
		values() {
			webidl$10.brandCheck(this, Headers$8);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
		}
		entries() {
			webidl$10.brandCheck(this, Headers$8);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "key+value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
		}
		/**
		* @param {(value: string, key: string, self: Headers) => void} callbackFn
		* @param {unknown} thisArg
		*/
		forEach(callbackFn, thisArg = globalThis) {
			webidl$10.brandCheck(this, Headers$8);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
			for (const [key, value] of this) callbackFn.apply(thisArg, [
				value,
				key,
				this
			]);
		}
		[Symbol.for("nodejs.util.inspect.custom")]() {
			webidl$10.brandCheck(this, Headers$8);
			return this[kHeadersList$5];
		}
	};
	Headers$8.prototype[Symbol.iterator] = Headers$8.prototype.entries;
	Object.defineProperties(Headers$8.prototype, {
		append: kEnumerableProperty$7,
		delete: kEnumerableProperty$7,
		get: kEnumerableProperty$7,
		has: kEnumerableProperty$7,
		set: kEnumerableProperty$7,
		getSetCookie: kEnumerableProperty$7,
		keys: kEnumerableProperty$7,
		values: kEnumerableProperty$7,
		entries: kEnumerableProperty$7,
		forEach: kEnumerableProperty$7,
		[Symbol.iterator]: { enumerable: false },
		[Symbol.toStringTag]: {
			value: "Headers",
			configurable: true
		},
		[util$9.inspect.custom]: { enumerable: false }
	});
	webidl$10.converters.HeadersInit = function(V) {
		if (webidl$10.util.Type(V) === "Object") {
			if (V[Symbol.iterator]) return webidl$10.converters["sequence<sequence<ByteString>>"](V);
			return webidl$10.converters["record<ByteString, ByteString>"](V);
		}
		throw webidl$10.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	};
	module.exports = {
		fill: fill$1,
		Headers: Headers$8,
		HeadersList: HeadersList$2
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({ "node_modules/undici/lib/fetch/response.js"(exports, module) {
	const { Headers: Headers$7, HeadersList: HeadersList$1, fill } = require_headers();
	const { extractBody: extractBody$1, cloneBody: cloneBody$1, mixinBody: mixinBody$1 } = require_body();
	const util$8 = require_util$8();
	const { kEnumerableProperty: kEnumerableProperty$6 } = util$8;
	const { isValidReasonPhrase, isCancelled: isCancelled$1, isAborted: isAborted$1, isBlobLike: isBlobLike$2, serializeJavascriptValueToJSONString, isErrorLike: isErrorLike$1, isomorphicEncode: isomorphicEncode$1 } = require_util$7();
	const { redirectStatusSet: redirectStatusSet$1, nullBodyStatus: nullBodyStatus$1, DOMException: DOMException$4 } = require_constants$4();
	const { kState: kState$6, kHeaders: kHeaders$3, kGuard: kGuard$3, kRealm: kRealm$3 } = require_symbols$3();
	const { webidl: webidl$9 } = require_webidl();
	const { FormData: FormData$1 } = require_formdata();
	const { getGlobalOrigin: getGlobalOrigin$2 } = require_global$1();
	const { URLSerializer: URLSerializer$3 } = require_dataURL();
	const { kHeadersList: kHeadersList$4, kConstruct: kConstruct$3 } = require_symbols$4();
	const assert$5 = require("assert");
	const { types: types$2 } = require("util");
	const ReadableStream$1 = globalThis.ReadableStream || require("stream/web").ReadableStream;
	const textEncoder = new TextEncoder("utf-8");
	var Response$4 = class Response$4 {
		static error() {
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response$4();
			responseObject[kState$6] = makeNetworkError$1();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kHeadersList$4] = responseObject[kState$6].headersList;
			responseObject[kHeaders$3][kGuard$3] = "immutable";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			return responseObject;
		}
		static json(data, init$1 = {}) {
			webidl$9.argumentLengthCheck(arguments, 1, { header: "Response.json" });
			if (init$1 !== null) init$1 = webidl$9.converters.ResponseInit(init$1);
			const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
			const body = extractBody$1(bytes);
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response$4();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kGuard$3] = "response";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			initializeResponse(responseObject, init$1, {
				body: body[0],
				type: "application/json"
			});
			return responseObject;
		}
		static redirect(url, status = 302) {
			const relevantRealm = { settingsObject: {} };
			webidl$9.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
			url = webidl$9.converters.USVString(url);
			status = webidl$9.converters["unsigned short"](status);
			let parsedURL;
			try {
				parsedURL = new URL(url, getGlobalOrigin$2());
			} catch (err) {
				throw Object.assign(new TypeError("Failed to parse URL from " + url), { cause: err });
			}
			if (!redirectStatusSet$1.has(status)) throw new RangeError("Invalid status code " + status);
			const responseObject = new Response$4();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kGuard$3] = "immutable";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			responseObject[kState$6].status = status;
			const value = isomorphicEncode$1(URLSerializer$3(parsedURL));
			responseObject[kState$6].headersList.append("location", value);
			return responseObject;
		}
		constructor(body = null, init$1 = {}) {
			if (body !== null) body = webidl$9.converters.BodyInit(body);
			init$1 = webidl$9.converters.ResponseInit(init$1);
			this[kRealm$3] = { settingsObject: {} };
			this[kState$6] = makeResponse$1({});
			this[kHeaders$3] = new Headers$7(kConstruct$3);
			this[kHeaders$3][kGuard$3] = "response";
			this[kHeaders$3][kHeadersList$4] = this[kState$6].headersList;
			this[kHeaders$3][kRealm$3] = this[kRealm$3];
			let bodyWithType = null;
			if (body != null) {
				const [extractedBody, type] = extractBody$1(body);
				bodyWithType = {
					body: extractedBody,
					type
				};
			}
			initializeResponse(this, init$1, bodyWithType);
		}
		get type() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].type;
		}
		get url() {
			webidl$9.brandCheck(this, Response$4);
			const urlList = this[kState$6].urlList;
			const url = urlList[urlList.length - 1] ?? null;
			if (url === null) return "";
			return URLSerializer$3(url, true);
		}
		get redirected() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].urlList.length > 1;
		}
		get status() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].status;
		}
		get ok() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].status >= 200 && this[kState$6].status <= 299;
		}
		get statusText() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].statusText;
		}
		get headers() {
			webidl$9.brandCheck(this, Response$4);
			return this[kHeaders$3];
		}
		get body() {
			webidl$9.brandCheck(this, Response$4);
			return this[kState$6].body ? this[kState$6].body.stream : null;
		}
		get bodyUsed() {
			webidl$9.brandCheck(this, Response$4);
			return !!this[kState$6].body && util$8.isDisturbed(this[kState$6].body.stream);
		}
		clone() {
			webidl$9.brandCheck(this, Response$4);
			if (this.bodyUsed || this.body && this.body.locked) throw webidl$9.errors.exception({
				header: "Response.clone",
				message: "Body has already been consumed."
			});
			const clonedResponse = cloneResponse$1(this[kState$6]);
			const clonedResponseObject = new Response$4();
			clonedResponseObject[kState$6] = clonedResponse;
			clonedResponseObject[kRealm$3] = this[kRealm$3];
			clonedResponseObject[kHeaders$3][kHeadersList$4] = clonedResponse.headersList;
			clonedResponseObject[kHeaders$3][kGuard$3] = this[kHeaders$3][kGuard$3];
			clonedResponseObject[kHeaders$3][kRealm$3] = this[kHeaders$3][kRealm$3];
			return clonedResponseObject;
		}
	};
	mixinBody$1(Response$4);
	Object.defineProperties(Response$4.prototype, {
		type: kEnumerableProperty$6,
		url: kEnumerableProperty$6,
		status: kEnumerableProperty$6,
		ok: kEnumerableProperty$6,
		redirected: kEnumerableProperty$6,
		statusText: kEnumerableProperty$6,
		headers: kEnumerableProperty$6,
		clone: kEnumerableProperty$6,
		body: kEnumerableProperty$6,
		bodyUsed: kEnumerableProperty$6,
		[Symbol.toStringTag]: {
			value: "Response",
			configurable: true
		}
	});
	Object.defineProperties(Response$4, {
		json: kEnumerableProperty$6,
		redirect: kEnumerableProperty$6,
		error: kEnumerableProperty$6
	});
	function cloneResponse$1(response) {
		if (response.internalResponse) return filterResponse$1(cloneResponse$1(response.internalResponse), response.type);
		const newResponse = makeResponse$1({
			...response,
			body: null
		});
		if (response.body != null) newResponse.body = cloneBody$1(response.body);
		return newResponse;
	}
	function makeResponse$1(init$1) {
		return {
			aborted: false,
			rangeRequested: false,
			timingAllowPassed: false,
			requestIncludesCredentials: false,
			type: "default",
			status: 200,
			timingInfo: null,
			cacheState: "",
			statusText: "",
			...init$1,
			headersList: init$1.headersList ? new HeadersList$1(init$1.headersList) : new HeadersList$1(),
			urlList: init$1.urlList ? [...init$1.urlList] : []
		};
	}
	function makeNetworkError$1(reason) {
		const isError = isErrorLike$1(reason);
		return makeResponse$1({
			type: "error",
			status: 0,
			error: isError ? reason : new Error(reason ? String(reason) : reason),
			aborted: reason && reason.name === "AbortError"
		});
	}
	function makeFilteredResponse(response, state) {
		state = {
			internalResponse: response,
			...state
		};
		return new Proxy(response, {
			get(target, p) {
				return p in state ? state[p] : target[p];
			},
			set(target, p, value) {
				assert$5(!(p in state));
				target[p] = value;
				return true;
			}
		});
	}
	function filterResponse$1(response, type) {
		if (type === "basic") return makeFilteredResponse(response, {
			type: "basic",
			headersList: response.headersList
		});
		else if (type === "cors") return makeFilteredResponse(response, {
			type: "cors",
			headersList: response.headersList
		});
		else if (type === "opaque") return makeFilteredResponse(response, {
			type: "opaque",
			urlList: Object.freeze([]),
			status: 0,
			statusText: "",
			body: null
		});
		else if (type === "opaqueredirect") return makeFilteredResponse(response, {
			type: "opaqueredirect",
			status: 0,
			statusText: "",
			headersList: [],
			body: null
		});
		else assert$5(false);
	}
	function makeAppropriateNetworkError$1(fetchParams, err = null) {
		assert$5(isCancelled$1(fetchParams));
		return isAborted$1(fetchParams) ? makeNetworkError$1(Object.assign(new DOMException$4("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError$1(Object.assign(new DOMException$4("Request was cancelled."), { cause: err }));
	}
	function initializeResponse(response, init$1, body) {
		if (init$1.status !== null && (init$1.status < 200 || init$1.status > 599)) throw new RangeError("init[\"status\"] must be in the range of 200 to 599, inclusive.");
		if ("statusText" in init$1 && init$1.statusText != null) {
			if (!isValidReasonPhrase(String(init$1.statusText))) throw new TypeError("Invalid statusText");
		}
		if ("status" in init$1 && init$1.status != null) response[kState$6].status = init$1.status;
		if ("statusText" in init$1 && init$1.statusText != null) response[kState$6].statusText = init$1.statusText;
		if ("headers" in init$1 && init$1.headers != null) fill(response[kHeaders$3], init$1.headers);
		if (body) {
			if (nullBodyStatus$1.includes(response.status)) throw webidl$9.errors.exception({
				header: "Response constructor",
				message: "Invalid response status code " + response.status
			});
			response[kState$6].body = body.body;
			if (body.type != null && !response[kState$6].headersList.contains("Content-Type")) response[kState$6].headersList.append("content-type", body.type);
		}
	}
	webidl$9.converters.ReadableStream = webidl$9.interfaceConverter(ReadableStream$1);
	webidl$9.converters.FormData = webidl$9.interfaceConverter(FormData$1);
	webidl$9.converters.URLSearchParams = webidl$9.interfaceConverter(URLSearchParams);
	webidl$9.converters.XMLHttpRequestBodyInit = function(V) {
		if (typeof V === "string") return webidl$9.converters.USVString(V);
		if (isBlobLike$2(V)) return webidl$9.converters.Blob(V, { strict: false });
		if (types$2.isArrayBuffer(V) || types$2.isTypedArray(V) || types$2.isDataView(V)) return webidl$9.converters.BufferSource(V);
		if (util$8.isFormDataLike(V)) return webidl$9.converters.FormData(V, { strict: false });
		if (V instanceof URLSearchParams) return webidl$9.converters.URLSearchParams(V);
		return webidl$9.converters.DOMString(V);
	};
	webidl$9.converters.BodyInit = function(V) {
		if (V instanceof ReadableStream$1) return webidl$9.converters.ReadableStream(V);
		if (V?.[Symbol.asyncIterator]) return V;
		return webidl$9.converters.XMLHttpRequestBodyInit(V);
	};
	webidl$9.converters.ResponseInit = webidl$9.dictionaryConverter([
		{
			key: "status",
			converter: webidl$9.converters["unsigned short"],
			defaultValue: 200
		},
		{
			key: "statusText",
			converter: webidl$9.converters.ByteString,
			defaultValue: ""
		},
		{
			key: "headers",
			converter: webidl$9.converters.HeadersInit
		}
	]);
	module.exports = {
		makeNetworkError: makeNetworkError$1,
		makeResponse: makeResponse$1,
		makeAppropriateNetworkError: makeAppropriateNetworkError$1,
		filterResponse: filterResponse$1,
		Response: Response$4,
		cloneResponse: cloneResponse$1
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/request.js
var require_request = __commonJS({ "node_modules/undici/lib/fetch/request.js"(exports, module) {
	const { extractBody, mixinBody, cloneBody } = require_body();
	const { Headers: Headers$6, fill: fillHeaders, HeadersList } = require_headers();
	const { FinalizationRegistry } = require_dispatcher_weakref()();
	const util$7 = require_util$8();
	const { isValidHTTPToken, sameOrigin: sameOrigin$1, normalizeMethod, makePolicyContainer: makePolicyContainer$1, normalizeMethodRecord } = require_util$7();
	const { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = require_constants$4();
	const { kEnumerableProperty: kEnumerableProperty$5 } = util$7;
	const { kHeaders: kHeaders$2, kSignal, kState: kState$5, kGuard: kGuard$2, kRealm: kRealm$2 } = require_symbols$3();
	const { webidl: webidl$8 } = require_webidl();
	const { getGlobalOrigin: getGlobalOrigin$1 } = require_global$1();
	const { URLSerializer: URLSerializer$2 } = require_dataURL();
	const { kHeadersList: kHeadersList$3, kConstruct: kConstruct$2 } = require_symbols$4();
	const assert$4 = require("assert");
	const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require("events");
	let TransformStream$1 = globalThis.TransformStream;
	const kAbortController = Symbol("abortController");
	const requestFinalizer = new FinalizationRegistry(({ signal, abort: abort$1 }) => {
		signal.removeEventListener("abort", abort$1);
	});
	var Request$3 = class Request$3 {
		constructor(input, init$1 = {}) {
			if (input === kConstruct$2) return;
			webidl$8.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
			input = webidl$8.converters.RequestInfo(input);
			init$1 = webidl$8.converters.RequestInit(init$1);
			this[kRealm$2] = { settingsObject: {
				baseUrl: getGlobalOrigin$1(),
				get origin() {
					return this.baseUrl?.origin;
				},
				policyContainer: makePolicyContainer$1()
			} };
			let request$3 = null;
			let fallbackMode = null;
			const baseUrl$1 = this[kRealm$2].settingsObject.baseUrl;
			let signal = null;
			if (typeof input === "string") {
				let parsedURL;
				try {
					parsedURL = new URL(input, baseUrl$1);
				} catch (err) {
					throw new TypeError("Failed to parse URL from " + input, { cause: err });
				}
				if (parsedURL.username || parsedURL.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
				request$3 = makeRequest$2({ urlList: [parsedURL] });
				fallbackMode = "cors";
			} else {
				assert$4(input instanceof Request$3);
				request$3 = input[kState$5];
				signal = input[kSignal];
			}
			const origin = this[kRealm$2].settingsObject.origin;
			let window$1 = "client";
			if (request$3.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin$1(request$3.window, origin)) window$1 = request$3.window;
			if (init$1.window != null) throw new TypeError(`'window' option '${window$1}' must be null`);
			if ("window" in init$1) window$1 = "no-window";
			request$3 = makeRequest$2({
				method: request$3.method,
				headersList: request$3.headersList,
				unsafeRequest: request$3.unsafeRequest,
				client: this[kRealm$2].settingsObject,
				window: window$1,
				priority: request$3.priority,
				origin: request$3.origin,
				referrer: request$3.referrer,
				referrerPolicy: request$3.referrerPolicy,
				mode: request$3.mode,
				credentials: request$3.credentials,
				cache: request$3.cache,
				redirect: request$3.redirect,
				integrity: request$3.integrity,
				keepalive: request$3.keepalive,
				reloadNavigation: request$3.reloadNavigation,
				historyNavigation: request$3.historyNavigation,
				urlList: [...request$3.urlList]
			});
			const initHasKey = Object.keys(init$1).length !== 0;
			if (initHasKey) {
				if (request$3.mode === "navigate") request$3.mode = "same-origin";
				request$3.reloadNavigation = false;
				request$3.historyNavigation = false;
				request$3.origin = "client";
				request$3.referrer = "client";
				request$3.referrerPolicy = "";
				request$3.url = request$3.urlList[request$3.urlList.length - 1];
				request$3.urlList = [request$3.url];
			}
			if (init$1.referrer !== void 0) {
				const referrer = init$1.referrer;
				if (referrer === "") request$3.referrer = "no-referrer";
				else {
					let parsedReferrer;
					try {
						parsedReferrer = new URL(referrer, baseUrl$1);
					} catch (err) {
						throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
					}
					if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin$1(parsedReferrer, this[kRealm$2].settingsObject.baseUrl)) request$3.referrer = "client";
					else request$3.referrer = parsedReferrer;
				}
			}
			if (init$1.referrerPolicy !== void 0) request$3.referrerPolicy = init$1.referrerPolicy;
			let mode;
			if (init$1.mode !== void 0) mode = init$1.mode;
			else mode = fallbackMode;
			if (mode === "navigate") throw webidl$8.errors.exception({
				header: "Request constructor",
				message: "invalid request mode navigate."
			});
			if (mode != null) request$3.mode = mode;
			if (init$1.credentials !== void 0) request$3.credentials = init$1.credentials;
			if (init$1.cache !== void 0) request$3.cache = init$1.cache;
			if (request$3.cache === "only-if-cached" && request$3.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
			if (init$1.redirect !== void 0) request$3.redirect = init$1.redirect;
			if (init$1.integrity != null) request$3.integrity = String(init$1.integrity);
			if (init$1.keepalive !== void 0) request$3.keepalive = Boolean(init$1.keepalive);
			if (init$1.method !== void 0) {
				let method = init$1.method;
				if (!isValidHTTPToken(method)) throw new TypeError(`'${method}' is not a valid HTTP method.`);
				if (forbiddenMethodsSet.has(method.toUpperCase())) throw new TypeError(`'${method}' HTTP method is unsupported.`);
				method = normalizeMethodRecord[method] ?? normalizeMethod(method);
				request$3.method = method;
			}
			if (init$1.signal !== void 0) signal = init$1.signal;
			this[kState$5] = request$3;
			const ac = new AbortController();
			this[kSignal] = ac.signal;
			this[kSignal][kRealm$2] = this[kRealm$2];
			if (signal != null) {
				if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
				if (signal.aborted) ac.abort(signal.reason);
				else {
					this[kAbortController] = ac;
					const acRef = new WeakRef(ac);
					const abort$1 = function() {
						const ac$1 = acRef.deref();
						if (ac$1 !== void 0) ac$1.abort(this.reason);
					};
					try {
						if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) setMaxListeners(100, signal);
						else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) setMaxListeners(100, signal);
					} catch {}
					util$7.addAbortListener(signal, abort$1);
					requestFinalizer.register(ac, {
						signal,
						abort: abort$1
					});
				}
			}
			this[kHeaders$2] = new Headers$6(kConstruct$2);
			this[kHeaders$2][kHeadersList$3] = request$3.headersList;
			this[kHeaders$2][kGuard$2] = "request";
			this[kHeaders$2][kRealm$2] = this[kRealm$2];
			if (mode === "no-cors") {
				if (!corsSafeListedMethodsSet.has(request$3.method)) throw new TypeError(`'${request$3.method} is unsupported in no-cors mode.`);
				this[kHeaders$2][kGuard$2] = "request-no-cors";
			}
			if (initHasKey) {
				/** @type {HeadersList} */
				const headersList = this[kHeaders$2][kHeadersList$3];
				const headers = init$1.headers !== void 0 ? init$1.headers : new HeadersList(headersList);
				headersList.clear();
				if (headers instanceof HeadersList) {
					for (const [key, val] of headers) headersList.append(key, val);
					headersList.cookies = headers.cookies;
				} else fillHeaders(this[kHeaders$2], headers);
			}
			const inputBody = input instanceof Request$3 ? input[kState$5].body : null;
			if ((init$1.body != null || inputBody != null) && (request$3.method === "GET" || request$3.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
			let initBody = null;
			if (init$1.body != null) {
				const [extractedBody, contentType] = extractBody(init$1.body, request$3.keepalive);
				initBody = extractedBody;
				if (contentType && !this[kHeaders$2][kHeadersList$3].contains("content-type")) this[kHeaders$2].append("content-type", contentType);
			}
			const inputOrInitBody = initBody ?? inputBody;
			if (inputOrInitBody != null && inputOrInitBody.source == null) {
				if (initBody != null && init$1.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
				if (request$3.mode !== "same-origin" && request$3.mode !== "cors") throw new TypeError("If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"");
				request$3.useCORSPreflightFlag = true;
			}
			let finalBody = inputOrInitBody;
			if (initBody == null && inputBody != null) {
				if (util$7.isDisturbed(inputBody.stream) || inputBody.stream.locked) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
				if (!TransformStream$1) TransformStream$1 = require("stream/web").TransformStream;
				const identityTransform = new TransformStream$1();
				inputBody.stream.pipeThrough(identityTransform);
				finalBody = {
					source: inputBody.source,
					length: inputBody.length,
					stream: identityTransform.readable
				};
			}
			this[kState$5].body = finalBody;
		}
		get method() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].method;
		}
		get url() {
			webidl$8.brandCheck(this, Request$3);
			return URLSerializer$2(this[kState$5].url);
		}
		get headers() {
			webidl$8.brandCheck(this, Request$3);
			return this[kHeaders$2];
		}
		get destination() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].destination;
		}
		get referrer() {
			webidl$8.brandCheck(this, Request$3);
			if (this[kState$5].referrer === "no-referrer") return "";
			if (this[kState$5].referrer === "client") return "about:client";
			return this[kState$5].referrer.toString();
		}
		get referrerPolicy() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].referrerPolicy;
		}
		get mode() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].mode;
		}
		get credentials() {
			return this[kState$5].credentials;
		}
		get cache() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].cache;
		}
		get redirect() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].redirect;
		}
		get integrity() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].integrity;
		}
		get keepalive() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].keepalive;
		}
		get isReloadNavigation() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].reloadNavigation;
		}
		get isHistoryNavigation() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].historyNavigation;
		}
		get signal() {
			webidl$8.brandCheck(this, Request$3);
			return this[kSignal];
		}
		get body() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].body ? this[kState$5].body.stream : null;
		}
		get bodyUsed() {
			webidl$8.brandCheck(this, Request$3);
			return !!this[kState$5].body && util$7.isDisturbed(this[kState$5].body.stream);
		}
		get duplex() {
			webidl$8.brandCheck(this, Request$3);
			return "half";
		}
		clone() {
			webidl$8.brandCheck(this, Request$3);
			if (this.bodyUsed || this.body?.locked) throw new TypeError("unusable");
			const clonedRequest = cloneRequest(this[kState$5]);
			const clonedRequestObject = new Request$3(kConstruct$2);
			clonedRequestObject[kState$5] = clonedRequest;
			clonedRequestObject[kRealm$2] = this[kRealm$2];
			clonedRequestObject[kHeaders$2] = new Headers$6(kConstruct$2);
			clonedRequestObject[kHeaders$2][kHeadersList$3] = clonedRequest.headersList;
			clonedRequestObject[kHeaders$2][kGuard$2] = this[kHeaders$2][kGuard$2];
			clonedRequestObject[kHeaders$2][kRealm$2] = this[kHeaders$2][kRealm$2];
			const ac = new AbortController();
			if (this.signal.aborted) ac.abort(this.signal.reason);
			else util$7.addAbortListener(this.signal, () => {
				ac.abort(this.signal.reason);
			});
			clonedRequestObject[kSignal] = ac.signal;
			return clonedRequestObject;
		}
	};
	mixinBody(Request$3);
	function makeRequest$2(init$1) {
		const request$3 = {
			method: "GET",
			localURLsOnly: false,
			unsafeRequest: false,
			body: null,
			client: null,
			reservedClient: null,
			replacesClientId: "",
			window: "client",
			keepalive: false,
			serviceWorkers: "all",
			initiator: "",
			destination: "",
			priority: null,
			origin: "client",
			policyContainer: "client",
			referrer: "client",
			referrerPolicy: "",
			mode: "no-cors",
			useCORSPreflightFlag: false,
			credentials: "same-origin",
			useCredentials: false,
			cache: "default",
			redirect: "follow",
			integrity: "",
			cryptoGraphicsNonceMetadata: "",
			parserMetadata: "",
			reloadNavigation: false,
			historyNavigation: false,
			userActivation: false,
			taintedOrigin: false,
			redirectCount: 0,
			responseTainting: "basic",
			preventNoCacheCacheControlHeaderModification: false,
			done: false,
			timingAllowFailed: false,
			...init$1,
			headersList: init$1.headersList ? new HeadersList(init$1.headersList) : new HeadersList()
		};
		request$3.url = request$3.urlList[0];
		return request$3;
	}
	function cloneRequest(request$3) {
		const newRequest = makeRequest$2({
			...request$3,
			body: null
		});
		if (request$3.body != null) newRequest.body = cloneBody(request$3.body);
		return newRequest;
	}
	Object.defineProperties(Request$3.prototype, {
		method: kEnumerableProperty$5,
		url: kEnumerableProperty$5,
		headers: kEnumerableProperty$5,
		redirect: kEnumerableProperty$5,
		clone: kEnumerableProperty$5,
		signal: kEnumerableProperty$5,
		duplex: kEnumerableProperty$5,
		destination: kEnumerableProperty$5,
		body: kEnumerableProperty$5,
		bodyUsed: kEnumerableProperty$5,
		isHistoryNavigation: kEnumerableProperty$5,
		isReloadNavigation: kEnumerableProperty$5,
		keepalive: kEnumerableProperty$5,
		integrity: kEnumerableProperty$5,
		cache: kEnumerableProperty$5,
		credentials: kEnumerableProperty$5,
		attribute: kEnumerableProperty$5,
		referrerPolicy: kEnumerableProperty$5,
		referrer: kEnumerableProperty$5,
		mode: kEnumerableProperty$5,
		[Symbol.toStringTag]: {
			value: "Request",
			configurable: true
		}
	});
	webidl$8.converters.Request = webidl$8.interfaceConverter(Request$3);
	webidl$8.converters.RequestInfo = function(V) {
		if (typeof V === "string") return webidl$8.converters.USVString(V);
		if (V instanceof Request$3) return webidl$8.converters.Request(V);
		return webidl$8.converters.USVString(V);
	};
	webidl$8.converters.AbortSignal = webidl$8.interfaceConverter(AbortSignal);
	webidl$8.converters.RequestInit = webidl$8.dictionaryConverter([
		{
			key: "method",
			converter: webidl$8.converters.ByteString
		},
		{
			key: "headers",
			converter: webidl$8.converters.HeadersInit
		},
		{
			key: "body",
			converter: webidl$8.nullableConverter(webidl$8.converters.BodyInit)
		},
		{
			key: "referrer",
			converter: webidl$8.converters.USVString
		},
		{
			key: "referrerPolicy",
			converter: webidl$8.converters.DOMString,
			allowedValues: referrerPolicy
		},
		{
			key: "mode",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestMode
		},
		{
			key: "credentials",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestCredentials
		},
		{
			key: "cache",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestCache
		},
		{
			key: "redirect",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestRedirect
		},
		{
			key: "integrity",
			converter: webidl$8.converters.DOMString
		},
		{
			key: "keepalive",
			converter: webidl$8.converters.boolean
		},
		{
			key: "signal",
			converter: webidl$8.nullableConverter((signal) => webidl$8.converters.AbortSignal(signal, { strict: false }))
		},
		{
			key: "window",
			converter: webidl$8.converters.any
		},
		{
			key: "duplex",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestDuplex
		}
	]);
	module.exports = {
		Request: Request$3,
		makeRequest: makeRequest$2
	};
} });

//#endregion
//#region node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({ "node_modules/undici/lib/fetch/index.js"(exports, module) {
	const { Response: Response$3, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = require_response();
	const { Headers: Headers$5 } = require_headers();
	const { Request: Request$2, makeRequest: makeRequest$1 } = require_request();
	const zlib$2 = require("zlib");
	const { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise: createDeferredPromise$1, isBlobLike: isBlobLike$1, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme: urlIsHttpHttpsScheme$1, urlHasHttpsScheme } = require_util$7();
	const { kState: kState$4, kHeaders: kHeaders$1, kGuard: kGuard$1, kRealm: kRealm$1 } = require_symbols$3();
	const assert$3 = require("assert");
	const { safelyExtractBody } = require_body();
	const { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet, DOMException: DOMException$3 } = require_constants$4();
	const { kHeadersList: kHeadersList$2 } = require_symbols$4();
	const EE = require("events");
	const { Readable: Readable$2, pipeline } = require("stream");
	const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util$8();
	const { dataURLProcessor, serializeAMimeType: serializeAMimeType$1 } = require_dataURL();
	const { TransformStream } = require("stream/web");
	const { getGlobalDispatcher: getGlobalDispatcher$4 } = require_global();
	const { webidl: webidl$7 } = require_webidl();
	const { STATUS_CODES: STATUS_CODES$1 } = require("http");
	const GET_OR_HEAD = ["GET", "HEAD"];
	/** @type {import('buffer').resolveObjectURL} */
	let resolveObjectURL;
	let ReadableStream = globalThis.ReadableStream;
	var Fetch = class extends EE {
		constructor(dispatcher) {
			super();
			this.dispatcher = dispatcher;
			this.connection = null;
			this.dump = false;
			this.state = "ongoing";
			this.setMaxListeners(21);
		}
		terminate(reason) {
			if (this.state !== "ongoing") return;
			this.state = "terminated";
			this.connection?.destroy(reason);
			this.emit("terminated", reason);
		}
		abort(error$1) {
			if (this.state !== "ongoing") return;
			this.state = "aborted";
			if (!error$1) error$1 = new DOMException$3("The operation was aborted.", "AbortError");
			this.serializedAbortReason = error$1;
			this.connection?.destroy(error$1);
			this.emit("terminated", error$1);
		}
	};
	function fetch$3(input, init$1 = {}) {
		webidl$7.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
		const p = createDeferredPromise$1();
		let requestObject;
		try {
			requestObject = new Request$2(input, init$1);
		} catch (e) {
			p.reject(e);
			return p.promise;
		}
		const request$3 = requestObject[kState$4];
		if (requestObject.signal.aborted) {
			abortFetch(p, request$3, null, requestObject.signal.reason);
			return p.promise;
		}
		const globalObject = request$3.client.globalObject;
		if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") request$3.serviceWorkers = "none";
		let responseObject = null;
		const relevantRealm = null;
		let locallyAborted = false;
		let controller = null;
		addAbortListener(requestObject.signal, () => {
			locallyAborted = true;
			assert$3(controller != null);
			controller.abort(requestObject.signal.reason);
			abortFetch(p, request$3, responseObject, requestObject.signal.reason);
		});
		const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
		const processResponse = (response) => {
			if (locallyAborted) return Promise.resolve();
			if (response.aborted) {
				abortFetch(p, request$3, responseObject, controller.serializedAbortReason);
				return Promise.resolve();
			}
			if (response.type === "error") {
				p.reject(Object.assign(new TypeError("fetch failed"), { cause: response.error }));
				return Promise.resolve();
			}
			responseObject = new Response$3();
			responseObject[kState$4] = response;
			responseObject[kRealm$1] = relevantRealm;
			responseObject[kHeaders$1][kHeadersList$2] = response.headersList;
			responseObject[kHeaders$1][kGuard$1] = "immutable";
			responseObject[kHeaders$1][kRealm$1] = relevantRealm;
			p.resolve(responseObject);
		};
		controller = fetching$2({
			request: request$3,
			processResponseEndOfBody: handleFetchDone,
			processResponse,
			dispatcher: init$1.dispatcher ?? getGlobalDispatcher$4()
		});
		return p.promise;
	}
	function finalizeAndReportTiming(response, initiatorType = "other") {
		if (response.type === "error" && response.aborted) return;
		if (!response.urlList?.length) return;
		const originalURL = response.urlList[0];
		let timingInfo = response.timingInfo;
		let cacheState = response.cacheState;
		if (!urlIsHttpHttpsScheme$1(originalURL)) return;
		if (timingInfo === null) return;
		if (!response.timingAllowPassed) {
			timingInfo = createOpaqueTimingInfo({ startTime: timingInfo.startTime });
			cacheState = "";
		}
		timingInfo.endTime = coarsenedSharedCurrentTime();
		response.timingInfo = timingInfo;
		markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
	}
	function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis$1, cacheState) {
		if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis$1, cacheState);
	}
	function abortFetch(p, request$3, responseObject, error$1) {
		if (!error$1) error$1 = new DOMException$3("The operation was aborted.", "AbortError");
		p.reject(error$1);
		if (request$3.body != null && isReadable(request$3.body?.stream)) request$3.body.stream.cancel(error$1).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
		if (responseObject == null) return;
		const response = responseObject[kState$4];
		if (response.body != null && isReadable(response.body?.stream)) response.body.stream.cancel(error$1).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
	}
	function fetching$2({ request: request$3, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher }) {
		let taskDestination = null;
		let crossOriginIsolatedCapability = false;
		if (request$3.client != null) {
			taskDestination = request$3.client.globalObject;
			crossOriginIsolatedCapability = request$3.client.crossOriginIsolatedCapability;
		}
		const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
		const timingInfo = createOpaqueTimingInfo({ startTime: currenTime });
		const fetchParams = {
			controller: new Fetch(dispatcher),
			request: request$3,
			timingInfo,
			processRequestBodyChunkLength,
			processRequestEndOfBody,
			processResponse,
			processResponseConsumeBody,
			processResponseEndOfBody,
			taskDestination,
			crossOriginIsolatedCapability
		};
		assert$3(!request$3.body || request$3.body.stream);
		if (request$3.window === "client") request$3.window = request$3.client?.globalObject?.constructor?.name === "Window" ? request$3.client : "no-window";
		if (request$3.origin === "client") request$3.origin = request$3.client?.origin;
		if (request$3.policyContainer === "client") if (request$3.client != null) request$3.policyContainer = clonePolicyContainer(request$3.client.policyContainer);
		else request$3.policyContainer = makePolicyContainer();
		if (!request$3.headersList.contains("accept")) {
			const value = "*/*";
			request$3.headersList.append("accept", value);
		}
		if (!request$3.headersList.contains("accept-language")) request$3.headersList.append("accept-language", "*");
		if (request$3.priority === null) {}
		if (subresourceSet.has(request$3.destination)) {}
		mainFetch(fetchParams).catch((err) => {
			fetchParams.controller.terminate(err);
		});
		return fetchParams.controller;
	}
	async function mainFetch(fetchParams, recursive = false) {
		const request$3 = fetchParams.request;
		let response = null;
		if (request$3.localURLsOnly && !urlIsLocal(requestCurrentURL(request$3))) response = makeNetworkError("local URLs only");
		tryUpgradeRequestToAPotentiallyTrustworthyURL(request$3);
		if (requestBadPort(request$3) === "blocked") response = makeNetworkError("bad port");
		if (request$3.referrerPolicy === "") request$3.referrerPolicy = request$3.policyContainer.referrerPolicy;
		if (request$3.referrer !== "no-referrer") request$3.referrer = determineRequestsReferrer(request$3);
		if (response === null) response = await (async () => {
			const currentURL = requestCurrentURL(request$3);
			if (sameOrigin(currentURL, request$3.url) && request$3.responseTainting === "basic" || currentURL.protocol === "data:" || request$3.mode === "navigate" || request$3.mode === "websocket") {
				request$3.responseTainting = "basic";
				return await schemeFetch(fetchParams);
			}
			if (request$3.mode === "same-origin") return makeNetworkError("request mode cannot be \"same-origin\"");
			if (request$3.mode === "no-cors") {
				if (request$3.redirect !== "follow") return makeNetworkError("redirect mode cannot be \"follow\" for \"no-cors\" request");
				request$3.responseTainting = "opaque";
				return await schemeFetch(fetchParams);
			}
			if (!urlIsHttpHttpsScheme$1(requestCurrentURL(request$3))) return makeNetworkError("URL scheme must be a HTTP(S) scheme");
			request$3.responseTainting = "cors";
			return await httpFetch(fetchParams);
		})();
		if (recursive) return response;
		if (response.status !== 0 && !response.internalResponse) {
			if (request$3.responseTainting === "cors") {}
			if (request$3.responseTainting === "basic") response = filterResponse(response, "basic");
			else if (request$3.responseTainting === "cors") response = filterResponse(response, "cors");
			else if (request$3.responseTainting === "opaque") response = filterResponse(response, "opaque");
			else assert$3(false);
		}
		let internalResponse = response.status === 0 ? response : response.internalResponse;
		if (internalResponse.urlList.length === 0) internalResponse.urlList.push(...request$3.urlList);
		if (!request$3.timingAllowFailed) response.timingAllowPassed = true;
		if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request$3.headers.contains("range")) response = internalResponse = makeNetworkError();
		if (response.status !== 0 && (request$3.method === "HEAD" || request$3.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
			internalResponse.body = null;
			fetchParams.controller.dump = true;
		}
		if (request$3.integrity) {
			const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
			if (request$3.responseTainting === "opaque" || response.body == null) {
				processBodyError(response.error);
				return;
			}
			const processBody = (bytes) => {
				if (!bytesMatch(bytes, request$3.integrity)) {
					processBodyError("integrity mismatch");
					return;
				}
				response.body = safelyExtractBody(bytes)[0];
				fetchFinale(fetchParams, response);
			};
			await fullyReadBody(response.body, processBody, processBodyError);
		} else fetchFinale(fetchParams, response);
	}
	function schemeFetch(fetchParams) {
		if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) return Promise.resolve(makeAppropriateNetworkError(fetchParams));
		const { request: request$3 } = fetchParams;
		const { protocol: scheme } = requestCurrentURL(request$3);
		switch (scheme) {
			case "about:": return Promise.resolve(makeNetworkError("about scheme is not supported"));
			case "blob:": {
				if (!resolveObjectURL) resolveObjectURL = require("buffer").resolveObjectURL;
				const blobURLEntry = requestCurrentURL(request$3);
				if (blobURLEntry.search.length !== 0) return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
				const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
				if (request$3.method !== "GET" || !isBlobLike$1(blobURLEntryObject)) return Promise.resolve(makeNetworkError("invalid method"));
				const bodyWithType = safelyExtractBody(blobURLEntryObject);
				const body = bodyWithType[0];
				const length = isomorphicEncode(`${body.length}`);
				const type = bodyWithType[1] ?? "";
				const response = makeResponse({
					statusText: "OK",
					headersList: [["content-length", {
						name: "Content-Length",
						value: length
					}], ["content-type", {
						name: "Content-Type",
						value: type
					}]]
				});
				response.body = body;
				return Promise.resolve(response);
			}
			case "data:": {
				const currentURL = requestCurrentURL(request$3);
				const dataURLStruct = dataURLProcessor(currentURL);
				if (dataURLStruct === "failure") return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
				const mimeType = serializeAMimeType$1(dataURLStruct.mimeType);
				return Promise.resolve(makeResponse({
					statusText: "OK",
					headersList: [["content-type", {
						name: "Content-Type",
						value: mimeType
					}]],
					body: safelyExtractBody(dataURLStruct.body)[0]
				}));
			}
			case "file:": return Promise.resolve(makeNetworkError("not implemented... yet..."));
			case "http:":
			case "https:": return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
			default: return Promise.resolve(makeNetworkError("unknown scheme"));
		}
	}
	function finalizeResponse(fetchParams, response) {
		fetchParams.request.done = true;
		if (fetchParams.processResponseDone != null) queueMicrotask(() => fetchParams.processResponseDone(response));
	}
	function fetchFinale(fetchParams, response) {
		if (response.type === "error") {
			response.urlList = [fetchParams.request.urlList[0]];
			response.timingInfo = createOpaqueTimingInfo({ startTime: fetchParams.timingInfo.startTime });
		}
		const processResponseEndOfBody = () => {
			fetchParams.request.done = true;
			if (fetchParams.processResponseEndOfBody != null) queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
		};
		if (fetchParams.processResponse != null) queueMicrotask(() => fetchParams.processResponse(response));
		if (response.body == null) processResponseEndOfBody();
		else {
			const identityTransformAlgorithm = (chunk, controller) => {
				controller.enqueue(chunk);
			};
			const transformStream = new TransformStream({
				start() {},
				transform: identityTransformAlgorithm,
				flush: processResponseEndOfBody
			}, { size() {
				return 1;
			} }, { size() {
				return 1;
			} });
			response.body = { stream: response.body.stream.pipeThrough(transformStream) };
		}
		if (fetchParams.processResponseConsumeBody != null) {
			const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
			const processBodyError = (failure$1) => fetchParams.processResponseConsumeBody(response, failure$1);
			if (response.body == null) queueMicrotask(() => processBody(null));
			else return fullyReadBody(response.body, processBody, processBodyError);
			return Promise.resolve();
		}
	}
	async function httpFetch(fetchParams) {
		const request$3 = fetchParams.request;
		let response = null;
		let actualResponse = null;
		const timingInfo = fetchParams.timingInfo;
		if (request$3.serviceWorkers === "all") {}
		if (response === null) {
			if (request$3.redirect === "follow") request$3.serviceWorkers = "none";
			actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
			if (request$3.responseTainting === "cors" && corsCheck(request$3, response) === "failure") return makeNetworkError("cors failure");
			if (TAOCheck(request$3, response) === "failure") request$3.timingAllowFailed = true;
		}
		if ((request$3.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request$3.origin, request$3.client, request$3.destination, actualResponse) === "blocked") return makeNetworkError("blocked");
		if (redirectStatusSet.has(actualResponse.status)) {
			if (request$3.redirect !== "manual") fetchParams.controller.connection.destroy();
			if (request$3.redirect === "error") response = makeNetworkError("unexpected redirect");
			else if (request$3.redirect === "manual") response = actualResponse;
			else if (request$3.redirect === "follow") response = await httpRedirectFetch(fetchParams, response);
			else assert$3(false);
		}
		response.timingInfo = timingInfo;
		return response;
	}
	function httpRedirectFetch(fetchParams, response) {
		const request$3 = fetchParams.request;
		const actualResponse = response.internalResponse ? response.internalResponse : response;
		let locationURL;
		try {
			locationURL = responseLocationURL(actualResponse, requestCurrentURL(request$3).hash);
			if (locationURL == null) return response;
		} catch (err) {
			return Promise.resolve(makeNetworkError(err));
		}
		if (!urlIsHttpHttpsScheme$1(locationURL)) return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
		if (request$3.redirectCount === 20) return Promise.resolve(makeNetworkError("redirect count exceeded"));
		request$3.redirectCount += 1;
		if (request$3.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request$3, locationURL)) return Promise.resolve(makeNetworkError("cross origin not allowed for request mode \"cors\""));
		if (request$3.responseTainting === "cors" && (locationURL.username || locationURL.password)) return Promise.resolve(makeNetworkError("URL cannot contain credentials for request mode \"cors\""));
		if (actualResponse.status !== 303 && request$3.body != null && request$3.body.source == null) return Promise.resolve(makeNetworkError());
		if ([301, 302].includes(actualResponse.status) && request$3.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request$3.method)) {
			request$3.method = "GET";
			request$3.body = null;
			for (const headerName of requestBodyHeader) request$3.headersList.delete(headerName);
		}
		if (!sameOrigin(requestCurrentURL(request$3), locationURL)) {
			request$3.headersList.delete("authorization");
			request$3.headersList.delete("proxy-authorization", true);
			request$3.headersList.delete("cookie");
			request$3.headersList.delete("host");
		}
		if (request$3.body != null) {
			assert$3(request$3.body.source != null);
			request$3.body = safelyExtractBody(request$3.body.source)[0];
		}
		const timingInfo = fetchParams.timingInfo;
		timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
		if (timingInfo.redirectStartTime === 0) timingInfo.redirectStartTime = timingInfo.startTime;
		request$3.urlList.push(locationURL);
		setRequestReferrerPolicyOnRedirect(request$3, actualResponse);
		return mainFetch(fetchParams, true);
	}
	async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
		const request$3 = fetchParams.request;
		let httpFetchParams = null;
		let httpRequest = null;
		let response = null;
		const httpCache = null;
		const revalidatingFlag = false;
		if (request$3.window === "no-window" && request$3.redirect === "error") {
			httpFetchParams = fetchParams;
			httpRequest = request$3;
		} else {
			httpRequest = makeRequest$1(request$3);
			httpFetchParams = { ...fetchParams };
			httpFetchParams.request = httpRequest;
		}
		const includeCredentials = request$3.credentials === "include" || request$3.credentials === "same-origin" && request$3.responseTainting === "basic";
		const contentLength = httpRequest.body ? httpRequest.body.length : null;
		let contentLengthHeaderValue = null;
		if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) contentLengthHeaderValue = "0";
		if (contentLength != null) contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
		if (contentLengthHeaderValue != null) httpRequest.headersList.append("content-length", contentLengthHeaderValue);
		if (contentLength != null && httpRequest.keepalive) {}
		if (httpRequest.referrer instanceof URL) httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
		appendRequestOriginHeader(httpRequest);
		appendFetchMetadata(httpRequest);
		if (!httpRequest.headersList.contains("user-agent")) httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
		if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) httpRequest.cache = "no-store";
		if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) httpRequest.headersList.append("cache-control", "max-age=0");
		if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
			if (!httpRequest.headersList.contains("pragma")) httpRequest.headersList.append("pragma", "no-cache");
			if (!httpRequest.headersList.contains("cache-control")) httpRequest.headersList.append("cache-control", "no-cache");
		}
		if (httpRequest.headersList.contains("range")) httpRequest.headersList.append("accept-encoding", "identity");
		if (!httpRequest.headersList.contains("accept-encoding")) if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
		else httpRequest.headersList.append("accept-encoding", "gzip, deflate");
		httpRequest.headersList.delete("host");
		if (includeCredentials) {}
		if (httpCache == null) httpRequest.cache = "no-store";
		if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {}
		if (response == null) {
			if (httpRequest.mode === "only-if-cached") return makeNetworkError("only if cached");
			const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
			if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {}
			if (revalidatingFlag && forwardResponse.status === 304) {}
			if (response == null) response = forwardResponse;
		}
		response.urlList = [...httpRequest.urlList];
		if (httpRequest.headersList.contains("range")) response.rangeRequested = true;
		response.requestIncludesCredentials = includeCredentials;
		if (response.status === 407) {
			if (request$3.window === "no-window") return makeNetworkError();
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			return makeNetworkError("proxy authentication required");
		}
		if (response.status === 421 && !isNewConnectionFetch && (request$3.body == null || request$3.body.source != null)) {
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			fetchParams.controller.connection.destroy();
			response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
		}
		if (isAuthenticationFetch) {}
		return response;
	}
	async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
		assert$3(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
		fetchParams.controller.connection = {
			abort: null,
			destroyed: false,
			destroy(err) {
				if (!this.destroyed) {
					this.destroyed = true;
					this.abort?.(err ?? new DOMException$3("The operation was aborted.", "AbortError"));
				}
			}
		};
		const request$3 = fetchParams.request;
		let response = null;
		const timingInfo = fetchParams.timingInfo;
		const httpCache = null;
		if (httpCache == null) request$3.cache = "no-store";
		const newConnection = forceNewConnection ? "yes" : "no";
		if (request$3.mode === "websocket") {}
		let requestBody = null;
		if (request$3.body == null && fetchParams.processRequestEndOfBody) queueMicrotask(() => fetchParams.processRequestEndOfBody());
		else if (request$3.body != null) {
			const processBodyChunk = async function* (bytes) {
				if (isCancelled(fetchParams)) return;
				yield bytes;
				fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
			};
			const processEndOfBody = () => {
				if (isCancelled(fetchParams)) return;
				if (fetchParams.processRequestEndOfBody) fetchParams.processRequestEndOfBody();
			};
			const processBodyError = (e) => {
				if (isCancelled(fetchParams)) return;
				if (e.name === "AbortError") fetchParams.controller.abort();
				else fetchParams.controller.terminate(e);
			};
			requestBody = async function* () {
				try {
					for await (const bytes of request$3.body.stream) yield* processBodyChunk(bytes);
					processEndOfBody();
				} catch (err) {
					processBodyError(err);
				}
			}();
		}
		try {
			const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
			if (socket) response = makeResponse({
				status,
				statusText,
				headersList,
				socket
			});
			else {
				const iterator$1 = body[Symbol.asyncIterator]();
				fetchParams.controller.next = () => iterator$1.next();
				response = makeResponse({
					status,
					statusText,
					headersList
				});
			}
		} catch (err) {
			if (err.name === "AbortError") {
				fetchParams.controller.connection.destroy();
				return makeAppropriateNetworkError(fetchParams, err);
			}
			return makeNetworkError(err);
		}
		const pullAlgorithm = () => {
			fetchParams.controller.resume();
		};
		const cancelAlgorithm = (reason) => {
			fetchParams.controller.abort(reason);
		};
		if (!ReadableStream) ReadableStream = require("stream/web").ReadableStream;
		const stream$6 = new ReadableStream({
			async start(controller) {
				fetchParams.controller.controller = controller;
			},
			async pull(controller) {
				await pullAlgorithm(controller);
			},
			async cancel(reason) {
				await cancelAlgorithm(reason);
			}
		}, {
			highWaterMark: 0,
			size() {
				return 1;
			}
		});
		response.body = { stream: stream$6 };
		fetchParams.controller.on("terminated", onAborted);
		fetchParams.controller.resume = async () => {
			while (true) {
				let bytes;
				let isFailure;
				try {
					const { done, value } = await fetchParams.controller.next();
					if (isAborted(fetchParams)) break;
					bytes = done ? void 0 : value;
				} catch (err) {
					if (fetchParams.controller.ended && !timingInfo.encodedBodySize) bytes = void 0;
					else {
						bytes = err;
						isFailure = true;
					}
				}
				if (bytes === void 0) {
					readableStreamClose(fetchParams.controller.controller);
					finalizeResponse(fetchParams, response);
					return;
				}
				timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
				if (isFailure) {
					fetchParams.controller.terminate(bytes);
					return;
				}
				fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
				if (isErrored(stream$6)) {
					fetchParams.controller.terminate();
					return;
				}
				if (!fetchParams.controller.controller.desiredSize) return;
			}
		};
		function onAborted(reason) {
			if (isAborted(fetchParams)) {
				response.aborted = true;
				if (isReadable(stream$6)) fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
			} else if (isReadable(stream$6)) fetchParams.controller.controller.error(new TypeError("terminated", { cause: isErrorLike(reason) ? reason : void 0 }));
			fetchParams.controller.connection.destroy();
		}
		return response;
		async function dispatch({ body }) {
			const url = requestCurrentURL(request$3);
			/** @type {import('../..').Agent} */
			const agent = fetchParams.controller.dispatcher;
			return new Promise((resolve, reject) => agent.dispatch({
				path: url.pathname + url.search,
				origin: url.origin,
				method: request$3.method,
				body: fetchParams.controller.dispatcher.isMockActive ? request$3.body && (request$3.body.source || request$3.body.stream) : body,
				headers: request$3.headersList.entries,
				maxRedirections: 0,
				upgrade: request$3.mode === "websocket" ? "websocket" : void 0
			}, {
				body: null,
				abort: null,
				onConnect(abort$1) {
					const { connection } = fetchParams.controller;
					if (connection.destroyed) abort$1(new DOMException$3("The operation was aborted.", "AbortError"));
					else {
						fetchParams.controller.on("terminated", abort$1);
						this.abort = connection.abort = abort$1;
					}
				},
				onHeaders(status, headersList, resume$3, statusText) {
					if (status < 200) return;
					let codings = [];
					let location = "";
					const headers = new Headers$5();
					if (Array.isArray(headersList)) for (let n = 0; n < headersList.length; n += 2) {
						const key = headersList[n + 0].toString("latin1");
						const val = headersList[n + 1].toString("latin1");
						if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x) => x.trim());
						else if (key.toLowerCase() === "location") location = val;
						headers[kHeadersList$2].append(key, val);
					}
					else {
						const keys = Object.keys(headersList);
						for (const key of keys) {
							const val = headersList[key];
							if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
							else if (key.toLowerCase() === "location") location = val;
							headers[kHeadersList$2].append(key, val);
						}
					}
					this.body = new Readable$2({ read: resume$3 });
					const decoders$1 = [];
					const willFollow = request$3.redirect === "follow" && location && redirectStatusSet.has(status);
					if (request$3.method !== "HEAD" && request$3.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) for (const coding of codings) if (coding === "x-gzip" || coding === "gzip") decoders$1.push(zlib$2.createGunzip({
						flush: zlib$2.constants.Z_SYNC_FLUSH,
						finishFlush: zlib$2.constants.Z_SYNC_FLUSH
					}));
					else if (coding === "deflate") decoders$1.push(zlib$2.createInflate());
					else if (coding === "br") decoders$1.push(zlib$2.createBrotliDecompress());
					else {
						decoders$1.length = 0;
						break;
					}
					resolve({
						status,
						statusText,
						headersList: headers[kHeadersList$2],
						body: decoders$1.length ? pipeline(this.body, ...decoders$1, () => {}) : this.body.on("error", () => {})
					});
					return true;
				},
				onData(chunk) {
					if (fetchParams.controller.dump) return;
					const bytes = chunk;
					timingInfo.encodedBodySize += bytes.byteLength;
					return this.body.push(bytes);
				},
				onComplete() {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					fetchParams.controller.ended = true;
					this.body.push(null);
				},
				onError(error$1) {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					this.body?.destroy(error$1);
					fetchParams.controller.terminate(error$1);
					reject(error$1);
				},
				onUpgrade(status, headersList, socket) {
					if (status !== 101) return;
					const headers = new Headers$5();
					for (let n = 0; n < headersList.length; n += 2) {
						const key = headersList[n + 0].toString("latin1");
						const val = headersList[n + 1].toString("latin1");
						headers[kHeadersList$2].append(key, val);
					}
					resolve({
						status,
						statusText: STATUS_CODES$1[status],
						headersList: headers[kHeadersList$2],
						socket
					});
					return true;
				}
			}));
		}
	}
	module.exports = {
		fetch: fetch$3,
		Fetch,
		fetching: fetching$2,
		finalizeAndReportTiming
	};
} });

//#endregion
//#region node_modules/undici/lib/fileapi/symbols.js
var require_symbols$2 = __commonJS({ "node_modules/undici/lib/fileapi/symbols.js"(exports, module) {
	module.exports = {
		kState: Symbol("FileReader state"),
		kResult: Symbol("FileReader result"),
		kError: Symbol("FileReader error"),
		kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
		kEvents: Symbol("FileReader events"),
		kAborted: Symbol("FileReader aborted")
	};
} });

//#endregion
//#region node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({ "node_modules/undici/lib/fileapi/progressevent.js"(exports, module) {
	const { webidl: webidl$6 } = require_webidl();
	const kState$3 = Symbol("ProgressEvent state");
	/**
	* @see https://xhr.spec.whatwg.org/#progressevent
	*/
	var ProgressEvent$1 = class ProgressEvent$1 extends Event {
		constructor(type, eventInitDict = {}) {
			type = webidl$6.converters.DOMString(type);
			eventInitDict = webidl$6.converters.ProgressEventInit(eventInitDict ?? {});
			super(type, eventInitDict);
			this[kState$3] = {
				lengthComputable: eventInitDict.lengthComputable,
				loaded: eventInitDict.loaded,
				total: eventInitDict.total
			};
		}
		get lengthComputable() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].lengthComputable;
		}
		get loaded() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].loaded;
		}
		get total() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].total;
		}
	};
	webidl$6.converters.ProgressEventInit = webidl$6.dictionaryConverter([
		{
			key: "lengthComputable",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "loaded",
			converter: webidl$6.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "total",
			converter: webidl$6.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "bubbles",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		}
	]);
	module.exports = { ProgressEvent: ProgressEvent$1 };
} });

//#endregion
//#region node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({ "node_modules/undici/lib/fileapi/encoding.js"(exports, module) {
	/**
	* @see https://encoding.spec.whatwg.org/#concept-encoding-get
	* @param {string|undefined} label
	*/
	function getEncoding$1(label) {
		if (!label) return "failure";
		switch (label.trim().toLowerCase()) {
			case "unicode-1-1-utf-8":
			case "unicode11utf8":
			case "unicode20utf8":
			case "utf-8":
			case "utf8":
			case "x-unicode20utf8": return "UTF-8";
			case "866":
			case "cp866":
			case "csibm866":
			case "ibm866": return "IBM866";
			case "csisolatin2":
			case "iso-8859-2":
			case "iso-ir-101":
			case "iso8859-2":
			case "iso88592":
			case "iso_8859-2":
			case "iso_8859-2:1987":
			case "l2":
			case "latin2": return "ISO-8859-2";
			case "csisolatin3":
			case "iso-8859-3":
			case "iso-ir-109":
			case "iso8859-3":
			case "iso88593":
			case "iso_8859-3":
			case "iso_8859-3:1988":
			case "l3":
			case "latin3": return "ISO-8859-3";
			case "csisolatin4":
			case "iso-8859-4":
			case "iso-ir-110":
			case "iso8859-4":
			case "iso88594":
			case "iso_8859-4":
			case "iso_8859-4:1988":
			case "l4":
			case "latin4": return "ISO-8859-4";
			case "csisolatincyrillic":
			case "cyrillic":
			case "iso-8859-5":
			case "iso-ir-144":
			case "iso8859-5":
			case "iso88595":
			case "iso_8859-5":
			case "iso_8859-5:1988": return "ISO-8859-5";
			case "arabic":
			case "asmo-708":
			case "csiso88596e":
			case "csiso88596i":
			case "csisolatinarabic":
			case "ecma-114":
			case "iso-8859-6":
			case "iso-8859-6-e":
			case "iso-8859-6-i":
			case "iso-ir-127":
			case "iso8859-6":
			case "iso88596":
			case "iso_8859-6":
			case "iso_8859-6:1987": return "ISO-8859-6";
			case "csisolatingreek":
			case "ecma-118":
			case "elot_928":
			case "greek":
			case "greek8":
			case "iso-8859-7":
			case "iso-ir-126":
			case "iso8859-7":
			case "iso88597":
			case "iso_8859-7":
			case "iso_8859-7:1987":
			case "sun_eu_greek": return "ISO-8859-7";
			case "csiso88598e":
			case "csisolatinhebrew":
			case "hebrew":
			case "iso-8859-8":
			case "iso-8859-8-e":
			case "iso-ir-138":
			case "iso8859-8":
			case "iso88598":
			case "iso_8859-8":
			case "iso_8859-8:1988":
			case "visual": return "ISO-8859-8";
			case "csiso88598i":
			case "iso-8859-8-i":
			case "logical": return "ISO-8859-8-I";
			case "csisolatin6":
			case "iso-8859-10":
			case "iso-ir-157":
			case "iso8859-10":
			case "iso885910":
			case "l6":
			case "latin6": return "ISO-8859-10";
			case "iso-8859-13":
			case "iso8859-13":
			case "iso885913": return "ISO-8859-13";
			case "iso-8859-14":
			case "iso8859-14":
			case "iso885914": return "ISO-8859-14";
			case "csisolatin9":
			case "iso-8859-15":
			case "iso8859-15":
			case "iso885915":
			case "iso_8859-15":
			case "l9": return "ISO-8859-15";
			case "iso-8859-16": return "ISO-8859-16";
			case "cskoi8r":
			case "koi":
			case "koi8":
			case "koi8-r":
			case "koi8_r": return "KOI8-R";
			case "koi8-ru":
			case "koi8-u": return "KOI8-U";
			case "csmacintosh":
			case "mac":
			case "macintosh":
			case "x-mac-roman": return "macintosh";
			case "iso-8859-11":
			case "iso8859-11":
			case "iso885911":
			case "tis-620":
			case "windows-874": return "windows-874";
			case "cp1250":
			case "windows-1250":
			case "x-cp1250": return "windows-1250";
			case "cp1251":
			case "windows-1251":
			case "x-cp1251": return "windows-1251";
			case "ansi_x3.4-1968":
			case "ascii":
			case "cp1252":
			case "cp819":
			case "csisolatin1":
			case "ibm819":
			case "iso-8859-1":
			case "iso-ir-100":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "iso_8859-1:1987":
			case "l1":
			case "latin1":
			case "us-ascii":
			case "windows-1252":
			case "x-cp1252": return "windows-1252";
			case "cp1253":
			case "windows-1253":
			case "x-cp1253": return "windows-1253";
			case "cp1254":
			case "csisolatin5":
			case "iso-8859-9":
			case "iso-ir-148":
			case "iso8859-9":
			case "iso88599":
			case "iso_8859-9":
			case "iso_8859-9:1989":
			case "l5":
			case "latin5":
			case "windows-1254":
			case "x-cp1254": return "windows-1254";
			case "cp1255":
			case "windows-1255":
			case "x-cp1255": return "windows-1255";
			case "cp1256":
			case "windows-1256":
			case "x-cp1256": return "windows-1256";
			case "cp1257":
			case "windows-1257":
			case "x-cp1257": return "windows-1257";
			case "cp1258":
			case "windows-1258":
			case "x-cp1258": return "windows-1258";
			case "x-mac-cyrillic":
			case "x-mac-ukrainian": return "x-mac-cyrillic";
			case "chinese":
			case "csgb2312":
			case "csiso58gb231280":
			case "gb2312":
			case "gb_2312":
			case "gb_2312-80":
			case "gbk":
			case "iso-ir-58":
			case "x-gbk": return "GBK";
			case "gb18030": return "gb18030";
			case "big5":
			case "big5-hkscs":
			case "cn-big5":
			case "csbig5":
			case "x-x-big5": return "Big5";
			case "cseucpkdfmtjapanese":
			case "euc-jp":
			case "x-euc-jp": return "EUC-JP";
			case "csiso2022jp":
			case "iso-2022-jp": return "ISO-2022-JP";
			case "csshiftjis":
			case "ms932":
			case "ms_kanji":
			case "shift-jis":
			case "shift_jis":
			case "sjis":
			case "windows-31j":
			case "x-sjis": return "Shift_JIS";
			case "cseuckr":
			case "csksc56011987":
			case "euc-kr":
			case "iso-ir-149":
			case "korean":
			case "ks_c_5601-1987":
			case "ks_c_5601-1989":
			case "ksc5601":
			case "ksc_5601":
			case "windows-949": return "EUC-KR";
			case "csiso2022kr":
			case "hz-gb-2312":
			case "iso-2022-cn":
			case "iso-2022-cn-ext":
			case "iso-2022-kr":
			case "replacement": return "replacement";
			case "unicodefffe":
			case "utf-16be": return "UTF-16BE";
			case "csunicode":
			case "iso-10646-ucs-2":
			case "ucs-2":
			case "unicode":
			case "unicodefeff":
			case "utf-16":
			case "utf-16le": return "UTF-16LE";
			case "x-user-defined": return "x-user-defined";
			default: return "failure";
		}
	}
	module.exports = { getEncoding: getEncoding$1 };
} });

//#endregion
//#region node_modules/undici/lib/fileapi/util.js
var require_util$5 = __commonJS({ "node_modules/undici/lib/fileapi/util.js"(exports, module) {
	const { kState: kState$2, kError: kError$3, kResult: kResult$1, kAborted: kAborted$2, kLastProgressEventFired } = require_symbols$2();
	const { ProgressEvent } = require_progressevent();
	const { getEncoding } = require_encoding();
	const { DOMException: DOMException$2 } = require_constants$4();
	const { serializeAMimeType, parseMIMEType } = require_dataURL();
	const { types: types$1 } = require("util");
	const { StringDecoder } = require("string_decoder");
	const { btoa } = require("buffer");
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors$3 = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	/**
	* @see https://w3c.github.io/FileAPI/#readOperation
	* @param {import('./filereader').FileReader} fr
	* @param {import('buffer').Blob} blob
	* @param {string} type
	* @param {string?} encodingName
	*/
	function readOperation$1(fr, blob, type, encodingName) {
		if (fr[kState$2] === "loading") throw new DOMException$2("Invalid state", "InvalidStateError");
		fr[kState$2] = "loading";
		fr[kResult$1] = null;
		fr[kError$3] = null;
		/** @type {import('stream/web').ReadableStream} */
		const stream$6 = blob.stream();
		const reader = stream$6.getReader();
		/** @type {Uint8Array[]} */
		const bytes = [];
		let chunkPromise = reader.read();
		let isFirstChunk = true;
		(async () => {
			while (!fr[kAborted$2]) try {
				const { done, value } = await chunkPromise;
				if (isFirstChunk && !fr[kAborted$2]) queueMicrotask(() => {
					fireAProgressEvent$1("loadstart", fr);
				});
				isFirstChunk = false;
				if (!done && types$1.isUint8Array(value)) {
					bytes.push(value);
					if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted$2]) {
						fr[kLastProgressEventFired] = Date.now();
						queueMicrotask(() => {
							fireAProgressEvent$1("progress", fr);
						});
					}
					chunkPromise = reader.read();
				} else if (done) {
					queueMicrotask(() => {
						fr[kState$2] = "done";
						try {
							const result = packageData(bytes, type, blob.type, encodingName);
							if (fr[kAborted$2]) return;
							fr[kResult$1] = result;
							fireAProgressEvent$1("load", fr);
						} catch (error$1) {
							fr[kError$3] = error$1;
							fireAProgressEvent$1("error", fr);
						}
						if (fr[kState$2] !== "loading") fireAProgressEvent$1("loadend", fr);
					});
					break;
				}
			} catch (error$1) {
				if (fr[kAborted$2]) return;
				queueMicrotask(() => {
					fr[kState$2] = "done";
					fr[kError$3] = error$1;
					fireAProgressEvent$1("error", fr);
					if (fr[kState$2] !== "loading") fireAProgressEvent$1("loadend", fr);
				});
				break;
			}
		})();
	}
	/**
	* @see https://w3c.github.io/FileAPI/#fire-a-progress-event
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e The name of the event
	* @param {import('./filereader').FileReader} reader
	*/
	function fireAProgressEvent$1(e, reader) {
		const event = new ProgressEvent(e, {
			bubbles: false,
			cancelable: false
		});
		reader.dispatchEvent(event);
	}
	/**
	* @see https://w3c.github.io/FileAPI/#blob-package-data
	* @param {Uint8Array[]} bytes
	* @param {string} type
	* @param {string?} mimeType
	* @param {string?} encodingName
	*/
	function packageData(bytes, type, mimeType, encodingName) {
		switch (type) {
			case "DataURL": {
				let dataURL = "data:";
				const parsed = parseMIMEType(mimeType || "application/octet-stream");
				if (parsed !== "failure") dataURL += serializeAMimeType(parsed);
				dataURL += ";base64,";
				const decoder = new StringDecoder("latin1");
				for (const chunk of bytes) dataURL += btoa(decoder.write(chunk));
				dataURL += btoa(decoder.end());
				return dataURL;
			}
			case "Text": {
				let encoding = "failure";
				if (encodingName) encoding = getEncoding(encodingName);
				if (encoding === "failure" && mimeType) {
					const type$1 = parseMIMEType(mimeType);
					if (type$1 !== "failure") encoding = getEncoding(type$1.parameters.get("charset"));
				}
				if (encoding === "failure") encoding = "UTF-8";
				return decode(bytes, encoding);
			}
			case "ArrayBuffer": {
				const sequence = combineByteSequences(bytes);
				return sequence.buffer;
			}
			case "BinaryString": {
				let binaryString = "";
				const decoder = new StringDecoder("latin1");
				for (const chunk of bytes) binaryString += decoder.write(chunk);
				binaryString += decoder.end();
				return binaryString;
			}
		}
	}
	/**
	* @see https://encoding.spec.whatwg.org/#decode
	* @param {Uint8Array[]} ioQueue
	* @param {string} encoding
	*/
	function decode(ioQueue, encoding) {
		const bytes = combineByteSequences(ioQueue);
		const BOMEncoding = BOMSniffing(bytes);
		let slice = 0;
		if (BOMEncoding !== null) {
			encoding = BOMEncoding;
			slice = BOMEncoding === "UTF-8" ? 3 : 2;
		}
		const sliced = bytes.slice(slice);
		return new TextDecoder(encoding).decode(sliced);
	}
	/**
	* @see https://encoding.spec.whatwg.org/#bom-sniff
	* @param {Uint8Array} ioQueue
	*/
	function BOMSniffing(ioQueue) {
		const [a$1, b, c] = ioQueue;
		if (a$1 === 239 && b === 187 && c === 191) return "UTF-8";
		else if (a$1 === 254 && b === 255) return "UTF-16BE";
		else if (a$1 === 255 && b === 254) return "UTF-16LE";
		return null;
	}
	/**
	* @param {Uint8Array[]} sequences
	*/
	function combineByteSequences(sequences) {
		const size = sequences.reduce((a$1, b) => {
			return a$1 + b.byteLength;
		}, 0);
		let offset = 0;
		return sequences.reduce((a$1, b) => {
			a$1.set(b, offset);
			offset += b.byteLength;
			return a$1;
		}, new Uint8Array(size));
	}
	module.exports = {
		staticPropertyDescriptors: staticPropertyDescriptors$3,
		readOperation: readOperation$1,
		fireAProgressEvent: fireAProgressEvent$1
	};
} });

//#endregion
//#region node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({ "node_modules/undici/lib/fileapi/filereader.js"(exports, module) {
	const { staticPropertyDescriptors: staticPropertyDescriptors$2, readOperation, fireAProgressEvent } = require_util$5();
	const { kState: kState$1, kError: kError$2, kResult, kEvents, kAborted: kAborted$1 } = require_symbols$2();
	const { webidl: webidl$5 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$4 } = require_util$8();
	var FileReader = class FileReader extends EventTarget {
		constructor() {
			super();
			this[kState$1] = "empty";
			this[kResult] = null;
			this[kError$2] = null;
			this[kEvents] = {
				loadend: null,
				error: null,
				abort: null,
				load: null,
				progress: null,
				loadstart: null
			};
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
		* @param {import('buffer').Blob} blob
		*/
		readAsArrayBuffer(blob) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "ArrayBuffer");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsBinaryString
		* @param {import('buffer').Blob} blob
		*/
		readAsBinaryString(blob) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "BinaryString");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsDataText
		* @param {import('buffer').Blob} blob
		* @param {string?} encoding
		*/
		readAsText(blob, encoding = void 0) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			if (encoding !== void 0) encoding = webidl$5.converters.DOMString(encoding);
			readOperation(this, blob, "Text", encoding);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
		* @param {import('buffer').Blob} blob
		*/
		readAsDataURL(blob) {
			webidl$5.brandCheck(this, FileReader);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "DataURL");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-abort
		*/
		abort() {
			if (this[kState$1] === "empty" || this[kState$1] === "done") {
				this[kResult] = null;
				return;
			}
			if (this[kState$1] === "loading") {
				this[kState$1] = "done";
				this[kResult] = null;
			}
			this[kAborted$1] = true;
			fireAProgressEvent("abort", this);
			if (this[kState$1] !== "loading") fireAProgressEvent("loadend", this);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
		*/
		get readyState() {
			webidl$5.brandCheck(this, FileReader);
			switch (this[kState$1]) {
				case "empty": return this.EMPTY;
				case "loading": return this.LOADING;
				case "done": return this.DONE;
			}
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-result
		*/
		get result() {
			webidl$5.brandCheck(this, FileReader);
			return this[kResult];
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-error
		*/
		get error() {
			webidl$5.brandCheck(this, FileReader);
			return this[kError$2];
		}
		get onloadend() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].loadend;
		}
		set onloadend(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].loadend) this.removeEventListener("loadend", this[kEvents].loadend);
			if (typeof fn === "function") {
				this[kEvents].loadend = fn;
				this.addEventListener("loadend", fn);
			} else this[kEvents].loadend = null;
		}
		get onerror() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].error;
		}
		set onerror(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].error) this.removeEventListener("error", this[kEvents].error);
			if (typeof fn === "function") {
				this[kEvents].error = fn;
				this.addEventListener("error", fn);
			} else this[kEvents].error = null;
		}
		get onloadstart() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].loadstart;
		}
		set onloadstart(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].loadstart) this.removeEventListener("loadstart", this[kEvents].loadstart);
			if (typeof fn === "function") {
				this[kEvents].loadstart = fn;
				this.addEventListener("loadstart", fn);
			} else this[kEvents].loadstart = null;
		}
		get onprogress() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].progress;
		}
		set onprogress(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].progress) this.removeEventListener("progress", this[kEvents].progress);
			if (typeof fn === "function") {
				this[kEvents].progress = fn;
				this.addEventListener("progress", fn);
			} else this[kEvents].progress = null;
		}
		get onload() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].load;
		}
		set onload(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].load) this.removeEventListener("load", this[kEvents].load);
			if (typeof fn === "function") {
				this[kEvents].load = fn;
				this.addEventListener("load", fn);
			} else this[kEvents].load = null;
		}
		get onabort() {
			webidl$5.brandCheck(this, FileReader);
			return this[kEvents].abort;
		}
		set onabort(fn) {
			webidl$5.brandCheck(this, FileReader);
			if (this[kEvents].abort) this.removeEventListener("abort", this[kEvents].abort);
			if (typeof fn === "function") {
				this[kEvents].abort = fn;
				this.addEventListener("abort", fn);
			} else this[kEvents].abort = null;
		}
	};
	FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
	FileReader.LOADING = FileReader.prototype.LOADING = 1;
	FileReader.DONE = FileReader.prototype.DONE = 2;
	Object.defineProperties(FileReader.prototype, {
		EMPTY: staticPropertyDescriptors$2,
		LOADING: staticPropertyDescriptors$2,
		DONE: staticPropertyDescriptors$2,
		readAsArrayBuffer: kEnumerableProperty$4,
		readAsBinaryString: kEnumerableProperty$4,
		readAsText: kEnumerableProperty$4,
		readAsDataURL: kEnumerableProperty$4,
		abort: kEnumerableProperty$4,
		readyState: kEnumerableProperty$4,
		result: kEnumerableProperty$4,
		error: kEnumerableProperty$4,
		onloadstart: kEnumerableProperty$4,
		onprogress: kEnumerableProperty$4,
		onload: kEnumerableProperty$4,
		onabort: kEnumerableProperty$4,
		onerror: kEnumerableProperty$4,
		onloadend: kEnumerableProperty$4,
		[Symbol.toStringTag]: {
			value: "FileReader",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(FileReader, {
		EMPTY: staticPropertyDescriptors$2,
		LOADING: staticPropertyDescriptors$2,
		DONE: staticPropertyDescriptors$2
	});
	module.exports = { FileReader };
} });

//#endregion
//#region node_modules/undici/lib/cache/symbols.js
var require_symbols$1 = __commonJS({ "node_modules/undici/lib/cache/symbols.js"(exports, module) {
	module.exports = { kConstruct: require_symbols$4().kConstruct };
} });

//#endregion
//#region node_modules/undici/lib/cache/util.js
var require_util$4 = __commonJS({ "node_modules/undici/lib/cache/util.js"(exports, module) {
	const assert$2 = require("assert");
	const { URLSerializer: URLSerializer$1 } = require_dataURL();
	const { isValidHeaderName } = require_util$7();
	/**
	* @see https://url.spec.whatwg.org/#concept-url-equals
	* @param {URL} A
	* @param {URL} B
	* @param {boolean | undefined} excludeFragment
	* @returns {boolean}
	*/
	function urlEquals$1(A, B, excludeFragment = false) {
		const serializedA = URLSerializer$1(A, excludeFragment);
		const serializedB = URLSerializer$1(B, excludeFragment);
		return serializedA === serializedB;
	}
	/**
	* @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
	* @param {string} header
	*/
	function fieldValues(header) {
		assert$2(header !== null);
		const values = [];
		for (let value of header.split(",")) {
			value = value.trim();
			if (!value.length) continue;
			else if (!isValidHeaderName(value)) continue;
			values.push(value);
		}
		return values;
	}
	module.exports = {
		urlEquals: urlEquals$1,
		fieldValues
	};
} });

//#endregion
//#region node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({ "node_modules/undici/lib/cache/cache.js"(exports, module) {
	const { kConstruct: kConstruct$1 } = require_symbols$1();
	const { urlEquals, fieldValues: getFieldValues } = require_util$4();
	const { kEnumerableProperty: kEnumerableProperty$3, isDisturbed } = require_util$8();
	const { kHeadersList: kHeadersList$1 } = require_symbols$4();
	const { webidl: webidl$4 } = require_webidl();
	const { Response: Response$2, cloneResponse } = require_response();
	const { Request: Request$1 } = require_request();
	const { kState, kHeaders, kGuard, kRealm } = require_symbols$3();
	const { fetching: fetching$1 } = require_fetch();
	const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util$7();
	const assert$1 = require("assert");
	const { getGlobalDispatcher: getGlobalDispatcher$3 } = require_global();
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
	* @typedef {Object} CacheBatchOperation
	* @property {'delete' | 'put'} type
	* @property {any} request
	* @property {any} response
	* @property {import('../../types/cache').CacheQueryOptions} options
	*/
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
	* @typedef {[any, any][]} requestResponseList
	*/
	var Cache$1 = class Cache$1 {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
		* @type {requestResponseList}
		*/
		#relevantRequestResponseList;
		constructor() {
			if (arguments[0] !== kConstruct$1) webidl$4.illegalConstructor();
			this.#relevantRequestResponseList = arguments[1];
		}
		async match(request$3, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
			request$3 = webidl$4.converters.RequestInfo(request$3);
			options = webidl$4.converters.CacheQueryOptions(options);
			const p = await this.matchAll(request$3, options);
			if (p.length === 0) return;
			return p[0];
		}
		async matchAll(request$3 = void 0, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			if (request$3 !== void 0) request$3 = webidl$4.converters.RequestInfo(request$3);
			options = webidl$4.converters.CacheQueryOptions(options);
			let r = null;
			if (request$3 !== void 0) {
				if (request$3 instanceof Request$1) {
					r = request$3[kState];
					if (r.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$3 === "string") r = new Request$1(request$3)[kState];
			}
			const responses = [];
			if (request$3 === void 0) for (const requestResponse of this.#relevantRequestResponseList) responses.push(requestResponse[1]);
			else {
				const requestResponses = this.#queryCache(r, options);
				for (const requestResponse of requestResponses) responses.push(requestResponse[1]);
			}
			const responseList = [];
			for (const response of responses) {
				const responseObject = new Response$2(response.body?.source ?? null);
				const body = responseObject[kState].body;
				responseObject[kState] = response;
				responseObject[kState].body = body;
				responseObject[kHeaders][kHeadersList$1] = response.headersList;
				responseObject[kHeaders][kGuard] = "immutable";
				responseList.push(responseObject);
			}
			return Object.freeze(responseList);
		}
		async add(request$3) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
			request$3 = webidl$4.converters.RequestInfo(request$3);
			const requests = [request$3];
			const responseArrayPromise = this.addAll(requests);
			return await responseArrayPromise;
		}
		async addAll(requests) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
			requests = webidl$4.converters["sequence<RequestInfo>"](requests);
			const responsePromises = [];
			const requestList = [];
			for (const request$3 of requests) {
				if (typeof request$3 === "string") continue;
				const r = request$3[kState];
				if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") throw webidl$4.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme when method is not GET."
				});
			}
			/** @type {ReturnType<typeof fetching>[]} */
			const fetchControllers = [];
			for (const request$3 of requests) {
				const r = new Request$1(request$3)[kState];
				if (!urlIsHttpHttpsScheme(r.url)) throw webidl$4.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme."
				});
				r.initiator = "fetch";
				r.destination = "subresource";
				requestList.push(r);
				const responsePromise = createDeferredPromise();
				fetchControllers.push(fetching$1({
					request: r,
					dispatcher: getGlobalDispatcher$3(),
					processResponse(response) {
						if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) responsePromise.reject(webidl$4.errors.exception({
							header: "Cache.addAll",
							message: "Received an invalid status code or the request failed."
						}));
						else if (response.headersList.contains("vary")) {
							const fieldValues$1 = getFieldValues(response.headersList.get("vary"));
							for (const fieldValue of fieldValues$1) if (fieldValue === "*") {
								responsePromise.reject(webidl$4.errors.exception({
									header: "Cache.addAll",
									message: "invalid vary field value"
								}));
								for (const controller of fetchControllers) controller.abort();
								return;
							}
						}
					},
					processResponseEndOfBody(response) {
						if (response.aborted) {
							responsePromise.reject(new DOMException("aborted", "AbortError"));
							return;
						}
						responsePromise.resolve(response);
					}
				}));
				responsePromises.push(responsePromise.promise);
			}
			const p = Promise.all(responsePromises);
			const responses = await p;
			const operations = [];
			let index = 0;
			for (const response of responses) {
				/** @type {CacheBatchOperation} */
				const operation = {
					type: "put",
					request: requestList[index],
					response
				};
				operations.push(operation);
				index++;
			}
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(void 0);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async put(request$3, response) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
			request$3 = webidl$4.converters.RequestInfo(request$3);
			response = webidl$4.converters.Response(response);
			let innerRequest = null;
			if (request$3 instanceof Request$1) innerRequest = request$3[kState];
			else innerRequest = new Request$1(request$3)[kState];
			if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Expected an http/s scheme when method is not GET"
			});
			const innerResponse = response[kState];
			if (innerResponse.status === 206) throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Got 206 status"
			});
			if (innerResponse.headersList.contains("vary")) {
				const fieldValues$1 = getFieldValues(innerResponse.headersList.get("vary"));
				for (const fieldValue of fieldValues$1) if (fieldValue === "*") throw webidl$4.errors.exception({
					header: "Cache.put",
					message: "Got * vary field value"
				});
			}
			if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Response body is locked or disturbed"
			});
			const clonedResponse = cloneResponse(innerResponse);
			const bodyReadPromise = createDeferredPromise();
			if (innerResponse.body != null) {
				const stream$6 = innerResponse.body.stream;
				const reader = stream$6.getReader();
				readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
			} else bodyReadPromise.resolve(void 0);
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation = {
				type: "put",
				request: innerRequest,
				response: clonedResponse
			};
			operations.push(operation);
			const bytes = await bodyReadPromise.promise;
			if (clonedResponse.body != null) clonedResponse.body.source = bytes;
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve();
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async delete(request$3, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
			request$3 = webidl$4.converters.RequestInfo(request$3);
			options = webidl$4.converters.CacheQueryOptions(options);
			/**
			* @type {Request}
			*/
			let r = null;
			if (request$3 instanceof Request$1) {
				r = request$3[kState];
				if (r.method !== "GET" && !options.ignoreMethod) return false;
			} else {
				assert$1(typeof request$3 === "string");
				r = new Request$1(request$3)[kState];
			}
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation = {
				type: "delete",
				request: r,
				options
			};
			operations.push(operation);
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			let requestResponses;
			try {
				requestResponses = this.#batchCacheOperations(operations);
			} catch (e) {
				errorData = e;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(!!requestResponses?.length);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
		* @param {any} request
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @returns {readonly Request[]}
		*/
		async keys(request$3 = void 0, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			if (request$3 !== void 0) request$3 = webidl$4.converters.RequestInfo(request$3);
			options = webidl$4.converters.CacheQueryOptions(options);
			let r = null;
			if (request$3 !== void 0) {
				if (request$3 instanceof Request$1) {
					r = request$3[kState];
					if (r.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$3 === "string") r = new Request$1(request$3)[kState];
			}
			const promise = createDeferredPromise();
			const requests = [];
			if (request$3 === void 0) for (const requestResponse of this.#relevantRequestResponseList) requests.push(requestResponse[0]);
			else {
				const requestResponses = this.#queryCache(r, options);
				for (const requestResponse of requestResponses) requests.push(requestResponse[0]);
			}
			queueMicrotask(() => {
				const requestList = [];
				for (const request$4 of requests) {
					const requestObject = new Request$1("https://a");
					requestObject[kState] = request$4;
					requestObject[kHeaders][kHeadersList$1] = request$4.headersList;
					requestObject[kHeaders][kGuard] = "immutable";
					requestObject[kRealm] = request$4.client;
					requestList.push(requestObject);
				}
				promise.resolve(Object.freeze(requestList));
			});
			return promise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
		* @param {CacheBatchOperation[]} operations
		* @returns {requestResponseList}
		*/
		#batchCacheOperations(operations) {
			const cache = this.#relevantRequestResponseList;
			const backupCache = [...cache];
			const addedItems = [];
			const resultList = [];
			try {
				for (const operation of operations) {
					if (operation.type !== "delete" && operation.type !== "put") throw webidl$4.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "operation type does not match \"delete\" or \"put\""
					});
					if (operation.type === "delete" && operation.response != null) throw webidl$4.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "delete operation should not have an associated response"
					});
					if (this.#queryCache(operation.request, operation.options, addedItems).length) throw new DOMException("???", "InvalidStateError");
					let requestResponses;
					if (operation.type === "delete") {
						requestResponses = this.#queryCache(operation.request, operation.options);
						if (requestResponses.length === 0) return [];
						for (const requestResponse of requestResponses) {
							const idx = cache.indexOf(requestResponse);
							assert$1(idx !== -1);
							cache.splice(idx, 1);
						}
					} else if (operation.type === "put") {
						if (operation.response == null) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "put operation should have an associated response"
						});
						const r = operation.request;
						if (!urlIsHttpHttpsScheme(r.url)) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "expected http or https scheme"
						});
						if (r.method !== "GET") throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "not get method"
						});
						if (operation.options != null) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "options must not be defined"
						});
						requestResponses = this.#queryCache(operation.request);
						for (const requestResponse of requestResponses) {
							const idx = cache.indexOf(requestResponse);
							assert$1(idx !== -1);
							cache.splice(idx, 1);
						}
						cache.push([operation.request, operation.response]);
						addedItems.push([operation.request, operation.response]);
					}
					resultList.push([operation.request, operation.response]);
				}
				return resultList;
			} catch (e) {
				this.#relevantRequestResponseList.length = 0;
				this.#relevantRequestResponseList = backupCache;
				throw e;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#query-cache
		* @param {any} requestQuery
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @param {requestResponseList} targetStorage
		* @returns {requestResponseList}
		*/
		#queryCache(requestQuery, options, targetStorage) {
			/** @type {requestResponseList} */
			const resultList = [];
			const storage = targetStorage ?? this.#relevantRequestResponseList;
			for (const requestResponse of storage) {
				const [cachedRequest, cachedResponse] = requestResponse;
				if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) resultList.push(requestResponse);
			}
			return resultList;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
		* @param {any} requestQuery
		* @param {any} request
		* @param {any | null} response
		* @param {import('../../types/cache').CacheQueryOptions | undefined} options
		* @returns {boolean}
		*/
		#requestMatchesCachedItem(requestQuery, request$3, response = null, options) {
			const queryURL = new URL(requestQuery.url);
			const cachedURL = new URL(request$3.url);
			if (options?.ignoreSearch) {
				cachedURL.search = "";
				queryURL.search = "";
			}
			if (!urlEquals(queryURL, cachedURL, true)) return false;
			if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) return true;
			const fieldValues$1 = getFieldValues(response.headersList.get("vary"));
			for (const fieldValue of fieldValues$1) {
				if (fieldValue === "*") return false;
				const requestValue = request$3.headersList.get(fieldValue);
				const queryValue = requestQuery.headersList.get(fieldValue);
				if (requestValue !== queryValue) return false;
			}
			return true;
		}
	};
	Object.defineProperties(Cache$1.prototype, {
		[Symbol.toStringTag]: {
			value: "Cache",
			configurable: true
		},
		match: kEnumerableProperty$3,
		matchAll: kEnumerableProperty$3,
		add: kEnumerableProperty$3,
		addAll: kEnumerableProperty$3,
		put: kEnumerableProperty$3,
		delete: kEnumerableProperty$3,
		keys: kEnumerableProperty$3
	});
	const cacheQueryOptionConverters = [
		{
			key: "ignoreSearch",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreMethod",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreVary",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		}
	];
	webidl$4.converters.CacheQueryOptions = webidl$4.dictionaryConverter(cacheQueryOptionConverters);
	webidl$4.converters.MultiCacheQueryOptions = webidl$4.dictionaryConverter([...cacheQueryOptionConverters, {
		key: "cacheName",
		converter: webidl$4.converters.DOMString
	}]);
	webidl$4.converters.Response = webidl$4.interfaceConverter(Response$2);
	webidl$4.converters["sequence<RequestInfo>"] = webidl$4.sequenceConverter(webidl$4.converters.RequestInfo);
	module.exports = { Cache: Cache$1 };
} });

//#endregion
//#region node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({ "node_modules/undici/lib/cache/cachestorage.js"(exports, module) {
	const { kConstruct } = require_symbols$1();
	const { Cache } = require_cache();
	const { webidl: webidl$3 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$2 } = require_util$8();
	var CacheStorage = class CacheStorage {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
		* @type {Map<string, import('./cache').requestResponseList}
		*/
		#caches = new Map();
		constructor() {
			if (arguments[0] !== kConstruct) webidl$3.illegalConstructor();
		}
		async match(request$3, options = {}) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
			request$3 = webidl$3.converters.RequestInfo(request$3);
			options = webidl$3.converters.MultiCacheQueryOptions(options);
			if (options.cacheName != null) {
				if (this.#caches.has(options.cacheName)) {
					const cacheList = this.#caches.get(options.cacheName);
					const cache = new Cache(kConstruct, cacheList);
					return await cache.match(request$3, options);
				}
			} else for (const cacheList of this.#caches.values()) {
				const cache = new Cache(kConstruct, cacheList);
				const response = await cache.match(request$3, options);
				if (response !== void 0) return response;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-has
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async has(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			return this.#caches.has(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
		* @param {string} cacheName
		* @returns {Promise<Cache>}
		*/
		async open(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			if (this.#caches.has(cacheName)) {
				const cache$1 = this.#caches.get(cacheName);
				return new Cache(kConstruct, cache$1);
			}
			const cache = [];
			this.#caches.set(cacheName, cache);
			return new Cache(kConstruct, cache);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async delete(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			return this.#caches.delete(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
		* @returns {string[]}
		*/
		async keys() {
			webidl$3.brandCheck(this, CacheStorage);
			const keys = this.#caches.keys();
			return [...keys];
		}
	};
	Object.defineProperties(CacheStorage.prototype, {
		[Symbol.toStringTag]: {
			value: "CacheStorage",
			configurable: true
		},
		match: kEnumerableProperty$2,
		has: kEnumerableProperty$2,
		open: kEnumerableProperty$2,
		delete: kEnumerableProperty$2,
		keys: kEnumerableProperty$2
	});
	module.exports = { CacheStorage };
} });

//#endregion
//#region node_modules/undici/lib/cookies/constants.js
var require_constants$2 = __commonJS({ "node_modules/undici/lib/cookies/constants.js"(exports, module) {
	const maxAttributeValueSize$1 = 1024;
	const maxNameValuePairSize$1 = 4096;
	module.exports = {
		maxAttributeValueSize: maxAttributeValueSize$1,
		maxNameValuePairSize: maxNameValuePairSize$1
	};
} });

//#endregion
//#region node_modules/undici/lib/cookies/util.js
var require_util$3 = __commonJS({ "node_modules/undici/lib/cookies/util.js"(exports, module) {
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	function isCTLExcludingHtab$1(value) {
		if (value.length === 0) return false;
		for (const char of value) {
			const code$1 = char.charCodeAt(0);
			if (code$1 >= 0 || code$1 <= 8 || code$1 >= 10 || code$1 <= 31 || code$1 === 127) return false;
		}
	}
	/**
	CHAR           = <any US-ASCII character (octets 0 - 127)>
	token          = 1*<any CHAR except CTLs or separators>
	separators     = "(" | ")" | "<" | ">" | "@"
	| "," | ";" | ":" | "\" | <">
	| "/" | "[" | "]" | "?" | "="
	| "{" | "}" | SP | HT
	* @param {string} name
	*/
	function validateCookieName(name) {
		for (const char of name) {
			const code$1 = char.charCodeAt(0);
			if (code$1 <= 32 || code$1 > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") throw new Error("Invalid cookie name");
		}
	}
	/**
	cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	; US-ASCII characters excluding CTLs,
	; whitespace DQUOTE, comma, semicolon,
	; and backslash
	* @param {string} value
	*/
	function validateCookieValue(value) {
		for (const char of value) {
			const code$1 = char.charCodeAt(0);
			if (code$1 < 33 || code$1 === 34 || code$1 === 44 || code$1 === 59 || code$1 === 92 || code$1 > 126) throw new Error("Invalid header value");
		}
	}
	/**
	* path-value        = <any CHAR except CTLs or ";">
	* @param {string} path
	*/
	function validateCookiePath(path$8) {
		for (const char of path$8) {
			const code$1 = char.charCodeAt(0);
			if (code$1 < 33 || char === ";") throw new Error("Invalid cookie path");
		}
	}
	/**
	* I have no idea why these values aren't allowed to be honest,
	* but Deno tests these. - Khafra
	* @param {string} domain
	*/
	function validateCookieDomain(domain) {
		if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) throw new Error("Invalid cookie domain");
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
	* @param {number|Date} date
	IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
	; fixed length/zone/capitalization subset of the format
	; see Section 3.3 of [RFC5322]
	
	day-name     = %x4D.6F.6E ; "Mon", case-sensitive
	/ %x54.75.65 ; "Tue", case-sensitive
	/ %x57.65.64 ; "Wed", case-sensitive
	/ %x54.68.75 ; "Thu", case-sensitive
	/ %x46.72.69 ; "Fri", case-sensitive
	/ %x53.61.74 ; "Sat", case-sensitive
	/ %x53.75.6E ; "Sun", case-sensitive
	date1        = day SP month SP year
	; e.g., 02 Jun 1982
	
	day          = 2DIGIT
	month        = %x4A.61.6E ; "Jan", case-sensitive
	/ %x46.65.62 ; "Feb", case-sensitive
	/ %x4D.61.72 ; "Mar", case-sensitive
	/ %x41.70.72 ; "Apr", case-sensitive
	/ %x4D.61.79 ; "May", case-sensitive
	/ %x4A.75.6E ; "Jun", case-sensitive
	/ %x4A.75.6C ; "Jul", case-sensitive
	/ %x41.75.67 ; "Aug", case-sensitive
	/ %x53.65.70 ; "Sep", case-sensitive
	/ %x4F.63.74 ; "Oct", case-sensitive
	/ %x4E.6F.76 ; "Nov", case-sensitive
	/ %x44.65.63 ; "Dec", case-sensitive
	year         = 4DIGIT
	
	GMT          = %x47.4D.54 ; "GMT", case-sensitive
	
	time-of-day  = hour ":" minute ":" second
	; 00:00:00 - 23:59:60 (leap second)
	
	hour         = 2DIGIT
	minute       = 2DIGIT
	second       = 2DIGIT
	*/
	function toIMFDate(date) {
		if (typeof date === "number") date = new Date(date);
		const days = [
			"Sun",
			"Mon",
			"Tue",
			"Wed",
			"Thu",
			"Fri",
			"Sat"
		];
		const months = [
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		];
		const dayName = days[date.getUTCDay()];
		const day = date.getUTCDate().toString().padStart(2, "0");
		const month = months[date.getUTCMonth()];
		const year = date.getUTCFullYear();
		const hour = date.getUTCHours().toString().padStart(2, "0");
		const minute = date.getUTCMinutes().toString().padStart(2, "0");
		const second = date.getUTCSeconds().toString().padStart(2, "0");
		return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
	}
	/**
	max-age-av        = "Max-Age=" non-zero-digit *DIGIT
	; In practice, both expires-av and max-age-av
	; are limited to dates representable by the
	; user agent.
	* @param {number} maxAge
	*/
	function validateCookieMaxAge(maxAge) {
		if (maxAge < 0) throw new Error("Invalid cookie max-age");
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
	* @param {import('./index').Cookie} cookie
	*/
	function stringify$2(cookie) {
		if (cookie.name.length === 0) return null;
		validateCookieName(cookie.name);
		validateCookieValue(cookie.value);
		const out = [`${cookie.name}=${cookie.value}`];
		if (cookie.name.startsWith("__Secure-")) cookie.secure = true;
		if (cookie.name.startsWith("__Host-")) {
			cookie.secure = true;
			cookie.domain = null;
			cookie.path = "/";
		}
		if (cookie.secure) out.push("Secure");
		if (cookie.httpOnly) out.push("HttpOnly");
		if (typeof cookie.maxAge === "number") {
			validateCookieMaxAge(cookie.maxAge);
			out.push(`Max-Age=${cookie.maxAge}`);
		}
		if (cookie.domain) {
			validateCookieDomain(cookie.domain);
			out.push(`Domain=${cookie.domain}`);
		}
		if (cookie.path) {
			validateCookiePath(cookie.path);
			out.push(`Path=${cookie.path}`);
		}
		if (cookie.expires && cookie.expires.toString() !== "Invalid Date") out.push(`Expires=${toIMFDate(cookie.expires)}`);
		if (cookie.sameSite) out.push(`SameSite=${cookie.sameSite}`);
		for (const part of cookie.unparsed) {
			if (!part.includes("=")) throw new Error("Invalid unparsed");
			const [key, ...value] = part.split("=");
			out.push(`${key.trim()}=${value.join("=")}`);
		}
		return out.join("; ");
	}
	module.exports = {
		isCTLExcludingHtab: isCTLExcludingHtab$1,
		validateCookieName,
		validateCookiePath,
		validateCookieValue,
		toIMFDate,
		stringify: stringify$2
	};
} });

//#endregion
//#region node_modules/undici/lib/cookies/parse.js
var require_parse$2 = __commonJS({ "node_modules/undici/lib/cookies/parse.js"(exports, module) {
	const { maxNameValuePairSize, maxAttributeValueSize } = require_constants$2();
	const { isCTLExcludingHtab } = require_util$3();
	const { collectASequenceOfCodePointsFast } = require_dataURL();
	const assert = require("assert");
	/**
	* @description Parses the field-value attributes of a set-cookie header string.
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} header
	* @returns if the header is invalid, null will be returned
	*/
	function parseSetCookie$1(header) {
		if (isCTLExcludingHtab(header)) return null;
		let nameValuePair = "";
		let unparsedAttributes = "";
		let name = "";
		let value = "";
		if (header.includes(";")) {
			const position = { position: 0 };
			nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
			unparsedAttributes = header.slice(position.position);
		} else nameValuePair = header;
		if (!nameValuePair.includes("=")) value = nameValuePair;
		else {
			const position = { position: 0 };
			name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
			value = nameValuePair.slice(position.position + 1);
		}
		name = name.trim();
		value = value.trim();
		if (name.length + value.length > maxNameValuePairSize) return null;
		return {
			name,
			value,
			...parseUnparsedAttributes(unparsedAttributes)
		};
	}
	/**
	* Parses the remaining attributes of a set-cookie header
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} unparsedAttributes
	* @param {[Object.<string, unknown>]={}} cookieAttributeList
	*/
	function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
		if (unparsedAttributes.length === 0) return cookieAttributeList;
		assert(unparsedAttributes[0] === ";");
		unparsedAttributes = unparsedAttributes.slice(1);
		let cookieAv = "";
		if (unparsedAttributes.includes(";")) {
			cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
			unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
		} else {
			cookieAv = unparsedAttributes;
			unparsedAttributes = "";
		}
		let attributeName = "";
		let attributeValue = "";
		if (cookieAv.includes("=")) {
			const position = { position: 0 };
			attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
			attributeValue = cookieAv.slice(position.position + 1);
		} else attributeName = cookieAv;
		attributeName = attributeName.trim();
		attributeValue = attributeValue.trim();
		if (attributeValue.length > maxAttributeValueSize) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
		const attributeNameLowercase = attributeName.toLowerCase();
		if (attributeNameLowercase === "expires") {
			const expiryTime = new Date(attributeValue);
			cookieAttributeList.expires = expiryTime;
		} else if (attributeNameLowercase === "max-age") {
			const charCode = attributeValue.charCodeAt(0);
			if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			if (!/^\d+$/.test(attributeValue)) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			const deltaSeconds = Number(attributeValue);
			cookieAttributeList.maxAge = deltaSeconds;
		} else if (attributeNameLowercase === "domain") {
			let cookieDomain = attributeValue;
			if (cookieDomain[0] === ".") cookieDomain = cookieDomain.slice(1);
			cookieDomain = cookieDomain.toLowerCase();
			cookieAttributeList.domain = cookieDomain;
		} else if (attributeNameLowercase === "path") {
			let cookiePath = "";
			if (attributeValue.length === 0 || attributeValue[0] !== "/") cookiePath = "/";
			else cookiePath = attributeValue;
			cookieAttributeList.path = cookiePath;
		} else if (attributeNameLowercase === "secure") cookieAttributeList.secure = true;
		else if (attributeNameLowercase === "httponly") cookieAttributeList.httpOnly = true;
		else if (attributeNameLowercase === "samesite") {
			let enforcement = "Default";
			const attributeValueLowercase = attributeValue.toLowerCase();
			if (attributeValueLowercase.includes("none")) enforcement = "None";
			if (attributeValueLowercase.includes("strict")) enforcement = "Strict";
			if (attributeValueLowercase.includes("lax")) enforcement = "Lax";
			cookieAttributeList.sameSite = enforcement;
		} else {
			cookieAttributeList.unparsed ??= [];
			cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
		}
		return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
	}
	module.exports = {
		parseSetCookie: parseSetCookie$1,
		parseUnparsedAttributes
	};
} });

//#endregion
//#region node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({ "node_modules/undici/lib/cookies/index.js"(exports, module) {
	const { parseSetCookie } = require_parse$2();
	const { stringify: stringify$1 } = require_util$3();
	const { webidl: webidl$2 } = require_webidl();
	const { Headers: Headers$4 } = require_headers();
	/**
	* @typedef {Object} Cookie
	* @property {string} name
	* @property {string} value
	* @property {Date|number|undefined} expires
	* @property {number|undefined} maxAge
	* @property {string|undefined} domain
	* @property {string|undefined} path
	* @property {boolean|undefined} secure
	* @property {boolean|undefined} httpOnly
	* @property {'Strict'|'Lax'|'None'} sameSite
	* @property {string[]} unparsed
	*/
	/**
	* @param {Headers} headers
	* @returns {Record<string, string>}
	*/
	function getCookies(headers) {
		webidl$2.argumentLengthCheck(arguments, 1, { header: "getCookies" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		const cookie = headers.get("cookie");
		const out = {};
		if (!cookie) return out;
		for (const piece of cookie.split(";")) {
			const [name, ...value] = piece.split("=");
			out[name.trim()] = value.join("=");
		}
		return out;
	}
	/**
	* @param {Headers} headers
	* @param {string} name
	* @param {{ path?: string, domain?: string }|undefined} attributes
	* @returns {void}
	*/
	function deleteCookie(headers, name, attributes) {
		webidl$2.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		name = webidl$2.converters.DOMString(name);
		attributes = webidl$2.converters.DeleteCookieAttributes(attributes);
		setCookie(headers, {
			name,
			value: "",
			expires: new Date(0),
			...attributes
		});
	}
	/**
	* @param {Headers} headers
	* @returns {Cookie[]}
	*/
	function getSetCookies(headers) {
		webidl$2.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		const cookies = headers.getSetCookie();
		if (!cookies) return [];
		return cookies.map((pair) => parseSetCookie(pair));
	}
	/**
	* @param {Headers} headers
	* @param {Cookie} cookie
	* @returns {void}
	*/
	function setCookie(headers, cookie) {
		webidl$2.argumentLengthCheck(arguments, 2, { header: "setCookie" });
		webidl$2.brandCheck(headers, Headers$4, { strict: false });
		cookie = webidl$2.converters.Cookie(cookie);
		const str = stringify$1(cookie);
		if (str) headers.append("Set-Cookie", stringify$1(cookie));
	}
	webidl$2.converters.DeleteCookieAttributes = webidl$2.dictionaryConverter([{
		converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
		key: "path",
		defaultValue: null
	}, {
		converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
		key: "domain",
		defaultValue: null
	}]);
	webidl$2.converters.Cookie = webidl$2.dictionaryConverter([
		{
			converter: webidl$2.converters.DOMString,
			key: "name"
		},
		{
			converter: webidl$2.converters.DOMString,
			key: "value"
		},
		{
			converter: webidl$2.nullableConverter((value) => {
				if (typeof value === "number") return webidl$2.converters["unsigned long long"](value);
				return new Date(value);
			}),
			key: "expires",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters["long long"]),
			key: "maxAge",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
			key: "domain",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
			key: "path",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.boolean),
			key: "secure",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.boolean),
			key: "httpOnly",
			defaultValue: null
		},
		{
			converter: webidl$2.converters.USVString,
			key: "sameSite",
			allowedValues: [
				"Strict",
				"Lax",
				"None"
			]
		},
		{
			converter: webidl$2.sequenceConverter(webidl$2.converters.DOMString),
			key: "unparsed",
			defaultValue: []
		}
	]);
	module.exports = {
		getCookies,
		deleteCookie,
		getSetCookies,
		setCookie
	};
} });

//#endregion
//#region node_modules/undici/lib/websocket/constants.js
var require_constants$1 = __commonJS({ "node_modules/undici/lib/websocket/constants.js"(exports, module) {
	const uid$1 = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors$1 = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	const states$4 = {
		CONNECTING: 0,
		OPEN: 1,
		CLOSING: 2,
		CLOSED: 3
	};
	const opcodes$3 = {
		CONTINUATION: 0,
		TEXT: 1,
		BINARY: 2,
		CLOSE: 8,
		PING: 9,
		PONG: 10
	};
	const maxUnsigned16Bit$1 = 2 ** 16 - 1;
	const parserStates$1 = {
		INFO: 0,
		PAYLOADLENGTH_16: 2,
		PAYLOADLENGTH_64: 3,
		READ_DATA: 4
	};
	const emptyBuffer$2 = Buffer.allocUnsafe(0);
	module.exports = {
		uid: uid$1,
		staticPropertyDescriptors: staticPropertyDescriptors$1,
		states: states$4,
		opcodes: opcodes$3,
		maxUnsigned16Bit: maxUnsigned16Bit$1,
		parserStates: parserStates$1,
		emptyBuffer: emptyBuffer$2
	};
} });

//#endregion
//#region node_modules/undici/lib/websocket/symbols.js
var require_symbols = __commonJS({ "node_modules/undici/lib/websocket/symbols.js"(exports, module) {
	module.exports = {
		kWebSocketURL: Symbol("url"),
		kReadyState: Symbol("ready state"),
		kController: Symbol("controller"),
		kResponse: Symbol("response"),
		kBinaryType: Symbol("binary type"),
		kSentClose: Symbol("sent close"),
		kReceivedClose: Symbol("received close"),
		kByteParser: Symbol("byte parser")
	};
} });

//#endregion
//#region node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({ "node_modules/undici/lib/websocket/events.js"(exports, module) {
	const { webidl: webidl$1 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$1 } = require_util$8();
	const { MessagePort } = require("worker_threads");
	/**
	* @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
	*/
	var MessageEvent$2 = class MessageEvent$2 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.MessageEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get data() {
			webidl$1.brandCheck(this, MessageEvent$2);
			return this.#eventInit.data;
		}
		get origin() {
			webidl$1.brandCheck(this, MessageEvent$2);
			return this.#eventInit.origin;
		}
		get lastEventId() {
			webidl$1.brandCheck(this, MessageEvent$2);
			return this.#eventInit.lastEventId;
		}
		get source() {
			webidl$1.brandCheck(this, MessageEvent$2);
			return this.#eventInit.source;
		}
		get ports() {
			webidl$1.brandCheck(this, MessageEvent$2);
			if (!Object.isFrozen(this.#eventInit.ports)) Object.freeze(this.#eventInit.ports);
			return this.#eventInit.ports;
		}
		initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
			webidl$1.brandCheck(this, MessageEvent$2);
			webidl$1.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
			return new MessageEvent$2(type, {
				bubbles,
				cancelable,
				data,
				origin,
				lastEventId,
				source,
				ports
			});
		}
	};
	/**
	* @see https://websockets.spec.whatwg.org/#the-closeevent-interface
	*/
	var CloseEvent$2 = class CloseEvent$2 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.CloseEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get wasClean() {
			webidl$1.brandCheck(this, CloseEvent$2);
			return this.#eventInit.wasClean;
		}
		get code() {
			webidl$1.brandCheck(this, CloseEvent$2);
			return this.#eventInit.code;
		}
		get reason() {
			webidl$1.brandCheck(this, CloseEvent$2);
			return this.#eventInit.reason;
		}
	};
	var ErrorEvent$2 = class ErrorEvent$2 extends Event {
		#eventInit;
		constructor(type, eventInitDict) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
			super(type, eventInitDict);
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.ErrorEventInit(eventInitDict ?? {});
			this.#eventInit = eventInitDict;
		}
		get message() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.message;
		}
		get filename() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.filename;
		}
		get lineno() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.lineno;
		}
		get colno() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.colno;
		}
		get error() {
			webidl$1.brandCheck(this, ErrorEvent$2);
			return this.#eventInit.error;
		}
	};
	Object.defineProperties(MessageEvent$2.prototype, {
		[Symbol.toStringTag]: {
			value: "MessageEvent",
			configurable: true
		},
		data: kEnumerableProperty$1,
		origin: kEnumerableProperty$1,
		lastEventId: kEnumerableProperty$1,
		source: kEnumerableProperty$1,
		ports: kEnumerableProperty$1,
		initMessageEvent: kEnumerableProperty$1
	});
	Object.defineProperties(CloseEvent$2.prototype, {
		[Symbol.toStringTag]: {
			value: "CloseEvent",
			configurable: true
		},
		reason: kEnumerableProperty$1,
		code: kEnumerableProperty$1,
		wasClean: kEnumerableProperty$1
	});
	Object.defineProperties(ErrorEvent$2.prototype, {
		[Symbol.toStringTag]: {
			value: "ErrorEvent",
			configurable: true
		},
		message: kEnumerableProperty$1,
		filename: kEnumerableProperty$1,
		lineno: kEnumerableProperty$1,
		colno: kEnumerableProperty$1,
		error: kEnumerableProperty$1
	});
	webidl$1.converters.MessagePort = webidl$1.interfaceConverter(MessagePort);
	webidl$1.converters["sequence<MessagePort>"] = webidl$1.sequenceConverter(webidl$1.converters.MessagePort);
	const eventInit = [
		{
			key: "bubbles",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		}
	];
	webidl$1.converters.MessageEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "data",
			converter: webidl$1.converters.any,
			defaultValue: null
		},
		{
			key: "origin",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lastEventId",
			converter: webidl$1.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "source",
			converter: webidl$1.nullableConverter(webidl$1.converters.MessagePort),
			defaultValue: null
		},
		{
			key: "ports",
			converter: webidl$1.converters["sequence<MessagePort>"],
			get defaultValue() {
				return [];
			}
		}
	]);
	webidl$1.converters.CloseEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "wasClean",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "code",
			converter: webidl$1.converters["unsigned short"],
			defaultValue: 0
		},
		{
			key: "reason",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		}
	]);
	webidl$1.converters.ErrorEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "message",
			converter: webidl$1.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "filename",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lineno",
			converter: webidl$1.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "colno",
			converter: webidl$1.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "error",
			converter: webidl$1.converters.any
		}
	]);
	module.exports = {
		MessageEvent: MessageEvent$2,
		CloseEvent: CloseEvent$2,
		ErrorEvent: ErrorEvent$2
	};
} });

//#endregion
//#region node_modules/undici/lib/websocket/util.js
var require_util$2 = __commonJS({ "node_modules/undici/lib/websocket/util.js"(exports, module) {
	const { kReadyState: kReadyState$3, kController: kController$1, kResponse: kResponse$2, kBinaryType: kBinaryType$1, kWebSocketURL: kWebSocketURL$1 } = require_symbols();
	const { states: states$3, opcodes: opcodes$2 } = require_constants$1();
	const { MessageEvent: MessageEvent$1, ErrorEvent: ErrorEvent$1 } = require_events();
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isEstablished$1(ws) {
		return ws[kReadyState$3] === states$3.OPEN;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isClosing$1(ws) {
		return ws[kReadyState$3] === states$3.CLOSING;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isClosed(ws) {
		return ws[kReadyState$3] === states$3.CLOSED;
	}
	/**
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e
	* @param {EventTarget} target
	* @param {EventInit | undefined} eventInitDict
	*/
	function fireEvent$2(e, target, eventConstructor = Event, eventInitDict) {
		const event = new eventConstructor(e, eventInitDict);
		target.dispatchEvent(event);
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @param {import('./websocket').WebSocket} ws
	* @param {number} type Opcode
	* @param {Buffer} data application data
	*/
	function websocketMessageReceived$1(ws, type, data) {
		if (ws[kReadyState$3] !== states$3.OPEN) return;
		let dataForEvent;
		if (type === opcodes$2.TEXT) try {
			dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
		} catch {
			failWebsocketConnection$3(ws, "Received invalid UTF-8 in text frame.");
			return;
		}
		else if (type === opcodes$2.BINARY) if (ws[kBinaryType$1] === "blob") dataForEvent = new Blob([data]);
		else dataForEvent = new Uint8Array(data).buffer;
		fireEvent$2("message", ws, MessageEvent$1, {
			origin: ws[kWebSocketURL$1].origin,
			data: dataForEvent
		});
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455
	* @see https://datatracker.ietf.org/doc/html/rfc2616
	* @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
	* @param {string} protocol
	*/
	function isValidSubprotocol$1(protocol) {
		if (protocol.length === 0) return false;
		for (const char of protocol) {
			const code$1 = char.charCodeAt(0);
			if (code$1 < 33 || code$1 > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code$1 === 32 || code$1 === 9) return false;
		}
		return true;
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
	* @param {number} code
	*/
	function isValidStatusCode$4(code$1) {
		if (code$1 >= 1e3 && code$1 < 1015) return code$1 !== 1004 && code$1 !== 1005 && code$1 !== 1006;
		return code$1 >= 3e3 && code$1 <= 4999;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	* @param {string|undefined} reason
	*/
	function failWebsocketConnection$3(ws, reason) {
		const { [kController$1]: controller, [kResponse$2]: response } = ws;
		controller.abort();
		if (response?.socket && !response.socket.destroyed) response.socket.destroy();
		if (reason) fireEvent$2("error", ws, ErrorEvent$1, { error: new Error(reason) });
	}
	module.exports = {
		isEstablished: isEstablished$1,
		isClosing: isClosing$1,
		isClosed,
		fireEvent: fireEvent$2,
		isValidSubprotocol: isValidSubprotocol$1,
		isValidStatusCode: isValidStatusCode$4,
		failWebsocketConnection: failWebsocketConnection$3,
		websocketMessageReceived: websocketMessageReceived$1
	};
} });

//#endregion
//#region node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({ "node_modules/undici/lib/websocket/connection.js"(exports, module) {
	const diagnosticsChannel$1 = require("diagnostics_channel");
	const { uid, states: states$2 } = require_constants$1();
	const { kReadyState: kReadyState$2, kSentClose: kSentClose$2, kByteParser: kByteParser$1, kReceivedClose: kReceivedClose$1 } = require_symbols();
	const { fireEvent: fireEvent$1, failWebsocketConnection: failWebsocketConnection$2 } = require_util$2();
	const { CloseEvent: CloseEvent$1 } = require_events();
	const { makeRequest } = require_request();
	const { fetching } = require_fetch();
	const { Headers: Headers$3 } = require_headers();
	const { getGlobalDispatcher: getGlobalDispatcher$2 } = require_global();
	const { kHeadersList } = require_symbols$4();
	const channels$1 = {};
	channels$1.open = diagnosticsChannel$1.channel("undici:websocket:open");
	channels$1.close = diagnosticsChannel$1.channel("undici:websocket:close");
	channels$1.socketError = diagnosticsChannel$1.channel("undici:websocket:socket_error");
	/** @type {import('crypto')} */
	let crypto$5;
	try {
		crypto$5 = require("crypto");
	} catch {}
	/**
	* @see https://websockets.spec.whatwg.org/#concept-websocket-establish
	* @param {URL} url
	* @param {string|string[]} protocols
	* @param {import('./websocket').WebSocket} ws
	* @param {(response: any) => void} onEstablish
	* @param {Partial<import('../../types/websocket').WebSocketInit>} options
	*/
	function establishWebSocketConnection$1(url, protocols, ws, onEstablish, options) {
		const requestURL = url;
		requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
		const request$3 = makeRequest({
			urlList: [requestURL],
			serviceWorkers: "none",
			referrer: "no-referrer",
			mode: "websocket",
			credentials: "include",
			cache: "no-store",
			redirect: "error"
		});
		if (options.headers) {
			const headersList = new Headers$3(options.headers)[kHeadersList];
			request$3.headersList = headersList;
		}
		const keyValue = crypto$5.randomBytes(16).toString("base64");
		request$3.headersList.append("sec-websocket-key", keyValue);
		request$3.headersList.append("sec-websocket-version", "13");
		for (const protocol of protocols) request$3.headersList.append("sec-websocket-protocol", protocol);
		const permessageDeflate = "";
		const controller = fetching({
			request: request$3,
			useParallelQueue: true,
			dispatcher: options.dispatcher ?? getGlobalDispatcher$2(),
			processResponse(response) {
				if (response.type === "error" || response.status !== 101) {
					failWebsocketConnection$2(ws, "Received network error or non-101 status code.");
					return;
				}
				if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection$2(ws, "Server did not respond with sent protocols.");
					return;
				}
				if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
					failWebsocketConnection$2(ws, "Server did not set Upgrade header to \"websocket\".");
					return;
				}
				if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
					failWebsocketConnection$2(ws, "Server did not set Connection header to \"upgrade\".");
					return;
				}
				const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
				const digest = crypto$5.createHash("sha1").update(keyValue + uid).digest("base64");
				if (secWSAccept !== digest) {
					failWebsocketConnection$2(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
					return;
				}
				const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
				if (secExtension !== null && secExtension !== permessageDeflate) {
					failWebsocketConnection$2(ws, "Received different permessage-deflate than the one set.");
					return;
				}
				const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
				if (secProtocol !== null && secProtocol !== request$3.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection$2(ws, "Protocol was not set in the opening handshake.");
					return;
				}
				response.socket.on("data", onSocketData);
				response.socket.on("close", onSocketClose);
				response.socket.on("error", onSocketError);
				if (channels$1.open.hasSubscribers) channels$1.open.publish({
					address: response.socket.address(),
					protocol: secProtocol,
					extensions: secExtension
				});
				onEstablish(response);
			}
		});
		return controller;
	}
	/**
	* @param {Buffer} chunk
	*/
	function onSocketData(chunk) {
		if (!this.ws[kByteParser$1].write(chunk)) this.pause();
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
	*/
	function onSocketClose() {
		const { ws } = this;
		const wasClean = ws[kSentClose$2] && ws[kReceivedClose$1];
		let code$1 = 1005;
		let reason = "";
		const result = ws[kByteParser$1].closingInfo;
		if (result) {
			code$1 = result.code ?? 1005;
			reason = result.reason;
		} else if (!ws[kSentClose$2]) code$1 = 1006;
		ws[kReadyState$2] = states$2.CLOSED;
		fireEvent$1("close", ws, CloseEvent$1, {
			wasClean,
			code: code$1,
			reason
		});
		if (channels$1.close.hasSubscribers) channels$1.close.publish({
			websocket: ws,
			code: code$1,
			reason
		});
	}
	function onSocketError(error$1) {
		const { ws } = this;
		ws[kReadyState$2] = states$2.CLOSING;
		if (channels$1.socketError.hasSubscribers) channels$1.socketError.publish(error$1);
		this.destroy();
	}
	module.exports = { establishWebSocketConnection: establishWebSocketConnection$1 };
} });

//#endregion
//#region node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({ "node_modules/undici/lib/websocket/frame.js"(exports, module) {
	const { maxUnsigned16Bit } = require_constants$1();
	/** @type {import('crypto')} */
	let crypto$4;
	try {
		crypto$4 = require("crypto");
	} catch {}
	var WebsocketFrameSend$2 = class {
		/**
		* @param {Buffer|undefined} data
		*/
		constructor(data) {
			this.frameData = data;
			this.maskKey = crypto$4.randomBytes(4);
		}
		createFrame(opcode) {
			const bodyLength$1 = this.frameData?.byteLength ?? 0;
			/** @type {number} */
			let payloadLength = bodyLength$1;
			let offset = 6;
			if (bodyLength$1 > maxUnsigned16Bit) {
				offset += 8;
				payloadLength = 127;
			} else if (bodyLength$1 > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const buffer$1 = Buffer.allocUnsafe(bodyLength$1 + offset);
			buffer$1[0] = buffer$1[1] = 0;
			buffer$1[0] |= 128;
			buffer$1[0] = (buffer$1[0] & 240) + opcode;
			/*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
			buffer$1[offset - 4] = this.maskKey[0];
			buffer$1[offset - 3] = this.maskKey[1];
			buffer$1[offset - 2] = this.maskKey[2];
			buffer$1[offset - 1] = this.maskKey[3];
			buffer$1[1] = payloadLength;
			if (payloadLength === 126) buffer$1.writeUInt16BE(bodyLength$1, 2);
			else if (payloadLength === 127) {
				buffer$1[2] = buffer$1[3] = 0;
				buffer$1.writeUIntBE(bodyLength$1, 4, 6);
			}
			buffer$1[1] |= 128;
			for (let i$1 = 0; i$1 < bodyLength$1; i$1++) buffer$1[offset + i$1] = this.frameData[i$1] ^ this.maskKey[i$1 % 4];
			return buffer$1;
		}
	};
	module.exports = { WebsocketFrameSend: WebsocketFrameSend$2 };
} });

//#endregion
//#region node_modules/undici/lib/websocket/receiver.js
var require_receiver$1 = __commonJS({ "node_modules/undici/lib/websocket/receiver.js"(exports, module) {
	const { Writable: Writable$1 } = require("stream");
	const diagnosticsChannel = require("diagnostics_channel");
	const { parserStates, opcodes: opcodes$1, states: states$1, emptyBuffer: emptyBuffer$1 } = require_constants$1();
	const { kReadyState: kReadyState$1, kSentClose: kSentClose$1, kResponse: kResponse$1, kReceivedClose } = require_symbols();
	const { isValidStatusCode: isValidStatusCode$3, failWebsocketConnection: failWebsocketConnection$1, websocketMessageReceived } = require_util$2();
	const { WebsocketFrameSend: WebsocketFrameSend$1 } = require_frame();
	const channels = {};
	channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
	channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
	var ByteParser$1 = class extends Writable$1 {
		#buffers = [];
		#byteOffset = 0;
		#state = parserStates.INFO;
		#info = {};
		#fragments = [];
		constructor(ws) {
			super();
			this.ws = ws;
		}
		/**
		* @param {Buffer} chunk
		* @param {() => void} callback
		*/
		_write(chunk, _, callback) {
			this.#buffers.push(chunk);
			this.#byteOffset += chunk.length;
			this.run(callback);
		}
		/**
		* Runs whenever a new chunk is received.
		* Callback is called whenever there are no more chunks buffering,
		* or not enough bytes are buffered to parse.
		*/
		run(callback) {
			while (true) {
				if (this.#state === parserStates.INFO) {
					if (this.#byteOffset < 2) return callback();
					const buffer$1 = this.consume(2);
					this.#info.fin = (buffer$1[0] & 128) !== 0;
					this.#info.opcode = buffer$1[0] & 15;
					this.#info.originalOpcode ??= this.#info.opcode;
					this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes$1.CONTINUATION;
					if (this.#info.fragmented && this.#info.opcode !== opcodes$1.BINARY && this.#info.opcode !== opcodes$1.TEXT) {
						failWebsocketConnection$1(this.ws, "Invalid frame type was fragmented.");
						return;
					}
					const payloadLength = buffer$1[1] & 127;
					if (payloadLength <= 125) {
						this.#info.payloadLength = payloadLength;
						this.#state = parserStates.READ_DATA;
					} else if (payloadLength === 126) this.#state = parserStates.PAYLOADLENGTH_16;
					else if (payloadLength === 127) this.#state = parserStates.PAYLOADLENGTH_64;
					if (this.#info.fragmented && payloadLength > 125) {
						failWebsocketConnection$1(this.ws, "Fragmented frame exceeded 125 bytes.");
						return;
					} else if ((this.#info.opcode === opcodes$1.PING || this.#info.opcode === opcodes$1.PONG || this.#info.opcode === opcodes$1.CLOSE) && payloadLength > 125) {
						failWebsocketConnection$1(this.ws, "Payload length for control frame exceeded 125 bytes.");
						return;
					} else if (this.#info.opcode === opcodes$1.CLOSE) {
						if (payloadLength === 1) {
							failWebsocketConnection$1(this.ws, "Received close frame with a 1-byte body.");
							return;
						}
						const body = this.consume(payloadLength);
						this.#info.closeInfo = this.parseCloseBody(false, body);
						if (!this.ws[kSentClose$1]) {
							const body$1 = Buffer.allocUnsafe(2);
							body$1.writeUInt16BE(this.#info.closeInfo.code, 0);
							const closeFrame = new WebsocketFrameSend$1(body$1);
							this.ws[kResponse$1].socket.write(closeFrame.createFrame(opcodes$1.CLOSE), (err) => {
								if (!err) this.ws[kSentClose$1] = true;
							});
						}
						this.ws[kReadyState$1] = states$1.CLOSING;
						this.ws[kReceivedClose] = true;
						this.end();
						return;
					} else if (this.#info.opcode === opcodes$1.PING) {
						const body = this.consume(payloadLength);
						if (!this.ws[kReceivedClose]) {
							const frame = new WebsocketFrameSend$1(body);
							this.ws[kResponse$1].socket.write(frame.createFrame(opcodes$1.PONG));
							if (channels.ping.hasSubscribers) channels.ping.publish({ payload: body });
						}
						this.#state = parserStates.INFO;
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					} else if (this.#info.opcode === opcodes$1.PONG) {
						const body = this.consume(payloadLength);
						if (channels.pong.hasSubscribers) channels.pong.publish({ payload: body });
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					}
				} else if (this.#state === parserStates.PAYLOADLENGTH_16) {
					if (this.#byteOffset < 2) return callback();
					const buffer$1 = this.consume(2);
					this.#info.payloadLength = buffer$1.readUInt16BE(0);
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.PAYLOADLENGTH_64) {
					if (this.#byteOffset < 8) return callback();
					const buffer$1 = this.consume(8);
					const upper = buffer$1.readUInt32BE(0);
					if (upper > 2 ** 31 - 1) {
						failWebsocketConnection$1(this.ws, "Received payload length > 2^31 bytes.");
						return;
					}
					const lower = buffer$1.readUInt32BE(4);
					this.#info.payloadLength = (upper << 8) + lower;
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.READ_DATA) {
					if (this.#byteOffset < this.#info.payloadLength) return callback();
					else if (this.#byteOffset >= this.#info.payloadLength) {
						const body = this.consume(this.#info.payloadLength);
						this.#fragments.push(body);
						if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes$1.CONTINUATION) {
							const fullMessage = Buffer.concat(this.#fragments);
							websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
							this.#info = {};
							this.#fragments.length = 0;
						}
						this.#state = parserStates.INFO;
					}
				}
				if (this.#byteOffset > 0) continue;
				else {
					callback();
					break;
				}
			}
		}
		/**
		* Take n bytes from the buffered Buffers
		* @param {number} n
		* @returns {Buffer|null}
		*/
		consume(n) {
			if (n > this.#byteOffset) return null;
			else if (n === 0) return emptyBuffer$1;
			if (this.#buffers[0].length === n) {
				this.#byteOffset -= this.#buffers[0].length;
				return this.#buffers.shift();
			}
			const buffer$1 = Buffer.allocUnsafe(n);
			let offset = 0;
			while (offset !== n) {
				const next = this.#buffers[0];
				const { length } = next;
				if (length + offset === n) {
					buffer$1.set(this.#buffers.shift(), offset);
					break;
				} else if (length + offset > n) {
					buffer$1.set(next.subarray(0, n - offset), offset);
					this.#buffers[0] = next.subarray(n - offset);
					break;
				} else {
					buffer$1.set(this.#buffers.shift(), offset);
					offset += next.length;
				}
			}
			this.#byteOffset -= n;
			return buffer$1;
		}
		parseCloseBody(onlyCode, data) {
			/** @type {number|undefined} */
			let code$1;
			if (data.length >= 2) code$1 = data.readUInt16BE(0);
			if (onlyCode) {
				if (!isValidStatusCode$3(code$1)) return null;
				return { code: code$1 };
			}
			/** @type {Buffer} */
			let reason = data.subarray(2);
			if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) reason = reason.subarray(3);
			if (code$1 !== void 0 && !isValidStatusCode$3(code$1)) return null;
			try {
				reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
			} catch {
				return null;
			}
			return {
				code: code$1,
				reason
			};
		}
		get closingInfo() {
			return this.#info.closeInfo;
		}
	};
	module.exports = { ByteParser: ByteParser$1 };
} });

//#endregion
//#region node_modules/undici/lib/websocket/websocket.js
var require_websocket$1 = __commonJS({ "node_modules/undici/lib/websocket/websocket.js"(exports, module) {
	const { webidl } = require_webidl();
	const { DOMException: DOMException$1 } = require_constants$4();
	const { URLSerializer } = require_dataURL();
	const { getGlobalOrigin } = require_global$1();
	const { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants$1();
	const { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = require_symbols();
	const { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util$2();
	const { establishWebSocketConnection } = require_connection();
	const { WebsocketFrameSend } = require_frame();
	const { ByteParser } = require_receiver$1();
	const { kEnumerableProperty, isBlobLike } = require_util$8();
	const { getGlobalDispatcher: getGlobalDispatcher$1 } = require_global();
	const { types } = require("util");
	let experimentalWarned = false;
	var WebSocket$4 = class WebSocket$4 extends EventTarget {
		#events = {
			open: null,
			error: null,
			close: null,
			message: null
		};
		#bufferedAmount = 0;
		#protocol = "";
		#extensions = "";
		/**
		* @param {string} url
		* @param {string|string[]} protocols
		*/
		constructor(url, protocols = []) {
			super();
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
			if (!experimentalWarned) {
				experimentalWarned = true;
				process.emitWarning("WebSockets are experimental, expect them to change at any time.", { code: "UNDICI-WS" });
			}
			const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
			url = webidl.converters.USVString(url);
			protocols = options.protocols;
			const baseURL = getGlobalOrigin();
			let urlRecord;
			try {
				urlRecord = new URL(url, baseURL);
			} catch (e) {
				throw new DOMException$1(e, "SyntaxError");
			}
			if (urlRecord.protocol === "http:") urlRecord.protocol = "ws:";
			else if (urlRecord.protocol === "https:") urlRecord.protocol = "wss:";
			if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") throw new DOMException$1(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
			if (urlRecord.hash || urlRecord.href.endsWith("#")) throw new DOMException$1("Got fragment", "SyntaxError");
			if (typeof protocols === "string") protocols = [protocols];
			if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) throw new DOMException$1("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) throw new DOMException$1("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			this[kWebSocketURL] = new URL(urlRecord.href);
			this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options);
			this[kReadyState] = WebSocket$4.CONNECTING;
			this[kBinaryType] = "blob";
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-close
		* @param {number|undefined} code
		* @param {string|undefined} reason
		*/
		close(code$1 = void 0, reason = void 0) {
			webidl.brandCheck(this, WebSocket$4);
			if (code$1 !== void 0) code$1 = webidl.converters["unsigned short"](code$1, { clamp: true });
			if (reason !== void 0) reason = webidl.converters.USVString(reason);
			if (code$1 !== void 0) {
				if (code$1 !== 1e3 && (code$1 < 3e3 || code$1 > 4999)) throw new DOMException$1("invalid code", "InvalidAccessError");
			}
			let reasonByteLength = 0;
			if (reason !== void 0) {
				reasonByteLength = Buffer.byteLength(reason);
				if (reasonByteLength > 123) throw new DOMException$1(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
			}
			if (this[kReadyState] === WebSocket$4.CLOSING || this[kReadyState] === WebSocket$4.CLOSED) {} else if (!isEstablished(this)) {
				failWebsocketConnection(this, "Connection was closed before it was established.");
				this[kReadyState] = WebSocket$4.CLOSING;
			} else if (!isClosing(this)) {
				const frame = new WebsocketFrameSend();
				if (code$1 !== void 0 && reason === void 0) {
					frame.frameData = Buffer.allocUnsafe(2);
					frame.frameData.writeUInt16BE(code$1, 0);
				} else if (code$1 !== void 0 && reason !== void 0) {
					frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
					frame.frameData.writeUInt16BE(code$1, 0);
					frame.frameData.write(reason, 2, "utf-8");
				} else frame.frameData = emptyBuffer;
				/** @type {import('stream').Duplex} */
				const socket = this[kResponse].socket;
				socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
					if (!err) this[kSentClose] = true;
				});
				this[kReadyState] = states.CLOSING;
			} else this[kReadyState] = WebSocket$4.CLOSING;
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-send
		* @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
		*/
		send(data) {
			webidl.brandCheck(this, WebSocket$4);
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
			data = webidl.converters.WebSocketSendData(data);
			if (this[kReadyState] === WebSocket$4.CONNECTING) throw new DOMException$1("Sent before connected.", "InvalidStateError");
			if (!isEstablished(this) || isClosing(this)) return;
			/** @type {import('stream').Duplex} */
			const socket = this[kResponse].socket;
			if (typeof data === "string") {
				const value = Buffer.from(data);
				const frame = new WebsocketFrameSend(value);
				const buffer$1 = frame.createFrame(opcodes.TEXT);
				this.#bufferedAmount += value.byteLength;
				socket.write(buffer$1, () => {
					this.#bufferedAmount -= value.byteLength;
				});
			} else if (types.isArrayBuffer(data)) {
				const value = Buffer.from(data);
				const frame = new WebsocketFrameSend(value);
				const buffer$1 = frame.createFrame(opcodes.BINARY);
				this.#bufferedAmount += value.byteLength;
				socket.write(buffer$1, () => {
					this.#bufferedAmount -= value.byteLength;
				});
			} else if (ArrayBuffer.isView(data)) {
				const ab = Buffer.from(data, data.byteOffset, data.byteLength);
				const frame = new WebsocketFrameSend(ab);
				const buffer$1 = frame.createFrame(opcodes.BINARY);
				this.#bufferedAmount += ab.byteLength;
				socket.write(buffer$1, () => {
					this.#bufferedAmount -= ab.byteLength;
				});
			} else if (isBlobLike(data)) {
				const frame = new WebsocketFrameSend();
				data.arrayBuffer().then((ab) => {
					const value = Buffer.from(ab);
					frame.frameData = value;
					const buffer$1 = frame.createFrame(opcodes.BINARY);
					this.#bufferedAmount += value.byteLength;
					socket.write(buffer$1, () => {
						this.#bufferedAmount -= value.byteLength;
					});
				});
			}
		}
		get readyState() {
			webidl.brandCheck(this, WebSocket$4);
			return this[kReadyState];
		}
		get bufferedAmount() {
			webidl.brandCheck(this, WebSocket$4);
			return this.#bufferedAmount;
		}
		get url() {
			webidl.brandCheck(this, WebSocket$4);
			return URLSerializer(this[kWebSocketURL]);
		}
		get extensions() {
			webidl.brandCheck(this, WebSocket$4);
			return this.#extensions;
		}
		get protocol() {
			webidl.brandCheck(this, WebSocket$4);
			return this.#protocol;
		}
		get onopen() {
			webidl.brandCheck(this, WebSocket$4);
			return this.#events.open;
		}
		set onopen(fn) {
			webidl.brandCheck(this, WebSocket$4);
			if (this.#events.open) this.removeEventListener("open", this.#events.open);
			if (typeof fn === "function") {
				this.#events.open = fn;
				this.addEventListener("open", fn);
			} else this.#events.open = null;
		}
		get onerror() {
			webidl.brandCheck(this, WebSocket$4);
			return this.#events.error;
		}
		set onerror(fn) {
			webidl.brandCheck(this, WebSocket$4);
			if (this.#events.error) this.removeEventListener("error", this.#events.error);
			if (typeof fn === "function") {
				this.#events.error = fn;
				this.addEventListener("error", fn);
			} else this.#events.error = null;
		}
		get onclose() {
			webidl.brandCheck(this, WebSocket$4);
			return this.#events.close;
		}
		set onclose(fn) {
			webidl.brandCheck(this, WebSocket$4);
			if (this.#events.close) this.removeEventListener("close", this.#events.close);
			if (typeof fn === "function") {
				this.#events.close = fn;
				this.addEventListener("close", fn);
			} else this.#events.close = null;
		}
		get onmessage() {
			webidl.brandCheck(this, WebSocket$4);
			return this.#events.message;
		}
		set onmessage(fn) {
			webidl.brandCheck(this, WebSocket$4);
			if (this.#events.message) this.removeEventListener("message", this.#events.message);
			if (typeof fn === "function") {
				this.#events.message = fn;
				this.addEventListener("message", fn);
			} else this.#events.message = null;
		}
		get binaryType() {
			webidl.brandCheck(this, WebSocket$4);
			return this[kBinaryType];
		}
		set binaryType(type) {
			webidl.brandCheck(this, WebSocket$4);
			if (type !== "blob" && type !== "arraybuffer") this[kBinaryType] = "blob";
			else this[kBinaryType] = type;
		}
		/**
		* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
		*/
		#onConnectionEstablished(response) {
			this[kResponse] = response;
			const parser = new ByteParser(this);
			parser.on("drain", function onParserDrain() {
				this.ws[kResponse].socket.resume();
			});
			response.socket.ws = this;
			this[kByteParser] = parser;
			this[kReadyState] = states.OPEN;
			const extensions = response.headersList.get("sec-websocket-extensions");
			if (extensions !== null) this.#extensions = extensions;
			const protocol = response.headersList.get("sec-websocket-protocol");
			if (protocol !== null) this.#protocol = protocol;
			fireEvent("open", this);
		}
	};
	WebSocket$4.CONNECTING = WebSocket$4.prototype.CONNECTING = states.CONNECTING;
	WebSocket$4.OPEN = WebSocket$4.prototype.OPEN = states.OPEN;
	WebSocket$4.CLOSING = WebSocket$4.prototype.CLOSING = states.CLOSING;
	WebSocket$4.CLOSED = WebSocket$4.prototype.CLOSED = states.CLOSED;
	Object.defineProperties(WebSocket$4.prototype, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors,
		url: kEnumerableProperty,
		readyState: kEnumerableProperty,
		bufferedAmount: kEnumerableProperty,
		onopen: kEnumerableProperty,
		onerror: kEnumerableProperty,
		onclose: kEnumerableProperty,
		close: kEnumerableProperty,
		onmessage: kEnumerableProperty,
		binaryType: kEnumerableProperty,
		send: kEnumerableProperty,
		extensions: kEnumerableProperty,
		protocol: kEnumerableProperty,
		[Symbol.toStringTag]: {
			value: "WebSocket",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(WebSocket$4, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors
	});
	webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
	webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
		if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) return webidl.converters["sequence<DOMString>"](V);
		return webidl.converters.DOMString(V);
	};
	webidl.converters.WebSocketInit = webidl.dictionaryConverter([
		{
			key: "protocols",
			converter: webidl.converters["DOMString or sequence<DOMString>"],
			get defaultValue() {
				return [];
			}
		},
		{
			key: "dispatcher",
			converter: (V) => V,
			get defaultValue() {
				return getGlobalDispatcher$1();
			}
		},
		{
			key: "headers",
			converter: webidl.nullableConverter(webidl.converters.HeadersInit)
		}
	]);
	webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
		if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) return webidl.converters.WebSocketInit(V);
		return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
	};
	webidl.converters.WebSocketSendData = function(V) {
		if (webidl.util.Type(V) === "Object") {
			if (isBlobLike(V)) return webidl.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) return webidl.converters.BufferSource(V);
		}
		return webidl.converters.USVString(V);
	};
	module.exports = { WebSocket: WebSocket$4 };
} });

//#endregion
//#region node_modules/undici/index.js
var require_undici = __commonJS({ "node_modules/undici/index.js"(exports, module) {
	const Client = require_client();
	const Dispatcher = require_dispatcher();
	const errors = require_errors();
	const Pool = require_pool();
	const BalancedPool = require_balanced_pool();
	const Agent$1 = require_agent();
	const util$6 = require_util$8();
	const { InvalidArgumentError } = errors;
	const api = require_api();
	const buildConnector = require_connect();
	const MockClient = require_mock_client();
	const MockAgent = require_mock_agent();
	const MockPool = require_mock_pool();
	const mockErrors = require_mock_errors();
	const ProxyAgent = require_proxy_agent();
	const RetryHandler = require_RetryHandler();
	const { getGlobalDispatcher, setGlobalDispatcher } = require_global();
	const DecoratorHandler = require_DecoratorHandler();
	const RedirectHandler = require_RedirectHandler();
	const createRedirectInterceptor = require_redirectInterceptor();
	let hasCrypto;
	try {
		require("crypto");
		hasCrypto = true;
	} catch {
		hasCrypto = false;
	}
	Object.assign(Dispatcher.prototype, api);
	module.exports.Dispatcher = Dispatcher;
	module.exports.Client = Client;
	module.exports.Pool = Pool;
	module.exports.BalancedPool = BalancedPool;
	module.exports.Agent = Agent$1;
	module.exports.ProxyAgent = ProxyAgent;
	module.exports.RetryHandler = RetryHandler;
	module.exports.DecoratorHandler = DecoratorHandler;
	module.exports.RedirectHandler = RedirectHandler;
	module.exports.createRedirectInterceptor = createRedirectInterceptor;
	module.exports.buildConnector = buildConnector;
	module.exports.errors = errors;
	function makeDispatcher(fn) {
		return (url, opts, handler$1) => {
			if (typeof opts === "function") {
				handler$1 = opts;
				opts = null;
			}
			if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) throw new InvalidArgumentError("invalid url");
			if (opts != null && typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			if (opts && opts.path != null) {
				if (typeof opts.path !== "string") throw new InvalidArgumentError("invalid opts.path");
				let path$8 = opts.path;
				if (!opts.path.startsWith("/")) path$8 = `/${path$8}`;
				url = new URL(util$6.parseOrigin(url).origin + path$8);
			} else {
				if (!opts) opts = typeof url === "object" ? url : {};
				url = util$6.parseURL(url);
			}
			const { agent, dispatcher = getGlobalDispatcher() } = opts;
			if (agent) throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
			return fn.call(dispatcher, {
				...opts,
				origin: url.origin,
				path: url.search ? `${url.pathname}${url.search}` : url.pathname,
				method: opts.method || (opts.body ? "PUT" : "GET")
			}, handler$1);
		};
	}
	module.exports.setGlobalDispatcher = setGlobalDispatcher;
	module.exports.getGlobalDispatcher = getGlobalDispatcher;
	if (util$6.nodeMajor > 16 || util$6.nodeMajor === 16 && util$6.nodeMinor >= 8) {
		let fetchImpl = null;
		module.exports.fetch = async function fetch$4(resource) {
			if (!fetchImpl) fetchImpl = require_fetch().fetch;
			try {
				return await fetchImpl(...arguments);
			} catch (err) {
				if (typeof err === "object") Error.captureStackTrace(err, this);
				throw err;
			}
		};
		module.exports.Headers = require_headers().Headers;
		module.exports.Response = require_response().Response;
		module.exports.Request = require_request().Request;
		module.exports.FormData = require_formdata().FormData;
		module.exports.File = require_file().File;
		module.exports.FileReader = require_filereader().FileReader;
		const { setGlobalOrigin: setGlobalOrigin$1, getGlobalOrigin: getGlobalOrigin$5 } = require_global$1();
		module.exports.setGlobalOrigin = setGlobalOrigin$1;
		module.exports.getGlobalOrigin = getGlobalOrigin$5;
		const { CacheStorage: CacheStorage$1 } = require_cachestorage();
		const { kConstruct: kConstruct$5 } = require_symbols$1();
		module.exports.caches = new CacheStorage$1(kConstruct$5);
	}
	if (util$6.nodeMajor >= 16) {
		const { deleteCookie: deleteCookie$1, getCookies: getCookies$1, getSetCookies: getSetCookies$1, setCookie: setCookie$1 } = require_cookies();
		module.exports.deleteCookie = deleteCookie$1;
		module.exports.getCookies = getCookies$1;
		module.exports.getSetCookies = getSetCookies$1;
		module.exports.setCookie = setCookie$1;
		const { parseMIMEType: parseMIMEType$4, serializeAMimeType: serializeAMimeType$5 } = require_dataURL();
		module.exports.parseMIMEType = parseMIMEType$4;
		module.exports.serializeAMimeType = serializeAMimeType$5;
	}
	if (util$6.nodeMajor >= 18 && hasCrypto) {
		const { WebSocket: WebSocket$5 } = require_websocket$1();
		module.exports.WebSocket = WebSocket$5;
	}
	module.exports.request = makeDispatcher(api.request);
	module.exports.stream = makeDispatcher(api.stream);
	module.exports.pipeline = makeDispatcher(api.pipeline);
	module.exports.connect = makeDispatcher(api.connect);
	module.exports.upgrade = makeDispatcher(api.upgrade);
	module.exports.MockClient = MockClient;
	module.exports.MockPool = MockPool;
	module.exports.MockAgent = MockAgent;
	module.exports.mockErrors = mockErrors;
} });

//#endregion
//#region node_modules/@actions/http-client/lib/index.js
var require_lib$2 = __commonJS({ "node_modules/@actions/http-client/lib/index.js"(exports) {
	var __createBinding$18 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$15 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$15 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$18(result, mod, k);
		}
		__setModuleDefault$15(result, mod);
		return result;
	};
	var __awaiter$10 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
	const http$5 = __importStar$15(require("http"));
	const https$3 = __importStar$15(require("https"));
	const pm = __importStar$15(require_proxy());
	const tunnel = __importStar$15(require_tunnel());
	const undici_1$1 = require_undici();
	var HttpCodes;
	(function(HttpCodes$1) {
		HttpCodes$1[HttpCodes$1["OK"] = 200] = "OK";
		HttpCodes$1[HttpCodes$1["MultipleChoices"] = 300] = "MultipleChoices";
		HttpCodes$1[HttpCodes$1["MovedPermanently"] = 301] = "MovedPermanently";
		HttpCodes$1[HttpCodes$1["ResourceMoved"] = 302] = "ResourceMoved";
		HttpCodes$1[HttpCodes$1["SeeOther"] = 303] = "SeeOther";
		HttpCodes$1[HttpCodes$1["NotModified"] = 304] = "NotModified";
		HttpCodes$1[HttpCodes$1["UseProxy"] = 305] = "UseProxy";
		HttpCodes$1[HttpCodes$1["SwitchProxy"] = 306] = "SwitchProxy";
		HttpCodes$1[HttpCodes$1["TemporaryRedirect"] = 307] = "TemporaryRedirect";
		HttpCodes$1[HttpCodes$1["PermanentRedirect"] = 308] = "PermanentRedirect";
		HttpCodes$1[HttpCodes$1["BadRequest"] = 400] = "BadRequest";
		HttpCodes$1[HttpCodes$1["Unauthorized"] = 401] = "Unauthorized";
		HttpCodes$1[HttpCodes$1["PaymentRequired"] = 402] = "PaymentRequired";
		HttpCodes$1[HttpCodes$1["Forbidden"] = 403] = "Forbidden";
		HttpCodes$1[HttpCodes$1["NotFound"] = 404] = "NotFound";
		HttpCodes$1[HttpCodes$1["MethodNotAllowed"] = 405] = "MethodNotAllowed";
		HttpCodes$1[HttpCodes$1["NotAcceptable"] = 406] = "NotAcceptable";
		HttpCodes$1[HttpCodes$1["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
		HttpCodes$1[HttpCodes$1["RequestTimeout"] = 408] = "RequestTimeout";
		HttpCodes$1[HttpCodes$1["Conflict"] = 409] = "Conflict";
		HttpCodes$1[HttpCodes$1["Gone"] = 410] = "Gone";
		HttpCodes$1[HttpCodes$1["TooManyRequests"] = 429] = "TooManyRequests";
		HttpCodes$1[HttpCodes$1["InternalServerError"] = 500] = "InternalServerError";
		HttpCodes$1[HttpCodes$1["NotImplemented"] = 501] = "NotImplemented";
		HttpCodes$1[HttpCodes$1["BadGateway"] = 502] = "BadGateway";
		HttpCodes$1[HttpCodes$1["ServiceUnavailable"] = 503] = "ServiceUnavailable";
		HttpCodes$1[HttpCodes$1["GatewayTimeout"] = 504] = "GatewayTimeout";
	})(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
	var Headers$2;
	(function(Headers$9) {
		Headers$9["Accept"] = "accept";
		Headers$9["ContentType"] = "content-type";
	})(Headers$2 || (exports.Headers = Headers$2 = {}));
	var MediaTypes;
	(function(MediaTypes$1) {
		MediaTypes$1["ApplicationJson"] = "application/json";
	})(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
	/**
	* Returns the proxy URL, depending upon the supplied url and proxy environment variables.
	* @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	*/
	function getProxyUrl(serverUrl) {
		const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
		return proxyUrl ? proxyUrl.href : "";
	}
	exports.getProxyUrl = getProxyUrl;
	const HttpRedirectCodes = [
		HttpCodes.MovedPermanently,
		HttpCodes.ResourceMoved,
		HttpCodes.SeeOther,
		HttpCodes.TemporaryRedirect,
		HttpCodes.PermanentRedirect
	];
	const HttpResponseRetryCodes = [
		HttpCodes.BadGateway,
		HttpCodes.ServiceUnavailable,
		HttpCodes.GatewayTimeout
	];
	const RetryableHttpVerbs = [
		"OPTIONS",
		"GET",
		"DELETE",
		"HEAD"
	];
	const ExponentialBackoffCeiling = 10;
	const ExponentialBackoffTimeSlice = 5;
	var HttpClientError = class HttpClientError extends Error {
		constructor(message, statusCode) {
			super(message);
			this.name = "HttpClientError";
			this.statusCode = statusCode;
			Object.setPrototypeOf(this, HttpClientError.prototype);
		}
	};
	exports.HttpClientError = HttpClientError;
	var HttpClientResponse = class {
		constructor(message) {
			this.message = message;
		}
		readBody() {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter$10(this, void 0, void 0, function* () {
					let output = Buffer.alloc(0);
					this.message.on("data", (chunk) => {
						output = Buffer.concat([output, chunk]);
					});
					this.message.on("end", () => {
						resolve(output.toString());
					});
				}));
			});
		}
		readBodyBuffer() {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter$10(this, void 0, void 0, function* () {
					const chunks = [];
					this.message.on("data", (chunk) => {
						chunks.push(chunk);
					});
					this.message.on("end", () => {
						resolve(Buffer.concat(chunks));
					});
				}));
			});
		}
	};
	exports.HttpClientResponse = HttpClientResponse;
	function isHttps(requestUrl) {
		const parsedUrl = new URL(requestUrl);
		return parsedUrl.protocol === "https:";
	}
	exports.isHttps = isHttps;
	var HttpClient = class {
		constructor(userAgent$1, handlers, requestOptions) {
			this._ignoreSslError = false;
			this._allowRedirects = true;
			this._allowRedirectDowngrade = false;
			this._maxRedirects = 50;
			this._allowRetries = false;
			this._maxRetries = 1;
			this._keepAlive = false;
			this._disposed = false;
			this.userAgent = userAgent$1;
			this.handlers = handlers || [];
			this.requestOptions = requestOptions;
			if (requestOptions) {
				if (requestOptions.ignoreSslError != null) this._ignoreSslError = requestOptions.ignoreSslError;
				this._socketTimeout = requestOptions.socketTimeout;
				if (requestOptions.allowRedirects != null) this._allowRedirects = requestOptions.allowRedirects;
				if (requestOptions.allowRedirectDowngrade != null) this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
				if (requestOptions.maxRedirects != null) this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
				if (requestOptions.keepAlive != null) this._keepAlive = requestOptions.keepAlive;
				if (requestOptions.allowRetries != null) this._allowRetries = requestOptions.allowRetries;
				if (requestOptions.maxRetries != null) this._maxRetries = requestOptions.maxRetries;
			}
		}
		options(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
			});
		}
		get(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("GET", requestUrl, null, additionalHeaders || {});
			});
		}
		del(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("DELETE", requestUrl, null, additionalHeaders || {});
			});
		}
		post(requestUrl, data, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("POST", requestUrl, data, additionalHeaders || {});
			});
		}
		patch(requestUrl, data, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("PATCH", requestUrl, data, additionalHeaders || {});
			});
		}
		put(requestUrl, data, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("PUT", requestUrl, data, additionalHeaders || {});
			});
		}
		head(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("HEAD", requestUrl, null, additionalHeaders || {});
			});
		}
		sendStream(verb, requestUrl, stream$6, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request(verb, requestUrl, stream$6, additionalHeaders);
			});
		}
		/**
		* Gets a typed object from an endpoint
		* Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
		*/
		getJson(requestUrl, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				const res = yield this.get(requestUrl, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		postJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.post(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		putJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.put(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		patchJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$2.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.patch(requestUrl, data, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		/**
		* Makes a raw http request.
		* All other methods such as get, post, patch, and request ultimately call this.
		* Prefer get, del, post and patch
		*/
		request(verb, requestUrl, data, headers) {
			return __awaiter$10(this, void 0, void 0, function* () {
				if (this._disposed) throw new Error("Client has already been disposed.");
				const parsedUrl = new URL(requestUrl);
				let info$1 = this._prepareRequest(verb, parsedUrl, headers);
				const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
				let numTries = 0;
				let response;
				do {
					response = yield this.requestRaw(info$1, data);
					if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
						let authenticationHandler;
						for (const handler$1 of this.handlers) if (handler$1.canHandleAuthentication(response)) {
							authenticationHandler = handler$1;
							break;
						}
						if (authenticationHandler) return authenticationHandler.handleAuthentication(this, info$1, data);
						else return response;
					}
					let redirectsRemaining = this._maxRedirects;
					while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
						const redirectUrl = response.message.headers["location"];
						if (!redirectUrl) break;
						const parsedRedirectUrl = new URL(redirectUrl);
						if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
						yield response.readBody();
						if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
							for (const header in headers) if (header.toLowerCase() === "authorization") delete headers[header];
						}
						info$1 = this._prepareRequest(verb, parsedRedirectUrl, headers);
						response = yield this.requestRaw(info$1, data);
						redirectsRemaining--;
					}
					if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) return response;
					numTries += 1;
					if (numTries < maxTries) {
						yield response.readBody();
						yield this._performExponentialBackoff(numTries);
					}
				} while (numTries < maxTries);
				return response;
			});
		}
		/**
		* Needs to be called if keepAlive is set to true in request options.
		*/
		dispose() {
			if (this._agent) this._agent.destroy();
			this._disposed = true;
		}
		/**
		* Raw request.
		* @param info
		* @param data
		*/
		requestRaw(info$1, data) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => {
					function callbackForResult(err, res) {
						if (err) reject(err);
						else if (!res) reject(new Error("Unknown error"));
						else resolve(res);
					}
					this.requestRawWithCallback(info$1, data, callbackForResult);
				});
			});
		}
		/**
		* Raw request with callback.
		* @param info
		* @param data
		* @param onResult
		*/
		requestRawWithCallback(info$1, data, onResult) {
			if (typeof data === "string") {
				if (!info$1.options.headers) info$1.options.headers = {};
				info$1.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
			}
			let callbackCalled = false;
			function handleResult(err, res) {
				if (!callbackCalled) {
					callbackCalled = true;
					onResult(err, res);
				}
			}
			const req$1 = info$1.httpModule.request(info$1.options, (msg) => {
				const res = new HttpClientResponse(msg);
				handleResult(void 0, res);
			});
			let socket;
			req$1.on("socket", (sock) => {
				socket = sock;
			});
			req$1.setTimeout(this._socketTimeout || 3 * 6e4, () => {
				if (socket) socket.end();
				handleResult(new Error(`Request timeout: ${info$1.options.path}`));
			});
			req$1.on("error", function(err) {
				handleResult(err);
			});
			if (data && typeof data === "string") req$1.write(data, "utf8");
			if (data && typeof data !== "string") {
				data.on("close", function() {
					req$1.end();
				});
				data.pipe(req$1);
			} else req$1.end();
		}
		/**
		* Gets an http agent. This function is useful when you need an http agent that handles
		* routing through a proxy server - depending upon the url and proxy environment variables.
		* @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
		*/
		getAgent(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			return this._getAgent(parsedUrl);
		}
		getAgentDispatcher(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			const useProxy = proxyUrl && proxyUrl.hostname;
			if (!useProxy) return;
			return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
		}
		_prepareRequest(method, requestUrl, headers) {
			const info$1 = {};
			info$1.parsedUrl = requestUrl;
			const usingSsl = info$1.parsedUrl.protocol === "https:";
			info$1.httpModule = usingSsl ? https$3 : http$5;
			const defaultPort$1 = usingSsl ? 443 : 80;
			info$1.options = {};
			info$1.options.host = info$1.parsedUrl.hostname;
			info$1.options.port = info$1.parsedUrl.port ? parseInt(info$1.parsedUrl.port) : defaultPort$1;
			info$1.options.path = (info$1.parsedUrl.pathname || "") + (info$1.parsedUrl.search || "");
			info$1.options.method = method;
			info$1.options.headers = this._mergeHeaders(headers);
			if (this.userAgent != null) info$1.options.headers["user-agent"] = this.userAgent;
			info$1.options.agent = this._getAgent(info$1.parsedUrl);
			if (this.handlers) for (const handler$1 of this.handlers) handler$1.prepareRequest(info$1.options);
			return info$1;
		}
		_mergeHeaders(headers) {
			if (this.requestOptions && this.requestOptions.headers) return Object.assign({}, lowercaseKeys$1(this.requestOptions.headers), lowercaseKeys$1(headers || {}));
			return lowercaseKeys$1(headers || {});
		}
		_getExistingOrDefaultHeader(additionalHeaders, header, _default$13) {
			let clientHeader;
			if (this.requestOptions && this.requestOptions.headers) clientHeader = lowercaseKeys$1(this.requestOptions.headers)[header];
			return additionalHeaders[header] || clientHeader || _default$13;
		}
		_getAgent(parsedUrl) {
			let agent;
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			const useProxy = proxyUrl && proxyUrl.hostname;
			if (this._keepAlive && useProxy) agent = this._proxyAgent;
			if (!useProxy) agent = this._agent;
			if (agent) return agent;
			const usingSsl = parsedUrl.protocol === "https:";
			let maxSockets = 100;
			if (this.requestOptions) maxSockets = this.requestOptions.maxSockets || http$5.globalAgent.maxSockets;
			if (proxyUrl && proxyUrl.hostname) {
				const agentOptions = {
					maxSockets,
					keepAlive: this._keepAlive,
					proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && { proxyAuth: `${proxyUrl.username}:${proxyUrl.password}` }), {
						host: proxyUrl.hostname,
						port: proxyUrl.port
					})
				};
				let tunnelAgent;
				const overHttps = proxyUrl.protocol === "https:";
				if (usingSsl) tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
				else tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
				agent = tunnelAgent(agentOptions);
				this._proxyAgent = agent;
			}
			if (!agent) {
				const options = {
					keepAlive: this._keepAlive,
					maxSockets
				};
				agent = usingSsl ? new https$3.Agent(options) : new http$5.Agent(options);
				this._agent = agent;
			}
			if (usingSsl && this._ignoreSslError) agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });
			return agent;
		}
		_getProxyAgentDispatcher(parsedUrl, proxyUrl) {
			let proxyAgent;
			if (this._keepAlive) proxyAgent = this._proxyAgentDispatcher;
			if (proxyAgent) return proxyAgent;
			const usingSsl = parsedUrl.protocol === "https:";
			proxyAgent = new undici_1$1.ProxyAgent(Object.assign({
				uri: proxyUrl.href,
				pipelining: !this._keepAlive ? 0 : 1
			}, (proxyUrl.username || proxyUrl.password) && { token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}` }));
			this._proxyAgentDispatcher = proxyAgent;
			if (usingSsl && this._ignoreSslError) proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, { rejectUnauthorized: false });
			return proxyAgent;
		}
		_performExponentialBackoff(retryNumber) {
			return __awaiter$10(this, void 0, void 0, function* () {
				retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
				const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
				return new Promise((resolve) => setTimeout(() => resolve(), ms));
			});
		}
		_processResponse(res, options) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => __awaiter$10(this, void 0, void 0, function* () {
					const statusCode = res.message.statusCode || 0;
					const response = {
						statusCode,
						result: null,
						headers: {}
					};
					if (statusCode === HttpCodes.NotFound) resolve(response);
					function dateTimeDeserializer(key, value) {
						if (typeof value === "string") {
							const a$1 = new Date(value);
							if (!isNaN(a$1.valueOf())) return a$1;
						}
						return value;
					}
					let obj;
					let contents;
					try {
						contents = yield res.readBody();
						if (contents && contents.length > 0) {
							if (options && options.deserializeDates) obj = JSON.parse(contents, dateTimeDeserializer);
							else obj = JSON.parse(contents);
							response.result = obj;
						}
						response.headers = res.message.headers;
					} catch (err) {}
					if (statusCode > 299) {
						let msg;
						if (obj && obj.message) msg = obj.message;
						else if (contents && contents.length > 0) msg = contents;
						else msg = `Failed request: (${statusCode})`;
						const err = new HttpClientError(msg, statusCode);
						err.result = response.result;
						reject(err);
					} else resolve(response);
				}));
			});
		}
	};
	exports.HttpClient = HttpClient;
	const lowercaseKeys$1 = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
} });

//#endregion
//#region node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({ "node_modules/@actions/http-client/lib/auth.js"(exports) {
	var __awaiter$9 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
	var BasicCredentialHandler = class {
		constructor(username, password) {
			this.username = username;
			this.password = password;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BasicCredentialHandler = BasicCredentialHandler;
	var BearerCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Bearer ${this.token}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BearerCredentialHandler = BearerCredentialHandler;
	var PersonalAccessTokenCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
} });

//#endregion
//#region node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({ "node_modules/@actions/core/lib/oidc-utils.js"(exports) {
	var __awaiter$8 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OidcClient = void 0;
	const http_client_1 = require_lib$2();
	const auth_1 = require_auth();
	const core_1$1 = require_core();
	var OidcClient = class OidcClient {
		static createHttpClient(allowRetry = true, maxRetry = 10) {
			const requestOptions = {
				allowRetries: allowRetry,
				maxRetries: maxRetry
			};
			return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
		}
		static getRequestToken() {
			const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
			if (!token) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
			return token;
		}
		static getIDTokenUrl() {
			const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
			if (!runtimeUrl) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
			return runtimeUrl;
		}
		static getCall(id_token_url) {
			var _a$5;
			return __awaiter$8(this, void 0, void 0, function* () {
				const httpclient = OidcClient.createHttpClient();
				const res = yield httpclient.getJson(id_token_url).catch((error$1) => {
					throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error$1.statusCode}\n 
        Error Message: ${error$1.message}`);
				});
				const id_token = (_a$5 = res.result) === null || _a$5 === void 0 ? void 0 : _a$5.value;
				if (!id_token) throw new Error("Response json body do not have ID Token field");
				return id_token;
			});
		}
		static getIDToken(audience) {
			return __awaiter$8(this, void 0, void 0, function* () {
				try {
					let id_token_url = OidcClient.getIDTokenUrl();
					if (audience) {
						const encodedAudience = encodeURIComponent(audience);
						id_token_url = `${id_token_url}&audience=${encodedAudience}`;
					}
					(0, core_1$1.debug)(`ID token url is ${id_token_url}`);
					const id_token = yield OidcClient.getCall(id_token_url);
					(0, core_1$1.setSecret)(id_token);
					return id_token;
				} catch (error$1) {
					throw new Error(`Error message: ${error$1.message}`);
				}
			});
		}
	};
	exports.OidcClient = OidcClient;
} });

//#endregion
//#region node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({ "node_modules/@actions/core/lib/summary.js"(exports) {
	var __awaiter$7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
	const os_1$3 = require("os");
	const fs_1$2 = require("fs");
	const { access, appendFile, writeFile } = fs_1$2.promises;
	exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
	exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
	var Summary = class {
		constructor() {
			this._buffer = "";
		}
		/**
		* Finds the summary file path from the environment, rejects if env var is not found or file does not exist
		* Also checks r/w permissions.
		*
		* @returns step summary file path
		*/
		filePath() {
			return __awaiter$7(this, void 0, void 0, function* () {
				if (this._filePath) return this._filePath;
				const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
				if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
				try {
					yield access(pathFromEnv, fs_1$2.constants.R_OK | fs_1$2.constants.W_OK);
				} catch (_a$5) {
					throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
				}
				this._filePath = pathFromEnv;
				return this._filePath;
			});
		}
		/**
		* Wraps content in an HTML tag, adding any HTML attributes
		*
		* @param {string} tag HTML tag to wrap
		* @param {string | null} content content within the tag
		* @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
		*
		* @returns {string} content wrapped in HTML element
		*/
		wrap(tag, content, attrs = {}) {
			const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
			if (!content) return `<${tag}${htmlAttrs}>`;
			return `<${tag}${htmlAttrs}>${content}</${tag}>`;
		}
		/**
		* Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
		*
		* @param {SummaryWriteOptions} [options] (optional) options for write operation
		*
		* @returns {Promise<Summary>} summary instance
		*/
		write(options) {
			return __awaiter$7(this, void 0, void 0, function* () {
				const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
				const filePath = yield this.filePath();
				const writeFunc = overwrite ? writeFile : appendFile;
				yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
				return this.emptyBuffer();
			});
		}
		/**
		* Clears the summary buffer and wipes the summary file
		*
		* @returns {Summary} summary instance
		*/
		clear() {
			return __awaiter$7(this, void 0, void 0, function* () {
				return this.emptyBuffer().write({ overwrite: true });
			});
		}
		/**
		* Returns the current summary buffer as a string
		*
		* @returns {string} string of summary buffer
		*/
		stringify() {
			return this._buffer;
		}
		/**
		* If the summary buffer is empty
		*
		* @returns {boolen} true if the buffer is empty
		*/
		isEmptyBuffer() {
			return this._buffer.length === 0;
		}
		/**
		* Resets the summary buffer without writing to summary file
		*
		* @returns {Summary} summary instance
		*/
		emptyBuffer() {
			this._buffer = "";
			return this;
		}
		/**
		* Adds raw text to the summary buffer
		*
		* @param {string} text content to add
		* @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
		*
		* @returns {Summary} summary instance
		*/
		addRaw(text, addEOL = false) {
			this._buffer += text;
			return addEOL ? this.addEOL() : this;
		}
		/**
		* Adds the operating system-specific end-of-line marker to the buffer
		*
		* @returns {Summary} summary instance
		*/
		addEOL() {
			return this.addRaw(os_1$3.EOL);
		}
		/**
		* Adds an HTML codeblock to the summary buffer
		*
		* @param {string} code content to render within fenced code block
		* @param {string} lang (optional) language to syntax highlight code
		*
		* @returns {Summary} summary instance
		*/
		addCodeBlock(code$1, lang) {
			const attrs = Object.assign({}, lang && { lang });
			const element = this.wrap("pre", this.wrap("code", code$1), attrs);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML list to the summary buffer
		*
		* @param {string[]} items list of items to render
		* @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
		*
		* @returns {Summary} summary instance
		*/
		addList(items, ordered = false) {
			const tag = ordered ? "ol" : "ul";
			const listItems = items.map((item) => this.wrap("li", item)).join("");
			const element = this.wrap(tag, listItems);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML table to the summary buffer
		*
		* @param {SummaryTableCell[]} rows table rows
		*
		* @returns {Summary} summary instance
		*/
		addTable(rows) {
			const tableBody = rows.map((row) => {
				const cells = row.map((cell) => {
					if (typeof cell === "string") return this.wrap("td", cell);
					const { header, data, colspan, rowspan } = cell;
					const tag = header ? "th" : "td";
					const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
					return this.wrap(tag, data, attrs);
				}).join("");
				return this.wrap("tr", cells);
			}).join("");
			const element = this.wrap("table", tableBody);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds a collapsable HTML details element to the summary buffer
		*
		* @param {string} label text for the closed state
		* @param {string} content collapsable content
		*
		* @returns {Summary} summary instance
		*/
		addDetails(label, content) {
			const element = this.wrap("details", this.wrap("summary", label) + content);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML image tag to the summary buffer
		*
		* @param {string} src path to the image you to embed
		* @param {string} alt text description of the image
		* @param {SummaryImageOptions} options (optional) addition image attributes
		*
		* @returns {Summary} summary instance
		*/
		addImage(src, alt, options) {
			const { width, height } = options || {};
			const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
			const element = this.wrap("img", null, Object.assign({
				src,
				alt
			}, attrs));
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML section heading element
		*
		* @param {string} text heading text
		* @param {number | string} [level=1] (optional) the heading level, default: 1
		*
		* @returns {Summary} summary instance
		*/
		addHeading(text, level) {
			const tag = `h${level}`;
			const allowedTag = [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			].includes(tag) ? tag : "h1";
			const element = this.wrap(allowedTag, text);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML thematic break (<hr>) to the summary buffer
		*
		* @returns {Summary} summary instance
		*/
		addSeparator() {
			const element = this.wrap("hr", null);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML line break (<br>) to the summary buffer
		*
		* @returns {Summary} summary instance
		*/
		addBreak() {
			const element = this.wrap("br", null);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML blockquote to the summary buffer
		*
		* @param {string} text quote text
		* @param {string} cite (optional) citation url
		*
		* @returns {Summary} summary instance
		*/
		addQuote(text, cite) {
			const attrs = Object.assign({}, cite && { cite });
			const element = this.wrap("blockquote", text, attrs);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML anchor tag to the summary buffer
		*
		* @param {string} text link text/content
		* @param {string} href hyperlink
		*
		* @returns {Summary} summary instance
		*/
		addLink(text, href) {
			const element = this.wrap("a", text, { href });
			return this.addRaw(element).addEOL();
		}
	};
	const _summary = new Summary();
	/**
	* @deprecated use `core.summary`
	*/
	exports.markdownSummary = _summary;
	exports.summary = _summary;
} });

//#endregion
//#region node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({ "node_modules/@actions/core/lib/path-utils.js"(exports) {
	var __createBinding$17 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$14 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$14 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$17(result, mod, k);
		}
		__setModuleDefault$14(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
	const path$7 = __importStar$14(require("path"));
	/**
	* toPosixPath converts the given path to the posix form. On Windows, \\ will be
	* replaced with /.
	*
	* @param pth. Path to transform.
	* @return string Posix path.
	*/
	function toPosixPath(pth) {
		return pth.replace(/[\\]/g, "/");
	}
	exports.toPosixPath = toPosixPath;
	/**
	* toWin32Path converts the given path to the win32 form. On Linux, / will be
	* replaced with \\.
	*
	* @param pth. Path to transform.
	* @return string Win32 path.
	*/
	function toWin32Path(pth) {
		return pth.replace(/[/]/g, "\\");
	}
	exports.toWin32Path = toWin32Path;
	/**
	* toPlatformPath converts the given path to a platform-specific path. It does
	* this by replacing instances of / and \ with the platform-specific path
	* separator.
	*
	* @param pth The path to platformize.
	* @return string The platform-specific path.
	*/
	function toPlatformPath(pth) {
		return pth.replace(/[/\\]/g, path$7.sep);
	}
	exports.toPlatformPath = toPlatformPath;
} });

//#endregion
//#region node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({ "node_modules/@actions/io/lib/io-util.js"(exports) {
	var __createBinding$16 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		});
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$13 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$13 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$16(result, mod, k);
		}
		__setModuleDefault$13(result, mod);
		return result;
	};
	var __awaiter$6 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var _a$4;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
	const fs$7 = __importStar$13(require("fs"));
	const path$6 = __importStar$13(require("path"));
	_a$4 = fs$7.promises, exports.chmod = _a$4.chmod, exports.copyFile = _a$4.copyFile, exports.lstat = _a$4.lstat, exports.mkdir = _a$4.mkdir, exports.open = _a$4.open, exports.readdir = _a$4.readdir, exports.readlink = _a$4.readlink, exports.rename = _a$4.rename, exports.rm = _a$4.rm, exports.rmdir = _a$4.rmdir, exports.stat = _a$4.stat, exports.symlink = _a$4.symlink, exports.unlink = _a$4.unlink;
	exports.IS_WINDOWS = process.platform === "win32";
	exports.UV_FS_O_EXLOCK = 268435456;
	exports.READONLY = fs$7.constants.O_RDONLY;
	function exists(fsPath) {
		return __awaiter$6(this, void 0, void 0, function* () {
			try {
				yield exports.stat(fsPath);
			} catch (err) {
				if (err.code === "ENOENT") return false;
				throw err;
			}
			return true;
		});
	}
	exports.exists = exists;
	function isDirectory(fsPath, useStat = false) {
		return __awaiter$6(this, void 0, void 0, function* () {
			const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
			return stats.isDirectory();
		});
	}
	exports.isDirectory = isDirectory;
	/**
	* On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
	* \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
	*/
	function isRooted(p) {
		p = normalizeSeparators(p);
		if (!p) throw new Error("isRooted() parameter \"p\" cannot be empty");
		if (exports.IS_WINDOWS) return p.startsWith("\\") || /^[A-Z]:/i.test(p);
		return p.startsWith("/");
	}
	exports.isRooted = isRooted;
	/**
	* Best effort attempt to determine whether a file exists and is executable.
	* @param filePath    file path to check
	* @param extensions  additional file extensions to try
	* @return if file exists and is executable, returns the file path. otherwise empty string.
	*/
	function tryGetExecutablePath(filePath, extensions) {
		return __awaiter$6(this, void 0, void 0, function* () {
			let stats = void 0;
			try {
				stats = yield exports.stat(filePath);
			} catch (err) {
				if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
			}
			if (stats && stats.isFile()) {
				if (exports.IS_WINDOWS) {
					const upperExt = path$6.extname(filePath).toUpperCase();
					if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) return filePath;
				} else if (isUnixExecutable(stats)) return filePath;
			}
			const originalFilePath = filePath;
			for (const extension$1 of extensions) {
				filePath = originalFilePath + extension$1;
				stats = void 0;
				try {
					stats = yield exports.stat(filePath);
				} catch (err) {
					if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
				}
				if (stats && stats.isFile()) {
					if (exports.IS_WINDOWS) {
						try {
							const directory = path$6.dirname(filePath);
							const upperName = path$6.basename(filePath).toUpperCase();
							for (const actualName of yield exports.readdir(directory)) if (upperName === actualName.toUpperCase()) {
								filePath = path$6.join(directory, actualName);
								break;
							}
						} catch (err) {
							console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
						}
						return filePath;
					} else if (isUnixExecutable(stats)) return filePath;
				}
			}
			return "";
		});
	}
	exports.tryGetExecutablePath = tryGetExecutablePath;
	function normalizeSeparators(p) {
		p = p || "";
		if (exports.IS_WINDOWS) {
			p = p.replace(/\//g, "\\");
			return p.replace(/\\\\+/g, "\\");
		}
		return p.replace(/\/\/+/g, "/");
	}
	function isUnixExecutable(stats) {
		return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
	}
	function getCmdPath() {
		var _a$5;
		return (_a$5 = process.env["COMSPEC"]) !== null && _a$5 !== void 0 ? _a$5 : `cmd.exe`;
	}
	exports.getCmdPath = getCmdPath;
} });

//#endregion
//#region node_modules/@actions/io/lib/io.js
var require_io = __commonJS({ "node_modules/@actions/io/lib/io.js"(exports) {
	var __createBinding$15 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		});
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$12 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$12 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$15(result, mod, k);
		}
		__setModuleDefault$12(result, mod);
		return result;
	};
	var __awaiter$5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
	const assert_1$1 = require("assert");
	const path$5 = __importStar$12(require("path"));
	const ioUtil$1 = __importStar$12(require_io_util());
	/**
	* Copies a file or folder.
	* Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
	*
	* @param     source    source path
	* @param     dest      destination path
	* @param     options   optional. See CopyOptions.
	*/
	function cp(source, dest, options = {}) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const { force, recursive, copySourceDirectory } = readCopyOptions(options);
			const destStat = (yield ioUtil$1.exists(dest)) ? yield ioUtil$1.stat(dest) : null;
			if (destStat && destStat.isFile() && !force) return;
			const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path$5.join(dest, path$5.basename(source)) : dest;
			if (!(yield ioUtil$1.exists(source))) throw new Error(`no such file or directory: ${source}`);
			const sourceStat = yield ioUtil$1.stat(source);
			if (sourceStat.isDirectory()) if (!recursive) throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
			else yield cpDirRecursive(source, newDest, 0, force);
			else {
				if (path$5.relative(source, newDest) === "") throw new Error(`'${newDest}' and '${source}' are the same file`);
				yield copyFile(source, newDest, force);
			}
		});
	}
	exports.cp = cp;
	/**
	* Moves a path.
	*
	* @param     source    source path
	* @param     dest      destination path
	* @param     options   optional. See MoveOptions.
	*/
	function mv(source, dest, options = {}) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (yield ioUtil$1.exists(dest)) {
				let destExists = true;
				if (yield ioUtil$1.isDirectory(dest)) {
					dest = path$5.join(dest, path$5.basename(source));
					destExists = yield ioUtil$1.exists(dest);
				}
				if (destExists) if (options.force == null || options.force) yield rmRF(dest);
				else throw new Error("Destination already exists");
			}
			yield mkdirP(path$5.dirname(dest));
			yield ioUtil$1.rename(source, dest);
		});
	}
	exports.mv = mv;
	/**
	* Remove a path recursively with force
	*
	* @param inputPath path to remove
	*/
	function rmRF(inputPath) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (ioUtil$1.IS_WINDOWS) {
				if (/[*"<>|]/.test(inputPath)) throw new Error("File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows");
			}
			try {
				yield ioUtil$1.rm(inputPath, {
					force: true,
					maxRetries: 3,
					recursive: true,
					retryDelay: 300
				});
			} catch (err) {
				throw new Error(`File was unable to be removed ${err}`);
			}
		});
	}
	exports.rmRF = rmRF;
	/**
	* Make a directory.  Creates the full path with folders in between
	* Will throw if it fails
	*
	* @param   fsPath        path to create
	* @returns Promise<void>
	*/
	function mkdirP(fsPath) {
		return __awaiter$5(this, void 0, void 0, function* () {
			assert_1$1.ok(fsPath, "a path argument must be provided");
			yield ioUtil$1.mkdir(fsPath, { recursive: true });
		});
	}
	exports.mkdirP = mkdirP;
	/**
	* Returns path of a tool had the tool actually been invoked.  Resolves via paths.
	* If you check and the tool does not exist, it will throw.
	*
	* @param     tool              name of the tool
	* @param     check             whether to check if tool exists
	* @returns   Promise<string>   path to tool
	*/
	function which(tool, check) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			if (check) {
				const result = yield which(tool, false);
				if (!result) if (ioUtil$1.IS_WINDOWS) throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
				else throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
				return result;
			}
			const matches = yield findInPath(tool);
			if (matches && matches.length > 0) return matches[0];
			return "";
		});
	}
	exports.which = which;
	/**
	* Returns a list of all occurrences of the given tool on the system path.
	*
	* @returns   Promise<string[]>  the paths of the tool
	*/
	function findInPath(tool) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			const extensions = [];
			if (ioUtil$1.IS_WINDOWS && process.env["PATHEXT"]) {
				for (const extension$1 of process.env["PATHEXT"].split(path$5.delimiter)) if (extension$1) extensions.push(extension$1);
			}
			if (ioUtil$1.isRooted(tool)) {
				const filePath = yield ioUtil$1.tryGetExecutablePath(tool, extensions);
				if (filePath) return [filePath];
				return [];
			}
			if (tool.includes(path$5.sep)) return [];
			const directories = [];
			if (process.env.PATH) {
				for (const p of process.env.PATH.split(path$5.delimiter)) if (p) directories.push(p);
			}
			const matches = [];
			for (const directory of directories) {
				const filePath = yield ioUtil$1.tryGetExecutablePath(path$5.join(directory, tool), extensions);
				if (filePath) matches.push(filePath);
			}
			return matches;
		});
	}
	exports.findInPath = findInPath;
	function readCopyOptions(options) {
		const force = options.force == null ? true : options.force;
		const recursive = Boolean(options.recursive);
		const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
		return {
			force,
			recursive,
			copySourceDirectory
		};
	}
	function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (currentDepth >= 255) return;
			currentDepth++;
			yield mkdirP(destDir);
			const files = yield ioUtil$1.readdir(sourceDir);
			for (const fileName of files) {
				const srcFile = `${sourceDir}/${fileName}`;
				const destFile = `${destDir}/${fileName}`;
				const srcFileStat = yield ioUtil$1.lstat(srcFile);
				if (srcFileStat.isDirectory()) yield cpDirRecursive(srcFile, destFile, currentDepth, force);
				else yield copyFile(srcFile, destFile, force);
			}
			yield ioUtil$1.chmod(destDir, (yield ioUtil$1.stat(sourceDir)).mode);
		});
	}
	function copyFile(srcFile, destFile, force) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if ((yield ioUtil$1.lstat(srcFile)).isSymbolicLink()) {
				try {
					yield ioUtil$1.lstat(destFile);
					yield ioUtil$1.unlink(destFile);
				} catch (e) {
					if (e.code === "EPERM") {
						yield ioUtil$1.chmod(destFile, "0666");
						yield ioUtil$1.unlink(destFile);
					}
				}
				const symlinkFull = yield ioUtil$1.readlink(srcFile);
				yield ioUtil$1.symlink(symlinkFull, destFile, ioUtil$1.IS_WINDOWS ? "junction" : null);
			} else if (!(yield ioUtil$1.exists(destFile)) || force) yield ioUtil$1.copyFile(srcFile, destFile);
		});
	}
} });

//#endregion
//#region node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({ "node_modules/@actions/exec/lib/toolrunner.js"(exports) {
	var __createBinding$14 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		});
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$11 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$11 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$14(result, mod, k);
		}
		__setModuleDefault$11(result, mod);
		return result;
	};
	var __awaiter$4 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.argStringToArray = exports.ToolRunner = void 0;
	const os$3 = __importStar$11(require("os"));
	const events = __importStar$11(require("events"));
	const child = __importStar$11(require("child_process"));
	const path$4 = __importStar$11(require("path"));
	const io = __importStar$11(require_io());
	const ioUtil = __importStar$11(require_io_util());
	const timers_1 = require("timers");
	const IS_WINDOWS = process.platform === "win32";
	var ToolRunner = class extends events.EventEmitter {
		constructor(toolPath, args, options) {
			super();
			if (!toolPath) throw new Error("Parameter 'toolPath' cannot be null or empty.");
			this.toolPath = toolPath;
			this.args = args || [];
			this.options = options || {};
		}
		_debug(message) {
			if (this.options.listeners && this.options.listeners.debug) this.options.listeners.debug(message);
		}
		_getCommandString(options, noPrefix) {
			const toolPath = this._getSpawnFileName();
			const args = this._getSpawnArgs(options);
			let cmd = noPrefix ? "" : "[command]";
			if (IS_WINDOWS) if (this._isCmdFile()) {
				cmd += toolPath;
				for (const a$1 of args) cmd += ` ${a$1}`;
			} else if (options.windowsVerbatimArguments) {
				cmd += `"${toolPath}"`;
				for (const a$1 of args) cmd += ` ${a$1}`;
			} else {
				cmd += this._windowsQuoteCmdArg(toolPath);
				for (const a$1 of args) cmd += ` ${this._windowsQuoteCmdArg(a$1)}`;
			}
			else {
				cmd += toolPath;
				for (const a$1 of args) cmd += ` ${a$1}`;
			}
			return cmd;
		}
		_processLineBuffer(data, strBuffer, onLine) {
			try {
				let s$1 = strBuffer + data.toString();
				let n = s$1.indexOf(os$3.EOL);
				while (n > -1) {
					const line = s$1.substring(0, n);
					onLine(line);
					s$1 = s$1.substring(n + os$3.EOL.length);
					n = s$1.indexOf(os$3.EOL);
				}
				return s$1;
			} catch (err) {
				this._debug(`error processing line. Failed with error ${err}`);
				return "";
			}
		}
		_getSpawnFileName() {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) return process.env["COMSPEC"] || "cmd.exe";
			}
			return this.toolPath;
		}
		_getSpawnArgs(options) {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) {
					let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
					for (const a$1 of this.args) {
						argline += " ";
						argline += options.windowsVerbatimArguments ? a$1 : this._windowsQuoteCmdArg(a$1);
					}
					argline += "\"";
					return [argline];
				}
			}
			return this.args;
		}
		_endsWith(str, end) {
			return str.endsWith(end);
		}
		_isCmdFile() {
			const upperToolPath = this.toolPath.toUpperCase();
			return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
		}
		_windowsQuoteCmdArg(arg) {
			if (!this._isCmdFile()) return this._uvQuoteCmdArg(arg);
			if (!arg) return "\"\"";
			const cmdSpecialChars = [
				" ",
				"	",
				"&",
				"(",
				")",
				"[",
				"]",
				"{",
				"}",
				"^",
				"=",
				";",
				"!",
				"'",
				"+",
				",",
				"`",
				"~",
				"|",
				"<",
				">",
				"\""
			];
			let needsQuotes = false;
			for (const char of arg) if (cmdSpecialChars.some((x) => x === char)) {
				needsQuotes = true;
				break;
			}
			if (!needsQuotes) return arg;
			let reverse = "\"";
			let quoteHit = true;
			for (let i$1 = arg.length; i$1 > 0; i$1--) {
				reverse += arg[i$1 - 1];
				if (quoteHit && arg[i$1 - 1] === "\\") reverse += "\\";
				else if (arg[i$1 - 1] === "\"") {
					quoteHit = true;
					reverse += "\"";
				} else quoteHit = false;
			}
			reverse += "\"";
			return reverse.split("").reverse().join("");
		}
		_uvQuoteCmdArg(arg) {
			if (!arg) return "\"\"";
			if (!arg.includes(" ") && !arg.includes("	") && !arg.includes("\"")) return arg;
			if (!arg.includes("\"") && !arg.includes("\\")) return `"${arg}"`;
			let reverse = "\"";
			let quoteHit = true;
			for (let i$1 = arg.length; i$1 > 0; i$1--) {
				reverse += arg[i$1 - 1];
				if (quoteHit && arg[i$1 - 1] === "\\") reverse += "\\";
				else if (arg[i$1 - 1] === "\"") {
					quoteHit = true;
					reverse += "\\";
				} else quoteHit = false;
			}
			reverse += "\"";
			return reverse.split("").reverse().join("");
		}
		_cloneExecOptions(options) {
			options = options || {};
			const result = {
				cwd: options.cwd || process.cwd(),
				env: options.env || process.env,
				silent: options.silent || false,
				windowsVerbatimArguments: options.windowsVerbatimArguments || false,
				failOnStdErr: options.failOnStdErr || false,
				ignoreReturnCode: options.ignoreReturnCode || false,
				delay: options.delay || 1e4
			};
			result.outStream = options.outStream || process.stdout;
			result.errStream = options.errStream || process.stderr;
			return result;
		}
		_getSpawnOptions(options, toolPath) {
			options = options || {};
			const result = {};
			result.cwd = options.cwd;
			result.env = options.env;
			result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
			if (options.windowsVerbatimArguments) result.argv0 = `"${toolPath}"`;
			return result;
		}
		/**
		* Exec a tool.
		* Output will be streamed to the live console.
		* Returns promise with return code
		*
		* @param     tool     path to tool to exec
		* @param     options  optional exec options.  See ExecOptions
		* @returns   number
		*/
		exec() {
			return __awaiter$4(this, void 0, void 0, function* () {
				if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) this.toolPath = path$4.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
				this.toolPath = yield io.which(this.toolPath, true);
				return new Promise((resolve, reject) => __awaiter$4(this, void 0, void 0, function* () {
					this._debug(`exec tool: ${this.toolPath}`);
					this._debug("arguments:");
					for (const arg of this.args) this._debug(`   ${arg}`);
					const optionsNonNull = this._cloneExecOptions(this.options);
					if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os$3.EOL);
					const state = new ExecState(optionsNonNull, this.toolPath);
					state.on("debug", (message) => {
						this._debug(message);
					});
					if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
					const fileName = this._getSpawnFileName();
					const cp$1 = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
					let stdbuffer = "";
					if (cp$1.stdout) cp$1.stdout.on("data", (data) => {
						if (this.options.listeners && this.options.listeners.stdout) this.options.listeners.stdout(data);
						if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(data);
						stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.stdline) this.options.listeners.stdline(line);
						});
					});
					let errbuffer = "";
					if (cp$1.stderr) cp$1.stderr.on("data", (data) => {
						state.processStderr = true;
						if (this.options.listeners && this.options.listeners.stderr) this.options.listeners.stderr(data);
						if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
							const s$1 = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
							s$1.write(data);
						}
						errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.errline) this.options.listeners.errline(line);
						});
					});
					cp$1.on("error", (err) => {
						state.processError = err.message;
						state.processExited = true;
						state.processClosed = true;
						state.CheckComplete();
					});
					cp$1.on("exit", (code$1) => {
						state.processExitCode = code$1;
						state.processExited = true;
						this._debug(`Exit code ${code$1} received from tool '${this.toolPath}'`);
						state.CheckComplete();
					});
					cp$1.on("close", (code$1) => {
						state.processExitCode = code$1;
						state.processExited = true;
						state.processClosed = true;
						this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
						state.CheckComplete();
					});
					state.on("done", (error$1, exitCode) => {
						if (stdbuffer.length > 0) this.emit("stdline", stdbuffer);
						if (errbuffer.length > 0) this.emit("errline", errbuffer);
						cp$1.removeAllListeners();
						if (error$1) reject(error$1);
						else resolve(exitCode);
					});
					if (this.options.input) {
						if (!cp$1.stdin) throw new Error("child process missing stdin");
						cp$1.stdin.end(this.options.input);
					}
				}));
			});
		}
	};
	exports.ToolRunner = ToolRunner;
	/**
	* Convert an arg string to an array of args. Handles escaping
	*
	* @param    argString   string of arguments
	* @returns  string[]    array of arguments
	*/
	function argStringToArray(argString) {
		const args = [];
		let inQuotes = false;
		let escaped = false;
		let arg = "";
		function append(c) {
			if (escaped && c !== "\"") arg += "\\";
			arg += c;
			escaped = false;
		}
		for (let i$1 = 0; i$1 < argString.length; i$1++) {
			const c = argString.charAt(i$1);
			if (c === "\"") {
				if (!escaped) inQuotes = !inQuotes;
				else append(c);
				continue;
			}
			if (c === "\\" && escaped) {
				append(c);
				continue;
			}
			if (c === "\\" && inQuotes) {
				escaped = true;
				continue;
			}
			if (c === " " && !inQuotes) {
				if (arg.length > 0) {
					args.push(arg);
					arg = "";
				}
				continue;
			}
			append(c);
		}
		if (arg.length > 0) args.push(arg.trim());
		return args;
	}
	exports.argStringToArray = argStringToArray;
	var ExecState = class ExecState extends events.EventEmitter {
		constructor(options, toolPath) {
			super();
			this.processClosed = false;
			this.processError = "";
			this.processExitCode = 0;
			this.processExited = false;
			this.processStderr = false;
			this.delay = 1e4;
			this.done = false;
			this.timeout = null;
			if (!toolPath) throw new Error("toolPath must not be empty");
			this.options = options;
			this.toolPath = toolPath;
			if (options.delay) this.delay = options.delay;
		}
		CheckComplete() {
			if (this.done) return;
			if (this.processClosed) this._setResult();
			else if (this.processExited) this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
		}
		_debug(message) {
			this.emit("debug", message);
		}
		_setResult() {
			let error$1;
			if (this.processExited) {
				if (this.processError) error$1 = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
				else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) error$1 = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
				else if (this.processStderr && this.options.failOnStdErr) error$1 = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
			}
			if (this.timeout) {
				clearTimeout(this.timeout);
				this.timeout = null;
			}
			this.done = true;
			this.emit("done", error$1, this.processExitCode);
		}
		static HandleTimeout(state) {
			if (state.done) return;
			if (!state.processClosed && state.processExited) {
				const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
				state._debug(message);
			}
			state._setResult();
		}
	};
} });

//#endregion
//#region node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({ "node_modules/@actions/exec/lib/exec.js"(exports) {
	var __createBinding$13 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		Object.defineProperty(o, k2, {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		});
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$10 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$10 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding$13(result, mod, k);
		}
		__setModuleDefault$10(result, mod);
		return result;
	};
	var __awaiter$3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getExecOutput = exports.exec = void 0;
	const string_decoder_1 = require("string_decoder");
	const tr = __importStar$10(require_toolrunner());
	/**
	* Exec a command.
	* Output will be streamed to the live console.
	* Returns promise with return code
	*
	* @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
	* @param     args               optional arguments for tool. Escaping is handled by the lib.
	* @param     options            optional exec options.  See ExecOptions
	* @returns   Promise<number>    exit code
	*/
	function exec$1(commandLine, args, options) {
		return __awaiter$3(this, void 0, void 0, function* () {
			const commandArgs = tr.argStringToArray(commandLine);
			if (commandArgs.length === 0) throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
			const toolPath = commandArgs[0];
			args = commandArgs.slice(1).concat(args || []);
			const runner = new tr.ToolRunner(toolPath, args, options);
			return runner.exec();
		});
	}
	exports.exec = exec$1;
	/**
	* Exec a command and get the output.
	* Output will be streamed to the live console.
	* Returns promise with the exit code and collected stdout and stderr
	*
	* @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
	* @param     args                  optional arguments for tool. Escaping is handled by the lib.
	* @param     options               optional exec options.  See ExecOptions
	* @returns   Promise<ExecOutput>   exit code, stdout, and stderr
	*/
	function getExecOutput(commandLine, args, options) {
		var _a$5, _b$1;
		return __awaiter$3(this, void 0, void 0, function* () {
			let stdout = "";
			let stderr = "";
			const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
			const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
			const originalStdoutListener = (_a$5 = options === null || options === void 0 ? void 0 : options.listeners) === null || _a$5 === void 0 ? void 0 : _a$5.stdout;
			const originalStdErrListener = (_b$1 = options === null || options === void 0 ? void 0 : options.listeners) === null || _b$1 === void 0 ? void 0 : _b$1.stderr;
			const stdErrListener = (data) => {
				stderr += stderrDecoder.write(data);
				if (originalStdErrListener) originalStdErrListener(data);
			};
			const stdOutListener = (data) => {
				stdout += stdoutDecoder.write(data);
				if (originalStdoutListener) originalStdoutListener(data);
			};
			const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), {
				stdout: stdOutListener,
				stderr: stdErrListener
			});
			const exitCode = yield exec$1(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
			stdout += stdoutDecoder.end();
			stderr += stderrDecoder.end();
			return {
				exitCode,
				stdout,
				stderr
			};
		});
	}
	exports.getExecOutput = getExecOutput;
} });

//#endregion
//#region node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS({ "node_modules/@actions/core/lib/platform.js"(exports) {
	var __createBinding$12 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$9 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$9 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$12(result, mod, k);
		}
		__setModuleDefault$9(result, mod);
		return result;
	};
	var __awaiter$2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __importDefault$4 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
	const os_1$2 = __importDefault$4(require("os"));
	const exec = __importStar$9(require_exec());
	const getWindowsInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		const { stdout: version$2 } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Version\"", void 0, { silent: true });
		const { stdout: name } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Caption\"", void 0, { silent: true });
		return {
			name: name.trim(),
			version: version$2.trim()
		};
	});
	const getMacOsInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		var _a$5, _b$1, _c$1, _d;
		const { stdout } = yield exec.getExecOutput("sw_vers", void 0, { silent: true });
		const version$2 = (_b$1 = (_a$5 = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a$5 === void 0 ? void 0 : _a$5[1]) !== null && _b$1 !== void 0 ? _b$1 : "";
		const name = (_d = (_c$1 = stdout.match(/ProductName:\s*(.+)/)) === null || _c$1 === void 0 ? void 0 : _c$1[1]) !== null && _d !== void 0 ? _d : "";
		return {
			name,
			version: version$2
		};
	});
	const getLinuxInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		const { stdout } = yield exec.getExecOutput("lsb_release", [
			"-i",
			"-r",
			"-s"
		], { silent: true });
		const [name, version$2] = stdout.trim().split("\n");
		return {
			name,
			version: version$2
		};
	});
	exports.platform = os_1$2.default.platform();
	exports.arch = os_1$2.default.arch();
	exports.isWindows = exports.platform === "win32";
	exports.isMacOS = exports.platform === "darwin";
	exports.isLinux = exports.platform === "linux";
	function getDetails() {
		return __awaiter$2(this, void 0, void 0, function* () {
			return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
				platform: exports.platform,
				arch: exports.arch,
				isWindows: exports.isWindows,
				isMacOS: exports.isMacOS,
				isLinux: exports.isLinux
			});
		});
	}
	exports.getDetails = getDetails;
} });

//#endregion
//#region node_modules/@actions/core/lib/core.js
var require_core = __commonJS({ "node_modules/@actions/core/lib/core.js"(exports) {
	var __createBinding$11 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$8 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$8 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$11(result, mod, k);
		}
		__setModuleDefault$8(result, mod);
		return result;
	};
	var __awaiter$1 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
	const command_1 = require_command();
	const file_command_1 = require_file_command();
	const utils_1$1 = require_utils$4();
	const os$2 = __importStar$8(require("os"));
	const path$3 = __importStar$8(require("path"));
	const oidc_utils_1 = require_oidc_utils();
	/**
	* The code to exit an action
	*/
	var ExitCode;
	(function(ExitCode$1) {
		/**
		* A code indicating that the action was successful
		*/
		ExitCode$1[ExitCode$1["Success"] = 0] = "Success";
		/**
		* A code indicating that the action was a failure
		*/
		ExitCode$1[ExitCode$1["Failure"] = 1] = "Failure";
	})(ExitCode || (exports.ExitCode = ExitCode = {}));
	/**
	* Sets env variable for this action and future actions in the job
	* @param name the name of the variable to set
	* @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
	*/
	function exportVariable(name, val) {
		const convertedVal = (0, utils_1$1.toCommandValue)(val);
		process.env[name] = convertedVal;
		const filePath = process.env["GITHUB_ENV"] || "";
		if (filePath) return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
		(0, command_1.issueCommand)("set-env", { name }, convertedVal);
	}
	exports.exportVariable = exportVariable;
	/**
	* Registers a secret which will get masked from logs
	* @param secret value of the secret
	*/
	function setSecret(secret) {
		(0, command_1.issueCommand)("add-mask", {}, secret);
	}
	exports.setSecret = setSecret;
	/**
	* Prepends inputPath to the PATH (for this action and future actions)
	* @param inputPath
	*/
	function addPath(inputPath) {
		const filePath = process.env["GITHUB_PATH"] || "";
		if (filePath) (0, file_command_1.issueFileCommand)("PATH", inputPath);
		else (0, command_1.issueCommand)("add-path", {}, inputPath);
		process.env["PATH"] = `${inputPath}${path$3.delimiter}${process.env["PATH"]}`;
	}
	exports.addPath = addPath;
	/**
	* Gets the value of an input.
	* Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
	* Returns an empty string if the value is not defined.
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   string
	*/
	function getInput(name, options) {
		const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
		if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);
		if (options && options.trimWhitespace === false) return val;
		return val.trim();
	}
	exports.getInput = getInput;
	/**
	* Gets the values of an multiline input.  Each value is also trimmed.
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   string[]
	*
	*/
	function getMultilineInput(name, options) {
		const inputs = getInput(name, options).split("\n").filter((x) => x !== "");
		if (options && options.trimWhitespace === false) return inputs;
		return inputs.map((input) => input.trim());
	}
	exports.getMultilineInput = getMultilineInput;
	/**
	* Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
	* Support boolean input list: `true | True | TRUE | false | False | FALSE` .
	* The return value is also in boolean type.
	* ref: https://yaml.org/spec/1.2/spec.html#id2804923
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   boolean
	*/
	function getBooleanInput(name, options) {
		const trueValue = [
			"true",
			"True",
			"TRUE"
		];
		const falseValue = [
			"false",
			"False",
			"FALSE"
		];
		const val = getInput(name, options);
		if (trueValue.includes(val)) return true;
		if (falseValue.includes(val)) return false;
		throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\nSupport boolean input list: \`true | True | TRUE | false | False | FALSE\``);
	}
	exports.getBooleanInput = getBooleanInput;
	/**
	* Sets the value of an output.
	*
	* @param     name     name of the output to set
	* @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
	*/
	function setOutput(name, value) {
		const filePath = process.env["GITHUB_OUTPUT"] || "";
		if (filePath) return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
		process.stdout.write(os$2.EOL);
		(0, command_1.issueCommand)("set-output", { name }, (0, utils_1$1.toCommandValue)(value));
	}
	exports.setOutput = setOutput;
	/**
	* Enables or disables the echoing of commands into stdout for the rest of the step.
	* Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
	*
	*/
	function setCommandEcho(enabled) {
		(0, command_1.issue)("echo", enabled ? "on" : "off");
	}
	exports.setCommandEcho = setCommandEcho;
	/**
	* Sets the action status to failed.
	* When the action exits it will be with an exit code of 1
	* @param message add error issue message
	*/
	function setFailed(message) {
		process.exitCode = ExitCode.Failure;
		error(message);
	}
	exports.setFailed = setFailed;
	/**
	* Gets whether Actions Step Debug is on or not
	*/
	function isDebug() {
		return process.env["RUNNER_DEBUG"] === "1";
	}
	exports.isDebug = isDebug;
	/**
	* Writes debug message to user log
	* @param message debug message
	*/
	function debug$2(message) {
		(0, command_1.issueCommand)("debug", {}, message);
	}
	exports.debug = debug$2;
	/**
	* Adds an error issue
	* @param message error issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function error(message, properties = {}) {
		(0, command_1.issueCommand)("error", (0, utils_1$1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.error = error;
	/**
	* Adds a warning issue
	* @param message warning issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function warning(message, properties = {}) {
		(0, command_1.issueCommand)("warning", (0, utils_1$1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.warning = warning;
	/**
	* Adds a notice issue
	* @param message notice issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function notice(message, properties = {}) {
		(0, command_1.issueCommand)("notice", (0, utils_1$1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.notice = notice;
	/**
	* Writes info to log with console.log.
	* @param message info message
	*/
	function info(message) {
		process.stdout.write(message + os$2.EOL);
	}
	exports.info = info;
	/**
	* Begin an output group.
	*
	* Output until the next `groupEnd` will be foldable in this group
	*
	* @param name The name of the output group
	*/
	function startGroup(name) {
		(0, command_1.issue)("group", name);
	}
	exports.startGroup = startGroup;
	/**
	* End an output group.
	*/
	function endGroup() {
		(0, command_1.issue)("endgroup");
	}
	exports.endGroup = endGroup;
	/**
	* Wrap an asynchronous function call in a group.
	*
	* Returns the same type as the function itself.
	*
	* @param name The name of the group
	* @param fn The function to wrap in the group
	*/
	function group(name, fn) {
		return __awaiter$1(this, void 0, void 0, function* () {
			startGroup(name);
			let result;
			try {
				result = yield fn();
			} finally {
				endGroup();
			}
			return result;
		});
	}
	exports.group = group;
	/**
	* Saves state for current action, the state can only be retrieved by this action's post job execution.
	*
	* @param     name     name of the state to store
	* @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
	*/
	function saveState(name, value) {
		const filePath = process.env["GITHUB_STATE"] || "";
		if (filePath) return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
		(0, command_1.issueCommand)("save-state", { name }, (0, utils_1$1.toCommandValue)(value));
	}
	exports.saveState = saveState;
	/**
	* Gets the value of an state set by this action's main execution.
	*
	* @param     name     name of the state to get
	* @returns   string
	*/
	function getState(name) {
		return process.env[`STATE_${name}`] || "";
	}
	exports.getState = getState;
	function getIDToken(aud) {
		return __awaiter$1(this, void 0, void 0, function* () {
			return yield oidc_utils_1.OidcClient.getIDToken(aud);
		});
	}
	exports.getIDToken = getIDToken;
	/**
	* Summary exports
	*/
	var summary_1 = require_summary();
	Object.defineProperty(exports, "summary", {
		enumerable: true,
		get: function() {
			return summary_1.summary;
		}
	});
	/**
	* @deprecated use core.summary
	*/
	var summary_2 = require_summary();
	Object.defineProperty(exports, "markdownSummary", {
		enumerable: true,
		get: function() {
			return summary_2.markdownSummary;
		}
	});
	/**
	* Path exports
	*/
	var path_utils_1 = require_path_utils();
	Object.defineProperty(exports, "toPosixPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPosixPath;
		}
	});
	Object.defineProperty(exports, "toWin32Path", {
		enumerable: true,
		get: function() {
			return path_utils_1.toWin32Path;
		}
	});
	Object.defineProperty(exports, "toPlatformPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPlatformPath;
		}
	});
	/**
	* Platform utilities exports
	*/
	exports.platform = __importStar$8(require_platform());
} });
var import_core = __toESM$1(require_core(), 1);

//#endregion
//#region node_modules/@actions/github/lib/context.js
var require_context = __commonJS({ "node_modules/@actions/github/lib/context.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Context = void 0;
	const fs_1$1 = require("fs");
	const os_1$1 = require("os");
	var Context$2 = class {
		/**
		* Hydrate the context from the environment
		*/
		constructor() {
			var _a$5, _b$1, _c$1;
			this.payload = {};
			if (process.env.GITHUB_EVENT_PATH) if ((0, fs_1$1.existsSync)(process.env.GITHUB_EVENT_PATH)) this.payload = JSON.parse((0, fs_1$1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
			else {
				const path$8 = process.env.GITHUB_EVENT_PATH;
				process.stdout.write(`GITHUB_EVENT_PATH ${path$8} does not exist${os_1$1.EOL}`);
			}
			this.eventName = process.env.GITHUB_EVENT_NAME;
			this.sha = process.env.GITHUB_SHA;
			this.ref = process.env.GITHUB_REF;
			this.workflow = process.env.GITHUB_WORKFLOW;
			this.action = process.env.GITHUB_ACTION;
			this.actor = process.env.GITHUB_ACTOR;
			this.job = process.env.GITHUB_JOB;
			this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
			this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
			this.apiUrl = (_a$5 = process.env.GITHUB_API_URL) !== null && _a$5 !== void 0 ? _a$5 : `https://api.github.com`;
			this.serverUrl = (_b$1 = process.env.GITHUB_SERVER_URL) !== null && _b$1 !== void 0 ? _b$1 : `https://github.com`;
			this.graphqlUrl = (_c$1 = process.env.GITHUB_GRAPHQL_URL) !== null && _c$1 !== void 0 ? _c$1 : `https://api.github.com/graphql`;
		}
		get issue() {
			const payload = this.payload;
			return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
		}
		get repo() {
			if (process.env.GITHUB_REPOSITORY) {
				const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
				return {
					owner,
					repo
				};
			}
			if (this.payload.repository) return {
				owner: this.payload.repository.owner.login,
				repo: this.payload.repository.name
			};
			throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
		}
	};
	exports.Context = Context$2;
} });

//#endregion
//#region node_modules/@actions/github/lib/internal/utils.js
var require_utils$2 = __commonJS({ "node_modules/@actions/github/lib/internal/utils.js"(exports) {
	var __createBinding$10 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$7 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$7 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$10(result, mod, k);
		}
		__setModuleDefault$7(result, mod);
		return result;
	};
	var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getApiBaseUrl = exports.getProxyFetch = exports.getProxyAgentDispatcher = exports.getProxyAgent = exports.getAuthString = void 0;
	const httpClient = __importStar$7(require_lib$2());
	const undici_1 = require_undici();
	function getAuthString(token, options) {
		if (!token && !options.auth) throw new Error("Parameter token or opts.auth is required");
		else if (token && options.auth) throw new Error("Parameters token and opts.auth may not both be specified");
		return typeof options.auth === "string" ? options.auth : `token ${token}`;
	}
	exports.getAuthString = getAuthString;
	function getProxyAgent(destinationUrl) {
		const hc = new httpClient.HttpClient();
		return hc.getAgent(destinationUrl);
	}
	exports.getProxyAgent = getProxyAgent;
	function getProxyAgentDispatcher(destinationUrl) {
		const hc = new httpClient.HttpClient();
		return hc.getAgentDispatcher(destinationUrl);
	}
	exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
	function getProxyFetch(destinationUrl) {
		const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
		const proxyFetch = (url, opts) => __awaiter(this, void 0, void 0, function* () {
			return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
		});
		return proxyFetch;
	}
	exports.getProxyFetch = getProxyFetch;
	function getApiBaseUrl() {
		return process.env["GITHUB_API_URL"] || "https://api.github.com";
	}
	exports.getApiBaseUrl = getApiBaseUrl;
} });

//#endregion
//#region node_modules/universal-user-agent/dist-node/index.js
var require_dist_node$9 = __commonJS({ "node_modules/universal-user-agent/dist-node/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function getUserAgent() {
		if (typeof navigator === "object" && "userAgent" in navigator) return navigator.userAgent;
		if (typeof process === "object" && process.version !== void 0) return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
		return "<environment undetectable>";
	}
	exports.getUserAgent = getUserAgent;
} });

//#endregion
//#region node_modules/before-after-hook/lib/register.js
var require_register = __commonJS({ "node_modules/before-after-hook/lib/register.js"(exports, module) {
	module.exports = register$1;
	function register$1(state, name, method, options) {
		if (typeof method !== "function") throw new Error("method for before hook must be a function");
		if (!options) options = {};
		if (Array.isArray(name)) return name.reverse().reduce(function(callback, name$1) {
			return register$1.bind(null, state, name$1, callback, options);
		}, method)();
		return Promise.resolve().then(function() {
			if (!state.registry[name]) return method(options);
			return state.registry[name].reduce(function(method$1, registered) {
				return registered.hook.bind(null, method$1, options);
			}, method)();
		});
	}
} });

//#endregion
//#region node_modules/before-after-hook/lib/add.js
var require_add = __commonJS({ "node_modules/before-after-hook/lib/add.js"(exports, module) {
	module.exports = addHook$1;
	function addHook$1(state, kind, name, hook$1) {
		var orig = hook$1;
		if (!state.registry[name]) state.registry[name] = [];
		if (kind === "before") hook$1 = function(method, options) {
			return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
		};
		if (kind === "after") hook$1 = function(method, options) {
			var result;
			return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
				result = result_;
				return orig(result, options);
			}).then(function() {
				return result;
			});
		};
		if (kind === "error") hook$1 = function(method, options) {
			return Promise.resolve().then(method.bind(null, options)).catch(function(error$1) {
				return orig(error$1, options);
			});
		};
		state.registry[name].push({
			hook: hook$1,
			orig
		});
	}
} });

//#endregion
//#region node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS({ "node_modules/before-after-hook/lib/remove.js"(exports, module) {
	module.exports = removeHook$1;
	function removeHook$1(state, name, method) {
		if (!state.registry[name]) return;
		var index = state.registry[name].map(function(registered) {
			return registered.orig;
		}).indexOf(method);
		if (index === -1) return;
		state.registry[name].splice(index, 1);
	}
} });

//#endregion
//#region node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS({ "node_modules/before-after-hook/index.js"(exports, module) {
	var register = require_register();
	var addHook = require_add();
	var removeHook = require_remove();
	var bind = Function.bind;
	var bindable = bind.bind(bind);
	function bindApi(hook$1, state, name) {
		var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
		hook$1.api = { remove: removeHookRef };
		hook$1.remove = removeHookRef;
		[
			"before",
			"error",
			"after",
			"wrap"
		].forEach(function(kind) {
			var args = name ? [
				state,
				kind,
				name
			] : [state, kind];
			hook$1[kind] = hook$1.api[kind] = bindable(addHook, null).apply(null, args);
		});
	}
	function HookSingular() {
		var singularHookName = "h";
		var singularHookState = { registry: {} };
		var singularHook = register.bind(null, singularHookState, singularHookName);
		bindApi(singularHook, singularHookState, singularHookName);
		return singularHook;
	}
	function HookCollection() {
		var state = { registry: {} };
		var hook$1 = register.bind(null, state);
		bindApi(hook$1, state);
		return hook$1;
	}
	var collectionHookDeprecationMessageDisplayed = false;
	function Hook() {
		if (!collectionHookDeprecationMessageDisplayed) {
			console.warn("[before-after-hook]: \"Hook()\" repurposing warning, use \"Hook.Collection()\". Read more: https://git.io/upgrade-before-after-hook-to-1.4");
			collectionHookDeprecationMessageDisplayed = true;
		}
		return HookCollection();
	}
	Hook.Singular = HookSingular.bind();
	Hook.Collection = HookCollection.bind();
	module.exports = Hook;
	module.exports.Hook = Hook;
	module.exports.Singular = Hook.Singular;
	module.exports.Collection = Hook.Collection;
} });

//#endregion
//#region node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node$8 = __commonJS({ "node_modules/@octokit/endpoint/dist-node/index.js"(exports, module) {
	var __defProp$7 = Object.defineProperty;
	var __getOwnPropDesc$7 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$7 = Object.getOwnPropertyNames;
	var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
	var __export$7 = (target, all) => {
		for (var name in all) __defProp$7(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$7 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$7(from)) if (!__hasOwnProp$7.call(to, key) && key !== except) __defProp$7(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$7(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$7 = (mod) => __copyProps$7(__defProp$7({}, "__esModule", { value: true }), mod);
	var dist_src_exports$5 = {};
	__export$7(dist_src_exports$5, { endpoint: () => endpoint });
	module.exports = __toCommonJS$7(dist_src_exports$5);
	var import_universal_user_agent$3 = require_dist_node$9();
	var VERSION$5 = "9.0.6";
	var userAgent = `octokit-endpoint.js/${VERSION$5} ${(0, import_universal_user_agent$3.getUserAgent)()}`;
	var DEFAULTS = {
		method: "GET",
		baseUrl: "https://api.github.com",
		headers: {
			accept: "application/vnd.github.v3+json",
			"user-agent": userAgent
		},
		mediaType: { format: "" }
	};
	function lowercaseKeys(object) {
		if (!object) return {};
		return Object.keys(object).reduce((newObj, key) => {
			newObj[key.toLowerCase()] = object[key];
			return newObj;
		}, {});
	}
	function isPlainObject$2(value) {
		if (typeof value !== "object" || value === null) return false;
		if (Object.prototype.toString.call(value) !== "[object Object]") return false;
		const proto = Object.getPrototypeOf(value);
		if (proto === null) return true;
		const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
	}
	function mergeDeep(defaults, options) {
		const result = Object.assign({}, defaults);
		Object.keys(options).forEach((key) => {
			if (isPlainObject$2(options[key])) if (!(key in defaults)) Object.assign(result, { [key]: options[key] });
			else result[key] = mergeDeep(defaults[key], options[key]);
			else Object.assign(result, { [key]: options[key] });
		});
		return result;
	}
	function removeUndefinedProperties(obj) {
		for (const key in obj) if (obj[key] === void 0) delete obj[key];
		return obj;
	}
	function merge(defaults, route, options) {
		if (typeof route === "string") {
			let [method, url] = route.split(" ");
			options = Object.assign(url ? {
				method,
				url
			} : { url: method }, options);
		} else options = Object.assign({}, route);
		options.headers = lowercaseKeys(options.headers);
		removeUndefinedProperties(options);
		removeUndefinedProperties(options.headers);
		const mergedOptions = mergeDeep(defaults || {}, options);
		if (options.url === "/graphql") {
			if (defaults && defaults.mediaType.previews?.length) mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
			mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
		}
		return mergedOptions;
	}
	function addQueryParameters(url, parameters) {
		const separator = /\?/.test(url) ? "&" : "?";
		const names = Object.keys(parameters);
		if (names.length === 0) return url;
		return url + separator + names.map((name) => {
			if (name === "q") return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
			return `${name}=${encodeURIComponent(parameters[name])}`;
		}).join("&");
	}
	var urlVariableRegex = /\{[^{}}]+\}/g;
	function removeNonChars(variableName) {
		return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
	}
	function extractUrlVariableNames(url) {
		const matches = url.match(urlVariableRegex);
		if (!matches) return [];
		return matches.map(removeNonChars).reduce((a$1, b) => a$1.concat(b), []);
	}
	function omit$1(object, keysToOmit) {
		const result = { __proto__: null };
		for (const key of Object.keys(object)) if (keysToOmit.indexOf(key) === -1) result[key] = object[key];
		return result;
	}
	function encodeReserved(str) {
		return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
			if (!/%[0-9A-Fa-f]/.test(part)) part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
			return part;
		}).join("");
	}
	function encodeUnreserved(str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
			return "%" + c.charCodeAt(0).toString(16).toUpperCase();
		});
	}
	function encodeValue(operator, value, key) {
		value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
		if (key) return encodeUnreserved(key) + "=" + value;
		else return value;
	}
	function isDefined(value) {
		return value !== void 0 && value !== null;
	}
	function isKeyOperator(operator) {
		return operator === ";" || operator === "&" || operator === "?";
	}
	function getValues(context, operator, key, modifier) {
		var value = context[key], result = [];
		if (isDefined(value) && value !== "") if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
			value = value.toString();
			if (modifier && modifier !== "*") value = value.substring(0, parseInt(modifier, 10));
			result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
		} else if (modifier === "*") if (Array.isArray(value)) value.filter(isDefined).forEach(function(value2) {
			result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
		});
		else Object.keys(value).forEach(function(k) {
			if (isDefined(value[k])) result.push(encodeValue(operator, value[k], k));
		});
		else {
			const tmp = [];
			if (Array.isArray(value)) value.filter(isDefined).forEach(function(value2) {
				tmp.push(encodeValue(operator, value2));
			});
			else Object.keys(value).forEach(function(k) {
				if (isDefined(value[k])) {
					tmp.push(encodeUnreserved(k));
					tmp.push(encodeValue(operator, value[k].toString()));
				}
			});
			if (isKeyOperator(operator)) result.push(encodeUnreserved(key) + "=" + tmp.join(","));
			else if (tmp.length !== 0) result.push(tmp.join(","));
		}
		else if (operator === ";") {
			if (isDefined(value)) result.push(encodeUnreserved(key));
		} else if (value === "" && (operator === "&" || operator === "?")) result.push(encodeUnreserved(key) + "=");
		else if (value === "") result.push("");
		return result;
	}
	function parseUrl(template) {
		return { expand: expand.bind(null, template) };
	}
	function expand(template, context) {
		var operators = [
			"+",
			"#",
			".",
			"/",
			";",
			"?",
			"&"
		];
		template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
			if (expression) {
				let operator = "";
				const values = [];
				if (operators.indexOf(expression.charAt(0)) !== -1) {
					operator = expression.charAt(0);
					expression = expression.substr(1);
				}
				expression.split(/,/g).forEach(function(variable) {
					var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
					values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
				});
				if (operator && operator !== "+") {
					var separator = ",";
					if (operator === "?") separator = "&";
					else if (operator !== "#") separator = operator;
					return (values.length !== 0 ? operator : "") + values.join(separator);
				} else return values.join(",");
			} else return encodeReserved(literal);
		});
		if (template === "/") return template;
		else return template.replace(/\/$/, "");
	}
	function parse$6(options) {
		let method = options.method.toUpperCase();
		let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
		let headers = Object.assign({}, options.headers);
		let body;
		let parameters = omit$1(options, [
			"method",
			"baseUrl",
			"url",
			"headers",
			"request",
			"mediaType"
		]);
		const urlVariableNames = extractUrlVariableNames(url);
		url = parseUrl(url).expand(parameters);
		if (!/^http/.test(url)) url = options.baseUrl + url;
		const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
		const remainingParameters = omit$1(parameters, omittedParameters);
		const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
		if (!isBinaryRequest) {
			if (options.mediaType.format) headers.accept = headers.accept.split(/,/).map((format$2) => format$2.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
			if (url.endsWith("/graphql")) {
				if (options.mediaType.previews?.length) {
					const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
					headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
						const format$2 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
						return `application/vnd.github.${preview}-preview${format$2}`;
					}).join(",");
				}
			}
		}
		if (["GET", "HEAD"].includes(method)) url = addQueryParameters(url, remainingParameters);
		else if ("data" in remainingParameters) body = remainingParameters.data;
		else if (Object.keys(remainingParameters).length) body = remainingParameters;
		if (!headers["content-type"] && typeof body !== "undefined") headers["content-type"] = "application/json; charset=utf-8";
		if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") body = "";
		return Object.assign({
			method,
			url,
			headers
		}, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
	}
	function endpointWithDefaults(defaults, route, options) {
		return parse$6(merge(defaults, route, options));
	}
	function withDefaults$2(oldDefaults, newDefaults) {
		const DEFAULTS2 = merge(oldDefaults, newDefaults);
		const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
		return Object.assign(endpoint2, {
			DEFAULTS: DEFAULTS2,
			defaults: withDefaults$2.bind(null, DEFAULTS2),
			merge: merge.bind(null, DEFAULTS2),
			parse: parse$6
		});
	}
	var endpoint = withDefaults$2(null, DEFAULTS);
} });

//#endregion
//#region node_modules/deprecation/dist-node/index.js
var require_dist_node$7 = __commonJS({ "node_modules/deprecation/dist-node/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Deprecation = class extends Error {
		constructor(message) {
			super(message);
			/* istanbul ignore next */
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
			this.name = "Deprecation";
		}
	};
	exports.Deprecation = Deprecation;
} });

//#endregion
//#region node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({ "node_modules/wrappy/wrappy.js"(exports, module) {
	module.exports = wrappy$1;
	function wrappy$1(fn, cb) {
		if (fn && cb) return wrappy$1(fn)(cb);
		if (typeof fn !== "function") throw new TypeError("need wrapper function");
		Object.keys(fn).forEach(function(k) {
			wrapper[k] = fn[k];
		});
		return wrapper;
		function wrapper() {
			var args = new Array(arguments.length);
			for (var i$1 = 0; i$1 < args.length; i$1++) args[i$1] = arguments[i$1];
			var ret = fn.apply(this, args);
			var cb$1 = args[args.length - 1];
			if (typeof ret === "function" && ret !== cb$1) Object.keys(cb$1).forEach(function(k) {
				ret[k] = cb$1[k];
			});
			return ret;
		}
	}
} });

//#endregion
//#region node_modules/once/once.js
var require_once = __commonJS({ "node_modules/once/once.js"(exports, module) {
	var wrappy = require_wrappy();
	module.exports = wrappy(once);
	module.exports.strict = wrappy(onceStrict);
	once.proto = once(function() {
		Object.defineProperty(Function.prototype, "once", {
			value: function() {
				return once(this);
			},
			configurable: true
		});
		Object.defineProperty(Function.prototype, "onceStrict", {
			value: function() {
				return onceStrict(this);
			},
			configurable: true
		});
	});
	function once(fn) {
		var f = function() {
			if (f.called) return f.value;
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		f.called = false;
		return f;
	}
	function onceStrict(fn) {
		var f = function() {
			if (f.called) throw new Error(f.onceError);
			f.called = true;
			return f.value = fn.apply(this, arguments);
		};
		var name = fn.name || "Function wrapped with `once`";
		f.onceError = name + " shouldn't be called more than once";
		f.called = false;
		return f;
	}
} });

//#endregion
//#region node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node$6 = __commonJS({ "node_modules/@octokit/request-error/dist-node/index.js"(exports, module) {
	var __create = Object.create;
	var __defProp$6 = Object.defineProperty;
	var __getOwnPropDesc$6 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$6 = Object.getOwnPropertyNames;
	var __getProtoOf = Object.getPrototypeOf;
	var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
	var __export$6 = (target, all) => {
		for (var name in all) __defProp$6(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$6 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$6(from)) if (!__hasOwnProp$6.call(to, key) && key !== except) __defProp$6(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$6(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps$6(
		// If the importer is in node compatibility mode or this is not an ESM
		// file that has been converted to a CommonJS file using a Babel-
		// compatible transform (i.e. "__esModule" has not been set), then set
		// "default" to the CommonJS "module.exports" for node compatibility.
		isNodeMode || !mod || !mod.__esModule ? __defProp$6(target, "default", {
			value: mod,
			enumerable: true
		}) : target,
		mod
));
	var __toCommonJS$6 = (mod) => __copyProps$6(__defProp$6({}, "__esModule", { value: true }), mod);
	var dist_src_exports$4 = {};
	__export$6(dist_src_exports$4, { RequestError: () => RequestError });
	module.exports = __toCommonJS$6(dist_src_exports$4);
	var import_deprecation = require_dist_node$7();
	var import_once = __toESM(require_once());
	var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
	var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
	var RequestError = class extends Error {
		constructor(message, statusCode, options) {
			super(message);
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
			this.name = "HttpError";
			this.status = statusCode;
			let headers;
			if ("headers" in options && typeof options.headers !== "undefined") headers = options.headers;
			if ("response" in options) {
				this.response = options.response;
				headers = options.response.headers;
			}
			const requestCopy = Object.assign({}, options.request);
			if (options.request.headers.authorization) requestCopy.headers = Object.assign({}, options.request.headers, { authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]") });
			requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
			this.request = requestCopy;
			Object.defineProperty(this, "code", { get() {
				logOnceCode(new import_deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
				return statusCode;
			} });
			Object.defineProperty(this, "headers", { get() {
				logOnceHeaders(new import_deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
				return headers || {};
			} });
		}
	};
} });

//#endregion
//#region node_modules/@octokit/request/dist-node/index.js
var require_dist_node$5 = __commonJS({ "node_modules/@octokit/request/dist-node/index.js"(exports, module) {
	var __defProp$5 = Object.defineProperty;
	var __getOwnPropDesc$5 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$5 = Object.getOwnPropertyNames;
	var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
	var __export$5 = (target, all) => {
		for (var name in all) __defProp$5(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$5 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$5(from)) if (!__hasOwnProp$5.call(to, key) && key !== except) __defProp$5(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$5(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$5 = (mod) => __copyProps$5(__defProp$5({}, "__esModule", { value: true }), mod);
	var dist_src_exports$3 = {};
	__export$5(dist_src_exports$3, { request: () => request$1 });
	module.exports = __toCommonJS$5(dist_src_exports$3);
	var import_endpoint = require_dist_node$8();
	var import_universal_user_agent$2 = require_dist_node$9();
	var VERSION$4 = "8.4.1";
	function isPlainObject$1(value) {
		if (typeof value !== "object" || value === null) return false;
		if (Object.prototype.toString.call(value) !== "[object Object]") return false;
		const proto = Object.getPrototypeOf(value);
		if (proto === null) return true;
		const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
		return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
	}
	var import_request_error = require_dist_node$6();
	function getBufferResponse(response) {
		return response.arrayBuffer();
	}
	function fetchWrapper(requestOptions) {
		var _a$5, _b$1, _c$1, _d;
		const log$3 = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
		const parseSuccessResponseBody = ((_a$5 = requestOptions.request) == null ? void 0 : _a$5.parseSuccessResponseBody) !== false;
		if (isPlainObject$1(requestOptions.body) || Array.isArray(requestOptions.body)) requestOptions.body = JSON.stringify(requestOptions.body);
		let headers = {};
		let status;
		let url;
		let { fetch: fetch$4 } = globalThis;
		if ((_b$1 = requestOptions.request) == null ? void 0 : _b$1.fetch) fetch$4 = requestOptions.request.fetch;
		if (!fetch$4) throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
		return fetch$4(requestOptions.url, {
			method: requestOptions.method,
			body: requestOptions.body,
			redirect: (_c$1 = requestOptions.request) == null ? void 0 : _c$1.redirect,
			headers: requestOptions.headers,
			signal: (_d = requestOptions.request) == null ? void 0 : _d.signal,
			...requestOptions.body && { duplex: "half" }
		}).then(async (response) => {
			url = response.url;
			status = response.status;
			for (const keyAndValue of response.headers) headers[keyAndValue[0]] = keyAndValue[1];
			if ("deprecation" in headers) {
				const matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/);
				const deprecationLink = matches && matches.pop();
				log$3.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
			}
			if (status === 204 || status === 205) return;
			if (requestOptions.method === "HEAD") {
				if (status < 400) return;
				throw new import_request_error.RequestError(response.statusText, status, {
					response: {
						url,
						status,
						headers,
						data: void 0
					},
					request: requestOptions
				});
			}
			if (status === 304) throw new import_request_error.RequestError("Not modified", status, {
				response: {
					url,
					status,
					headers,
					data: await getResponseData(response)
				},
				request: requestOptions
			});
			if (status >= 400) {
				const data = await getResponseData(response);
				const error$1 = new import_request_error.RequestError(toErrorMessage(data), status, {
					response: {
						url,
						status,
						headers,
						data
					},
					request: requestOptions
				});
				throw error$1;
			}
			return parseSuccessResponseBody ? await getResponseData(response) : response.body;
		}).then((data) => {
			return {
				status,
				url,
				headers,
				data
			};
		}).catch((error$1) => {
			if (error$1 instanceof import_request_error.RequestError) throw error$1;
			else if (error$1.name === "AbortError") throw error$1;
			let message = error$1.message;
			if (error$1.name === "TypeError" && "cause" in error$1) {
				if (error$1.cause instanceof Error) message = error$1.cause.message;
				else if (typeof error$1.cause === "string") message = error$1.cause;
			}
			throw new import_request_error.RequestError(message, 500, { request: requestOptions });
		});
	}
	async function getResponseData(response) {
		const contentType = response.headers.get("content-type");
		if (/application\/json/.test(contentType)) return response.json().catch(() => response.text()).catch(() => "");
		if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) return response.text();
		return getBufferResponse(response);
	}
	function toErrorMessage(data) {
		if (typeof data === "string") return data;
		let suffix;
		if ("documentation_url" in data) suffix = ` - ${data.documentation_url}`;
		else suffix = "";
		if ("message" in data) {
			if (Array.isArray(data.errors)) return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
			return `${data.message}${suffix}`;
		}
		return `Unknown error: ${JSON.stringify(data)}`;
	}
	function withDefaults$1(oldEndpoint, newDefaults) {
		const endpoint2 = oldEndpoint.defaults(newDefaults);
		const newApi = function(route, parameters) {
			const endpointOptions = endpoint2.merge(route, parameters);
			if (!endpointOptions.request || !endpointOptions.request.hook) return fetchWrapper(endpoint2.parse(endpointOptions));
			const request2 = (route2, parameters2) => {
				return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
			};
			Object.assign(request2, {
				endpoint: endpoint2,
				defaults: withDefaults$1.bind(null, endpoint2)
			});
			return endpointOptions.request.hook(request2, endpointOptions);
		};
		return Object.assign(newApi, {
			endpoint: endpoint2,
			defaults: withDefaults$1.bind(null, endpoint2)
		});
	}
	var request$1 = withDefaults$1(import_endpoint.endpoint, { headers: { "user-agent": `octokit-request.js/${VERSION$4} ${(0, import_universal_user_agent$2.getUserAgent)()}` } });
} });

//#endregion
//#region node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node$4 = __commonJS({ "node_modules/@octokit/graphql/dist-node/index.js"(exports, module) {
	var __defProp$4 = Object.defineProperty;
	var __getOwnPropDesc$4 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$4 = Object.getOwnPropertyNames;
	var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
	var __export$4 = (target, all) => {
		for (var name in all) __defProp$4(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$4 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$4(from)) if (!__hasOwnProp$4.call(to, key) && key !== except) __defProp$4(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$4(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$4 = (mod) => __copyProps$4(__defProp$4({}, "__esModule", { value: true }), mod);
	var index_exports$1 = {};
	__export$4(index_exports$1, {
		GraphqlResponseError: () => GraphqlResponseError,
		graphql: () => graphql2,
		withCustomRequest: () => withCustomRequest
	});
	module.exports = __toCommonJS$4(index_exports$1);
	var import_request3 = require_dist_node$5();
	var import_universal_user_agent$1 = require_dist_node$9();
	var VERSION$3 = "7.1.1";
	var import_request2 = require_dist_node$5();
	var import_request$1 = require_dist_node$5();
	function _buildMessageForResponseErrors(data) {
		return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
	}
	var GraphqlResponseError = class extends Error {
		constructor(request2, headers, response) {
			super(_buildMessageForResponseErrors(response));
			this.request = request2;
			this.headers = headers;
			this.response = response;
			this.name = "GraphqlResponseError";
			this.errors = response.errors;
			this.data = response.data;
			if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
		}
	};
	var NON_VARIABLE_OPTIONS = [
		"method",
		"baseUrl",
		"url",
		"headers",
		"request",
		"query",
		"mediaType"
	];
	var FORBIDDEN_VARIABLE_OPTIONS = [
		"query",
		"method",
		"url"
	];
	var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
	function graphql(request2, query, options) {
		if (options) {
			if (typeof query === "string" && "query" in options) return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
			for (const key in options) {
				if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
				return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
			}
		}
		const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
		const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
			if (NON_VARIABLE_OPTIONS.includes(key)) {
				result[key] = parsedOptions[key];
				return result;
			}
			if (!result.variables) result.variables = {};
			result.variables[key] = parsedOptions[key];
			return result;
		}, {});
		const baseUrl$1 = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
		if (GHES_V3_SUFFIX_REGEX.test(baseUrl$1)) requestOptions.url = baseUrl$1.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
		return request2(requestOptions).then((response) => {
			if (response.data.errors) {
				const headers = {};
				for (const key of Object.keys(response.headers)) headers[key] = response.headers[key];
				throw new GraphqlResponseError(requestOptions, headers, response.data);
			}
			return response.data.data;
		});
	}
	function withDefaults(request2, newDefaults) {
		const newRequest = request2.defaults(newDefaults);
		const newApi = (query, options) => {
			return graphql(newRequest, query, options);
		};
		return Object.assign(newApi, {
			defaults: withDefaults.bind(null, newRequest),
			endpoint: newRequest.endpoint
		});
	}
	var graphql2 = withDefaults(import_request3.request, {
		headers: { "user-agent": `octokit-graphql.js/${VERSION$3} ${(0, import_universal_user_agent$1.getUserAgent)()}` },
		method: "POST",
		url: "/graphql"
	});
	function withCustomRequest(customRequest) {
		return withDefaults(customRequest, {
			method: "POST",
			url: "/graphql"
		});
	}
} });

//#endregion
//#region node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node$3 = __commonJS({ "node_modules/@octokit/auth-token/dist-node/index.js"(exports, module) {
	var __defProp$3 = Object.defineProperty;
	var __getOwnPropDesc$3 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$3 = Object.getOwnPropertyNames;
	var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
	var __export$3 = (target, all) => {
		for (var name in all) __defProp$3(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$3 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$3(from)) if (!__hasOwnProp$3.call(to, key) && key !== except) __defProp$3(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$3(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$3 = (mod) => __copyProps$3(__defProp$3({}, "__esModule", { value: true }), mod);
	var dist_src_exports$2 = {};
	__export$3(dist_src_exports$2, { createTokenAuth: () => createTokenAuth });
	module.exports = __toCommonJS$3(dist_src_exports$2);
	var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
	var REGEX_IS_INSTALLATION = /^ghs_/;
	var REGEX_IS_USER_TO_SERVER = /^ghu_/;
	async function auth$1(token) {
		const isApp = token.split(/\./).length === 3;
		const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
		const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
		const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
		return {
			type: "token",
			token,
			tokenType
		};
	}
	function withAuthorizationPrefix(token) {
		if (token.split(/\./).length === 3) return `bearer ${token}`;
		return `token ${token}`;
	}
	async function hook(token, request$3, route, parameters) {
		const endpoint$1 = request$3.endpoint.merge(route, parameters);
		endpoint$1.headers.authorization = withAuthorizationPrefix(token);
		return request$3(endpoint$1);
	}
	var createTokenAuth = function createTokenAuth2(token) {
		if (!token) throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
		if (typeof token !== "string") throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
		token = token.replace(/^(token|bearer) +/i, "");
		return Object.assign(auth$1.bind(null, token), { hook: hook.bind(null, token) });
	};
} });

//#endregion
//#region node_modules/@octokit/core/dist-node/index.js
var require_dist_node$2 = __commonJS({ "node_modules/@octokit/core/dist-node/index.js"(exports, module) {
	var __defProp$2 = Object.defineProperty;
	var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$2 = Object.getOwnPropertyNames;
	var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
	var __export$2 = (target, all) => {
		for (var name in all) __defProp$2(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$2 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$2(from)) if (!__hasOwnProp$2.call(to, key) && key !== except) __defProp$2(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$2(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$2 = (mod) => __copyProps$2(__defProp$2({}, "__esModule", { value: true }), mod);
	var index_exports = {};
	__export$2(index_exports, { Octokit: () => Octokit });
	module.exports = __toCommonJS$2(index_exports);
	var import_universal_user_agent = require_dist_node$9();
	var import_before_after_hook = require_before_after_hook();
	var import_request = require_dist_node$5();
	var import_graphql = require_dist_node$4();
	var import_auth_token = require_dist_node$3();
	var VERSION$2 = "5.2.1";
	var noop = () => {};
	var consoleWarn = console.warn.bind(console);
	var consoleError = console.error.bind(console);
	var userAgentTrail = `octokit-core.js/${VERSION$2} ${(0, import_universal_user_agent.getUserAgent)()}`;
	var Octokit = class {
		static {
			this.VERSION = VERSION$2;
		}
		static defaults(defaults) {
			const OctokitWithDefaults = class extends this {
				constructor(...args) {
					const options = args[0] || {};
					if (typeof defaults === "function") {
						super(defaults(options));
						return;
					}
					super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? { userAgent: `${options.userAgent} ${defaults.userAgent}` } : null));
				}
			};
			return OctokitWithDefaults;
		}
		static {
			this.plugins = [];
		}
		/**
		* Attach a plugin (or many) to your Octokit instance.
		*
		* @example
		* const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
		*/
		static plugin(...newPlugins) {
			const currentPlugins = this.plugins;
			const NewOctokit = class extends this {
				static {
					this.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
				}
			};
			return NewOctokit;
		}
		constructor(options = {}) {
			const hook$1 = new import_before_after_hook.Collection();
			const requestDefaults = {
				baseUrl: import_request.request.endpoint.DEFAULTS.baseUrl,
				headers: {},
				request: Object.assign({}, options.request, { hook: hook$1.bind(null, "request") }),
				mediaType: {
					previews: [],
					format: ""
				}
			};
			requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
			if (options.baseUrl) requestDefaults.baseUrl = options.baseUrl;
			if (options.previews) requestDefaults.mediaType.previews = options.previews;
			if (options.timeZone) requestDefaults.headers["time-zone"] = options.timeZone;
			this.request = import_request.request.defaults(requestDefaults);
			this.graphql = (0, import_graphql.withCustomRequest)(this.request).defaults(requestDefaults);
			this.log = Object.assign({
				debug: noop,
				info: noop,
				warn: consoleWarn,
				error: consoleError
			}, options.log);
			this.hook = hook$1;
			if (!options.authStrategy) if (!options.auth) this.auth = async () => ({ type: "unauthenticated" });
			else {
				const auth$2 = (0, import_auth_token.createTokenAuth)(options.auth);
				hook$1.wrap("request", auth$2.hook);
				this.auth = auth$2;
			}
			else {
				const { authStrategy,...otherOptions } = options;
				const auth$2 = authStrategy(Object.assign({
					request: this.request,
					log: this.log,
					octokit: this,
					octokitOptions: otherOptions
				}, options.auth));
				hook$1.wrap("request", auth$2.hook);
				this.auth = auth$2;
			}
			const classConstructor = this.constructor;
			for (let i$1 = 0; i$1 < classConstructor.plugins.length; ++i$1) Object.assign(this, classConstructor.plugins[i$1](this, options));
		}
	};
} });

//#endregion
//#region node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node$1 = __commonJS({ "node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js"(exports, module) {
	var __defProp$1 = Object.defineProperty;
	var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames$1 = Object.getOwnPropertyNames;
	var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
	var __export$1 = (target, all) => {
		for (var name in all) __defProp$1(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps$1 = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames$1(from)) if (!__hasOwnProp$1.call(to, key) && key !== except) __defProp$1(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS$1 = (mod) => __copyProps$1(__defProp$1({}, "__esModule", { value: true }), mod);
	var dist_src_exports$1 = {};
	__export$1(dist_src_exports$1, {
		legacyRestEndpointMethods: () => legacyRestEndpointMethods,
		restEndpointMethods: () => restEndpointMethods
	});
	module.exports = __toCommonJS$1(dist_src_exports$1);
	var VERSION$1 = "10.4.1";
	var Endpoints = {
		actions: {
			addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
			addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
			addSelectedRepoToOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
			approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
			cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
			createEnvironmentVariable: ["POST /repositories/{repository_id}/environments/{environment_name}/variables"],
			createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			createOrgVariable: ["POST /orgs/{org}/actions/variables"],
			createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
			createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
			createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
			createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
			createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
			createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
			deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
			deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
			deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
			deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			deleteEnvironmentVariable: ["DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
			deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			deleteRepoVariable: ["DELETE /repos/{owner}/{repo}/actions/variables/{name}"],
			deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
			deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
			deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
			deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
			disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
			disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
			downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
			downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
			downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
			downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
			enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
			enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
			forceCancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"],
			generateRunnerJitconfigForOrg: ["POST /orgs/{org}/actions/runners/generate-jitconfig"],
			generateRunnerJitconfigForRepo: ["POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"],
			getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
			getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
			getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
			getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
			getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
			getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
			getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
			getCustomOidcSubClaimForRepo: ["GET /repos/{owner}/{repo}/actions/oidc/customization/sub"],
			getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
			getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
			getEnvironmentVariable: ["GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
			getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
			getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
			getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
			getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
			getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
			getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
			getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
			getRepoPermissions: [
				"GET /repos/{owner}/{repo}/actions/permissions",
				{},
				{ renamed: ["actions", "getGithubActionsPermissionsRepository"] }
			],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
			getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
			getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
			getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
			getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
			getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
			getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
			getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
			getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
			getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
			getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
			listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
			listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
			listEnvironmentVariables: ["GET /repositories/{repository_id}/environments/{environment_name}/variables"],
			listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
			listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
			listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
			listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
			listOrgVariables: ["GET /orgs/{org}/actions/variables"],
			listRepoOrganizationSecrets: ["GET /repos/{owner}/{repo}/actions/organization-secrets"],
			listRepoOrganizationVariables: ["GET /repos/{owner}/{repo}/actions/organization-variables"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
			listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
			listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
			listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
			listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
			listSelectedReposForOrgVariable: ["GET /orgs/{org}/actions/variables/{name}/repositories"],
			listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
			listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
			listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
			listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
			listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
			listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
			reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
			reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
			reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
			removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
			removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
			removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
			removeSelectedRepoFromOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
			reviewCustomGatesForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"],
			reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
			setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
			setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
			setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
			setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
			setCustomOidcSubClaimForRepo: ["PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"],
			setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
			setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
			setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
			setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
			setSelectedReposForOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories"],
			setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
			setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"],
			updateEnvironmentVariable: ["PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
			updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
			updateRepoVariable: ["PATCH /repos/{owner}/{repo}/actions/variables/{name}"]
		},
		activity: {
			checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
			deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
			deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
			getFeeds: ["GET /feeds"],
			getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
			getThread: ["GET /notifications/threads/{thread_id}"],
			getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
			listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
			listNotificationsForAuthenticatedUser: ["GET /notifications"],
			listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
			listPublicEvents: ["GET /events"],
			listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
			listPublicEventsForUser: ["GET /users/{username}/events/public"],
			listPublicOrgEvents: ["GET /orgs/{org}/events"],
			listReceivedEventsForUser: ["GET /users/{username}/received_events"],
			listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
			listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
			listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
			listReposStarredByAuthenticatedUser: ["GET /user/starred"],
			listReposStarredByUser: ["GET /users/{username}/starred"],
			listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
			listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
			listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
			listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
			markNotificationsAsRead: ["PUT /notifications"],
			markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
			markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
			markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
			setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
			setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
			starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
			unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
		},
		apps: {
			addRepoToInstallation: [
				"PUT /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
			],
			addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
			checkToken: ["POST /applications/{client_id}/token"],
			createFromManifest: ["POST /app-manifests/{code}/conversions"],
			createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
			deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
			deleteInstallation: ["DELETE /app/installations/{installation_id}"],
			deleteToken: ["DELETE /applications/{client_id}/token"],
			getAuthenticated: ["GET /app"],
			getBySlug: ["GET /apps/{app_slug}"],
			getInstallation: ["GET /app/installations/{installation_id}"],
			getOrgInstallation: ["GET /orgs/{org}/installation"],
			getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
			getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
			getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
			getUserInstallation: ["GET /users/{username}/installation"],
			getWebhookConfigForApp: ["GET /app/hook/config"],
			getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
			listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
			listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
			listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
			listInstallationRequestsForAuthenticatedApp: ["GET /app/installation-requests"],
			listInstallations: ["GET /app/installations"],
			listInstallationsForAuthenticatedUser: ["GET /user/installations"],
			listPlans: ["GET /marketplace_listing/plans"],
			listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
			listReposAccessibleToInstallation: ["GET /installation/repositories"],
			listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
			listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
			listWebhookDeliveries: ["GET /app/hook/deliveries"],
			redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
			removeRepoFromInstallation: [
				"DELETE /user/installations/{installation_id}/repositories/{repository_id}",
				{},
				{ renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
			],
			removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
			resetToken: ["PATCH /applications/{client_id}/token"],
			revokeInstallationAccessToken: ["DELETE /installation/token"],
			scopeToken: ["POST /applications/{client_id}/token/scoped"],
			suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
			unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
			updateWebhookConfigForApp: ["PATCH /app/hook/config"]
		},
		billing: {
			getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
			getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
			getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
			getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
			getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
			getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
		},
		checks: {
			create: ["POST /repos/{owner}/{repo}/check-runs"],
			createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
			get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
			getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
			listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
			listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
			listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
			listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
			rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
			rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
			setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
			update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
		},
		codeScanning: {
			deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
			getAlert: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
				{},
				{ renamedParameters: { alert_id: "alert_number" } }
			],
			getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
			getCodeqlDatabase: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"],
			getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
			getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
			listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
			listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
			listAlertsInstances: [
				"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
				{},
				{ renamed: ["codeScanning", "listAlertInstances"] }
			],
			listCodeqlDatabases: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases"],
			listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
			updateDefaultSetup: ["PATCH /repos/{owner}/{repo}/code-scanning/default-setup"],
			uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
		},
		codesOfConduct: {
			getAllCodesOfConduct: ["GET /codes_of_conduct"],
			getConductCode: ["GET /codes_of_conduct/{key}"]
		},
		codespaces: {
			addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			checkPermissionsForDevcontainer: ["GET /repos/{owner}/{repo}/codespaces/permissions_check"],
			codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
			createForAuthenticatedUser: ["POST /user/codespaces"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
			createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
			createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
			deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
			deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
			exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
			getCodespacesForUserInOrg: ["GET /orgs/{org}/members/{username}/codespaces"],
			getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
			getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
			getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
			getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
			getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
			listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
			listForAuthenticatedUser: ["GET /user/codespaces"],
			listInOrganization: [
				"GET /orgs/{org}/codespaces",
				{},
				{ renamedParameters: { org_id: "org" } }
			],
			listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
			listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
			listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
			listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
			preFlightWithRepoForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/new"],
			publishForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/publish"],
			removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
			repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
			setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
			startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
			stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
			stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
			updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
		},
		copilot: {
			addCopilotSeatsForTeams: ["POST /orgs/{org}/copilot/billing/selected_teams"],
			addCopilotSeatsForUsers: ["POST /orgs/{org}/copilot/billing/selected_users"],
			cancelCopilotSeatAssignmentForTeams: ["DELETE /orgs/{org}/copilot/billing/selected_teams"],
			cancelCopilotSeatAssignmentForUsers: ["DELETE /orgs/{org}/copilot/billing/selected_users"],
			getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
			getCopilotSeatDetailsForUser: ["GET /orgs/{org}/members/{username}/copilot"],
			listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
		},
		dependabot: {
			addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
			createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
			createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
			deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
			getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
			getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
			getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
			getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
			listAlertsForEnterprise: ["GET /enterprises/{enterprise}/dependabot/alerts"],
			listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
			listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
			listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
			listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
			removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
			setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"]
		},
		dependencyGraph: {
			createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
			diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"],
			exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
		},
		emojis: { get: ["GET /emojis"] },
		gists: {
			checkIsStarred: ["GET /gists/{gist_id}/star"],
			create: ["POST /gists"],
			createComment: ["POST /gists/{gist_id}/comments"],
			delete: ["DELETE /gists/{gist_id}"],
			deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
			fork: ["POST /gists/{gist_id}/forks"],
			get: ["GET /gists/{gist_id}"],
			getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
			getRevision: ["GET /gists/{gist_id}/{sha}"],
			list: ["GET /gists"],
			listComments: ["GET /gists/{gist_id}/comments"],
			listCommits: ["GET /gists/{gist_id}/commits"],
			listForUser: ["GET /users/{username}/gists"],
			listForks: ["GET /gists/{gist_id}/forks"],
			listPublic: ["GET /gists/public"],
			listStarred: ["GET /gists/starred"],
			star: ["PUT /gists/{gist_id}/star"],
			unstar: ["DELETE /gists/{gist_id}/star"],
			update: ["PATCH /gists/{gist_id}"],
			updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
		},
		git: {
			createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
			createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
			createRef: ["POST /repos/{owner}/{repo}/git/refs"],
			createTag: ["POST /repos/{owner}/{repo}/git/tags"],
			createTree: ["POST /repos/{owner}/{repo}/git/trees"],
			deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
			getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
			getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
			getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
			getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
			getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
			listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
			updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
		},
		gitignore: {
			getAllTemplates: ["GET /gitignore/templates"],
			getTemplate: ["GET /gitignore/templates/{name}"]
		},
		interactions: {
			getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
			getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
			getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
			getRestrictionsForYourPublicRepos: [
				"GET /user/interaction-limits",
				{},
				{ renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
			],
			removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
			removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
			removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
			removeRestrictionsForYourPublicRepos: [
				"DELETE /user/interaction-limits",
				{},
				{ renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
			],
			setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
			setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
			setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
			setRestrictionsForYourPublicRepos: [
				"PUT /user/interaction-limits",
				{},
				{ renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
			]
		},
		issues: {
			addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
			addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
			checkUserCanBeAssignedToIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"],
			create: ["POST /repos/{owner}/{repo}/issues"],
			createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
			createLabel: ["POST /repos/{owner}/{repo}/labels"],
			createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
			deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
			deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
			get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
			getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
			getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
			getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
			list: ["GET /issues"],
			listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
			listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
			listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
			listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
			listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
			listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
			listForAuthenticatedUser: ["GET /user/issues"],
			listForOrg: ["GET /orgs/{org}/issues"],
			listForRepo: ["GET /repos/{owner}/{repo}/issues"],
			listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
			listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
			listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
			lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
			removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
			setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
			unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
			update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
			updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
			updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
			updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
		},
		licenses: {
			get: ["GET /licenses/{license}"],
			getAllCommonlyUsed: ["GET /licenses"],
			getForRepo: ["GET /repos/{owner}/{repo}/license"]
		},
		markdown: {
			render: ["POST /markdown"],
			renderRaw: ["POST /markdown/raw", { headers: { "content-type": "text/plain; charset=utf-8" } }]
		},
		meta: {
			get: ["GET /meta"],
			getAllVersions: ["GET /versions"],
			getOctocat: ["GET /octocat"],
			getZen: ["GET /zen"],
			root: ["GET /"]
		},
		migrations: {
			cancelImport: [
				"DELETE /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import" }
			],
			deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
			deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
			downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
			getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
			getCommitAuthors: [
				"GET /repos/{owner}/{repo}/import/authors",
				{},
				{ deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors" }
			],
			getImportStatus: [
				"GET /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status" }
			],
			getLargeFiles: [
				"GET /repos/{owner}/{repo}/import/large_files",
				{},
				{ deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files" }
			],
			getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
			getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
			listForAuthenticatedUser: ["GET /user/migrations"],
			listForOrg: ["GET /orgs/{org}/migrations"],
			listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
			listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
			listReposForUser: [
				"GET /user/migrations/{migration_id}/repositories",
				{},
				{ renamed: ["migrations", "listReposForAuthenticatedUser"] }
			],
			mapCommitAuthor: [
				"PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
				{},
				{ deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author" }
			],
			setLfsPreference: [
				"PATCH /repos/{owner}/{repo}/import/lfs",
				{},
				{ deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference" }
			],
			startForAuthenticatedUser: ["POST /user/migrations"],
			startForOrg: ["POST /orgs/{org}/migrations"],
			startImport: [
				"PUT /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import" }
			],
			unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
			unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
			updateImport: [
				"PATCH /repos/{owner}/{repo}/import",
				{},
				{ deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import" }
			]
		},
		oidc: {
			getOidcCustomSubTemplateForOrg: ["GET /orgs/{org}/actions/oidc/customization/sub"],
			updateOidcCustomSubTemplateForOrg: ["PUT /orgs/{org}/actions/oidc/customization/sub"]
		},
		orgs: {
			addSecurityManagerTeam: ["PUT /orgs/{org}/security-managers/teams/{team_slug}"],
			assignTeamToOrgRole: ["PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
			assignUserToOrgRole: ["PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"],
			blockUser: ["PUT /orgs/{org}/blocks/{username}"],
			cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
			checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
			checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
			checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
			convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
			createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
			createInvitation: ["POST /orgs/{org}/invitations"],
			createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
			createOrUpdateCustomPropertiesValuesForRepos: ["PATCH /orgs/{org}/properties/values"],
			createOrUpdateCustomProperty: ["PUT /orgs/{org}/properties/schema/{custom_property_name}"],
			createWebhook: ["POST /orgs/{org}/hooks"],
			delete: ["DELETE /orgs/{org}"],
			deleteCustomOrganizationRole: ["DELETE /orgs/{org}/organization-roles/{role_id}"],
			deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
			enableOrDisableSecurityProductOnAllOrgRepos: ["POST /orgs/{org}/{security_product}/{enablement}"],
			get: ["GET /orgs/{org}"],
			getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
			getCustomProperty: ["GET /orgs/{org}/properties/schema/{custom_property_name}"],
			getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
			getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
			getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
			getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
			getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
			getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
			list: ["GET /organizations"],
			listAppInstallations: ["GET /orgs/{org}/installations"],
			listBlockedUsers: ["GET /orgs/{org}/blocks"],
			listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
			listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
			listForAuthenticatedUser: ["GET /user/orgs"],
			listForUser: ["GET /users/{username}/orgs"],
			listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
			listMembers: ["GET /orgs/{org}/members"],
			listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
			listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
			listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
			listOrgRoles: ["GET /orgs/{org}/organization-roles"],
			listOrganizationFineGrainedPermissions: ["GET /orgs/{org}/organization-fine-grained-permissions"],
			listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
			listPatGrantRepositories: ["GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"],
			listPatGrantRequestRepositories: ["GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"],
			listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
			listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
			listPendingInvitations: ["GET /orgs/{org}/invitations"],
			listPublicMembers: ["GET /orgs/{org}/public_members"],
			listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
			listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
			listWebhooks: ["GET /orgs/{org}/hooks"],
			patchCustomOrganizationRole: ["PATCH /orgs/{org}/organization-roles/{role_id}"],
			pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
			removeCustomProperty: ["DELETE /orgs/{org}/properties/schema/{custom_property_name}"],
			removeMember: ["DELETE /orgs/{org}/members/{username}"],
			removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
			removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
			removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
			removeSecurityManagerTeam: ["DELETE /orgs/{org}/security-managers/teams/{team_slug}"],
			reviewPatGrantRequest: ["POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"],
			reviewPatGrantRequestsInBulk: ["POST /orgs/{org}/personal-access-token-requests"],
			revokeAllOrgRolesTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}"],
			revokeAllOrgRolesUser: ["DELETE /orgs/{org}/organization-roles/users/{username}"],
			revokeOrgRoleTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
			revokeOrgRoleUser: ["DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"],
			setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
			setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
			unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
			update: ["PATCH /orgs/{org}"],
			updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
			updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
			updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
			updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
			updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
		},
		packages: {
			deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
			deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
			deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
			deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getAllPackageVersionsForAPackageOwnedByAnOrg: [
				"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
				{},
				{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
			],
			getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
				"GET /user/packages/{package_type}/{package_name}/versions",
				{},
				{ renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"] }
			],
			getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
			getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
			getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
			getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
			getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
			getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
			getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
			listDockerMigrationConflictingPackagesForAuthenticatedUser: ["GET /user/docker/conflicts"],
			listDockerMigrationConflictingPackagesForOrganization: ["GET /orgs/{org}/docker/conflicts"],
			listDockerMigrationConflictingPackagesForUser: ["GET /users/{username}/docker/conflicts"],
			listPackagesForAuthenticatedUser: ["GET /user/packages"],
			listPackagesForOrganization: ["GET /orgs/{org}/packages"],
			listPackagesForUser: ["GET /users/{username}/packages"],
			restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
			restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
			restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
			restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
		},
		projects: {
			addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
			createCard: ["POST /projects/columns/{column_id}/cards"],
			createColumn: ["POST /projects/{project_id}/columns"],
			createForAuthenticatedUser: ["POST /user/projects"],
			createForOrg: ["POST /orgs/{org}/projects"],
			createForRepo: ["POST /repos/{owner}/{repo}/projects"],
			delete: ["DELETE /projects/{project_id}"],
			deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
			deleteColumn: ["DELETE /projects/columns/{column_id}"],
			get: ["GET /projects/{project_id}"],
			getCard: ["GET /projects/columns/cards/{card_id}"],
			getColumn: ["GET /projects/columns/{column_id}"],
			getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
			listCards: ["GET /projects/columns/{column_id}/cards"],
			listCollaborators: ["GET /projects/{project_id}/collaborators"],
			listColumns: ["GET /projects/{project_id}/columns"],
			listForOrg: ["GET /orgs/{org}/projects"],
			listForRepo: ["GET /repos/{owner}/{repo}/projects"],
			listForUser: ["GET /users/{username}/projects"],
			moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
			moveColumn: ["POST /projects/columns/{column_id}/moves"],
			removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
			update: ["PATCH /projects/{project_id}"],
			updateCard: ["PATCH /projects/columns/cards/{card_id}"],
			updateColumn: ["PATCH /projects/columns/{column_id}"]
		},
		pulls: {
			checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			create: ["POST /repos/{owner}/{repo}/pulls"],
			createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
			createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
			deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
			dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
			get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
			getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
			list: ["GET /repos/{owner}/{repo}/pulls"],
			listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
			listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
			listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
			listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
			listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
			listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
			merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
			removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
			submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
			update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
			updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
			updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
			updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
		},
		rateLimit: { get: ["GET /rate_limit"] },
		reactions: {
			createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
			createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
			createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
			createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
			createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
			createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
			createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
			deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
			deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
			deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
			deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
			deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],
			listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
			listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
			listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
			listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
			listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
			listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
			listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]
		},
		repos: {
			acceptInvitation: [
				"PATCH /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
			],
			acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
			addAppAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
			addStatusCheckContexts: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			addTeamAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			addUserAccessRestrictions: [
				"POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			cancelPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"],
			checkAutomatedSecurityFixes: ["GET /repos/{owner}/{repo}/automated-security-fixes"],
			checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
			checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
			codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
			compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
			compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
			createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
			createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
			createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
			createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
			createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
			createDeploymentBranchPolicy: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
			createDeploymentProtectionRule: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
			createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
			createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
			createForAuthenticatedUser: ["POST /user/repos"],
			createFork: ["POST /repos/{owner}/{repo}/forks"],
			createInOrg: ["POST /orgs/{org}/repos"],
			createOrUpdateCustomPropertiesValues: ["PATCH /repos/{owner}/{repo}/properties/values"],
			createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
			createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
			createOrgRuleset: ["POST /orgs/{org}/rulesets"],
			createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
			createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
			createRelease: ["POST /repos/{owner}/{repo}/releases"],
			createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
			createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
			createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
			createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
			declineInvitation: [
				"DELETE /user/repository_invitations/{invitation_id}",
				{},
				{ renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
			],
			declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
			delete: ["DELETE /repos/{owner}/{repo}"],
			deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
			deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
			deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
			deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
			deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
			deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
			deleteDeploymentBranchPolicy: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
			deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
			deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
			deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
			deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
			deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			deleteTagProtection: ["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],
			deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
			disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
			disableDeploymentProtectionRule: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
			disablePrivateVulnerabilityReporting: ["DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"],
			disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
			downloadArchive: [
				"GET /repos/{owner}/{repo}/zipball/{ref}",
				{},
				{ renamed: ["repos", "downloadZipballArchive"] }
			],
			downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
			downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
			enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
			enablePrivateVulnerabilityReporting: ["PUT /repos/{owner}/{repo}/private-vulnerability-reporting"],
			enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
			generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
			get: ["GET /repos/{owner}/{repo}"],
			getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
			getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			getAllDeploymentProtectionRules: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
			getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
			getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
			getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
			getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
			getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
			getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
			getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
			getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
			getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
			getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
			getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
			getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
			getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
			getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
			getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
			getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
			getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
			getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
			getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
			getCustomDeploymentProtectionRule: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
			getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
			getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
			getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
			getDeploymentBranchPolicy: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
			getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
			getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
			getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
			getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
			getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
			getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
			getOrgRulesets: ["GET /orgs/{org}/rulesets"],
			getPages: ["GET /repos/{owner}/{repo}/pages"],
			getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
			getPagesDeployment: ["GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"],
			getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
			getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
			getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
			getReadme: ["GET /repos/{owner}/{repo}/readme"],
			getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
			getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
			getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
			getRepoRuleSuite: ["GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"],
			getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
			getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
			getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
			getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
			getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
			getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
			getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
			getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
			getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
			getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
			listActivities: ["GET /repos/{owner}/{repo}/activity"],
			listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
			listBranches: ["GET /repos/{owner}/{repo}/branches"],
			listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
			listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
			listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
			listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
			listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
			listCommits: ["GET /repos/{owner}/{repo}/commits"],
			listContributors: ["GET /repos/{owner}/{repo}/contributors"],
			listCustomDeploymentRuleIntegrations: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"],
			listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
			listDeploymentBranchPolicies: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
			listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
			listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
			listForAuthenticatedUser: ["GET /user/repos"],
			listForOrg: ["GET /orgs/{org}/repos"],
			listForUser: ["GET /users/{username}/repos"],
			listForks: ["GET /repos/{owner}/{repo}/forks"],
			listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
			listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
			listLanguages: ["GET /repos/{owner}/{repo}/languages"],
			listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
			listPublic: ["GET /repositories"],
			listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
			listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
			listReleases: ["GET /repos/{owner}/{repo}/releases"],
			listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
			listTags: ["GET /repos/{owner}/{repo}/tags"],
			listTeams: ["GET /repos/{owner}/{repo}/teams"],
			listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
			listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
			merge: ["POST /repos/{owner}/{repo}/merges"],
			mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
			pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
			redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
			removeAppAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
			removeStatusCheckContexts: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			removeTeamAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			removeUserAccessRestrictions: [
				"DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
			replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
			requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
			setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
			setAppAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
				{},
				{ mapToData: "apps" }
			],
			setStatusCheckContexts: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
				{},
				{ mapToData: "contexts" }
			],
			setTeamAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
				{},
				{ mapToData: "teams" }
			],
			setUserAccessRestrictions: [
				"PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
				{},
				{ mapToData: "users" }
			],
			testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
			transfer: ["POST /repos/{owner}/{repo}/transfer"],
			update: ["PATCH /repos/{owner}/{repo}"],
			updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
			updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
			updateDeploymentBranchPolicy: ["PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
			updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
			updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
			updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
			updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
			updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
			updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
			updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
			updateStatusCheckPotection: [
				"PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
				{},
				{ renamed: ["repos", "updateStatusCheckProtection"] }
			],
			updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
			updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
			updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
			uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", { baseUrl: "https://uploads.github.com" }]
		},
		search: {
			code: ["GET /search/code"],
			commits: ["GET /search/commits"],
			issuesAndPullRequests: ["GET /search/issues"],
			labels: ["GET /search/labels"],
			repos: ["GET /search/repositories"],
			topics: ["GET /search/topics"],
			users: ["GET /search/users"]
		},
		secretScanning: {
			getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
			listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
			listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
			listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
			listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
			updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
		},
		securityAdvisories: {
			createFork: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"],
			createPrivateVulnerabilityReport: ["POST /repos/{owner}/{repo}/security-advisories/reports"],
			createRepositoryAdvisory: ["POST /repos/{owner}/{repo}/security-advisories"],
			createRepositoryAdvisoryCveRequest: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"],
			getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
			getRepositoryAdvisory: ["GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],
			listGlobalAdvisories: ["GET /advisories"],
			listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
			listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
			updateRepositoryAdvisory: ["PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"]
		},
		teams: {
			addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			create: ["POST /orgs/{org}/teams"],
			createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
			createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
			deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
			getByName: ["GET /orgs/{org}/teams/{team_slug}"],
			getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			list: ["GET /orgs/{org}/teams"],
			listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
			listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
			listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
			listForAuthenticatedUser: ["GET /user/teams"],
			listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
			listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
			listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
			listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
			removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
			removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
			removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
			updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
			updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
			updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
		},
		users: {
			addEmailForAuthenticated: [
				"POST /user/emails",
				{},
				{ renamed: ["users", "addEmailForAuthenticatedUser"] }
			],
			addEmailForAuthenticatedUser: ["POST /user/emails"],
			addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
			block: ["PUT /user/blocks/{username}"],
			checkBlocked: ["GET /user/blocks/{username}"],
			checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
			checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
			createGpgKeyForAuthenticated: [
				"POST /user/gpg_keys",
				{},
				{ renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
			],
			createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
			createPublicSshKeyForAuthenticated: [
				"POST /user/keys",
				{},
				{ renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
			],
			createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
			createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
			deleteEmailForAuthenticated: [
				"DELETE /user/emails",
				{},
				{ renamed: ["users", "deleteEmailForAuthenticatedUser"] }
			],
			deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
			deleteGpgKeyForAuthenticated: [
				"DELETE /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
			],
			deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
			deletePublicSshKeyForAuthenticated: [
				"DELETE /user/keys/{key_id}",
				{},
				{ renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
			],
			deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
			deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
			deleteSshSigningKeyForAuthenticatedUser: ["DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"],
			follow: ["PUT /user/following/{username}"],
			getAuthenticated: ["GET /user"],
			getByUsername: ["GET /users/{username}"],
			getContextForUser: ["GET /users/{username}/hovercard"],
			getGpgKeyForAuthenticated: [
				"GET /user/gpg_keys/{gpg_key_id}",
				{},
				{ renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
			],
			getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
			getPublicSshKeyForAuthenticated: [
				"GET /user/keys/{key_id}",
				{},
				{ renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
			],
			getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
			getSshSigningKeyForAuthenticatedUser: ["GET /user/ssh_signing_keys/{ssh_signing_key_id}"],
			list: ["GET /users"],
			listBlockedByAuthenticated: [
				"GET /user/blocks",
				{},
				{ renamed: ["users", "listBlockedByAuthenticatedUser"] }
			],
			listBlockedByAuthenticatedUser: ["GET /user/blocks"],
			listEmailsForAuthenticated: [
				"GET /user/emails",
				{},
				{ renamed: ["users", "listEmailsForAuthenticatedUser"] }
			],
			listEmailsForAuthenticatedUser: ["GET /user/emails"],
			listFollowedByAuthenticated: [
				"GET /user/following",
				{},
				{ renamed: ["users", "listFollowedByAuthenticatedUser"] }
			],
			listFollowedByAuthenticatedUser: ["GET /user/following"],
			listFollowersForAuthenticatedUser: ["GET /user/followers"],
			listFollowersForUser: ["GET /users/{username}/followers"],
			listFollowingForUser: ["GET /users/{username}/following"],
			listGpgKeysForAuthenticated: [
				"GET /user/gpg_keys",
				{},
				{ renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
			],
			listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
			listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
			listPublicEmailsForAuthenticated: [
				"GET /user/public_emails",
				{},
				{ renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
			],
			listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
			listPublicKeysForUser: ["GET /users/{username}/keys"],
			listPublicSshKeysForAuthenticated: [
				"GET /user/keys",
				{},
				{ renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
			],
			listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
			listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
			listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
			listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
			listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
			setPrimaryEmailVisibilityForAuthenticated: [
				"PATCH /user/email/visibility",
				{},
				{ renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
			],
			setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
			unblock: ["DELETE /user/blocks/{username}"],
			unfollow: ["DELETE /user/following/{username}"],
			updateAuthenticated: ["PATCH /user"]
		}
	};
	var endpoints_default = Endpoints;
	var endpointMethodsMap = /* @__PURE__ */ new Map();
	for (const [scope, endpoints] of Object.entries(endpoints_default)) for (const [methodName, endpoint$1] of Object.entries(endpoints)) {
		const [route, defaults, decorations] = endpoint$1;
		const [method, url] = route.split(/ /);
		const endpointDefaults = Object.assign({
			method,
			url
		}, defaults);
		if (!endpointMethodsMap.has(scope)) endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
		endpointMethodsMap.get(scope).set(methodName, {
			scope,
			methodName,
			endpointDefaults,
			decorations
		});
	}
	var handler = {
		has({ scope }, methodName) {
			return endpointMethodsMap.get(scope).has(methodName);
		},
		getOwnPropertyDescriptor(target, methodName) {
			return {
				value: this.get(target, methodName),
				configurable: true,
				writable: true,
				enumerable: true
			};
		},
		defineProperty(target, methodName, descriptor) {
			Object.defineProperty(target.cache, methodName, descriptor);
			return true;
		},
		deleteProperty(target, methodName) {
			delete target.cache[methodName];
			return true;
		},
		ownKeys({ scope }) {
			return [...endpointMethodsMap.get(scope).keys()];
		},
		set(target, methodName, value) {
			return target.cache[methodName] = value;
		},
		get({ octokit, scope, cache }, methodName) {
			if (cache[methodName]) return cache[methodName];
			const method = endpointMethodsMap.get(scope).get(methodName);
			if (!method) return void 0;
			const { endpointDefaults, decorations } = method;
			if (decorations) cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
			else cache[methodName] = octokit.request.defaults(endpointDefaults);
			return cache[methodName];
		}
	};
	function endpointsToMethods(octokit) {
		const newMethods = {};
		for (const scope of endpointMethodsMap.keys()) newMethods[scope] = new Proxy({
			octokit,
			scope,
			cache: {}
		}, handler);
		return newMethods;
	}
	function decorate(octokit, scope, methodName, defaults, decorations) {
		const requestWithDefaults = octokit.request.defaults(defaults);
		function withDecorations(...args) {
			let options = requestWithDefaults.endpoint.merge(...args);
			if (decorations.mapToData) {
				options = Object.assign({}, options, {
					data: options[decorations.mapToData],
					[decorations.mapToData]: void 0
				});
				return requestWithDefaults(options);
			}
			if (decorations.renamed) {
				const [newScope, newMethodName] = decorations.renamed;
				octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
			}
			if (decorations.deprecated) octokit.log.warn(decorations.deprecated);
			if (decorations.renamedParameters) {
				const options2 = requestWithDefaults.endpoint.merge(...args);
				for (const [name, alias] of Object.entries(decorations.renamedParameters)) if (name in options2) {
					octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
					if (!(alias in options2)) options2[alias] = options2[name];
					delete options2[name];
				}
				return requestWithDefaults(options2);
			}
			return requestWithDefaults(...args);
		}
		return Object.assign(withDecorations, requestWithDefaults);
	}
	function restEndpointMethods(octokit) {
		const api$1 = endpointsToMethods(octokit);
		return { rest: api$1 };
	}
	restEndpointMethods.VERSION = VERSION$1;
	function legacyRestEndpointMethods(octokit) {
		const api$1 = endpointsToMethods(octokit);
		return {
			...api$1,
			rest: api$1
		};
	}
	legacyRestEndpointMethods.VERSION = VERSION$1;
} });

//#endregion
//#region node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node = __commonJS({ "node_modules/@octokit/plugin-paginate-rest/dist-node/index.js"(exports, module) {
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __export = (target, all) => {
		for (var name in all) __defProp(target, name, {
			get: all[name],
			enumerable: true
		});
	};
	var __copyProps = (to, from, except, desc) => {
		if (from && typeof from === "object" || typeof from === "function") {
			for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
				get: () => from[key],
				enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
			});
		}
		return to;
	};
	var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
	var dist_src_exports = {};
	__export(dist_src_exports, {
		composePaginateRest: () => composePaginateRest,
		isPaginatingEndpoint: () => isPaginatingEndpoint,
		paginateRest: () => paginateRest,
		paginatingEndpoints: () => paginatingEndpoints
	});
	module.exports = __toCommonJS(dist_src_exports);
	var VERSION = "9.2.2";
	function normalizePaginatedListResponse(response) {
		if (!response.data) return {
			...response,
			data: []
		};
		const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
		if (!responseNeedsNormalization) return response;
		const incompleteResults = response.data.incomplete_results;
		const repositorySelection = response.data.repository_selection;
		const totalCount = response.data.total_count;
		delete response.data.incomplete_results;
		delete response.data.repository_selection;
		delete response.data.total_count;
		const namespaceKey = Object.keys(response.data)[0];
		const data = response.data[namespaceKey];
		response.data = data;
		if (typeof incompleteResults !== "undefined") response.data.incomplete_results = incompleteResults;
		if (typeof repositorySelection !== "undefined") response.data.repository_selection = repositorySelection;
		response.data.total_count = totalCount;
		return response;
	}
	function iterator(octokit, route, parameters) {
		const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
		const requestMethod = typeof route === "function" ? route : octokit.request;
		const method = options.method;
		const headers = options.headers;
		let url = options.url;
		return { [Symbol.asyncIterator]: () => ({ async next() {
			if (!url) return { done: true };
			try {
				const response = await requestMethod({
					method,
					url,
					headers
				});
				const normalizedResponse = normalizePaginatedListResponse(response);
				url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
				return { value: normalizedResponse };
			} catch (error$1) {
				if (error$1.status !== 409) throw error$1;
				url = "";
				return { value: {
					status: 200,
					headers: {},
					data: []
				} };
			}
		} }) };
	}
	function paginate(octokit, route, parameters, mapFn) {
		if (typeof parameters === "function") {
			mapFn = parameters;
			parameters = void 0;
		}
		return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
	}
	function gather(octokit, results, iterator2, mapFn) {
		return iterator2.next().then((result) => {
			if (result.done) return results;
			let earlyExit = false;
			function done() {
				earlyExit = true;
			}
			results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
			if (earlyExit) return results;
			return gather(octokit, results, iterator2, mapFn);
		});
	}
	var composePaginateRest = Object.assign(paginate, { iterator });
	var paginatingEndpoints = [
		"GET /advisories",
		"GET /app/hook/deliveries",
		"GET /app/installation-requests",
		"GET /app/installations",
		"GET /assignments/{assignment_id}/accepted_assignments",
		"GET /classrooms",
		"GET /classrooms/{classroom_id}/assignments",
		"GET /enterprises/{enterprise}/dependabot/alerts",
		"GET /enterprises/{enterprise}/secret-scanning/alerts",
		"GET /events",
		"GET /gists",
		"GET /gists/public",
		"GET /gists/starred",
		"GET /gists/{gist_id}/comments",
		"GET /gists/{gist_id}/commits",
		"GET /gists/{gist_id}/forks",
		"GET /installation/repositories",
		"GET /issues",
		"GET /licenses",
		"GET /marketplace_listing/plans",
		"GET /marketplace_listing/plans/{plan_id}/accounts",
		"GET /marketplace_listing/stubbed/plans",
		"GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
		"GET /networks/{owner}/{repo}/events",
		"GET /notifications",
		"GET /organizations",
		"GET /orgs/{org}/actions/cache/usage-by-repository",
		"GET /orgs/{org}/actions/permissions/repositories",
		"GET /orgs/{org}/actions/runners",
		"GET /orgs/{org}/actions/secrets",
		"GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/actions/variables",
		"GET /orgs/{org}/actions/variables/{name}/repositories",
		"GET /orgs/{org}/blocks",
		"GET /orgs/{org}/code-scanning/alerts",
		"GET /orgs/{org}/codespaces",
		"GET /orgs/{org}/codespaces/secrets",
		"GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/copilot/billing/seats",
		"GET /orgs/{org}/dependabot/alerts",
		"GET /orgs/{org}/dependabot/secrets",
		"GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
		"GET /orgs/{org}/events",
		"GET /orgs/{org}/failed_invitations",
		"GET /orgs/{org}/hooks",
		"GET /orgs/{org}/hooks/{hook_id}/deliveries",
		"GET /orgs/{org}/installations",
		"GET /orgs/{org}/invitations",
		"GET /orgs/{org}/invitations/{invitation_id}/teams",
		"GET /orgs/{org}/issues",
		"GET /orgs/{org}/members",
		"GET /orgs/{org}/members/{username}/codespaces",
		"GET /orgs/{org}/migrations",
		"GET /orgs/{org}/migrations/{migration_id}/repositories",
		"GET /orgs/{org}/organization-roles/{role_id}/teams",
		"GET /orgs/{org}/organization-roles/{role_id}/users",
		"GET /orgs/{org}/outside_collaborators",
		"GET /orgs/{org}/packages",
		"GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
		"GET /orgs/{org}/personal-access-token-requests",
		"GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
		"GET /orgs/{org}/personal-access-tokens",
		"GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
		"GET /orgs/{org}/projects",
		"GET /orgs/{org}/properties/values",
		"GET /orgs/{org}/public_members",
		"GET /orgs/{org}/repos",
		"GET /orgs/{org}/rulesets",
		"GET /orgs/{org}/rulesets/rule-suites",
		"GET /orgs/{org}/secret-scanning/alerts",
		"GET /orgs/{org}/security-advisories",
		"GET /orgs/{org}/teams",
		"GET /orgs/{org}/teams/{team_slug}/discussions",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
		"GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
		"GET /orgs/{org}/teams/{team_slug}/invitations",
		"GET /orgs/{org}/teams/{team_slug}/members",
		"GET /orgs/{org}/teams/{team_slug}/projects",
		"GET /orgs/{org}/teams/{team_slug}/repos",
		"GET /orgs/{org}/teams/{team_slug}/teams",
		"GET /projects/columns/{column_id}/cards",
		"GET /projects/{project_id}/collaborators",
		"GET /projects/{project_id}/columns",
		"GET /repos/{owner}/{repo}/actions/artifacts",
		"GET /repos/{owner}/{repo}/actions/caches",
		"GET /repos/{owner}/{repo}/actions/organization-secrets",
		"GET /repos/{owner}/{repo}/actions/organization-variables",
		"GET /repos/{owner}/{repo}/actions/runners",
		"GET /repos/{owner}/{repo}/actions/runs",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
		"GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
		"GET /repos/{owner}/{repo}/actions/secrets",
		"GET /repos/{owner}/{repo}/actions/variables",
		"GET /repos/{owner}/{repo}/actions/workflows",
		"GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
		"GET /repos/{owner}/{repo}/activity",
		"GET /repos/{owner}/{repo}/assignees",
		"GET /repos/{owner}/{repo}/branches",
		"GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
		"GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
		"GET /repos/{owner}/{repo}/code-scanning/alerts",
		"GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
		"GET /repos/{owner}/{repo}/code-scanning/analyses",
		"GET /repos/{owner}/{repo}/codespaces",
		"GET /repos/{owner}/{repo}/codespaces/devcontainers",
		"GET /repos/{owner}/{repo}/codespaces/secrets",
		"GET /repos/{owner}/{repo}/collaborators",
		"GET /repos/{owner}/{repo}/comments",
		"GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/commits",
		"GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
		"GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
		"GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
		"GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
		"GET /repos/{owner}/{repo}/commits/{ref}/status",
		"GET /repos/{owner}/{repo}/commits/{ref}/statuses",
		"GET /repos/{owner}/{repo}/contributors",
		"GET /repos/{owner}/{repo}/dependabot/alerts",
		"GET /repos/{owner}/{repo}/dependabot/secrets",
		"GET /repos/{owner}/{repo}/deployments",
		"GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
		"GET /repos/{owner}/{repo}/environments",
		"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
		"GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
		"GET /repos/{owner}/{repo}/events",
		"GET /repos/{owner}/{repo}/forks",
		"GET /repos/{owner}/{repo}/hooks",
		"GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
		"GET /repos/{owner}/{repo}/invitations",
		"GET /repos/{owner}/{repo}/issues",
		"GET /repos/{owner}/{repo}/issues/comments",
		"GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/issues/events",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/events",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
		"GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
		"GET /repos/{owner}/{repo}/keys",
		"GET /repos/{owner}/{repo}/labels",
		"GET /repos/{owner}/{repo}/milestones",
		"GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
		"GET /repos/{owner}/{repo}/notifications",
		"GET /repos/{owner}/{repo}/pages/builds",
		"GET /repos/{owner}/{repo}/projects",
		"GET /repos/{owner}/{repo}/pulls",
		"GET /repos/{owner}/{repo}/pulls/comments",
		"GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
		"GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
		"GET /repos/{owner}/{repo}/releases",
		"GET /repos/{owner}/{repo}/releases/{release_id}/assets",
		"GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
		"GET /repos/{owner}/{repo}/rules/branches/{branch}",
		"GET /repos/{owner}/{repo}/rulesets",
		"GET /repos/{owner}/{repo}/rulesets/rule-suites",
		"GET /repos/{owner}/{repo}/secret-scanning/alerts",
		"GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
		"GET /repos/{owner}/{repo}/security-advisories",
		"GET /repos/{owner}/{repo}/stargazers",
		"GET /repos/{owner}/{repo}/subscribers",
		"GET /repos/{owner}/{repo}/tags",
		"GET /repos/{owner}/{repo}/teams",
		"GET /repos/{owner}/{repo}/topics",
		"GET /repositories",
		"GET /repositories/{repository_id}/environments/{environment_name}/secrets",
		"GET /repositories/{repository_id}/environments/{environment_name}/variables",
		"GET /search/code",
		"GET /search/commits",
		"GET /search/issues",
		"GET /search/labels",
		"GET /search/repositories",
		"GET /search/topics",
		"GET /search/users",
		"GET /teams/{team_id}/discussions",
		"GET /teams/{team_id}/discussions/{discussion_number}/comments",
		"GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
		"GET /teams/{team_id}/discussions/{discussion_number}/reactions",
		"GET /teams/{team_id}/invitations",
		"GET /teams/{team_id}/members",
		"GET /teams/{team_id}/projects",
		"GET /teams/{team_id}/repos",
		"GET /teams/{team_id}/teams",
		"GET /user/blocks",
		"GET /user/codespaces",
		"GET /user/codespaces/secrets",
		"GET /user/emails",
		"GET /user/followers",
		"GET /user/following",
		"GET /user/gpg_keys",
		"GET /user/installations",
		"GET /user/installations/{installation_id}/repositories",
		"GET /user/issues",
		"GET /user/keys",
		"GET /user/marketplace_purchases",
		"GET /user/marketplace_purchases/stubbed",
		"GET /user/memberships/orgs",
		"GET /user/migrations",
		"GET /user/migrations/{migration_id}/repositories",
		"GET /user/orgs",
		"GET /user/packages",
		"GET /user/packages/{package_type}/{package_name}/versions",
		"GET /user/public_emails",
		"GET /user/repos",
		"GET /user/repository_invitations",
		"GET /user/social_accounts",
		"GET /user/ssh_signing_keys",
		"GET /user/starred",
		"GET /user/subscriptions",
		"GET /user/teams",
		"GET /users",
		"GET /users/{username}/events",
		"GET /users/{username}/events/orgs/{org}",
		"GET /users/{username}/events/public",
		"GET /users/{username}/followers",
		"GET /users/{username}/following",
		"GET /users/{username}/gists",
		"GET /users/{username}/gpg_keys",
		"GET /users/{username}/keys",
		"GET /users/{username}/orgs",
		"GET /users/{username}/packages",
		"GET /users/{username}/projects",
		"GET /users/{username}/received_events",
		"GET /users/{username}/received_events/public",
		"GET /users/{username}/repos",
		"GET /users/{username}/social_accounts",
		"GET /users/{username}/ssh_signing_keys",
		"GET /users/{username}/starred",
		"GET /users/{username}/subscriptions"
	];
	function isPaginatingEndpoint(arg) {
		if (typeof arg === "string") return paginatingEndpoints.includes(arg);
		else return false;
	}
	function paginateRest(octokit) {
		return { paginate: Object.assign(paginate.bind(null, octokit), { iterator: iterator.bind(null, octokit) }) };
	}
	paginateRest.VERSION = VERSION;
} });

//#endregion
//#region node_modules/@actions/github/lib/utils.js
var require_utils$1 = __commonJS({ "node_modules/@actions/github/lib/utils.js"(exports) {
	var __createBinding$9 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$6 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$6 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$9(result, mod, k);
		}
		__setModuleDefault$6(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
	const Context$1 = __importStar$6(require_context());
	const Utils = __importStar$6(require_utils$2());
	const core_1 = require_dist_node$2();
	const plugin_rest_endpoint_methods_1 = require_dist_node$1();
	const plugin_paginate_rest_1 = require_dist_node();
	exports.context = new Context$1.Context();
	const baseUrl = Utils.getApiBaseUrl();
	exports.defaults = {
		baseUrl,
		request: {
			agent: Utils.getProxyAgent(baseUrl),
			fetch: Utils.getProxyFetch(baseUrl)
		}
	};
	exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
	/**
	* Convience function to correctly format Octokit Options to pass into the constructor.
	*
	* @param     token    the repo PAT or GITHUB_TOKEN
	* @param     options  other options to set
	*/
	function getOctokitOptions(token, options) {
		const opts = Object.assign({}, options || {});
		const auth$2 = Utils.getAuthString(token, opts);
		if (auth$2) opts.auth = auth$2;
		return opts;
	}
	exports.getOctokitOptions = getOctokitOptions;
} });

//#endregion
//#region node_modules/@actions/github/lib/github.js
var require_github = __commonJS({ "node_modules/@actions/github/lib/github.js"(exports) {
	var __createBinding$8 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$5 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$5 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$8(result, mod, k);
		}
		__setModuleDefault$5(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOctokit = exports.context = void 0;
	const Context = __importStar$5(require_context());
	const utils_1 = require_utils$1();
	exports.context = new Context.Context();
	/**
	* Returns a hydrated octokit ready to use for GitHub Actions
	*
	* @param     token    the repo PAT or GITHUB_TOKEN
	* @param     options  other options to set
	*/
	function getOctokit(token, options, ...additionalPlugins) {
		const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
		return new GitHubWithPlugins((0, utils_1.getOctokitOptions)(token, options));
	}
	exports.getOctokit = getOctokit;
} });
var import_github = __toESM$1(require_github(), 1);

//#endregion
//#region src/github-utils.js
/**
* Get a PR diff using the GitHub API
* @param {Object} options Options for getting the diff
* @param {string} options.token GitHub token
* @param {string} options.owner Repository owner
* @param {string} options.repo Repository name
* @param {number|null} options.prNumber Pull request number (if applicable)
* @returns {Promise<{diff: string, prNumber: number|null}>} The PR diff and PR number
*/
async function getPRDiff({ token, owner, repo, prNumber = null }) {
	const octokit = (0, import_github.getOctokit)(token);
	let diff;
	try {
		if (prNumber) {
			console.log(`Getting diff for PR #${prNumber}`);
			const response = await octokit.rest.pulls.get({
				owner,
				repo,
				pull_number: prNumber,
				mediaType: { format: "diff" }
			});
			diff = response.data;
		} else {
			console.log("Not a pull request event, fetching diff between HEAD^1 and HEAD");
			const response = await octokit.rest.repos.compareCommits({
				owner,
				repo,
				base: "HEAD~1",
				head: "HEAD"
			});
			diff = response.data.files.map((file) => {
				return `diff --git a/${file.filename} b/${file.filename}
${file.patch || ""}`;
			}).join("\n");
		}
		return {
			diff,
			prNumber
		};
	} catch (error$1) {
		import_core.error(`Error getting PR diff: ${error$1.message}`);
		throw error$1;
	}
}
/**
* Extract the PR number from the GitHub context
* @returns {number|null} The PR number or null if not a PR
*/
function extractPRNumber() {
	const githubRef = process.env.GITHUB_REF || "";
	const isPR = process.env.GITHUB_EVENT_NAME === "pull_request" || process.env.GITHUB_EVENT_NAME === "pull_request_target";
	if (isPR && githubRef.startsWith("refs/pull/")) {
		const prNumber = parseInt(githubRef.split("/")[2], 10);
		return prNumber;
	}
	return null;
}
/**
* Get the repository owner and name from the GitHub context
* @returns {Object} Object containing owner and repo
*/
function getRepoInfo() {
	const repository = process.env.GITHUB_REPOSITORY || "";
	const [owner, repo] = repository.split("/");
	return {
		owner,
		repo
	};
}

//#endregion
//#region node_modules/extend/index.js
var require_extend = __commonJS({ "node_modules/extend/index.js"(exports, module) {
	var hasOwn = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var defineProperty = Object.defineProperty;
	var gOPD = Object.getOwnPropertyDescriptor;
	var isArray = function isArray$1(arr) {
		if (typeof Array.isArray === "function") return Array.isArray(arr);
		return toStr.call(arr) === "[object Array]";
	};
	var isPlainObject = function isPlainObject$3(obj) {
		if (!obj || toStr.call(obj) !== "[object Object]") return false;
		var hasOwnConstructor = hasOwn.call(obj, "constructor");
		var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
		if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) return false;
		var key;
		for (key in obj);
		return typeof key === "undefined" || hasOwn.call(obj, key);
	};
	var setProperty = function setProperty$1(target, options) {
		if (defineProperty && options.name === "__proto__") defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
		else target[options.name] = options.newValue;
	};
	var getProperty = function getProperty$1(obj, name) {
		if (name === "__proto__") {
			if (!hasOwn.call(obj, name)) return void 0;
			else if (gOPD) return gOPD(obj, name).value;
		}
		return obj[name];
	};
	module.exports = function extend() {
		var options, name, src, copy, copyIsArray, clone$1;
		var target = arguments[0];
		var i$1 = 1;
		var length = arguments.length;
		var deep = false;
		if (typeof target === "boolean") {
			deep = target;
			target = arguments[1] || {};
			i$1 = 2;
		}
		if (target == null || typeof target !== "object" && typeof target !== "function") target = {};
		for (; i$1 < length; ++i$1) {
			options = arguments[i$1];
			if (options != null) for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);
				if (target !== copy) {
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone$1 = src && isArray(src) ? src : [];
						} else clone$1 = src && isPlainObject(src) ? src : {};
						setProperty(target, {
							name,
							newValue: extend(deep, clone$1, copy)
						});
					} else if (typeof copy !== "undefined") setProperty(target, {
						name,
						newValue: copy
					});
				}
			}
		}
		return target;
	};
} });

//#endregion
//#region node_modules/webidl-conversions/lib/index.js
var require_lib$1 = __commonJS({ "node_modules/webidl-conversions/lib/index.js"(exports, module) {
	var conversions$1 = {};
	module.exports = conversions$1;
	function sign$1(x) {
		return x < 0 ? -1 : 1;
	}
	function evenRound(x) {
		if (x % 1 === .5 && (x & 1) === 0) return Math.floor(x);
		else return Math.round(x);
	}
	function createNumberConversion(bitLength, typeOpts) {
		if (!typeOpts.unsigned) --bitLength;
		const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
		const upperBound = Math.pow(2, bitLength) - 1;
		const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
		const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
		return function(V, opts) {
			if (!opts) opts = {};
			let x = +V;
			if (opts.enforceRange) {
				if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite number");
				x = sign$1(x) * Math.floor(Math.abs(x));
				if (x < lowerBound || x > upperBound) throw new TypeError("Argument is not in byte range");
				return x;
			}
			if (!isNaN(x) && opts.clamp) {
				x = evenRound(x);
				if (x < lowerBound) x = lowerBound;
				if (x > upperBound) x = upperBound;
				return x;
			}
			if (!Number.isFinite(x) || x === 0) return 0;
			x = sign$1(x) * Math.floor(Math.abs(x));
			x = x % moduloVal;
			if (!typeOpts.unsigned && x >= moduloBound) return x - moduloVal;
			else if (typeOpts.unsigned) {
				if (x < 0) x += moduloVal;
				else if (x === -0) return 0;
			}
			return x;
		};
	}
	conversions$1["void"] = function() {
		return void 0;
	};
	conversions$1["boolean"] = function(val) {
		return !!val;
	};
	conversions$1["byte"] = createNumberConversion(8, { unsigned: false });
	conversions$1["octet"] = createNumberConversion(8, { unsigned: true });
	conversions$1["short"] = createNumberConversion(16, { unsigned: false });
	conversions$1["unsigned short"] = createNumberConversion(16, { unsigned: true });
	conversions$1["long"] = createNumberConversion(32, { unsigned: false });
	conversions$1["unsigned long"] = createNumberConversion(32, { unsigned: true });
	conversions$1["long long"] = createNumberConversion(32, {
		unsigned: false,
		moduloBitLength: 64
	});
	conversions$1["unsigned long long"] = createNumberConversion(32, {
		unsigned: true,
		moduloBitLength: 64
	});
	conversions$1["double"] = function(V) {
		const x = +V;
		if (!Number.isFinite(x)) throw new TypeError("Argument is not a finite floating-point value");
		return x;
	};
	conversions$1["unrestricted double"] = function(V) {
		const x = +V;
		if (isNaN(x)) throw new TypeError("Argument is NaN");
		return x;
	};
	conversions$1["float"] = conversions$1["double"];
	conversions$1["unrestricted float"] = conversions$1["unrestricted double"];
	conversions$1["DOMString"] = function(V, opts) {
		if (!opts) opts = {};
		if (opts.treatNullAsEmptyString && V === null) return "";
		return String(V);
	};
	conversions$1["ByteString"] = function(V, opts) {
		const x = String(V);
		let c = void 0;
		for (let i$1 = 0; (c = x.codePointAt(i$1)) !== void 0; ++i$1) if (c > 255) throw new TypeError("Argument is not a valid bytestring");
		return x;
	};
	conversions$1["USVString"] = function(V) {
		const S = String(V);
		const n = S.length;
		const U = [];
		for (let i$1 = 0; i$1 < n; ++i$1) {
			const c = S.charCodeAt(i$1);
			if (c < 55296 || c > 57343) U.push(String.fromCodePoint(c));
			else if (56320 <= c && c <= 57343) U.push(String.fromCodePoint(65533));
			else if (i$1 === n - 1) U.push(String.fromCodePoint(65533));
			else {
				const d$1 = S.charCodeAt(i$1 + 1);
				if (56320 <= d$1 && d$1 <= 57343) {
					const a$1 = c & 1023;
					const b = d$1 & 1023;
					U.push(String.fromCodePoint(65536 + 1024 * a$1 + b));
					++i$1;
				} else U.push(String.fromCodePoint(65533));
			}
		}
		return U.join("");
	};
	conversions$1["Date"] = function(V, opts) {
		if (!(V instanceof Date)) throw new TypeError("Argument is not a Date object");
		if (isNaN(V)) return void 0;
		return V;
	};
	conversions$1["RegExp"] = function(V, opts) {
		if (!(V instanceof RegExp)) V = new RegExp(V);
		return V;
	};
} });

//#endregion
//#region node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({ "node_modules/whatwg-url/lib/utils.js"(exports, module) {
	module.exports.mixin = function mixin(target, source) {
		const keys = Object.getOwnPropertyNames(source);
		for (let i$1 = 0; i$1 < keys.length; ++i$1) Object.defineProperty(target, keys[i$1], Object.getOwnPropertyDescriptor(source, keys[i$1]));
	};
	module.exports.wrapperSymbol = Symbol("wrapper");
	module.exports.implSymbol = Symbol("impl");
	module.exports.wrapperForImpl = function(impl$1) {
		return impl$1[module.exports.wrapperSymbol];
	};
	module.exports.implForWrapper = function(wrapper) {
		return wrapper[module.exports.implSymbol];
	};
} });

//#endregion
//#region node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({ "node_modules/tr46/lib/mappingTable.json"(exports, module) {
	module.exports = [
		[[0, 44], "disallowed_STD3_valid"],
		[[45, 46], "valid"],
		[[47, 47], "disallowed_STD3_valid"],
		[[48, 57], "valid"],
		[[58, 64], "disallowed_STD3_valid"],
		[
			[65, 65],
			"mapped",
			[97]
		],
		[
			[66, 66],
			"mapped",
			[98]
		],
		[
			[67, 67],
			"mapped",
			[99]
		],
		[
			[68, 68],
			"mapped",
			[100]
		],
		[
			[69, 69],
			"mapped",
			[101]
		],
		[
			[70, 70],
			"mapped",
			[102]
		],
		[
			[71, 71],
			"mapped",
			[103]
		],
		[
			[72, 72],
			"mapped",
			[104]
		],
		[
			[73, 73],
			"mapped",
			[105]
		],
		[
			[74, 74],
			"mapped",
			[106]
		],
		[
			[75, 75],
			"mapped",
			[107]
		],
		[
			[76, 76],
			"mapped",
			[108]
		],
		[
			[77, 77],
			"mapped",
			[109]
		],
		[
			[78, 78],
			"mapped",
			[110]
		],
		[
			[79, 79],
			"mapped",
			[111]
		],
		[
			[80, 80],
			"mapped",
			[112]
		],
		[
			[81, 81],
			"mapped",
			[113]
		],
		[
			[82, 82],
			"mapped",
			[114]
		],
		[
			[83, 83],
			"mapped",
			[115]
		],
		[
			[84, 84],
			"mapped",
			[116]
		],
		[
			[85, 85],
			"mapped",
			[117]
		],
		[
			[86, 86],
			"mapped",
			[118]
		],
		[
			[87, 87],
			"mapped",
			[119]
		],
		[
			[88, 88],
			"mapped",
			[120]
		],
		[
			[89, 89],
			"mapped",
			[121]
		],
		[
			[90, 90],
			"mapped",
			[122]
		],
		[[91, 96], "disallowed_STD3_valid"],
		[[97, 122], "valid"],
		[[123, 127], "disallowed_STD3_valid"],
		[[128, 159], "disallowed"],
		[
			[160, 160],
			"disallowed_STD3_mapped",
			[32]
		],
		[
			[161, 167],
			"valid",
			[],
			"NV8"
		],
		[
			[168, 168],
			"disallowed_STD3_mapped",
			[32, 776]
		],
		[
			[169, 169],
			"valid",
			[],
			"NV8"
		],
		[
			[170, 170],
			"mapped",
			[97]
		],
		[
			[171, 172],
			"valid",
			[],
			"NV8"
		],
		[[173, 173], "ignored"],
		[
			[174, 174],
			"valid",
			[],
			"NV8"
		],
		[
			[175, 175],
			"disallowed_STD3_mapped",
			[32, 772]
		],
		[
			[176, 177],
			"valid",
			[],
			"NV8"
		],
		[
			[178, 178],
			"mapped",
			[50]
		],
		[
			[179, 179],
			"mapped",
			[51]
		],
		[
			[180, 180],
			"disallowed_STD3_mapped",
			[32, 769]
		],
		[
			[181, 181],
			"mapped",
			[956]
		],
		[
			[182, 182],
			"valid",
			[],
			"NV8"
		],
		[[183, 183], "valid"],
		[
			[184, 184],
			"disallowed_STD3_mapped",
			[32, 807]
		],
		[
			[185, 185],
			"mapped",
			[49]
		],
		[
			[186, 186],
			"mapped",
			[111]
		],
		[
			[187, 187],
			"valid",
			[],
			"NV8"
		],
		[
			[188, 188],
			"mapped",
			[
				49,
				8260,
				52
			]
		],
		[
			[189, 189],
			"mapped",
			[
				49,
				8260,
				50
			]
		],
		[
			[190, 190],
			"mapped",
			[
				51,
				8260,
				52
			]
		],
		[
			[191, 191],
			"valid",
			[],
			"NV8"
		],
		[
			[192, 192],
			"mapped",
			[224]
		],
		[
			[193, 193],
			"mapped",
			[225]
		],
		[
			[194, 194],
			"mapped",
			[226]
		],
		[
			[195, 195],
			"mapped",
			[227]
		],
		[
			[196, 196],
			"mapped",
			[228]
		],
		[
			[197, 197],
			"mapped",
			[229]
		],
		[
			[198, 198],
			"mapped",
			[230]
		],
		[
			[199, 199],
			"mapped",
			[231]
		],
		[
			[200, 200],
			"mapped",
			[232]
		],
		[
			[201, 201],
			"mapped",
			[233]
		],
		[
			[202, 202],
			"mapped",
			[234]
		],
		[
			[203, 203],
			"mapped",
			[235]
		],
		[
			[204, 204],
			"mapped",
			[236]
		],
		[
			[205, 205],
			"mapped",
			[237]
		],
		[
			[206, 206],
			"mapped",
			[238]
		],
		[
			[207, 207],
			"mapped",
			[239]
		],
		[
			[208, 208],
			"mapped",
			[240]
		],
		[
			[209, 209],
			"mapped",
			[241]
		],
		[
			[210, 210],
			"mapped",
			[242]
		],
		[
			[211, 211],
			"mapped",
			[243]
		],
		[
			[212, 212],
			"mapped",
			[244]
		],
		[
			[213, 213],
			"mapped",
			[245]
		],
		[
			[214, 214],
			"mapped",
			[246]
		],
		[
			[215, 215],
			"valid",
			[],
			"NV8"
		],
		[
			[216, 216],
			"mapped",
			[248]
		],
		[
			[217, 217],
			"mapped",
			[249]
		],
		[
			[218, 218],
			"mapped",
			[250]
		],
		[
			[219, 219],
			"mapped",
			[251]
		],
		[
			[220, 220],
			"mapped",
			[252]
		],
		[
			[221, 221],
			"mapped",
			[253]
		],
		[
			[222, 222],
			"mapped",
			[254]
		],
		[
			[223, 223],
			"deviation",
			[115, 115]
		],
		[[224, 246], "valid"],
		[
			[247, 247],
			"valid",
			[],
			"NV8"
		],
		[[248, 255], "valid"],
		[
			[256, 256],
			"mapped",
			[257]
		],
		[[257, 257], "valid"],
		[
			[258, 258],
			"mapped",
			[259]
		],
		[[259, 259], "valid"],
		[
			[260, 260],
			"mapped",
			[261]
		],
		[[261, 261], "valid"],
		[
			[262, 262],
			"mapped",
			[263]
		],
		[[263, 263], "valid"],
		[
			[264, 264],
			"mapped",
			[265]
		],
		[[265, 265], "valid"],
		[
			[266, 266],
			"mapped",
			[267]
		],
		[[267, 267], "valid"],
		[
			[268, 268],
			"mapped",
			[269]
		],
		[[269, 269], "valid"],
		[
			[270, 270],
			"mapped",
			[271]
		],
		[[271, 271], "valid"],
		[
			[272, 272],
			"mapped",
			[273]
		],
		[[273, 273], "valid"],
		[
			[274, 274],
			"mapped",
			[275]
		],
		[[275, 275], "valid"],
		[
			[276, 276],
			"mapped",
			[277]
		],
		[[277, 277], "valid"],
		[
			[278, 278],
			"mapped",
			[279]
		],
		[[279, 279], "valid"],
		[
			[280, 280],
			"mapped",
			[281]
		],
		[[281, 281], "valid"],
		[
			[282, 282],
			"mapped",
			[283]
		],
		[[283, 283], "valid"],
		[
			[284, 284],
			"mapped",
			[285]
		],
		[[285, 285], "valid"],
		[
			[286, 286],
			"mapped",
			[287]
		],
		[[287, 287], "valid"],
		[
			[288, 288],
			"mapped",
			[289]
		],
		[[289, 289], "valid"],
		[
			[290, 290],
			"mapped",
			[291]
		],
		[[291, 291], "valid"],
		[
			[292, 292],
			"mapped",
			[293]
		],
		[[293, 293], "valid"],
		[
			[294, 294],
			"mapped",
			[295]
		],
		[[295, 295], "valid"],
		[
			[296, 296],
			"mapped",
			[297]
		],
		[[297, 297], "valid"],
		[
			[298, 298],
			"mapped",
			[299]
		],
		[[299, 299], "valid"],
		[
			[300, 300],
			"mapped",
			[301]
		],
		[[301, 301], "valid"],
		[
			[302, 302],
			"mapped",
			[303]
		],
		[[303, 303], "valid"],
		[
			[304, 304],
			"mapped",
			[105, 775]
		],
		[[305, 305], "valid"],
		[
			[306, 307],
			"mapped",
			[105, 106]
		],
		[
			[308, 308],
			"mapped",
			[309]
		],
		[[309, 309], "valid"],
		[
			[310, 310],
			"mapped",
			[311]
		],
		[[311, 312], "valid"],
		[
			[313, 313],
			"mapped",
			[314]
		],
		[[314, 314], "valid"],
		[
			[315, 315],
			"mapped",
			[316]
		],
		[[316, 316], "valid"],
		[
			[317, 317],
			"mapped",
			[318]
		],
		[[318, 318], "valid"],
		[
			[319, 320],
			"mapped",
			[108, 183]
		],
		[
			[321, 321],
			"mapped",
			[322]
		],
		[[322, 322], "valid"],
		[
			[323, 323],
			"mapped",
			[324]
		],
		[[324, 324], "valid"],
		[
			[325, 325],
			"mapped",
			[326]
		],
		[[326, 326], "valid"],
		[
			[327, 327],
			"mapped",
			[328]
		],
		[[328, 328], "valid"],
		[
			[329, 329],
			"mapped",
			[700, 110]
		],
		[
			[330, 330],
			"mapped",
			[331]
		],
		[[331, 331], "valid"],
		[
			[332, 332],
			"mapped",
			[333]
		],
		[[333, 333], "valid"],
		[
			[334, 334],
			"mapped",
			[335]
		],
		[[335, 335], "valid"],
		[
			[336, 336],
			"mapped",
			[337]
		],
		[[337, 337], "valid"],
		[
			[338, 338],
			"mapped",
			[339]
		],
		[[339, 339], "valid"],
		[
			[340, 340],
			"mapped",
			[341]
		],
		[[341, 341], "valid"],
		[
			[342, 342],
			"mapped",
			[343]
		],
		[[343, 343], "valid"],
		[
			[344, 344],
			"mapped",
			[345]
		],
		[[345, 345], "valid"],
		[
			[346, 346],
			"mapped",
			[347]
		],
		[[347, 347], "valid"],
		[
			[348, 348],
			"mapped",
			[349]
		],
		[[349, 349], "valid"],
		[
			[350, 350],
			"mapped",
			[351]
		],
		[[351, 351], "valid"],
		[
			[352, 352],
			"mapped",
			[353]
		],
		[[353, 353], "valid"],
		[
			[354, 354],
			"mapped",
			[355]
		],
		[[355, 355], "valid"],
		[
			[356, 356],
			"mapped",
			[357]
		],
		[[357, 357], "valid"],
		[
			[358, 358],
			"mapped",
			[359]
		],
		[[359, 359], "valid"],
		[
			[360, 360],
			"mapped",
			[361]
		],
		[[361, 361], "valid"],
		[
			[362, 362],
			"mapped",
			[363]
		],
		[[363, 363], "valid"],
		[
			[364, 364],
			"mapped",
			[365]
		],
		[[365, 365], "valid"],
		[
			[366, 366],
			"mapped",
			[367]
		],
		[[367, 367], "valid"],
		[
			[368, 368],
			"mapped",
			[369]
		],
		[[369, 369], "valid"],
		[
			[370, 370],
			"mapped",
			[371]
		],
		[[371, 371], "valid"],
		[
			[372, 372],
			"mapped",
			[373]
		],
		[[373, 373], "valid"],
		[
			[374, 374],
			"mapped",
			[375]
		],
		[[375, 375], "valid"],
		[
			[376, 376],
			"mapped",
			[255]
		],
		[
			[377, 377],
			"mapped",
			[378]
		],
		[[378, 378], "valid"],
		[
			[379, 379],
			"mapped",
			[380]
		],
		[[380, 380], "valid"],
		[
			[381, 381],
			"mapped",
			[382]
		],
		[[382, 382], "valid"],
		[
			[383, 383],
			"mapped",
			[115]
		],
		[[384, 384], "valid"],
		[
			[385, 385],
			"mapped",
			[595]
		],
		[
			[386, 386],
			"mapped",
			[387]
		],
		[[387, 387], "valid"],
		[
			[388, 388],
			"mapped",
			[389]
		],
		[[389, 389], "valid"],
		[
			[390, 390],
			"mapped",
			[596]
		],
		[
			[391, 391],
			"mapped",
			[392]
		],
		[[392, 392], "valid"],
		[
			[393, 393],
			"mapped",
			[598]
		],
		[
			[394, 394],
			"mapped",
			[599]
		],
		[
			[395, 395],
			"mapped",
			[396]
		],
		[[396, 397], "valid"],
		[
			[398, 398],
			"mapped",
			[477]
		],
		[
			[399, 399],
			"mapped",
			[601]
		],
		[
			[400, 400],
			"mapped",
			[603]
		],
		[
			[401, 401],
			"mapped",
			[402]
		],
		[[402, 402], "valid"],
		[
			[403, 403],
			"mapped",
			[608]
		],
		[
			[404, 404],
			"mapped",
			[611]
		],
		[[405, 405], "valid"],
		[
			[406, 406],
			"mapped",
			[617]
		],
		[
			[407, 407],
			"mapped",
			[616]
		],
		[
			[408, 408],
			"mapped",
			[409]
		],
		[[409, 411], "valid"],
		[
			[412, 412],
			"mapped",
			[623]
		],
		[
			[413, 413],
			"mapped",
			[626]
		],
		[[414, 414], "valid"],
		[
			[415, 415],
			"mapped",
			[629]
		],
		[
			[416, 416],
			"mapped",
			[417]
		],
		[[417, 417], "valid"],
		[
			[418, 418],
			"mapped",
			[419]
		],
		[[419, 419], "valid"],
		[
			[420, 420],
			"mapped",
			[421]
		],
		[[421, 421], "valid"],
		[
			[422, 422],
			"mapped",
			[640]
		],
		[
			[423, 423],
			"mapped",
			[424]
		],
		[[424, 424], "valid"],
		[
			[425, 425],
			"mapped",
			[643]
		],
		[[426, 427], "valid"],
		[
			[428, 428],
			"mapped",
			[429]
		],
		[[429, 429], "valid"],
		[
			[430, 430],
			"mapped",
			[648]
		],
		[
			[431, 431],
			"mapped",
			[432]
		],
		[[432, 432], "valid"],
		[
			[433, 433],
			"mapped",
			[650]
		],
		[
			[434, 434],
			"mapped",
			[651]
		],
		[
			[435, 435],
			"mapped",
			[436]
		],
		[[436, 436], "valid"],
		[
			[437, 437],
			"mapped",
			[438]
		],
		[[438, 438], "valid"],
		[
			[439, 439],
			"mapped",
			[658]
		],
		[
			[440, 440],
			"mapped",
			[441]
		],
		[[441, 443], "valid"],
		[
			[444, 444],
			"mapped",
			[445]
		],
		[[445, 451], "valid"],
		[
			[452, 454],
			"mapped",
			[100, 382]
		],
		[
			[455, 457],
			"mapped",
			[108, 106]
		],
		[
			[458, 460],
			"mapped",
			[110, 106]
		],
		[
			[461, 461],
			"mapped",
			[462]
		],
		[[462, 462], "valid"],
		[
			[463, 463],
			"mapped",
			[464]
		],
		[[464, 464], "valid"],
		[
			[465, 465],
			"mapped",
			[466]
		],
		[[466, 466], "valid"],
		[
			[467, 467],
			"mapped",
			[468]
		],
		[[468, 468], "valid"],
		[
			[469, 469],
			"mapped",
			[470]
		],
		[[470, 470], "valid"],
		[
			[471, 471],
			"mapped",
			[472]
		],
		[[472, 472], "valid"],
		[
			[473, 473],
			"mapped",
			[474]
		],
		[[474, 474], "valid"],
		[
			[475, 475],
			"mapped",
			[476]
		],
		[[476, 477], "valid"],
		[
			[478, 478],
			"mapped",
			[479]
		],
		[[479, 479], "valid"],
		[
			[480, 480],
			"mapped",
			[481]
		],
		[[481, 481], "valid"],
		[
			[482, 482],
			"mapped",
			[483]
		],
		[[483, 483], "valid"],
		[
			[484, 484],
			"mapped",
			[485]
		],
		[[485, 485], "valid"],
		[
			[486, 486],
			"mapped",
			[487]
		],
		[[487, 487], "valid"],
		[
			[488, 488],
			"mapped",
			[489]
		],
		[[489, 489], "valid"],
		[
			[490, 490],
			"mapped",
			[491]
		],
		[[491, 491], "valid"],
		[
			[492, 492],
			"mapped",
			[493]
		],
		[[493, 493], "valid"],
		[
			[494, 494],
			"mapped",
			[495]
		],
		[[495, 496], "valid"],
		[
			[497, 499],
			"mapped",
			[100, 122]
		],
		[
			[500, 500],
			"mapped",
			[501]
		],
		[[501, 501], "valid"],
		[
			[502, 502],
			"mapped",
			[405]
		],
		[
			[503, 503],
			"mapped",
			[447]
		],
		[
			[504, 504],
			"mapped",
			[505]
		],
		[[505, 505], "valid"],
		[
			[506, 506],
			"mapped",
			[507]
		],
		[[507, 507], "valid"],
		[
			[508, 508],
			"mapped",
			[509]
		],
		[[509, 509], "valid"],
		[
			[510, 510],
			"mapped",
			[511]
		],
		[[511, 511], "valid"],
		[
			[512, 512],
			"mapped",
			[513]
		],
		[[513, 513], "valid"],
		[
			[514, 514],
			"mapped",
			[515]
		],
		[[515, 515], "valid"],
		[
			[516, 516],
			"mapped",
			[517]
		],
		[[517, 517], "valid"],
		[
			[518, 518],
			"mapped",
			[519]
		],
		[[519, 519], "valid"],
		[
			[520, 520],
			"mapped",
			[521]
		],
		[[521, 521], "valid"],
		[
			[522, 522],
			"mapped",
			[523]
		],
		[[523, 523], "valid"],
		[
			[524, 524],
			"mapped",
			[525]
		],
		[[525, 525], "valid"],
		[
			[526, 526],
			"mapped",
			[527]
		],
		[[527, 527], "valid"],
		[
			[528, 528],
			"mapped",
			[529]
		],
		[[529, 529], "valid"],
		[
			[530, 530],
			"mapped",
			[531]
		],
		[[531, 531], "valid"],
		[
			[532, 532],
			"mapped",
			[533]
		],
		[[533, 533], "valid"],
		[
			[534, 534],
			"mapped",
			[535]
		],
		[[535, 535], "valid"],
		[
			[536, 536],
			"mapped",
			[537]
		],
		[[537, 537], "valid"],
		[
			[538, 538],
			"mapped",
			[539]
		],
		[[539, 539], "valid"],
		[
			[540, 540],
			"mapped",
			[541]
		],
		[[541, 541], "valid"],
		[
			[542, 542],
			"mapped",
			[543]
		],
		[[543, 543], "valid"],
		[
			[544, 544],
			"mapped",
			[414]
		],
		[[545, 545], "valid"],
		[
			[546, 546],
			"mapped",
			[547]
		],
		[[547, 547], "valid"],
		[
			[548, 548],
			"mapped",
			[549]
		],
		[[549, 549], "valid"],
		[
			[550, 550],
			"mapped",
			[551]
		],
		[[551, 551], "valid"],
		[
			[552, 552],
			"mapped",
			[553]
		],
		[[553, 553], "valid"],
		[
			[554, 554],
			"mapped",
			[555]
		],
		[[555, 555], "valid"],
		[
			[556, 556],
			"mapped",
			[557]
		],
		[[557, 557], "valid"],
		[
			[558, 558],
			"mapped",
			[559]
		],
		[[559, 559], "valid"],
		[
			[560, 560],
			"mapped",
			[561]
		],
		[[561, 561], "valid"],
		[
			[562, 562],
			"mapped",
			[563]
		],
		[[563, 563], "valid"],
		[[564, 566], "valid"],
		[[567, 569], "valid"],
		[
			[570, 570],
			"mapped",
			[11365]
		],
		[
			[571, 571],
			"mapped",
			[572]
		],
		[[572, 572], "valid"],
		[
			[573, 573],
			"mapped",
			[410]
		],
		[
			[574, 574],
			"mapped",
			[11366]
		],
		[[575, 576], "valid"],
		[
			[577, 577],
			"mapped",
			[578]
		],
		[[578, 578], "valid"],
		[
			[579, 579],
			"mapped",
			[384]
		],
		[
			[580, 580],
			"mapped",
			[649]
		],
		[
			[581, 581],
			"mapped",
			[652]
		],
		[
			[582, 582],
			"mapped",
			[583]
		],
		[[583, 583], "valid"],
		[
			[584, 584],
			"mapped",
			[585]
		],
		[[585, 585], "valid"],
		[
			[586, 586],
			"mapped",
			[587]
		],
		[[587, 587], "valid"],
		[
			[588, 588],
			"mapped",
			[589]
		],
		[[589, 589], "valid"],
		[
			[590, 590],
			"mapped",
			[591]
		],
		[[591, 591], "valid"],
		[[592, 680], "valid"],
		[[681, 685], "valid"],
		[[686, 687], "valid"],
		[
			[688, 688],
			"mapped",
			[104]
		],
		[
			[689, 689],
			"mapped",
			[614]
		],
		[
			[690, 690],
			"mapped",
			[106]
		],
		[
			[691, 691],
			"mapped",
			[114]
		],
		[
			[692, 692],
			"mapped",
			[633]
		],
		[
			[693, 693],
			"mapped",
			[635]
		],
		[
			[694, 694],
			"mapped",
			[641]
		],
		[
			[695, 695],
			"mapped",
			[119]
		],
		[
			[696, 696],
			"mapped",
			[121]
		],
		[[697, 705], "valid"],
		[
			[706, 709],
			"valid",
			[],
			"NV8"
		],
		[[710, 721], "valid"],
		[
			[722, 727],
			"valid",
			[],
			"NV8"
		],
		[
			[728, 728],
			"disallowed_STD3_mapped",
			[32, 774]
		],
		[
			[729, 729],
			"disallowed_STD3_mapped",
			[32, 775]
		],
		[
			[730, 730],
			"disallowed_STD3_mapped",
			[32, 778]
		],
		[
			[731, 731],
			"disallowed_STD3_mapped",
			[32, 808]
		],
		[
			[732, 732],
			"disallowed_STD3_mapped",
			[32, 771]
		],
		[
			[733, 733],
			"disallowed_STD3_mapped",
			[32, 779]
		],
		[
			[734, 734],
			"valid",
			[],
			"NV8"
		],
		[
			[735, 735],
			"valid",
			[],
			"NV8"
		],
		[
			[736, 736],
			"mapped",
			[611]
		],
		[
			[737, 737],
			"mapped",
			[108]
		],
		[
			[738, 738],
			"mapped",
			[115]
		],
		[
			[739, 739],
			"mapped",
			[120]
		],
		[
			[740, 740],
			"mapped",
			[661]
		],
		[
			[741, 745],
			"valid",
			[],
			"NV8"
		],
		[
			[746, 747],
			"valid",
			[],
			"NV8"
		],
		[[748, 748], "valid"],
		[
			[749, 749],
			"valid",
			[],
			"NV8"
		],
		[[750, 750], "valid"],
		[
			[751, 767],
			"valid",
			[],
			"NV8"
		],
		[[768, 831], "valid"],
		[
			[832, 832],
			"mapped",
			[768]
		],
		[
			[833, 833],
			"mapped",
			[769]
		],
		[[834, 834], "valid"],
		[
			[835, 835],
			"mapped",
			[787]
		],
		[
			[836, 836],
			"mapped",
			[776, 769]
		],
		[
			[837, 837],
			"mapped",
			[953]
		],
		[[838, 846], "valid"],
		[[847, 847], "ignored"],
		[[848, 855], "valid"],
		[[856, 860], "valid"],
		[[861, 863], "valid"],
		[[864, 865], "valid"],
		[[866, 866], "valid"],
		[[867, 879], "valid"],
		[
			[880, 880],
			"mapped",
			[881]
		],
		[[881, 881], "valid"],
		[
			[882, 882],
			"mapped",
			[883]
		],
		[[883, 883], "valid"],
		[
			[884, 884],
			"mapped",
			[697]
		],
		[[885, 885], "valid"],
		[
			[886, 886],
			"mapped",
			[887]
		],
		[[887, 887], "valid"],
		[[888, 889], "disallowed"],
		[
			[890, 890],
			"disallowed_STD3_mapped",
			[32, 953]
		],
		[[891, 893], "valid"],
		[
			[894, 894],
			"disallowed_STD3_mapped",
			[59]
		],
		[
			[895, 895],
			"mapped",
			[1011]
		],
		[[896, 899], "disallowed"],
		[
			[900, 900],
			"disallowed_STD3_mapped",
			[32, 769]
		],
		[
			[901, 901],
			"disallowed_STD3_mapped",
			[
				32,
				776,
				769
			]
		],
		[
			[902, 902],
			"mapped",
			[940]
		],
		[
			[903, 903],
			"mapped",
			[183]
		],
		[
			[904, 904],
			"mapped",
			[941]
		],
		[
			[905, 905],
			"mapped",
			[942]
		],
		[
			[906, 906],
			"mapped",
			[943]
		],
		[[907, 907], "disallowed"],
		[
			[908, 908],
			"mapped",
			[972]
		],
		[[909, 909], "disallowed"],
		[
			[910, 910],
			"mapped",
			[973]
		],
		[
			[911, 911],
			"mapped",
			[974]
		],
		[[912, 912], "valid"],
		[
			[913, 913],
			"mapped",
			[945]
		],
		[
			[914, 914],
			"mapped",
			[946]
		],
		[
			[915, 915],
			"mapped",
			[947]
		],
		[
			[916, 916],
			"mapped",
			[948]
		],
		[
			[917, 917],
			"mapped",
			[949]
		],
		[
			[918, 918],
			"mapped",
			[950]
		],
		[
			[919, 919],
			"mapped",
			[951]
		],
		[
			[920, 920],
			"mapped",
			[952]
		],
		[
			[921, 921],
			"mapped",
			[953]
		],
		[
			[922, 922],
			"mapped",
			[954]
		],
		[
			[923, 923],
			"mapped",
			[955]
		],
		[
			[924, 924],
			"mapped",
			[956]
		],
		[
			[925, 925],
			"mapped",
			[957]
		],
		[
			[926, 926],
			"mapped",
			[958]
		],
		[
			[927, 927],
			"mapped",
			[959]
		],
		[
			[928, 928],
			"mapped",
			[960]
		],
		[
			[929, 929],
			"mapped",
			[961]
		],
		[[930, 930], "disallowed"],
		[
			[931, 931],
			"mapped",
			[963]
		],
		[
			[932, 932],
			"mapped",
			[964]
		],
		[
			[933, 933],
			"mapped",
			[965]
		],
		[
			[934, 934],
			"mapped",
			[966]
		],
		[
			[935, 935],
			"mapped",
			[967]
		],
		[
			[936, 936],
			"mapped",
			[968]
		],
		[
			[937, 937],
			"mapped",
			[969]
		],
		[
			[938, 938],
			"mapped",
			[970]
		],
		[
			[939, 939],
			"mapped",
			[971]
		],
		[[940, 961], "valid"],
		[
			[962, 962],
			"deviation",
			[963]
		],
		[[963, 974], "valid"],
		[
			[975, 975],
			"mapped",
			[983]
		],
		[
			[976, 976],
			"mapped",
			[946]
		],
		[
			[977, 977],
			"mapped",
			[952]
		],
		[
			[978, 978],
			"mapped",
			[965]
		],
		[
			[979, 979],
			"mapped",
			[973]
		],
		[
			[980, 980],
			"mapped",
			[971]
		],
		[
			[981, 981],
			"mapped",
			[966]
		],
		[
			[982, 982],
			"mapped",
			[960]
		],
		[[983, 983], "valid"],
		[
			[984, 984],
			"mapped",
			[985]
		],
		[[985, 985], "valid"],
		[
			[986, 986],
			"mapped",
			[987]
		],
		[[987, 987], "valid"],
		[
			[988, 988],
			"mapped",
			[989]
		],
		[[989, 989], "valid"],
		[
			[990, 990],
			"mapped",
			[991]
		],
		[[991, 991], "valid"],
		[
			[992, 992],
			"mapped",
			[993]
		],
		[[993, 993], "valid"],
		[
			[994, 994],
			"mapped",
			[995]
		],
		[[995, 995], "valid"],
		[
			[996, 996],
			"mapped",
			[997]
		],
		[[997, 997], "valid"],
		[
			[998, 998],
			"mapped",
			[999]
		],
		[[999, 999], "valid"],
		[
			[1e3, 1e3],
			"mapped",
			[1001]
		],
		[[1001, 1001], "valid"],
		[
			[1002, 1002],
			"mapped",
			[1003]
		],
		[[1003, 1003], "valid"],
		[
			[1004, 1004],
			"mapped",
			[1005]
		],
		[[1005, 1005], "valid"],
		[
			[1006, 1006],
			"mapped",
			[1007]
		],
		[[1007, 1007], "valid"],
		[
			[1008, 1008],
			"mapped",
			[954]
		],
		[
			[1009, 1009],
			"mapped",
			[961]
		],
		[
			[1010, 1010],
			"mapped",
			[963]
		],
		[[1011, 1011], "valid"],
		[
			[1012, 1012],
			"mapped",
			[952]
		],
		[
			[1013, 1013],
			"mapped",
			[949]
		],
		[
			[1014, 1014],
			"valid",
			[],
			"NV8"
		],
		[
			[1015, 1015],
			"mapped",
			[1016]
		],
		[[1016, 1016], "valid"],
		[
			[1017, 1017],
			"mapped",
			[963]
		],
		[
			[1018, 1018],
			"mapped",
			[1019]
		],
		[[1019, 1019], "valid"],
		[[1020, 1020], "valid"],
		[
			[1021, 1021],
			"mapped",
			[891]
		],
		[
			[1022, 1022],
			"mapped",
			[892]
		],
		[
			[1023, 1023],
			"mapped",
			[893]
		],
		[
			[1024, 1024],
			"mapped",
			[1104]
		],
		[
			[1025, 1025],
			"mapped",
			[1105]
		],
		[
			[1026, 1026],
			"mapped",
			[1106]
		],
		[
			[1027, 1027],
			"mapped",
			[1107]
		],
		[
			[1028, 1028],
			"mapped",
			[1108]
		],
		[
			[1029, 1029],
			"mapped",
			[1109]
		],
		[
			[1030, 1030],
			"mapped",
			[1110]
		],
		[
			[1031, 1031],
			"mapped",
			[1111]
		],
		[
			[1032, 1032],
			"mapped",
			[1112]
		],
		[
			[1033, 1033],
			"mapped",
			[1113]
		],
		[
			[1034, 1034],
			"mapped",
			[1114]
		],
		[
			[1035, 1035],
			"mapped",
			[1115]
		],
		[
			[1036, 1036],
			"mapped",
			[1116]
		],
		[
			[1037, 1037],
			"mapped",
			[1117]
		],
		[
			[1038, 1038],
			"mapped",
			[1118]
		],
		[
			[1039, 1039],
			"mapped",
			[1119]
		],
		[
			[1040, 1040],
			"mapped",
			[1072]
		],
		[
			[1041, 1041],
			"mapped",
			[1073]
		],
		[
			[1042, 1042],
			"mapped",
			[1074]
		],
		[
			[1043, 1043],
			"mapped",
			[1075]
		],
		[
			[1044, 1044],
			"mapped",
			[1076]
		],
		[
			[1045, 1045],
			"mapped",
			[1077]
		],
		[
			[1046, 1046],
			"mapped",
			[1078]
		],
		[
			[1047, 1047],
			"mapped",
			[1079]
		],
		[
			[1048, 1048],
			"mapped",
			[1080]
		],
		[
			[1049, 1049],
			"mapped",
			[1081]
		],
		[
			[1050, 1050],
			"mapped",
			[1082]
		],
		[
			[1051, 1051],
			"mapped",
			[1083]
		],
		[
			[1052, 1052],
			"mapped",
			[1084]
		],
		[
			[1053, 1053],
			"mapped",
			[1085]
		],
		[
			[1054, 1054],
			"mapped",
			[1086]
		],
		[
			[1055, 1055],
			"mapped",
			[1087]
		],
		[
			[1056, 1056],
			"mapped",
			[1088]
		],
		[
			[1057, 1057],
			"mapped",
			[1089]
		],
		[
			[1058, 1058],
			"mapped",
			[1090]
		],
		[
			[1059, 1059],
			"mapped",
			[1091]
		],
		[
			[1060, 1060],
			"mapped",
			[1092]
		],
		[
			[1061, 1061],
			"mapped",
			[1093]
		],
		[
			[1062, 1062],
			"mapped",
			[1094]
		],
		[
			[1063, 1063],
			"mapped",
			[1095]
		],
		[
			[1064, 1064],
			"mapped",
			[1096]
		],
		[
			[1065, 1065],
			"mapped",
			[1097]
		],
		[
			[1066, 1066],
			"mapped",
			[1098]
		],
		[
			[1067, 1067],
			"mapped",
			[1099]
		],
		[
			[1068, 1068],
			"mapped",
			[1100]
		],
		[
			[1069, 1069],
			"mapped",
			[1101]
		],
		[
			[1070, 1070],
			"mapped",
			[1102]
		],
		[
			[1071, 1071],
			"mapped",
			[1103]
		],
		[[1072, 1103], "valid"],
		[[1104, 1104], "valid"],
		[[1105, 1116], "valid"],
		[[1117, 1117], "valid"],
		[[1118, 1119], "valid"],
		[
			[1120, 1120],
			"mapped",
			[1121]
		],
		[[1121, 1121], "valid"],
		[
			[1122, 1122],
			"mapped",
			[1123]
		],
		[[1123, 1123], "valid"],
		[
			[1124, 1124],
			"mapped",
			[1125]
		],
		[[1125, 1125], "valid"],
		[
			[1126, 1126],
			"mapped",
			[1127]
		],
		[[1127, 1127], "valid"],
		[
			[1128, 1128],
			"mapped",
			[1129]
		],
		[[1129, 1129], "valid"],
		[
			[1130, 1130],
			"mapped",
			[1131]
		],
		[[1131, 1131], "valid"],
		[
			[1132, 1132],
			"mapped",
			[1133]
		],
		[[1133, 1133], "valid"],
		[
			[1134, 1134],
			"mapped",
			[1135]
		],
		[[1135, 1135], "valid"],
		[
			[1136, 1136],
			"mapped",
			[1137]
		],
		[[1137, 1137], "valid"],
		[
			[1138, 1138],
			"mapped",
			[1139]
		],
		[[1139, 1139], "valid"],
		[
			[1140, 1140],
			"mapped",
			[1141]
		],
		[[1141, 1141], "valid"],
		[
			[1142, 1142],
			"mapped",
			[1143]
		],
		[[1143, 1143], "valid"],
		[
			[1144, 1144],
			"mapped",
			[1145]
		],
		[[1145, 1145], "valid"],
		[
			[1146, 1146],
			"mapped",
			[1147]
		],
		[[1147, 1147], "valid"],
		[
			[1148, 1148],
			"mapped",
			[1149]
		],
		[[1149, 1149], "valid"],
		[
			[1150, 1150],
			"mapped",
			[1151]
		],
		[[1151, 1151], "valid"],
		[
			[1152, 1152],
			"mapped",
			[1153]
		],
		[[1153, 1153], "valid"],
		[
			[1154, 1154],
			"valid",
			[],
			"NV8"
		],
		[[1155, 1158], "valid"],
		[[1159, 1159], "valid"],
		[
			[1160, 1161],
			"valid",
			[],
			"NV8"
		],
		[
			[1162, 1162],
			"mapped",
			[1163]
		],
		[[1163, 1163], "valid"],
		[
			[1164, 1164],
			"mapped",
			[1165]
		],
		[[1165, 1165], "valid"],
		[
			[1166, 1166],
			"mapped",
			[1167]
		],
		[[1167, 1167], "valid"],
		[
			[1168, 1168],
			"mapped",
			[1169]
		],
		[[1169, 1169], "valid"],
		[
			[1170, 1170],
			"mapped",
			[1171]
		],
		[[1171, 1171], "valid"],
		[
			[1172, 1172],
			"mapped",
			[1173]
		],
		[[1173, 1173], "valid"],
		[
			[1174, 1174],
			"mapped",
			[1175]
		],
		[[1175, 1175], "valid"],
		[
			[1176, 1176],
			"mapped",
			[1177]
		],
		[[1177, 1177], "valid"],
		[
			[1178, 1178],
			"mapped",
			[1179]
		],
		[[1179, 1179], "valid"],
		[
			[1180, 1180],
			"mapped",
			[1181]
		],
		[[1181, 1181], "valid"],
		[
			[1182, 1182],
			"mapped",
			[1183]
		],
		[[1183, 1183], "valid"],
		[
			[1184, 1184],
			"mapped",
			[1185]
		],
		[[1185, 1185], "valid"],
		[
			[1186, 1186],
			"mapped",
			[1187]
		],
		[[1187, 1187], "valid"],
		[
			[1188, 1188],
			"mapped",
			[1189]
		],
		[[1189, 1189], "valid"],
		[
			[1190, 1190],
			"mapped",
			[1191]
		],
		[[1191, 1191], "valid"],
		[
			[1192, 1192],
			"mapped",
			[1193]
		],
		[[1193, 1193], "valid"],
		[
			[1194, 1194],
			"mapped",
			[1195]
		],
		[[1195, 1195], "valid"],
		[
			[1196, 1196],
			"mapped",
			[1197]
		],
		[[1197, 1197], "valid"],
		[
			[1198, 1198],
			"mapped",
			[1199]
		],
		[[1199, 1199], "valid"],
		[
			[1200, 1200],
			"mapped",
			[1201]
		],
		[[1201, 1201], "valid"],
		[
			[1202, 1202],
			"mapped",
			[1203]
		],
		[[1203, 1203], "valid"],
		[
			[1204, 1204],
			"mapped",
			[1205]
		],
		[[1205, 1205], "valid"],
		[
			[1206, 1206],
			"mapped",
			[1207]
		],
		[[1207, 1207], "valid"],
		[
			[1208, 1208],
			"mapped",
			[1209]
		],
		[[1209, 1209], "valid"],
		[
			[1210, 1210],
			"mapped",
			[1211]
		],
		[[1211, 1211], "valid"],
		[
			[1212, 1212],
			"mapped",
			[1213]
		],
		[[1213, 1213], "valid"],
		[
			[1214, 1214],
			"mapped",
			[1215]
		],
		[[1215, 1215], "valid"],
		[[1216, 1216], "disallowed"],
		[
			[1217, 1217],
			"mapped",
			[1218]
		],
		[[1218, 1218], "valid"],
		[
			[1219, 1219],
			"mapped",
			[1220]
		],
		[[1220, 1220], "valid"],
		[
			[1221, 1221],
			"mapped",
			[1222]
		],
		[[1222, 1222], "valid"],
		[
			[1223, 1223],
			"mapped",
			[1224]
		],
		[[1224, 1224], "valid"],
		[
			[1225, 1225],
			"mapped",
			[1226]
		],
		[[1226, 1226], "valid"],
		[
			[1227, 1227],
			"mapped",
			[1228]
		],
		[[1228, 1228], "valid"],
		[
			[1229, 1229],
			"mapped",
			[1230]
		],
		[[1230, 1230], "valid"],
		[[1231, 1231], "valid"],
		[
			[1232, 1232],
			"mapped",
			[1233]
		],
		[[1233, 1233], "valid"],
		[
			[1234, 1234],
			"mapped",
			[1235]
		],
		[[1235, 1235], "valid"],
		[
			[1236, 1236],
			"mapped",
			[1237]
		],
		[[1237, 1237], "valid"],
		[
			[1238, 1238],
			"mapped",
			[1239]
		],
		[[1239, 1239], "valid"],
		[
			[1240, 1240],
			"mapped",
			[1241]
		],
		[[1241, 1241], "valid"],
		[
			[1242, 1242],
			"mapped",
			[1243]
		],
		[[1243, 1243], "valid"],
		[
			[1244, 1244],
			"mapped",
			[1245]
		],
		[[1245, 1245], "valid"],
		[
			[1246, 1246],
			"mapped",
			[1247]
		],
		[[1247, 1247], "valid"],
		[
			[1248, 1248],
			"mapped",
			[1249]
		],
		[[1249, 1249], "valid"],
		[
			[1250, 1250],
			"mapped",
			[1251]
		],
		[[1251, 1251], "valid"],
		[
			[1252, 1252],
			"mapped",
			[1253]
		],
		[[1253, 1253], "valid"],
		[
			[1254, 1254],
			"mapped",
			[1255]
		],
		[[1255, 1255], "valid"],
		[
			[1256, 1256],
			"mapped",
			[1257]
		],
		[[1257, 1257], "valid"],
		[
			[1258, 1258],
			"mapped",
			[1259]
		],
		[[1259, 1259], "valid"],
		[
			[1260, 1260],
			"mapped",
			[1261]
		],
		[[1261, 1261], "valid"],
		[
			[1262, 1262],
			"mapped",
			[1263]
		],
		[[1263, 1263], "valid"],
		[
			[1264, 1264],
			"mapped",
			[1265]
		],
		[[1265, 1265], "valid"],
		[
			[1266, 1266],
			"mapped",
			[1267]
		],
		[[1267, 1267], "valid"],
		[
			[1268, 1268],
			"mapped",
			[1269]
		],
		[[1269, 1269], "valid"],
		[
			[1270, 1270],
			"mapped",
			[1271]
		],
		[[1271, 1271], "valid"],
		[
			[1272, 1272],
			"mapped",
			[1273]
		],
		[[1273, 1273], "valid"],
		[
			[1274, 1274],
			"mapped",
			[1275]
		],
		[[1275, 1275], "valid"],
		[
			[1276, 1276],
			"mapped",
			[1277]
		],
		[[1277, 1277], "valid"],
		[
			[1278, 1278],
			"mapped",
			[1279]
		],
		[[1279, 1279], "valid"],
		[
			[1280, 1280],
			"mapped",
			[1281]
		],
		[[1281, 1281], "valid"],
		[
			[1282, 1282],
			"mapped",
			[1283]
		],
		[[1283, 1283], "valid"],
		[
			[1284, 1284],
			"mapped",
			[1285]
		],
		[[1285, 1285], "valid"],
		[
			[1286, 1286],
			"mapped",
			[1287]
		],
		[[1287, 1287], "valid"],
		[
			[1288, 1288],
			"mapped",
			[1289]
		],
		[[1289, 1289], "valid"],
		[
			[1290, 1290],
			"mapped",
			[1291]
		],
		[[1291, 1291], "valid"],
		[
			[1292, 1292],
			"mapped",
			[1293]
		],
		[[1293, 1293], "valid"],
		[
			[1294, 1294],
			"mapped",
			[1295]
		],
		[[1295, 1295], "valid"],
		[
			[1296, 1296],
			"mapped",
			[1297]
		],
		[[1297, 1297], "valid"],
		[
			[1298, 1298],
			"mapped",
			[1299]
		],
		[[1299, 1299], "valid"],
		[
			[1300, 1300],
			"mapped",
			[1301]
		],
		[[1301, 1301], "valid"],
		[
			[1302, 1302],
			"mapped",
			[1303]
		],
		[[1303, 1303], "valid"],
		[
			[1304, 1304],
			"mapped",
			[1305]
		],
		[[1305, 1305], "valid"],
		[
			[1306, 1306],
			"mapped",
			[1307]
		],
		[[1307, 1307], "valid"],
		[
			[1308, 1308],
			"mapped",
			[1309]
		],
		[[1309, 1309], "valid"],
		[
			[1310, 1310],
			"mapped",
			[1311]
		],
		[[1311, 1311], "valid"],
		[
			[1312, 1312],
			"mapped",
			[1313]
		],
		[[1313, 1313], "valid"],
		[
			[1314, 1314],
			"mapped",
			[1315]
		],
		[[1315, 1315], "valid"],
		[
			[1316, 1316],
			"mapped",
			[1317]
		],
		[[1317, 1317], "valid"],
		[
			[1318, 1318],
			"mapped",
			[1319]
		],
		[[1319, 1319], "valid"],
		[
			[1320, 1320],
			"mapped",
			[1321]
		],
		[[1321, 1321], "valid"],
		[
			[1322, 1322],
			"mapped",
			[1323]
		],
		[[1323, 1323], "valid"],
		[
			[1324, 1324],
			"mapped",
			[1325]
		],
		[[1325, 1325], "valid"],
		[
			[1326, 1326],
			"mapped",
			[1327]
		],
		[[1327, 1327], "valid"],
		[[1328, 1328], "disallowed"],
		[
			[1329, 1329],
			"mapped",
			[1377]
		],
		[
			[1330, 1330],
			"mapped",
			[1378]
		],
		[
			[1331, 1331],
			"mapped",
			[1379]
		],
		[
			[1332, 1332],
			"mapped",
			[1380]
		],
		[
			[1333, 1333],
			"mapped",
			[1381]
		],
		[
			[1334, 1334],
			"mapped",
			[1382]
		],
		[
			[1335, 1335],
			"mapped",
			[1383]
		],
		[
			[1336, 1336],
			"mapped",
			[1384]
		],
		[
			[1337, 1337],
			"mapped",
			[1385]
		],
		[
			[1338, 1338],
			"mapped",
			[1386]
		],
		[
			[1339, 1339],
			"mapped",
			[1387]
		],
		[
			[1340, 1340],
			"mapped",
			[1388]
		],
		[
			[1341, 1341],
			"mapped",
			[1389]
		],
		[
			[1342, 1342],
			"mapped",
			[1390]
		],
		[
			[1343, 1343],
			"mapped",
			[1391]
		],
		[
			[1344, 1344],
			"mapped",
			[1392]
		],
		[
			[1345, 1345],
			"mapped",
			[1393]
		],
		[
			[1346, 1346],
			"mapped",
			[1394]
		],
		[
			[1347, 1347],
			"mapped",
			[1395]
		],
		[
			[1348, 1348],
			"mapped",
			[1396]
		],
		[
			[1349, 1349],
			"mapped",
			[1397]
		],
		[
			[1350, 1350],
			"mapped",
			[1398]
		],
		[
			[1351, 1351],
			"mapped",
			[1399]
		],
		[
			[1352, 1352],
			"mapped",
			[1400]
		],
		[
			[1353, 1353],
			"mapped",
			[1401]
		],
		[
			[1354, 1354],
			"mapped",
			[1402]
		],
		[
			[1355, 1355],
			"mapped",
			[1403]
		],
		[
			[1356, 1356],
			"mapped",
			[1404]
		],
		[
			[1357, 1357],
			"mapped",
			[1405]
		],
		[
			[1358, 1358],
			"mapped",
			[1406]
		],
		[
			[1359, 1359],
			"mapped",
			[1407]
		],
		[
			[1360, 1360],
			"mapped",
			[1408]
		],
		[
			[1361, 1361],
			"mapped",
			[1409]
		],
		[
			[1362, 1362],
			"mapped",
			[1410]
		],
		[
			[1363, 1363],
			"mapped",
			[1411]
		],
		[
			[1364, 1364],
			"mapped",
			[1412]
		],
		[
			[1365, 1365],
			"mapped",
			[1413]
		],
		[
			[1366, 1366],
			"mapped",
			[1414]
		],
		[[1367, 1368], "disallowed"],
		[[1369, 1369], "valid"],
		[
			[1370, 1375],
			"valid",
			[],
			"NV8"
		],
		[[1376, 1376], "disallowed"],
		[[1377, 1414], "valid"],
		[
			[1415, 1415],
			"mapped",
			[1381, 1410]
		],
		[[1416, 1416], "disallowed"],
		[
			[1417, 1417],
			"valid",
			[],
			"NV8"
		],
		[
			[1418, 1418],
			"valid",
			[],
			"NV8"
		],
		[[1419, 1420], "disallowed"],
		[
			[1421, 1422],
			"valid",
			[],
			"NV8"
		],
		[
			[1423, 1423],
			"valid",
			[],
			"NV8"
		],
		[[1424, 1424], "disallowed"],
		[[1425, 1441], "valid"],
		[[1442, 1442], "valid"],
		[[1443, 1455], "valid"],
		[[1456, 1465], "valid"],
		[[1466, 1466], "valid"],
		[[1467, 1469], "valid"],
		[
			[1470, 1470],
			"valid",
			[],
			"NV8"
		],
		[[1471, 1471], "valid"],
		[
			[1472, 1472],
			"valid",
			[],
			"NV8"
		],
		[[1473, 1474], "valid"],
		[
			[1475, 1475],
			"valid",
			[],
			"NV8"
		],
		[[1476, 1476], "valid"],
		[[1477, 1477], "valid"],
		[
			[1478, 1478],
			"valid",
			[],
			"NV8"
		],
		[[1479, 1479], "valid"],
		[[1480, 1487], "disallowed"],
		[[1488, 1514], "valid"],
		[[1515, 1519], "disallowed"],
		[[1520, 1524], "valid"],
		[[1525, 1535], "disallowed"],
		[[1536, 1539], "disallowed"],
		[[1540, 1540], "disallowed"],
		[[1541, 1541], "disallowed"],
		[
			[1542, 1546],
			"valid",
			[],
			"NV8"
		],
		[
			[1547, 1547],
			"valid",
			[],
			"NV8"
		],
		[
			[1548, 1548],
			"valid",
			[],
			"NV8"
		],
		[
			[1549, 1551],
			"valid",
			[],
			"NV8"
		],
		[[1552, 1557], "valid"],
		[[1558, 1562], "valid"],
		[
			[1563, 1563],
			"valid",
			[],
			"NV8"
		],
		[[1564, 1564], "disallowed"],
		[[1565, 1565], "disallowed"],
		[
			[1566, 1566],
			"valid",
			[],
			"NV8"
		],
		[
			[1567, 1567],
			"valid",
			[],
			"NV8"
		],
		[[1568, 1568], "valid"],
		[[1569, 1594], "valid"],
		[[1595, 1599], "valid"],
		[
			[1600, 1600],
			"valid",
			[],
			"NV8"
		],
		[[1601, 1618], "valid"],
		[[1619, 1621], "valid"],
		[[1622, 1624], "valid"],
		[[1625, 1630], "valid"],
		[[1631, 1631], "valid"],
		[[1632, 1641], "valid"],
		[
			[1642, 1645],
			"valid",
			[],
			"NV8"
		],
		[[1646, 1647], "valid"],
		[[1648, 1652], "valid"],
		[
			[1653, 1653],
			"mapped",
			[1575, 1652]
		],
		[
			[1654, 1654],
			"mapped",
			[1608, 1652]
		],
		[
			[1655, 1655],
			"mapped",
			[1735, 1652]
		],
		[
			[1656, 1656],
			"mapped",
			[1610, 1652]
		],
		[[1657, 1719], "valid"],
		[[1720, 1721], "valid"],
		[[1722, 1726], "valid"],
		[[1727, 1727], "valid"],
		[[1728, 1742], "valid"],
		[[1743, 1743], "valid"],
		[[1744, 1747], "valid"],
		[
			[1748, 1748],
			"valid",
			[],
			"NV8"
		],
		[[1749, 1756], "valid"],
		[[1757, 1757], "disallowed"],
		[
			[1758, 1758],
			"valid",
			[],
			"NV8"
		],
		[[1759, 1768], "valid"],
		[
			[1769, 1769],
			"valid",
			[],
			"NV8"
		],
		[[1770, 1773], "valid"],
		[[1774, 1775], "valid"],
		[[1776, 1785], "valid"],
		[[1786, 1790], "valid"],
		[[1791, 1791], "valid"],
		[
			[1792, 1805],
			"valid",
			[],
			"NV8"
		],
		[[1806, 1806], "disallowed"],
		[[1807, 1807], "disallowed"],
		[[1808, 1836], "valid"],
		[[1837, 1839], "valid"],
		[[1840, 1866], "valid"],
		[[1867, 1868], "disallowed"],
		[[1869, 1871], "valid"],
		[[1872, 1901], "valid"],
		[[1902, 1919], "valid"],
		[[1920, 1968], "valid"],
		[[1969, 1969], "valid"],
		[[1970, 1983], "disallowed"],
		[[1984, 2037], "valid"],
		[
			[2038, 2042],
			"valid",
			[],
			"NV8"
		],
		[[2043, 2047], "disallowed"],
		[[2048, 2093], "valid"],
		[[2094, 2095], "disallowed"],
		[
			[2096, 2110],
			"valid",
			[],
			"NV8"
		],
		[[2111, 2111], "disallowed"],
		[[2112, 2139], "valid"],
		[[2140, 2141], "disallowed"],
		[
			[2142, 2142],
			"valid",
			[],
			"NV8"
		],
		[[2143, 2207], "disallowed"],
		[[2208, 2208], "valid"],
		[[2209, 2209], "valid"],
		[[2210, 2220], "valid"],
		[[2221, 2226], "valid"],
		[[2227, 2228], "valid"],
		[[2229, 2274], "disallowed"],
		[[2275, 2275], "valid"],
		[[2276, 2302], "valid"],
		[[2303, 2303], "valid"],
		[[2304, 2304], "valid"],
		[[2305, 2307], "valid"],
		[[2308, 2308], "valid"],
		[[2309, 2361], "valid"],
		[[2362, 2363], "valid"],
		[[2364, 2381], "valid"],
		[[2382, 2382], "valid"],
		[[2383, 2383], "valid"],
		[[2384, 2388], "valid"],
		[[2389, 2389], "valid"],
		[[2390, 2391], "valid"],
		[
			[2392, 2392],
			"mapped",
			[2325, 2364]
		],
		[
			[2393, 2393],
			"mapped",
			[2326, 2364]
		],
		[
			[2394, 2394],
			"mapped",
			[2327, 2364]
		],
		[
			[2395, 2395],
			"mapped",
			[2332, 2364]
		],
		[
			[2396, 2396],
			"mapped",
			[2337, 2364]
		],
		[
			[2397, 2397],
			"mapped",
			[2338, 2364]
		],
		[
			[2398, 2398],
			"mapped",
			[2347, 2364]
		],
		[
			[2399, 2399],
			"mapped",
			[2351, 2364]
		],
		[[2400, 2403], "valid"],
		[
			[2404, 2405],
			"valid",
			[],
			"NV8"
		],
		[[2406, 2415], "valid"],
		[
			[2416, 2416],
			"valid",
			[],
			"NV8"
		],
		[[2417, 2418], "valid"],
		[[2419, 2423], "valid"],
		[[2424, 2424], "valid"],
		[[2425, 2426], "valid"],
		[[2427, 2428], "valid"],
		[[2429, 2429], "valid"],
		[[2430, 2431], "valid"],
		[[2432, 2432], "valid"],
		[[2433, 2435], "valid"],
		[[2436, 2436], "disallowed"],
		[[2437, 2444], "valid"],
		[[2445, 2446], "disallowed"],
		[[2447, 2448], "valid"],
		[[2449, 2450], "disallowed"],
		[[2451, 2472], "valid"],
		[[2473, 2473], "disallowed"],
		[[2474, 2480], "valid"],
		[[2481, 2481], "disallowed"],
		[[2482, 2482], "valid"],
		[[2483, 2485], "disallowed"],
		[[2486, 2489], "valid"],
		[[2490, 2491], "disallowed"],
		[[2492, 2492], "valid"],
		[[2493, 2493], "valid"],
		[[2494, 2500], "valid"],
		[[2501, 2502], "disallowed"],
		[[2503, 2504], "valid"],
		[[2505, 2506], "disallowed"],
		[[2507, 2509], "valid"],
		[[2510, 2510], "valid"],
		[[2511, 2518], "disallowed"],
		[[2519, 2519], "valid"],
		[[2520, 2523], "disallowed"],
		[
			[2524, 2524],
			"mapped",
			[2465, 2492]
		],
		[
			[2525, 2525],
			"mapped",
			[2466, 2492]
		],
		[[2526, 2526], "disallowed"],
		[
			[2527, 2527],
			"mapped",
			[2479, 2492]
		],
		[[2528, 2531], "valid"],
		[[2532, 2533], "disallowed"],
		[[2534, 2545], "valid"],
		[
			[2546, 2554],
			"valid",
			[],
			"NV8"
		],
		[
			[2555, 2555],
			"valid",
			[],
			"NV8"
		],
		[[2556, 2560], "disallowed"],
		[[2561, 2561], "valid"],
		[[2562, 2562], "valid"],
		[[2563, 2563], "valid"],
		[[2564, 2564], "disallowed"],
		[[2565, 2570], "valid"],
		[[2571, 2574], "disallowed"],
		[[2575, 2576], "valid"],
		[[2577, 2578], "disallowed"],
		[[2579, 2600], "valid"],
		[[2601, 2601], "disallowed"],
		[[2602, 2608], "valid"],
		[[2609, 2609], "disallowed"],
		[[2610, 2610], "valid"],
		[
			[2611, 2611],
			"mapped",
			[2610, 2620]
		],
		[[2612, 2612], "disallowed"],
		[[2613, 2613], "valid"],
		[
			[2614, 2614],
			"mapped",
			[2616, 2620]
		],
		[[2615, 2615], "disallowed"],
		[[2616, 2617], "valid"],
		[[2618, 2619], "disallowed"],
		[[2620, 2620], "valid"],
		[[2621, 2621], "disallowed"],
		[[2622, 2626], "valid"],
		[[2627, 2630], "disallowed"],
		[[2631, 2632], "valid"],
		[[2633, 2634], "disallowed"],
		[[2635, 2637], "valid"],
		[[2638, 2640], "disallowed"],
		[[2641, 2641], "valid"],
		[[2642, 2648], "disallowed"],
		[
			[2649, 2649],
			"mapped",
			[2582, 2620]
		],
		[
			[2650, 2650],
			"mapped",
			[2583, 2620]
		],
		[
			[2651, 2651],
			"mapped",
			[2588, 2620]
		],
		[[2652, 2652], "valid"],
		[[2653, 2653], "disallowed"],
		[
			[2654, 2654],
			"mapped",
			[2603, 2620]
		],
		[[2655, 2661], "disallowed"],
		[[2662, 2676], "valid"],
		[[2677, 2677], "valid"],
		[[2678, 2688], "disallowed"],
		[[2689, 2691], "valid"],
		[[2692, 2692], "disallowed"],
		[[2693, 2699], "valid"],
		[[2700, 2700], "valid"],
		[[2701, 2701], "valid"],
		[[2702, 2702], "disallowed"],
		[[2703, 2705], "valid"],
		[[2706, 2706], "disallowed"],
		[[2707, 2728], "valid"],
		[[2729, 2729], "disallowed"],
		[[2730, 2736], "valid"],
		[[2737, 2737], "disallowed"],
		[[2738, 2739], "valid"],
		[[2740, 2740], "disallowed"],
		[[2741, 2745], "valid"],
		[[2746, 2747], "disallowed"],
		[[2748, 2757], "valid"],
		[[2758, 2758], "disallowed"],
		[[2759, 2761], "valid"],
		[[2762, 2762], "disallowed"],
		[[2763, 2765], "valid"],
		[[2766, 2767], "disallowed"],
		[[2768, 2768], "valid"],
		[[2769, 2783], "disallowed"],
		[[2784, 2784], "valid"],
		[[2785, 2787], "valid"],
		[[2788, 2789], "disallowed"],
		[[2790, 2799], "valid"],
		[
			[2800, 2800],
			"valid",
			[],
			"NV8"
		],
		[
			[2801, 2801],
			"valid",
			[],
			"NV8"
		],
		[[2802, 2808], "disallowed"],
		[[2809, 2809], "valid"],
		[[2810, 2816], "disallowed"],
		[[2817, 2819], "valid"],
		[[2820, 2820], "disallowed"],
		[[2821, 2828], "valid"],
		[[2829, 2830], "disallowed"],
		[[2831, 2832], "valid"],
		[[2833, 2834], "disallowed"],
		[[2835, 2856], "valid"],
		[[2857, 2857], "disallowed"],
		[[2858, 2864], "valid"],
		[[2865, 2865], "disallowed"],
		[[2866, 2867], "valid"],
		[[2868, 2868], "disallowed"],
		[[2869, 2869], "valid"],
		[[2870, 2873], "valid"],
		[[2874, 2875], "disallowed"],
		[[2876, 2883], "valid"],
		[[2884, 2884], "valid"],
		[[2885, 2886], "disallowed"],
		[[2887, 2888], "valid"],
		[[2889, 2890], "disallowed"],
		[[2891, 2893], "valid"],
		[[2894, 2901], "disallowed"],
		[[2902, 2903], "valid"],
		[[2904, 2907], "disallowed"],
		[
			[2908, 2908],
			"mapped",
			[2849, 2876]
		],
		[
			[2909, 2909],
			"mapped",
			[2850, 2876]
		],
		[[2910, 2910], "disallowed"],
		[[2911, 2913], "valid"],
		[[2914, 2915], "valid"],
		[[2916, 2917], "disallowed"],
		[[2918, 2927], "valid"],
		[
			[2928, 2928],
			"valid",
			[],
			"NV8"
		],
		[[2929, 2929], "valid"],
		[
			[2930, 2935],
			"valid",
			[],
			"NV8"
		],
		[[2936, 2945], "disallowed"],
		[[2946, 2947], "valid"],
		[[2948, 2948], "disallowed"],
		[[2949, 2954], "valid"],
		[[2955, 2957], "disallowed"],
		[[2958, 2960], "valid"],
		[[2961, 2961], "disallowed"],
		[[2962, 2965], "valid"],
		[[2966, 2968], "disallowed"],
		[[2969, 2970], "valid"],
		[[2971, 2971], "disallowed"],
		[[2972, 2972], "valid"],
		[[2973, 2973], "disallowed"],
		[[2974, 2975], "valid"],
		[[2976, 2978], "disallowed"],
		[[2979, 2980], "valid"],
		[[2981, 2983], "disallowed"],
		[[2984, 2986], "valid"],
		[[2987, 2989], "disallowed"],
		[[2990, 2997], "valid"],
		[[2998, 2998], "valid"],
		[[2999, 3001], "valid"],
		[[3002, 3005], "disallowed"],
		[[3006, 3010], "valid"],
		[[3011, 3013], "disallowed"],
		[[3014, 3016], "valid"],
		[[3017, 3017], "disallowed"],
		[[3018, 3021], "valid"],
		[[3022, 3023], "disallowed"],
		[[3024, 3024], "valid"],
		[[3025, 3030], "disallowed"],
		[[3031, 3031], "valid"],
		[[3032, 3045], "disallowed"],
		[[3046, 3046], "valid"],
		[[3047, 3055], "valid"],
		[
			[3056, 3058],
			"valid",
			[],
			"NV8"
		],
		[
			[3059, 3066],
			"valid",
			[],
			"NV8"
		],
		[[3067, 3071], "disallowed"],
		[[3072, 3072], "valid"],
		[[3073, 3075], "valid"],
		[[3076, 3076], "disallowed"],
		[[3077, 3084], "valid"],
		[[3085, 3085], "disallowed"],
		[[3086, 3088], "valid"],
		[[3089, 3089], "disallowed"],
		[[3090, 3112], "valid"],
		[[3113, 3113], "disallowed"],
		[[3114, 3123], "valid"],
		[[3124, 3124], "valid"],
		[[3125, 3129], "valid"],
		[[3130, 3132], "disallowed"],
		[[3133, 3133], "valid"],
		[[3134, 3140], "valid"],
		[[3141, 3141], "disallowed"],
		[[3142, 3144], "valid"],
		[[3145, 3145], "disallowed"],
		[[3146, 3149], "valid"],
		[[3150, 3156], "disallowed"],
		[[3157, 3158], "valid"],
		[[3159, 3159], "disallowed"],
		[[3160, 3161], "valid"],
		[[3162, 3162], "valid"],
		[[3163, 3167], "disallowed"],
		[[3168, 3169], "valid"],
		[[3170, 3171], "valid"],
		[[3172, 3173], "disallowed"],
		[[3174, 3183], "valid"],
		[[3184, 3191], "disallowed"],
		[
			[3192, 3199],
			"valid",
			[],
			"NV8"
		],
		[[3200, 3200], "disallowed"],
		[[3201, 3201], "valid"],
		[[3202, 3203], "valid"],
		[[3204, 3204], "disallowed"],
		[[3205, 3212], "valid"],
		[[3213, 3213], "disallowed"],
		[[3214, 3216], "valid"],
		[[3217, 3217], "disallowed"],
		[[3218, 3240], "valid"],
		[[3241, 3241], "disallowed"],
		[[3242, 3251], "valid"],
		[[3252, 3252], "disallowed"],
		[[3253, 3257], "valid"],
		[[3258, 3259], "disallowed"],
		[[3260, 3261], "valid"],
		[[3262, 3268], "valid"],
		[[3269, 3269], "disallowed"],
		[[3270, 3272], "valid"],
		[[3273, 3273], "disallowed"],
		[[3274, 3277], "valid"],
		[[3278, 3284], "disallowed"],
		[[3285, 3286], "valid"],
		[[3287, 3293], "disallowed"],
		[[3294, 3294], "valid"],
		[[3295, 3295], "disallowed"],
		[[3296, 3297], "valid"],
		[[3298, 3299], "valid"],
		[[3300, 3301], "disallowed"],
		[[3302, 3311], "valid"],
		[[3312, 3312], "disallowed"],
		[[3313, 3314], "valid"],
		[[3315, 3328], "disallowed"],
		[[3329, 3329], "valid"],
		[[3330, 3331], "valid"],
		[[3332, 3332], "disallowed"],
		[[3333, 3340], "valid"],
		[[3341, 3341], "disallowed"],
		[[3342, 3344], "valid"],
		[[3345, 3345], "disallowed"],
		[[3346, 3368], "valid"],
		[[3369, 3369], "valid"],
		[[3370, 3385], "valid"],
		[[3386, 3386], "valid"],
		[[3387, 3388], "disallowed"],
		[[3389, 3389], "valid"],
		[[3390, 3395], "valid"],
		[[3396, 3396], "valid"],
		[[3397, 3397], "disallowed"],
		[[3398, 3400], "valid"],
		[[3401, 3401], "disallowed"],
		[[3402, 3405], "valid"],
		[[3406, 3406], "valid"],
		[[3407, 3414], "disallowed"],
		[[3415, 3415], "valid"],
		[[3416, 3422], "disallowed"],
		[[3423, 3423], "valid"],
		[[3424, 3425], "valid"],
		[[3426, 3427], "valid"],
		[[3428, 3429], "disallowed"],
		[[3430, 3439], "valid"],
		[
			[3440, 3445],
			"valid",
			[],
			"NV8"
		],
		[[3446, 3448], "disallowed"],
		[
			[3449, 3449],
			"valid",
			[],
			"NV8"
		],
		[[3450, 3455], "valid"],
		[[3456, 3457], "disallowed"],
		[[3458, 3459], "valid"],
		[[3460, 3460], "disallowed"],
		[[3461, 3478], "valid"],
		[[3479, 3481], "disallowed"],
		[[3482, 3505], "valid"],
		[[3506, 3506], "disallowed"],
		[[3507, 3515], "valid"],
		[[3516, 3516], "disallowed"],
		[[3517, 3517], "valid"],
		[[3518, 3519], "disallowed"],
		[[3520, 3526], "valid"],
		[[3527, 3529], "disallowed"],
		[[3530, 3530], "valid"],
		[[3531, 3534], "disallowed"],
		[[3535, 3540], "valid"],
		[[3541, 3541], "disallowed"],
		[[3542, 3542], "valid"],
		[[3543, 3543], "disallowed"],
		[[3544, 3551], "valid"],
		[[3552, 3557], "disallowed"],
		[[3558, 3567], "valid"],
		[[3568, 3569], "disallowed"],
		[[3570, 3571], "valid"],
		[
			[3572, 3572],
			"valid",
			[],
			"NV8"
		],
		[[3573, 3584], "disallowed"],
		[[3585, 3634], "valid"],
		[
			[3635, 3635],
			"mapped",
			[3661, 3634]
		],
		[[3636, 3642], "valid"],
		[[3643, 3646], "disallowed"],
		[
			[3647, 3647],
			"valid",
			[],
			"NV8"
		],
		[[3648, 3662], "valid"],
		[
			[3663, 3663],
			"valid",
			[],
			"NV8"
		],
		[[3664, 3673], "valid"],
		[
			[3674, 3675],
			"valid",
			[],
			"NV8"
		],
		[[3676, 3712], "disallowed"],
		[[3713, 3714], "valid"],
		[[3715, 3715], "disallowed"],
		[[3716, 3716], "valid"],
		[[3717, 3718], "disallowed"],
		[[3719, 3720], "valid"],
		[[3721, 3721], "disallowed"],
		[[3722, 3722], "valid"],
		[[3723, 3724], "disallowed"],
		[[3725, 3725], "valid"],
		[[3726, 3731], "disallowed"],
		[[3732, 3735], "valid"],
		[[3736, 3736], "disallowed"],
		[[3737, 3743], "valid"],
		[[3744, 3744], "disallowed"],
		[[3745, 3747], "valid"],
		[[3748, 3748], "disallowed"],
		[[3749, 3749], "valid"],
		[[3750, 3750], "disallowed"],
		[[3751, 3751], "valid"],
		[[3752, 3753], "disallowed"],
		[[3754, 3755], "valid"],
		[[3756, 3756], "disallowed"],
		[[3757, 3762], "valid"],
		[
			[3763, 3763],
			"mapped",
			[3789, 3762]
		],
		[[3764, 3769], "valid"],
		[[3770, 3770], "disallowed"],
		[[3771, 3773], "valid"],
		[[3774, 3775], "disallowed"],
		[[3776, 3780], "valid"],
		[[3781, 3781], "disallowed"],
		[[3782, 3782], "valid"],
		[[3783, 3783], "disallowed"],
		[[3784, 3789], "valid"],
		[[3790, 3791], "disallowed"],
		[[3792, 3801], "valid"],
		[[3802, 3803], "disallowed"],
		[
			[3804, 3804],
			"mapped",
			[3755, 3737]
		],
		[
			[3805, 3805],
			"mapped",
			[3755, 3745]
		],
		[[3806, 3807], "valid"],
		[[3808, 3839], "disallowed"],
		[[3840, 3840], "valid"],
		[
			[3841, 3850],
			"valid",
			[],
			"NV8"
		],
		[[3851, 3851], "valid"],
		[
			[3852, 3852],
			"mapped",
			[3851]
		],
		[
			[3853, 3863],
			"valid",
			[],
			"NV8"
		],
		[[3864, 3865], "valid"],
		[
			[3866, 3871],
			"valid",
			[],
			"NV8"
		],
		[[3872, 3881], "valid"],
		[
			[3882, 3892],
			"valid",
			[],
			"NV8"
		],
		[[3893, 3893], "valid"],
		[
			[3894, 3894],
			"valid",
			[],
			"NV8"
		],
		[[3895, 3895], "valid"],
		[
			[3896, 3896],
			"valid",
			[],
			"NV8"
		],
		[[3897, 3897], "valid"],
		[
			[3898, 3901],
			"valid",
			[],
			"NV8"
		],
		[[3902, 3906], "valid"],
		[
			[3907, 3907],
			"mapped",
			[3906, 4023]
		],
		[[3908, 3911], "valid"],
		[[3912, 3912], "disallowed"],
		[[3913, 3916], "valid"],
		[
			[3917, 3917],
			"mapped",
			[3916, 4023]
		],
		[[3918, 3921], "valid"],
		[
			[3922, 3922],
			"mapped",
			[3921, 4023]
		],
		[[3923, 3926], "valid"],
		[
			[3927, 3927],
			"mapped",
			[3926, 4023]
		],
		[[3928, 3931], "valid"],
		[
			[3932, 3932],
			"mapped",
			[3931, 4023]
		],
		[[3933, 3944], "valid"],
		[
			[3945, 3945],
			"mapped",
			[3904, 4021]
		],
		[[3946, 3946], "valid"],
		[[3947, 3948], "valid"],
		[[3949, 3952], "disallowed"],
		[[3953, 3954], "valid"],
		[
			[3955, 3955],
			"mapped",
			[3953, 3954]
		],
		[[3956, 3956], "valid"],
		[
			[3957, 3957],
			"mapped",
			[3953, 3956]
		],
		[
			[3958, 3958],
			"mapped",
			[4018, 3968]
		],
		[
			[3959, 3959],
			"mapped",
			[
				4018,
				3953,
				3968
			]
		],
		[
			[3960, 3960],
			"mapped",
			[4019, 3968]
		],
		[
			[3961, 3961],
			"mapped",
			[
				4019,
				3953,
				3968
			]
		],
		[[3962, 3968], "valid"],
		[
			[3969, 3969],
			"mapped",
			[3953, 3968]
		],
		[[3970, 3972], "valid"],
		[
			[3973, 3973],
			"valid",
			[],
			"NV8"
		],
		[[3974, 3979], "valid"],
		[[3980, 3983], "valid"],
		[[3984, 3986], "valid"],
		[
			[3987, 3987],
			"mapped",
			[3986, 4023]
		],
		[[3988, 3989], "valid"],
		[[3990, 3990], "valid"],
		[[3991, 3991], "valid"],
		[[3992, 3992], "disallowed"],
		[[3993, 3996], "valid"],
		[
			[3997, 3997],
			"mapped",
			[3996, 4023]
		],
		[[3998, 4001], "valid"],
		[
			[4002, 4002],
			"mapped",
			[4001, 4023]
		],
		[[4003, 4006], "valid"],
		[
			[4007, 4007],
			"mapped",
			[4006, 4023]
		],
		[[4008, 4011], "valid"],
		[
			[4012, 4012],
			"mapped",
			[4011, 4023]
		],
		[[4013, 4013], "valid"],
		[[4014, 4016], "valid"],
		[[4017, 4023], "valid"],
		[[4024, 4024], "valid"],
		[
			[4025, 4025],
			"mapped",
			[3984, 4021]
		],
		[[4026, 4028], "valid"],
		[[4029, 4029], "disallowed"],
		[
			[4030, 4037],
			"valid",
			[],
			"NV8"
		],
		[[4038, 4038], "valid"],
		[
			[4039, 4044],
			"valid",
			[],
			"NV8"
		],
		[[4045, 4045], "disallowed"],
		[
			[4046, 4046],
			"valid",
			[],
			"NV8"
		],
		[
			[4047, 4047],
			"valid",
			[],
			"NV8"
		],
		[
			[4048, 4049],
			"valid",
			[],
			"NV8"
		],
		[
			[4050, 4052],
			"valid",
			[],
			"NV8"
		],
		[
			[4053, 4056],
			"valid",
			[],
			"NV8"
		],
		[
			[4057, 4058],
			"valid",
			[],
			"NV8"
		],
		[[4059, 4095], "disallowed"],
		[[4096, 4129], "valid"],
		[[4130, 4130], "valid"],
		[[4131, 4135], "valid"],
		[[4136, 4136], "valid"],
		[[4137, 4138], "valid"],
		[[4139, 4139], "valid"],
		[[4140, 4146], "valid"],
		[[4147, 4149], "valid"],
		[[4150, 4153], "valid"],
		[[4154, 4159], "valid"],
		[[4160, 4169], "valid"],
		[
			[4170, 4175],
			"valid",
			[],
			"NV8"
		],
		[[4176, 4185], "valid"],
		[[4186, 4249], "valid"],
		[[4250, 4253], "valid"],
		[
			[4254, 4255],
			"valid",
			[],
			"NV8"
		],
		[[4256, 4293], "disallowed"],
		[[4294, 4294], "disallowed"],
		[
			[4295, 4295],
			"mapped",
			[11559]
		],
		[[4296, 4300], "disallowed"],
		[
			[4301, 4301],
			"mapped",
			[11565]
		],
		[[4302, 4303], "disallowed"],
		[[4304, 4342], "valid"],
		[[4343, 4344], "valid"],
		[[4345, 4346], "valid"],
		[
			[4347, 4347],
			"valid",
			[],
			"NV8"
		],
		[
			[4348, 4348],
			"mapped",
			[4316]
		],
		[[4349, 4351], "valid"],
		[
			[4352, 4441],
			"valid",
			[],
			"NV8"
		],
		[
			[4442, 4446],
			"valid",
			[],
			"NV8"
		],
		[[4447, 4448], "disallowed"],
		[
			[4449, 4514],
			"valid",
			[],
			"NV8"
		],
		[
			[4515, 4519],
			"valid",
			[],
			"NV8"
		],
		[
			[4520, 4601],
			"valid",
			[],
			"NV8"
		],
		[
			[4602, 4607],
			"valid",
			[],
			"NV8"
		],
		[[4608, 4614], "valid"],
		[[4615, 4615], "valid"],
		[[4616, 4678], "valid"],
		[[4679, 4679], "valid"],
		[[4680, 4680], "valid"],
		[[4681, 4681], "disallowed"],
		[[4682, 4685], "valid"],
		[[4686, 4687], "disallowed"],
		[[4688, 4694], "valid"],
		[[4695, 4695], "disallowed"],
		[[4696, 4696], "valid"],
		[[4697, 4697], "disallowed"],
		[[4698, 4701], "valid"],
		[[4702, 4703], "disallowed"],
		[[4704, 4742], "valid"],
		[[4743, 4743], "valid"],
		[[4744, 4744], "valid"],
		[[4745, 4745], "disallowed"],
		[[4746, 4749], "valid"],
		[[4750, 4751], "disallowed"],
		[[4752, 4782], "valid"],
		[[4783, 4783], "valid"],
		[[4784, 4784], "valid"],
		[[4785, 4785], "disallowed"],
		[[4786, 4789], "valid"],
		[[4790, 4791], "disallowed"],
		[[4792, 4798], "valid"],
		[[4799, 4799], "disallowed"],
		[[4800, 4800], "valid"],
		[[4801, 4801], "disallowed"],
		[[4802, 4805], "valid"],
		[[4806, 4807], "disallowed"],
		[[4808, 4814], "valid"],
		[[4815, 4815], "valid"],
		[[4816, 4822], "valid"],
		[[4823, 4823], "disallowed"],
		[[4824, 4846], "valid"],
		[[4847, 4847], "valid"],
		[[4848, 4878], "valid"],
		[[4879, 4879], "valid"],
		[[4880, 4880], "valid"],
		[[4881, 4881], "disallowed"],
		[[4882, 4885], "valid"],
		[[4886, 4887], "disallowed"],
		[[4888, 4894], "valid"],
		[[4895, 4895], "valid"],
		[[4896, 4934], "valid"],
		[[4935, 4935], "valid"],
		[[4936, 4954], "valid"],
		[[4955, 4956], "disallowed"],
		[[4957, 4958], "valid"],
		[[4959, 4959], "valid"],
		[
			[4960, 4960],
			"valid",
			[],
			"NV8"
		],
		[
			[4961, 4988],
			"valid",
			[],
			"NV8"
		],
		[[4989, 4991], "disallowed"],
		[[4992, 5007], "valid"],
		[
			[5008, 5017],
			"valid",
			[],
			"NV8"
		],
		[[5018, 5023], "disallowed"],
		[[5024, 5108], "valid"],
		[[5109, 5109], "valid"],
		[[5110, 5111], "disallowed"],
		[
			[5112, 5112],
			"mapped",
			[5104]
		],
		[
			[5113, 5113],
			"mapped",
			[5105]
		],
		[
			[5114, 5114],
			"mapped",
			[5106]
		],
		[
			[5115, 5115],
			"mapped",
			[5107]
		],
		[
			[5116, 5116],
			"mapped",
			[5108]
		],
		[
			[5117, 5117],
			"mapped",
			[5109]
		],
		[[5118, 5119], "disallowed"],
		[
			[5120, 5120],
			"valid",
			[],
			"NV8"
		],
		[[5121, 5740], "valid"],
		[
			[5741, 5742],
			"valid",
			[],
			"NV8"
		],
		[[5743, 5750], "valid"],
		[[5751, 5759], "valid"],
		[[5760, 5760], "disallowed"],
		[[5761, 5786], "valid"],
		[
			[5787, 5788],
			"valid",
			[],
			"NV8"
		],
		[[5789, 5791], "disallowed"],
		[[5792, 5866], "valid"],
		[
			[5867, 5872],
			"valid",
			[],
			"NV8"
		],
		[[5873, 5880], "valid"],
		[[5881, 5887], "disallowed"],
		[[5888, 5900], "valid"],
		[[5901, 5901], "disallowed"],
		[[5902, 5908], "valid"],
		[[5909, 5919], "disallowed"],
		[[5920, 5940], "valid"],
		[
			[5941, 5942],
			"valid",
			[],
			"NV8"
		],
		[[5943, 5951], "disallowed"],
		[[5952, 5971], "valid"],
		[[5972, 5983], "disallowed"],
		[[5984, 5996], "valid"],
		[[5997, 5997], "disallowed"],
		[[5998, 6e3], "valid"],
		[[6001, 6001], "disallowed"],
		[[6002, 6003], "valid"],
		[[6004, 6015], "disallowed"],
		[[6016, 6067], "valid"],
		[[6068, 6069], "disallowed"],
		[[6070, 6099], "valid"],
		[
			[6100, 6102],
			"valid",
			[],
			"NV8"
		],
		[[6103, 6103], "valid"],
		[
			[6104, 6107],
			"valid",
			[],
			"NV8"
		],
		[[6108, 6108], "valid"],
		[[6109, 6109], "valid"],
		[[6110, 6111], "disallowed"],
		[[6112, 6121], "valid"],
		[[6122, 6127], "disallowed"],
		[
			[6128, 6137],
			"valid",
			[],
			"NV8"
		],
		[[6138, 6143], "disallowed"],
		[
			[6144, 6149],
			"valid",
			[],
			"NV8"
		],
		[[6150, 6150], "disallowed"],
		[
			[6151, 6154],
			"valid",
			[],
			"NV8"
		],
		[[6155, 6157], "ignored"],
		[[6158, 6158], "disallowed"],
		[[6159, 6159], "disallowed"],
		[[6160, 6169], "valid"],
		[[6170, 6175], "disallowed"],
		[[6176, 6263], "valid"],
		[[6264, 6271], "disallowed"],
		[[6272, 6313], "valid"],
		[[6314, 6314], "valid"],
		[[6315, 6319], "disallowed"],
		[[6320, 6389], "valid"],
		[[6390, 6399], "disallowed"],
		[[6400, 6428], "valid"],
		[[6429, 6430], "valid"],
		[[6431, 6431], "disallowed"],
		[[6432, 6443], "valid"],
		[[6444, 6447], "disallowed"],
		[[6448, 6459], "valid"],
		[[6460, 6463], "disallowed"],
		[
			[6464, 6464],
			"valid",
			[],
			"NV8"
		],
		[[6465, 6467], "disallowed"],
		[
			[6468, 6469],
			"valid",
			[],
			"NV8"
		],
		[[6470, 6509], "valid"],
		[[6510, 6511], "disallowed"],
		[[6512, 6516], "valid"],
		[[6517, 6527], "disallowed"],
		[[6528, 6569], "valid"],
		[[6570, 6571], "valid"],
		[[6572, 6575], "disallowed"],
		[[6576, 6601], "valid"],
		[[6602, 6607], "disallowed"],
		[[6608, 6617], "valid"],
		[
			[6618, 6618],
			"valid",
			[],
			"XV8"
		],
		[[6619, 6621], "disallowed"],
		[
			[6622, 6623],
			"valid",
			[],
			"NV8"
		],
		[
			[6624, 6655],
			"valid",
			[],
			"NV8"
		],
		[[6656, 6683], "valid"],
		[[6684, 6685], "disallowed"],
		[
			[6686, 6687],
			"valid",
			[],
			"NV8"
		],
		[[6688, 6750], "valid"],
		[[6751, 6751], "disallowed"],
		[[6752, 6780], "valid"],
		[[6781, 6782], "disallowed"],
		[[6783, 6793], "valid"],
		[[6794, 6799], "disallowed"],
		[[6800, 6809], "valid"],
		[[6810, 6815], "disallowed"],
		[
			[6816, 6822],
			"valid",
			[],
			"NV8"
		],
		[[6823, 6823], "valid"],
		[
			[6824, 6829],
			"valid",
			[],
			"NV8"
		],
		[[6830, 6831], "disallowed"],
		[[6832, 6845], "valid"],
		[
			[6846, 6846],
			"valid",
			[],
			"NV8"
		],
		[[6847, 6911], "disallowed"],
		[[6912, 6987], "valid"],
		[[6988, 6991], "disallowed"],
		[[6992, 7001], "valid"],
		[
			[7002, 7018],
			"valid",
			[],
			"NV8"
		],
		[[7019, 7027], "valid"],
		[
			[7028, 7036],
			"valid",
			[],
			"NV8"
		],
		[[7037, 7039], "disallowed"],
		[[7040, 7082], "valid"],
		[[7083, 7085], "valid"],
		[[7086, 7097], "valid"],
		[[7098, 7103], "valid"],
		[[7104, 7155], "valid"],
		[[7156, 7163], "disallowed"],
		[
			[7164, 7167],
			"valid",
			[],
			"NV8"
		],
		[[7168, 7223], "valid"],
		[[7224, 7226], "disallowed"],
		[
			[7227, 7231],
			"valid",
			[],
			"NV8"
		],
		[[7232, 7241], "valid"],
		[[7242, 7244], "disallowed"],
		[[7245, 7293], "valid"],
		[
			[7294, 7295],
			"valid",
			[],
			"NV8"
		],
		[[7296, 7359], "disallowed"],
		[
			[7360, 7367],
			"valid",
			[],
			"NV8"
		],
		[[7368, 7375], "disallowed"],
		[[7376, 7378], "valid"],
		[
			[7379, 7379],
			"valid",
			[],
			"NV8"
		],
		[[7380, 7410], "valid"],
		[[7411, 7414], "valid"],
		[[7415, 7415], "disallowed"],
		[[7416, 7417], "valid"],
		[[7418, 7423], "disallowed"],
		[[7424, 7467], "valid"],
		[
			[7468, 7468],
			"mapped",
			[97]
		],
		[
			[7469, 7469],
			"mapped",
			[230]
		],
		[
			[7470, 7470],
			"mapped",
			[98]
		],
		[[7471, 7471], "valid"],
		[
			[7472, 7472],
			"mapped",
			[100]
		],
		[
			[7473, 7473],
			"mapped",
			[101]
		],
		[
			[7474, 7474],
			"mapped",
			[477]
		],
		[
			[7475, 7475],
			"mapped",
			[103]
		],
		[
			[7476, 7476],
			"mapped",
			[104]
		],
		[
			[7477, 7477],
			"mapped",
			[105]
		],
		[
			[7478, 7478],
			"mapped",
			[106]
		],
		[
			[7479, 7479],
			"mapped",
			[107]
		],
		[
			[7480, 7480],
			"mapped",
			[108]
		],
		[
			[7481, 7481],
			"mapped",
			[109]
		],
		[
			[7482, 7482],
			"mapped",
			[110]
		],
		[[7483, 7483], "valid"],
		[
			[7484, 7484],
			"mapped",
			[111]
		],
		[
			[7485, 7485],
			"mapped",
			[547]
		],
		[
			[7486, 7486],
			"mapped",
			[112]
		],
		[
			[7487, 7487],
			"mapped",
			[114]
		],
		[
			[7488, 7488],
			"mapped",
			[116]
		],
		[
			[7489, 7489],
			"mapped",
			[117]
		],
		[
			[7490, 7490],
			"mapped",
			[119]
		],
		[
			[7491, 7491],
			"mapped",
			[97]
		],
		[
			[7492, 7492],
			"mapped",
			[592]
		],
		[
			[7493, 7493],
			"mapped",
			[593]
		],
		[
			[7494, 7494],
			"mapped",
			[7426]
		],
		[
			[7495, 7495],
			"mapped",
			[98]
		],
		[
			[7496, 7496],
			"mapped",
			[100]
		],
		[
			[7497, 7497],
			"mapped",
			[101]
		],
		[
			[7498, 7498],
			"mapped",
			[601]
		],
		[
			[7499, 7499],
			"mapped",
			[603]
		],
		[
			[7500, 7500],
			"mapped",
			[604]
		],
		[
			[7501, 7501],
			"mapped",
			[103]
		],
		[[7502, 7502], "valid"],
		[
			[7503, 7503],
			"mapped",
			[107]
		],
		[
			[7504, 7504],
			"mapped",
			[109]
		],
		[
			[7505, 7505],
			"mapped",
			[331]
		],
		[
			[7506, 7506],
			"mapped",
			[111]
		],
		[
			[7507, 7507],
			"mapped",
			[596]
		],
		[
			[7508, 7508],
			"mapped",
			[7446]
		],
		[
			[7509, 7509],
			"mapped",
			[7447]
		],
		[
			[7510, 7510],
			"mapped",
			[112]
		],
		[
			[7511, 7511],
			"mapped",
			[116]
		],
		[
			[7512, 7512],
			"mapped",
			[117]
		],
		[
			[7513, 7513],
			"mapped",
			[7453]
		],
		[
			[7514, 7514],
			"mapped",
			[623]
		],
		[
			[7515, 7515],
			"mapped",
			[118]
		],
		[
			[7516, 7516],
			"mapped",
			[7461]
		],
		[
			[7517, 7517],
			"mapped",
			[946]
		],
		[
			[7518, 7518],
			"mapped",
			[947]
		],
		[
			[7519, 7519],
			"mapped",
			[948]
		],
		[
			[7520, 7520],
			"mapped",
			[966]
		],
		[
			[7521, 7521],
			"mapped",
			[967]
		],
		[
			[7522, 7522],
			"mapped",
			[105]
		],
		[
			[7523, 7523],
			"mapped",
			[114]
		],
		[
			[7524, 7524],
			"mapped",
			[117]
		],
		[
			[7525, 7525],
			"mapped",
			[118]
		],
		[
			[7526, 7526],
			"mapped",
			[946]
		],
		[
			[7527, 7527],
			"mapped",
			[947]
		],
		[
			[7528, 7528],
			"mapped",
			[961]
		],
		[
			[7529, 7529],
			"mapped",
			[966]
		],
		[
			[7530, 7530],
			"mapped",
			[967]
		],
		[[7531, 7531], "valid"],
		[[7532, 7543], "valid"],
		[
			[7544, 7544],
			"mapped",
			[1085]
		],
		[[7545, 7578], "valid"],
		[
			[7579, 7579],
			"mapped",
			[594]
		],
		[
			[7580, 7580],
			"mapped",
			[99]
		],
		[
			[7581, 7581],
			"mapped",
			[597]
		],
		[
			[7582, 7582],
			"mapped",
			[240]
		],
		[
			[7583, 7583],
			"mapped",
			[604]
		],
		[
			[7584, 7584],
			"mapped",
			[102]
		],
		[
			[7585, 7585],
			"mapped",
			[607]
		],
		[
			[7586, 7586],
			"mapped",
			[609]
		],
		[
			[7587, 7587],
			"mapped",
			[613]
		],
		[
			[7588, 7588],
			"mapped",
			[616]
		],
		[
			[7589, 7589],
			"mapped",
			[617]
		],
		[
			[7590, 7590],
			"mapped",
			[618]
		],
		[
			[7591, 7591],
			"mapped",
			[7547]
		],
		[
			[7592, 7592],
			"mapped",
			[669]
		],
		[
			[7593, 7593],
			"mapped",
			[621]
		],
		[
			[7594, 7594],
			"mapped",
			[7557]
		],
		[
			[7595, 7595],
			"mapped",
			[671]
		],
		[
			[7596, 7596],
			"mapped",
			[625]
		],
		[
			[7597, 7597],
			"mapped",
			[624]
		],
		[
			[7598, 7598],
			"mapped",
			[626]
		],
		[
			[7599, 7599],
			"mapped",
			[627]
		],
		[
			[7600, 7600],
			"mapped",
			[628]
		],
		[
			[7601, 7601],
			"mapped",
			[629]
		],
		[
			[7602, 7602],
			"mapped",
			[632]
		],
		[
			[7603, 7603],
			"mapped",
			[642]
		],
		[
			[7604, 7604],
			"mapped",
			[643]
		],
		[
			[7605, 7605],
			"mapped",
			[427]
		],
		[
			[7606, 7606],
			"mapped",
			[649]
		],
		[
			[7607, 7607],
			"mapped",
			[650]
		],
		[
			[7608, 7608],
			"mapped",
			[7452]
		],
		[
			[7609, 7609],
			"mapped",
			[651]
		],
		[
			[7610, 7610],
			"mapped",
			[652]
		],
		[
			[7611, 7611],
			"mapped",
			[122]
		],
		[
			[7612, 7612],
			"mapped",
			[656]
		],
		[
			[7613, 7613],
			"mapped",
			[657]
		],
		[
			[7614, 7614],
			"mapped",
			[658]
		],
		[
			[7615, 7615],
			"mapped",
			[952]
		],
		[[7616, 7619], "valid"],
		[[7620, 7626], "valid"],
		[[7627, 7654], "valid"],
		[[7655, 7669], "valid"],
		[[7670, 7675], "disallowed"],
		[[7676, 7676], "valid"],
		[[7677, 7677], "valid"],
		[[7678, 7679], "valid"],
		[
			[7680, 7680],
			"mapped",
			[7681]
		],
		[[7681, 7681], "valid"],
		[
			[7682, 7682],
			"mapped",
			[7683]
		],
		[[7683, 7683], "valid"],
		[
			[7684, 7684],
			"mapped",
			[7685]
		],
		[[7685, 7685], "valid"],
		[
			[7686, 7686],
			"mapped",
			[7687]
		],
		[[7687, 7687], "valid"],
		[
			[7688, 7688],
			"mapped",
			[7689]
		],
		[[7689, 7689], "valid"],
		[
			[7690, 7690],
			"mapped",
			[7691]
		],
		[[7691, 7691], "valid"],
		[
			[7692, 7692],
			"mapped",
			[7693]
		],
		[[7693, 7693], "valid"],
		[
			[7694, 7694],
			"mapped",
			[7695]
		],
		[[7695, 7695], "valid"],
		[
			[7696, 7696],
			"mapped",
			[7697]
		],
		[[7697, 7697], "valid"],
		[
			[7698, 7698],
			"mapped",
			[7699]
		],
		[[7699, 7699], "valid"],
		[
			[7700, 7700],
			"mapped",
			[7701]
		],
		[[7701, 7701], "valid"],
		[
			[7702, 7702],
			"mapped",
			[7703]
		],
		[[7703, 7703], "valid"],
		[
			[7704, 7704],
			"mapped",
			[7705]
		],
		[[7705, 7705], "valid"],
		[
			[7706, 7706],
			"mapped",
			[7707]
		],
		[[7707, 7707], "valid"],
		[
			[7708, 7708],
			"mapped",
			[7709]
		],
		[[7709, 7709], "valid"],
		[
			[7710, 7710],
			"mapped",
			[7711]
		],
		[[7711, 7711], "valid"],
		[
			[7712, 7712],
			"mapped",
			[7713]
		],
		[[7713, 7713], "valid"],
		[
			[7714, 7714],
			"mapped",
			[7715]
		],
		[[7715, 7715], "valid"],
		[
			[7716, 7716],
			"mapped",
			[7717]
		],
		[[7717, 7717], "valid"],
		[
			[7718, 7718],
			"mapped",
			[7719]
		],
		[[7719, 7719], "valid"],
		[
			[7720, 7720],
			"mapped",
			[7721]
		],
		[[7721, 7721], "valid"],
		[
			[7722, 7722],
			"mapped",
			[7723]
		],
		[[7723, 7723], "valid"],
		[
			[7724, 7724],
			"mapped",
			[7725]
		],
		[[7725, 7725], "valid"],
		[
			[7726, 7726],
			"mapped",
			[7727]
		],
		[[7727, 7727], "valid"],
		[
			[7728, 7728],
			"mapped",
			[7729]
		],
		[[7729, 7729], "valid"],
		[
			[7730, 7730],
			"mapped",
			[7731]
		],
		[[7731, 7731], "valid"],
		[
			[7732, 7732],
			"mapped",
			[7733]
		],
		[[7733, 7733], "valid"],
		[
			[7734, 7734],
			"mapped",
			[7735]
		],
		[[7735, 7735], "valid"],
		[
			[7736, 7736],
			"mapped",
			[7737]
		],
		[[7737, 7737], "valid"],
		[
			[7738, 7738],
			"mapped",
			[7739]
		],
		[[7739, 7739], "valid"],
		[
			[7740, 7740],
			"mapped",
			[7741]
		],
		[[7741, 7741], "valid"],
		[
			[7742, 7742],
			"mapped",
			[7743]
		],
		[[7743, 7743], "valid"],
		[
			[7744, 7744],
			"mapped",
			[7745]
		],
		[[7745, 7745], "valid"],
		[
			[7746, 7746],
			"mapped",
			[7747]
		],
		[[7747, 7747], "valid"],
		[
			[7748, 7748],
			"mapped",
			[7749]
		],
		[[7749, 7749], "valid"],
		[
			[7750, 7750],
			"mapped",
			[7751]
		],
		[[7751, 7751], "valid"],
		[
			[7752, 7752],
			"mapped",
			[7753]
		],
		[[7753, 7753], "valid"],
		[
			[7754, 7754],
			"mapped",
			[7755]
		],
		[[7755, 7755], "valid"],
		[
			[7756, 7756],
			"mapped",
			[7757]
		],
		[[7757, 7757], "valid"],
		[
			[7758, 7758],
			"mapped",
			[7759]
		],
		[[7759, 7759], "valid"],
		[
			[7760, 7760],
			"mapped",
			[7761]
		],
		[[7761, 7761], "valid"],
		[
			[7762, 7762],
			"mapped",
			[7763]
		],
		[[7763, 7763], "valid"],
		[
			[7764, 7764],
			"mapped",
			[7765]
		],
		[[7765, 7765], "valid"],
		[
			[7766, 7766],
			"mapped",
			[7767]
		],
		[[7767, 7767], "valid"],
		[
			[7768, 7768],
			"mapped",
			[7769]
		],
		[[7769, 7769], "valid"],
		[
			[7770, 7770],
			"mapped",
			[7771]
		],
		[[7771, 7771], "valid"],
		[
			[7772, 7772],
			"mapped",
			[7773]
		],
		[[7773, 7773], "valid"],
		[
			[7774, 7774],
			"mapped",
			[7775]
		],
		[[7775, 7775], "valid"],
		[
			[7776, 7776],
			"mapped",
			[7777]
		],
		[[7777, 7777], "valid"],
		[
			[7778, 7778],
			"mapped",
			[7779]
		],
		[[7779, 7779], "valid"],
		[
			[7780, 7780],
			"mapped",
			[7781]
		],
		[[7781, 7781], "valid"],
		[
			[7782, 7782],
			"mapped",
			[7783]
		],
		[[7783, 7783], "valid"],
		[
			[7784, 7784],
			"mapped",
			[7785]
		],
		[[7785, 7785], "valid"],
		[
			[7786, 7786],
			"mapped",
			[7787]
		],
		[[7787, 7787], "valid"],
		[
			[7788, 7788],
			"mapped",
			[7789]
		],
		[[7789, 7789], "valid"],
		[
			[7790, 7790],
			"mapped",
			[7791]
		],
		[[7791, 7791], "valid"],
		[
			[7792, 7792],
			"mapped",
			[7793]
		],
		[[7793, 7793], "valid"],
		[
			[7794, 7794],
			"mapped",
			[7795]
		],
		[[7795, 7795], "valid"],
		[
			[7796, 7796],
			"mapped",
			[7797]
		],
		[[7797, 7797], "valid"],
		[
			[7798, 7798],
			"mapped",
			[7799]
		],
		[[7799, 7799], "valid"],
		[
			[7800, 7800],
			"mapped",
			[7801]
		],
		[[7801, 7801], "valid"],
		[
			[7802, 7802],
			"mapped",
			[7803]
		],
		[[7803, 7803], "valid"],
		[
			[7804, 7804],
			"mapped",
			[7805]
		],
		[[7805, 7805], "valid"],
		[
			[7806, 7806],
			"mapped",
			[7807]
		],
		[[7807, 7807], "valid"],
		[
			[7808, 7808],
			"mapped",
			[7809]
		],
		[[7809, 7809], "valid"],
		[
			[7810, 7810],
			"mapped",
			[7811]
		],
		[[7811, 7811], "valid"],
		[
			[7812, 7812],
			"mapped",
			[7813]
		],
		[[7813, 7813], "valid"],
		[
			[7814, 7814],
			"mapped",
			[7815]
		],
		[[7815, 7815], "valid"],
		[
			[7816, 7816],
			"mapped",
			[7817]
		],
		[[7817, 7817], "valid"],
		[
			[7818, 7818],
			"mapped",
			[7819]
		],
		[[7819, 7819], "valid"],
		[
			[7820, 7820],
			"mapped",
			[7821]
		],
		[[7821, 7821], "valid"],
		[
			[7822, 7822],
			"mapped",
			[7823]
		],
		[[7823, 7823], "valid"],
		[
			[7824, 7824],
			"mapped",
			[7825]
		],
		[[7825, 7825], "valid"],
		[
			[7826, 7826],
			"mapped",
			[7827]
		],
		[[7827, 7827], "valid"],
		[
			[7828, 7828],
			"mapped",
			[7829]
		],
		[[7829, 7833], "valid"],
		[
			[7834, 7834],
			"mapped",
			[97, 702]
		],
		[
			[7835, 7835],
			"mapped",
			[7777]
		],
		[[7836, 7837], "valid"],
		[
			[7838, 7838],
			"mapped",
			[115, 115]
		],
		[[7839, 7839], "valid"],
		[
			[7840, 7840],
			"mapped",
			[7841]
		],
		[[7841, 7841], "valid"],
		[
			[7842, 7842],
			"mapped",
			[7843]
		],
		[[7843, 7843], "valid"],
		[
			[7844, 7844],
			"mapped",
			[7845]
		],
		[[7845, 7845], "valid"],
		[
			[7846, 7846],
			"mapped",
			[7847]
		],
		[[7847, 7847], "valid"],
		[
			[7848, 7848],
			"mapped",
			[7849]
		],
		[[7849, 7849], "valid"],
		[
			[7850, 7850],
			"mapped",
			[7851]
		],
		[[7851, 7851], "valid"],
		[
			[7852, 7852],
			"mapped",
			[7853]
		],
		[[7853, 7853], "valid"],
		[
			[7854, 7854],
			"mapped",
			[7855]
		],
		[[7855, 7855], "valid"],
		[
			[7856, 7856],
			"mapped",
			[7857]
		],
		[[7857, 7857], "valid"],
		[
			[7858, 7858],
			"mapped",
			[7859]
		],
		[[7859, 7859], "valid"],
		[
			[7860, 7860],
			"mapped",
			[7861]
		],
		[[7861, 7861], "valid"],
		[
			[7862, 7862],
			"mapped",
			[7863]
		],
		[[7863, 7863], "valid"],
		[
			[7864, 7864],
			"mapped",
			[7865]
		],
		[[7865, 7865], "valid"],
		[
			[7866, 7866],
			"mapped",
			[7867]
		],
		[[7867, 7867], "valid"],
		[
			[7868, 7868],
			"mapped",
			[7869]
		],
		[[7869, 7869], "valid"],
		[
			[7870, 7870],
			"mapped",
			[7871]
		],
		[[7871, 7871], "valid"],
		[
			[7872, 7872],
			"mapped",
			[7873]
		],
		[[7873, 7873], "valid"],
		[
			[7874, 7874],
			"mapped",
			[7875]
		],
		[[7875, 7875], "valid"],
		[
			[7876, 7876],
			"mapped",
			[7877]
		],
		[[7877, 7877], "valid"],
		[
			[7878, 7878],
			"mapped",
			[7879]
		],
		[[7879, 7879], "valid"],
		[
			[7880, 7880],
			"mapped",
			[7881]
		],
		[[7881, 7881], "valid"],
		[
			[7882, 7882],
			"mapped",
			[7883]
		],
		[[7883, 7883], "valid"],
		[
			[7884, 7884],
			"mapped",
			[7885]
		],
		[[7885, 7885], "valid"],
		[
			[7886, 7886],
			"mapped",
			[7887]
		],
		[[7887, 7887], "valid"],
		[
			[7888, 7888],
			"mapped",
			[7889]
		],
		[[7889, 7889], "valid"],
		[
			[7890, 7890],
			"mapped",
			[7891]
		],
		[[7891, 7891], "valid"],
		[
			[7892, 7892],
			"mapped",
			[7893]
		],
		[[7893, 7893], "valid"],
		[
			[7894, 7894],
			"mapped",
			[7895]
		],
		[[7895, 7895], "valid"],
		[
			[7896, 7896],
			"mapped",
			[7897]
		],
		[[7897, 7897], "valid"],
		[
			[7898, 7898],
			"mapped",
			[7899]
		],
		[[7899, 7899], "valid"],
		[
			[7900, 7900],
			"mapped",
			[7901]
		],
		[[7901, 7901], "valid"],
		[
			[7902, 7902],
			"mapped",
			[7903]
		],
		[[7903, 7903], "valid"],
		[
			[7904, 7904],
			"mapped",
			[7905]
		],
		[[7905, 7905], "valid"],
		[
			[7906, 7906],
			"mapped",
			[7907]
		],
		[[7907, 7907], "valid"],
		[
			[7908, 7908],
			"mapped",
			[7909]
		],
		[[7909, 7909], "valid"],
		[
			[7910, 7910],
			"mapped",
			[7911]
		],
		[[7911, 7911], "valid"],
		[
			[7912, 7912],
			"mapped",
			[7913]
		],
		[[7913, 7913], "valid"],
		[
			[7914, 7914],
			"mapped",
			[7915]
		],
		[[7915, 7915], "valid"],
		[
			[7916, 7916],
			"mapped",
			[7917]
		],
		[[7917, 7917], "valid"],
		[
			[7918, 7918],
			"mapped",
			[7919]
		],
		[[7919, 7919], "valid"],
		[
			[7920, 7920],
			"mapped",
			[7921]
		],
		[[7921, 7921], "valid"],
		[
			[7922, 7922],
			"mapped",
			[7923]
		],
		[[7923, 7923], "valid"],
		[
			[7924, 7924],
			"mapped",
			[7925]
		],
		[[7925, 7925], "valid"],
		[
			[7926, 7926],
			"mapped",
			[7927]
		],
		[[7927, 7927], "valid"],
		[
			[7928, 7928],
			"mapped",
			[7929]
		],
		[[7929, 7929], "valid"],
		[
			[7930, 7930],
			"mapped",
			[7931]
		],
		[[7931, 7931], "valid"],
		[
			[7932, 7932],
			"mapped",
			[7933]
		],
		[[7933, 7933], "valid"],
		[
			[7934, 7934],
			"mapped",
			[7935]
		],
		[[7935, 7935], "valid"],
		[[7936, 7943], "valid"],
		[
			[7944, 7944],
			"mapped",
			[7936]
		],
		[
			[7945, 7945],
			"mapped",
			[7937]
		],
		[
			[7946, 7946],
			"mapped",
			[7938]
		],
		[
			[7947, 7947],
			"mapped",
			[7939]
		],
		[
			[7948, 7948],
			"mapped",
			[7940]
		],
		[
			[7949, 7949],
			"mapped",
			[7941]
		],
		[
			[7950, 7950],
			"mapped",
			[7942]
		],
		[
			[7951, 7951],
			"mapped",
			[7943]
		],
		[[7952, 7957], "valid"],
		[[7958, 7959], "disallowed"],
		[
			[7960, 7960],
			"mapped",
			[7952]
		],
		[
			[7961, 7961],
			"mapped",
			[7953]
		],
		[
			[7962, 7962],
			"mapped",
			[7954]
		],
		[
			[7963, 7963],
			"mapped",
			[7955]
		],
		[
			[7964, 7964],
			"mapped",
			[7956]
		],
		[
			[7965, 7965],
			"mapped",
			[7957]
		],
		[[7966, 7967], "disallowed"],
		[[7968, 7975], "valid"],
		[
			[7976, 7976],
			"mapped",
			[7968]
		],
		[
			[7977, 7977],
			"mapped",
			[7969]
		],
		[
			[7978, 7978],
			"mapped",
			[7970]
		],
		[
			[7979, 7979],
			"mapped",
			[7971]
		],
		[
			[7980, 7980],
			"mapped",
			[7972]
		],
		[
			[7981, 7981],
			"mapped",
			[7973]
		],
		[
			[7982, 7982],
			"mapped",
			[7974]
		],
		[
			[7983, 7983],
			"mapped",
			[7975]
		],
		[[7984, 7991], "valid"],
		[
			[7992, 7992],
			"mapped",
			[7984]
		],
		[
			[7993, 7993],
			"mapped",
			[7985]
		],
		[
			[7994, 7994],
			"mapped",
			[7986]
		],
		[
			[7995, 7995],
			"mapped",
			[7987]
		],
		[
			[7996, 7996],
			"mapped",
			[7988]
		],
		[
			[7997, 7997],
			"mapped",
			[7989]
		],
		[
			[7998, 7998],
			"mapped",
			[7990]
		],
		[
			[7999, 7999],
			"mapped",
			[7991]
		],
		[[8e3, 8005], "valid"],
		[[8006, 8007], "disallowed"],
		[
			[8008, 8008],
			"mapped",
			[8e3]
		],
		[
			[8009, 8009],
			"mapped",
			[8001]
		],
		[
			[8010, 8010],
			"mapped",
			[8002]
		],
		[
			[8011, 8011],
			"mapped",
			[8003]
		],
		[
			[8012, 8012],
			"mapped",
			[8004]
		],
		[
			[8013, 8013],
			"mapped",
			[8005]
		],
		[[8014, 8015], "disallowed"],
		[[8016, 8023], "valid"],
		[[8024, 8024], "disallowed"],
		[
			[8025, 8025],
			"mapped",
			[8017]
		],
		[[8026, 8026], "disallowed"],
		[
			[8027, 8027],
			"mapped",
			[8019]
		],
		[[8028, 8028], "disallowed"],
		[
			[8029, 8029],
			"mapped",
			[8021]
		],
		[[8030, 8030], "disallowed"],
		[
			[8031, 8031],
			"mapped",
			[8023]
		],
		[[8032, 8039], "valid"],
		[
			[8040, 8040],
			"mapped",
			[8032]
		],
		[
			[8041, 8041],
			"mapped",
			[8033]
		],
		[
			[8042, 8042],
			"mapped",
			[8034]
		],
		[
			[8043, 8043],
			"mapped",
			[8035]
		],
		[
			[8044, 8044],
			"mapped",
			[8036]
		],
		[
			[8045, 8045],
			"mapped",
			[8037]
		],
		[
			[8046, 8046],
			"mapped",
			[8038]
		],
		[
			[8047, 8047],
			"mapped",
			[8039]
		],
		[[8048, 8048], "valid"],
		[
			[8049, 8049],
			"mapped",
			[940]
		],
		[[8050, 8050], "valid"],
		[
			[8051, 8051],
			"mapped",
			[941]
		],
		[[8052, 8052], "valid"],
		[
			[8053, 8053],
			"mapped",
			[942]
		],
		[[8054, 8054], "valid"],
		[
			[8055, 8055],
			"mapped",
			[943]
		],
		[[8056, 8056], "valid"],
		[
			[8057, 8057],
			"mapped",
			[972]
		],
		[[8058, 8058], "valid"],
		[
			[8059, 8059],
			"mapped",
			[973]
		],
		[[8060, 8060], "valid"],
		[
			[8061, 8061],
			"mapped",
			[974]
		],
		[[8062, 8063], "disallowed"],
		[
			[8064, 8064],
			"mapped",
			[7936, 953]
		],
		[
			[8065, 8065],
			"mapped",
			[7937, 953]
		],
		[
			[8066, 8066],
			"mapped",
			[7938, 953]
		],
		[
			[8067, 8067],
			"mapped",
			[7939, 953]
		],
		[
			[8068, 8068],
			"mapped",
			[7940, 953]
		],
		[
			[8069, 8069],
			"mapped",
			[7941, 953]
		],
		[
			[8070, 8070],
			"mapped",
			[7942, 953]
		],
		[
			[8071, 8071],
			"mapped",
			[7943, 953]
		],
		[
			[8072, 8072],
			"mapped",
			[7936, 953]
		],
		[
			[8073, 8073],
			"mapped",
			[7937, 953]
		],
		[
			[8074, 8074],
			"mapped",
			[7938, 953]
		],
		[
			[8075, 8075],
			"mapped",
			[7939, 953]
		],
		[
			[8076, 8076],
			"mapped",
			[7940, 953]
		],
		[
			[8077, 8077],
			"mapped",
			[7941, 953]
		],
		[
			[8078, 8078],
			"mapped",
			[7942, 953]
		],
		[
			[8079, 8079],
			"mapped",
			[7943, 953]
		],
		[
			[8080, 8080],
			"mapped",
			[7968, 953]
		],
		[
			[8081, 8081],
			"mapped",
			[7969, 953]
		],
		[
			[8082, 8082],
			"mapped",
			[7970, 953]
		],
		[
			[8083, 8083],
			"mapped",
			[7971, 953]
		],
		[
			[8084, 8084],
			"mapped",
			[7972, 953]
		],
		[
			[8085, 8085],
			"mapped",
			[7973, 953]
		],
		[
			[8086, 8086],
			"mapped",
			[7974, 953]
		],
		[
			[8087, 8087],
			"mapped",
			[7975, 953]
		],
		[
			[8088, 8088],
			"mapped",
			[7968, 953]
		],
		[
			[8089, 8089],
			"mapped",
			[7969, 953]
		],
		[
			[8090, 8090],
			"mapped",
			[7970, 953]
		],
		[
			[8091, 8091],
			"mapped",
			[7971, 953]
		],
		[
			[8092, 8092],
			"mapped",
			[7972, 953]
		],
		[
			[8093, 8093],
			"mapped",
			[7973, 953]
		],
		[
			[8094, 8094],
			"mapped",
			[7974, 953]
		],
		[
			[8095, 8095],
			"mapped",
			[7975, 953]
		],
		[
			[8096, 8096],
			"mapped",
			[8032, 953]
		],
		[
			[8097, 8097],
			"mapped",
			[8033, 953]
		],
		[
			[8098, 8098],
			"mapped",
			[8034, 953]
		],
		[
			[8099, 8099],
			"mapped",
			[8035, 953]
		],
		[
			[8100, 8100],
			"mapped",
			[8036, 953]
		],
		[
			[8101, 8101],
			"mapped",
			[8037, 953]
		],
		[
			[8102, 8102],
			"mapped",
			[8038, 953]
		],
		[
			[8103, 8103],
			"mapped",
			[8039, 953]
		],
		[
			[8104, 8104],
			"mapped",
			[8032, 953]
		],
		[
			[8105, 8105],
			"mapped",
			[8033, 953]
		],
		[
			[8106, 8106],
			"mapped",
			[8034, 953]
		],
		[
			[8107, 8107],
			"mapped",
			[8035, 953]
		],
		[
			[8108, 8108],
			"mapped",
			[8036, 953]
		],
		[
			[8109, 8109],
			"mapped",
			[8037, 953]
		],
		[
			[8110, 8110],
			"mapped",
			[8038, 953]
		],
		[
			[8111, 8111],
			"mapped",
			[8039, 953]
		],
		[[8112, 8113], "valid"],
		[
			[8114, 8114],
			"mapped",
			[8048, 953]
		],
		[
			[8115, 8115],
			"mapped",
			[945, 953]
		],
		[
			[8116, 8116],
			"mapped",
			[940, 953]
		],
		[[8117, 8117], "disallowed"],
		[[8118, 8118], "valid"],
		[
			[8119, 8119],
			"mapped",
			[8118, 953]
		],
		[
			[8120, 8120],
			"mapped",
			[8112]
		],
		[
			[8121, 8121],
			"mapped",
			[8113]
		],
		[
			[8122, 8122],
			"mapped",
			[8048]
		],
		[
			[8123, 8123],
			"mapped",
			[940]
		],
		[
			[8124, 8124],
			"mapped",
			[945, 953]
		],
		[
			[8125, 8125],
			"disallowed_STD3_mapped",
			[32, 787]
		],
		[
			[8126, 8126],
			"mapped",
			[953]
		],
		[
			[8127, 8127],
			"disallowed_STD3_mapped",
			[32, 787]
		],
		[
			[8128, 8128],
			"disallowed_STD3_mapped",
			[32, 834]
		],
		[
			[8129, 8129],
			"disallowed_STD3_mapped",
			[
				32,
				776,
				834
			]
		],
		[
			[8130, 8130],
			"mapped",
			[8052, 953]
		],
		[
			[8131, 8131],
			"mapped",
			[951, 953]
		],
		[
			[8132, 8132],
			"mapped",
			[942, 953]
		],
		[[8133, 8133], "disallowed"],
		[[8134, 8134], "valid"],
		[
			[8135, 8135],
			"mapped",
			[8134, 953]
		],
		[
			[8136, 8136],
			"mapped",
			[8050]
		],
		[
			[8137, 8137],
			"mapped",
			[941]
		],
		[
			[8138, 8138],
			"mapped",
			[8052]
		],
		[
			[8139, 8139],
			"mapped",
			[942]
		],
		[
			[8140, 8140],
			"mapped",
			[951, 953]
		],
		[
			[8141, 8141],
			"disallowed_STD3_mapped",
			[
				32,
				787,
				768
			]
		],
		[
			[8142, 8142],
			"disallowed_STD3_mapped",
			[
				32,
				787,
				769
			]
		],
		[
			[8143, 8143],
			"disallowed_STD3_mapped",
			[
				32,
				787,
				834
			]
		],
		[[8144, 8146], "valid"],
		[
			[8147, 8147],
			"mapped",
			[912]
		],
		[[8148, 8149], "disallowed"],
		[[8150, 8151], "valid"],
		[
			[8152, 8152],
			"mapped",
			[8144]
		],
		[
			[8153, 8153],
			"mapped",
			[8145]
		],
		[
			[8154, 8154],
			"mapped",
			[8054]
		],
		[
			[8155, 8155],
			"mapped",
			[943]
		],
		[[8156, 8156], "disallowed"],
		[
			[8157, 8157],
			"disallowed_STD3_mapped",
			[
				32,
				788,
				768
			]
		],
		[
			[8158, 8158],
			"disallowed_STD3_mapped",
			[
				32,
				788,
				769
			]
		],
		[
			[8159, 8159],
			"disallowed_STD3_mapped",
			[
				32,
				788,
				834
			]
		],
		[[8160, 8162], "valid"],
		[
			[8163, 8163],
			"mapped",
			[944]
		],
		[[8164, 8167], "valid"],
		[
			[8168, 8168],
			"mapped",
			[8160]
		],
		[
			[8169, 8169],
			"mapped",
			[8161]
		],
		[
			[8170, 8170],
			"mapped",
			[8058]
		],
		[
			[8171, 8171],
			"mapped",
			[973]
		],
		[
			[8172, 8172],
			"mapped",
			[8165]
		],
		[
			[8173, 8173],
			"disallowed_STD3_mapped",
			[
				32,
				776,
				768
			]
		],
		[
			[8174, 8174],
			"disallowed_STD3_mapped",
			[
				32,
				776,
				769
			]
		],
		[
			[8175, 8175],
			"disallowed_STD3_mapped",
			[96]
		],
		[[8176, 8177], "disallowed"],
		[
			[8178, 8178],
			"mapped",
			[8060, 953]
		],
		[
			[8179, 8179],
			"mapped",
			[969, 953]
		],
		[
			[8180, 8180],
			"mapped",
			[974, 953]
		],
		[[8181, 8181], "disallowed"],
		[[8182, 8182], "valid"],
		[
			[8183, 8183],
			"mapped",
			[8182, 953]
		],
		[
			[8184, 8184],
			"mapped",
			[8056]
		],
		[
			[8185, 8185],
			"mapped",
			[972]
		],
		[
			[8186, 8186],
			"mapped",
			[8060]
		],
		[
			[8187, 8187],
			"mapped",
			[974]
		],
		[
			[8188, 8188],
			"mapped",
			[969, 953]
		],
		[
			[8189, 8189],
			"disallowed_STD3_mapped",
			[32, 769]
		],
		[
			[8190, 8190],
			"disallowed_STD3_mapped",
			[32, 788]
		],
		[[8191, 8191], "disallowed"],
		[
			[8192, 8202],
			"disallowed_STD3_mapped",
			[32]
		],
		[[8203, 8203], "ignored"],
		[
			[8204, 8205],
			"deviation",
			[]
		],
		[[8206, 8207], "disallowed"],
		[
			[8208, 8208],
			"valid",
			[],
			"NV8"
		],
		[
			[8209, 8209],
			"mapped",
			[8208]
		],
		[
			[8210, 8214],
			"valid",
			[],
			"NV8"
		],
		[
			[8215, 8215],
			"disallowed_STD3_mapped",
			[32, 819]
		],
		[
			[8216, 8227],
			"valid",
			[],
			"NV8"
		],
		[[8228, 8230], "disallowed"],
		[
			[8231, 8231],
			"valid",
			[],
			"NV8"
		],
		[[8232, 8238], "disallowed"],
		[
			[8239, 8239],
			"disallowed_STD3_mapped",
			[32]
		],
		[
			[8240, 8242],
			"valid",
			[],
			"NV8"
		],
		[
			[8243, 8243],
			"mapped",
			[8242, 8242]
		],
		[
			[8244, 8244],
			"mapped",
			[
				8242,
				8242,
				8242
			]
		],
		[
			[8245, 8245],
			"valid",
			[],
			"NV8"
		],
		[
			[8246, 8246],
			"mapped",
			[8245, 8245]
		],
		[
			[8247, 8247],
			"mapped",
			[
				8245,
				8245,
				8245
			]
		],
		[
			[8248, 8251],
			"valid",
			[],
			"NV8"
		],
		[
			[8252, 8252],
			"disallowed_STD3_mapped",
			[33, 33]
		],
		[
			[8253, 8253],
			"valid",
			[],
			"NV8"
		],
		[
			[8254, 8254],
			"disallowed_STD3_mapped",
			[32, 773]
		],
		[
			[8255, 8262],
			"valid",
			[],
			"NV8"
		],
		[
			[8263, 8263],
			"disallowed_STD3_mapped",
			[63, 63]
		],
		[
			[8264, 8264],
			"disallowed_STD3_mapped",
			[63, 33]
		],
		[
			[8265, 8265],
			"disallowed_STD3_mapped",
			[33, 63]
		],
		[
			[8266, 8269],
			"valid",
			[],
			"NV8"
		],
		[
			[8270, 8274],
			"valid",
			[],
			"NV8"
		],
		[
			[8275, 8276],
			"valid",
			[],
			"NV8"
		],
		[
			[8277, 8278],
			"valid",
			[],
			"NV8"
		],
		[
			[8279, 8279],
			"mapped",
			[
				8242,
				8242,
				8242,
				8242
			]
		],
		[
			[8280, 8286],
			"valid",
			[],
			"NV8"
		],
		[
			[8287, 8287],
			"disallowed_STD3_mapped",
			[32]
		],
		[[8288, 8288], "ignored"],
		[[8289, 8291], "disallowed"],
		[[8292, 8292], "ignored"],
		[[8293, 8293], "disallowed"],
		[[8294, 8297], "disallowed"],
		[[8298, 8303], "disallowed"],
		[
			[8304, 8304],
			"mapped",
			[48]
		],
		[
			[8305, 8305],
			"mapped",
			[105]
		],
		[[8306, 8307], "disallowed"],
		[
			[8308, 8308],
			"mapped",
			[52]
		],
		[
			[8309, 8309],
			"mapped",
			[53]
		],
		[
			[8310, 8310],
			"mapped",
			[54]
		],
		[
			[8311, 8311],
			"mapped",
			[55]
		],
		[
			[8312, 8312],
			"mapped",
			[56]
		],
		[
			[8313, 8313],
			"mapped",
			[57]
		],
		[
			[8314, 8314],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[8315, 8315],
			"mapped",
			[8722]
		],
		[
			[8316, 8316],
			"disallowed_STD3_mapped",
			[61]
		],
		[
			[8317, 8317],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[8318, 8318],
			"disallowed_STD3_mapped",
			[41]
		],
		[
			[8319, 8319],
			"mapped",
			[110]
		],
		[
			[8320, 8320],
			"mapped",
			[48]
		],
		[
			[8321, 8321],
			"mapped",
			[49]
		],
		[
			[8322, 8322],
			"mapped",
			[50]
		],
		[
			[8323, 8323],
			"mapped",
			[51]
		],
		[
			[8324, 8324],
			"mapped",
			[52]
		],
		[
			[8325, 8325],
			"mapped",
			[53]
		],
		[
			[8326, 8326],
			"mapped",
			[54]
		],
		[
			[8327, 8327],
			"mapped",
			[55]
		],
		[
			[8328, 8328],
			"mapped",
			[56]
		],
		[
			[8329, 8329],
			"mapped",
			[57]
		],
		[
			[8330, 8330],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[8331, 8331],
			"mapped",
			[8722]
		],
		[
			[8332, 8332],
			"disallowed_STD3_mapped",
			[61]
		],
		[
			[8333, 8333],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[8334, 8334],
			"disallowed_STD3_mapped",
			[41]
		],
		[[8335, 8335], "disallowed"],
		[
			[8336, 8336],
			"mapped",
			[97]
		],
		[
			[8337, 8337],
			"mapped",
			[101]
		],
		[
			[8338, 8338],
			"mapped",
			[111]
		],
		[
			[8339, 8339],
			"mapped",
			[120]
		],
		[
			[8340, 8340],
			"mapped",
			[601]
		],
		[
			[8341, 8341],
			"mapped",
			[104]
		],
		[
			[8342, 8342],
			"mapped",
			[107]
		],
		[
			[8343, 8343],
			"mapped",
			[108]
		],
		[
			[8344, 8344],
			"mapped",
			[109]
		],
		[
			[8345, 8345],
			"mapped",
			[110]
		],
		[
			[8346, 8346],
			"mapped",
			[112]
		],
		[
			[8347, 8347],
			"mapped",
			[115]
		],
		[
			[8348, 8348],
			"mapped",
			[116]
		],
		[[8349, 8351], "disallowed"],
		[
			[8352, 8359],
			"valid",
			[],
			"NV8"
		],
		[
			[8360, 8360],
			"mapped",
			[114, 115]
		],
		[
			[8361, 8362],
			"valid",
			[],
			"NV8"
		],
		[
			[8363, 8363],
			"valid",
			[],
			"NV8"
		],
		[
			[8364, 8364],
			"valid",
			[],
			"NV8"
		],
		[
			[8365, 8367],
			"valid",
			[],
			"NV8"
		],
		[
			[8368, 8369],
			"valid",
			[],
			"NV8"
		],
		[
			[8370, 8373],
			"valid",
			[],
			"NV8"
		],
		[
			[8374, 8376],
			"valid",
			[],
			"NV8"
		],
		[
			[8377, 8377],
			"valid",
			[],
			"NV8"
		],
		[
			[8378, 8378],
			"valid",
			[],
			"NV8"
		],
		[
			[8379, 8381],
			"valid",
			[],
			"NV8"
		],
		[
			[8382, 8382],
			"valid",
			[],
			"NV8"
		],
		[[8383, 8399], "disallowed"],
		[
			[8400, 8417],
			"valid",
			[],
			"NV8"
		],
		[
			[8418, 8419],
			"valid",
			[],
			"NV8"
		],
		[
			[8420, 8426],
			"valid",
			[],
			"NV8"
		],
		[
			[8427, 8427],
			"valid",
			[],
			"NV8"
		],
		[
			[8428, 8431],
			"valid",
			[],
			"NV8"
		],
		[
			[8432, 8432],
			"valid",
			[],
			"NV8"
		],
		[[8433, 8447], "disallowed"],
		[
			[8448, 8448],
			"disallowed_STD3_mapped",
			[
				97,
				47,
				99
			]
		],
		[
			[8449, 8449],
			"disallowed_STD3_mapped",
			[
				97,
				47,
				115
			]
		],
		[
			[8450, 8450],
			"mapped",
			[99]
		],
		[
			[8451, 8451],
			"mapped",
			[176, 99]
		],
		[
			[8452, 8452],
			"valid",
			[],
			"NV8"
		],
		[
			[8453, 8453],
			"disallowed_STD3_mapped",
			[
				99,
				47,
				111
			]
		],
		[
			[8454, 8454],
			"disallowed_STD3_mapped",
			[
				99,
				47,
				117
			]
		],
		[
			[8455, 8455],
			"mapped",
			[603]
		],
		[
			[8456, 8456],
			"valid",
			[],
			"NV8"
		],
		[
			[8457, 8457],
			"mapped",
			[176, 102]
		],
		[
			[8458, 8458],
			"mapped",
			[103]
		],
		[
			[8459, 8462],
			"mapped",
			[104]
		],
		[
			[8463, 8463],
			"mapped",
			[295]
		],
		[
			[8464, 8465],
			"mapped",
			[105]
		],
		[
			[8466, 8467],
			"mapped",
			[108]
		],
		[
			[8468, 8468],
			"valid",
			[],
			"NV8"
		],
		[
			[8469, 8469],
			"mapped",
			[110]
		],
		[
			[8470, 8470],
			"mapped",
			[110, 111]
		],
		[
			[8471, 8472],
			"valid",
			[],
			"NV8"
		],
		[
			[8473, 8473],
			"mapped",
			[112]
		],
		[
			[8474, 8474],
			"mapped",
			[113]
		],
		[
			[8475, 8477],
			"mapped",
			[114]
		],
		[
			[8478, 8479],
			"valid",
			[],
			"NV8"
		],
		[
			[8480, 8480],
			"mapped",
			[115, 109]
		],
		[
			[8481, 8481],
			"mapped",
			[
				116,
				101,
				108
			]
		],
		[
			[8482, 8482],
			"mapped",
			[116, 109]
		],
		[
			[8483, 8483],
			"valid",
			[],
			"NV8"
		],
		[
			[8484, 8484],
			"mapped",
			[122]
		],
		[
			[8485, 8485],
			"valid",
			[],
			"NV8"
		],
		[
			[8486, 8486],
			"mapped",
			[969]
		],
		[
			[8487, 8487],
			"valid",
			[],
			"NV8"
		],
		[
			[8488, 8488],
			"mapped",
			[122]
		],
		[
			[8489, 8489],
			"valid",
			[],
			"NV8"
		],
		[
			[8490, 8490],
			"mapped",
			[107]
		],
		[
			[8491, 8491],
			"mapped",
			[229]
		],
		[
			[8492, 8492],
			"mapped",
			[98]
		],
		[
			[8493, 8493],
			"mapped",
			[99]
		],
		[
			[8494, 8494],
			"valid",
			[],
			"NV8"
		],
		[
			[8495, 8496],
			"mapped",
			[101]
		],
		[
			[8497, 8497],
			"mapped",
			[102]
		],
		[[8498, 8498], "disallowed"],
		[
			[8499, 8499],
			"mapped",
			[109]
		],
		[
			[8500, 8500],
			"mapped",
			[111]
		],
		[
			[8501, 8501],
			"mapped",
			[1488]
		],
		[
			[8502, 8502],
			"mapped",
			[1489]
		],
		[
			[8503, 8503],
			"mapped",
			[1490]
		],
		[
			[8504, 8504],
			"mapped",
			[1491]
		],
		[
			[8505, 8505],
			"mapped",
			[105]
		],
		[
			[8506, 8506],
			"valid",
			[],
			"NV8"
		],
		[
			[8507, 8507],
			"mapped",
			[
				102,
				97,
				120
			]
		],
		[
			[8508, 8508],
			"mapped",
			[960]
		],
		[
			[8509, 8510],
			"mapped",
			[947]
		],
		[
			[8511, 8511],
			"mapped",
			[960]
		],
		[
			[8512, 8512],
			"mapped",
			[8721]
		],
		[
			[8513, 8516],
			"valid",
			[],
			"NV8"
		],
		[
			[8517, 8518],
			"mapped",
			[100]
		],
		[
			[8519, 8519],
			"mapped",
			[101]
		],
		[
			[8520, 8520],
			"mapped",
			[105]
		],
		[
			[8521, 8521],
			"mapped",
			[106]
		],
		[
			[8522, 8523],
			"valid",
			[],
			"NV8"
		],
		[
			[8524, 8524],
			"valid",
			[],
			"NV8"
		],
		[
			[8525, 8525],
			"valid",
			[],
			"NV8"
		],
		[[8526, 8526], "valid"],
		[
			[8527, 8527],
			"valid",
			[],
			"NV8"
		],
		[
			[8528, 8528],
			"mapped",
			[
				49,
				8260,
				55
			]
		],
		[
			[8529, 8529],
			"mapped",
			[
				49,
				8260,
				57
			]
		],
		[
			[8530, 8530],
			"mapped",
			[
				49,
				8260,
				49,
				48
			]
		],
		[
			[8531, 8531],
			"mapped",
			[
				49,
				8260,
				51
			]
		],
		[
			[8532, 8532],
			"mapped",
			[
				50,
				8260,
				51
			]
		],
		[
			[8533, 8533],
			"mapped",
			[
				49,
				8260,
				53
			]
		],
		[
			[8534, 8534],
			"mapped",
			[
				50,
				8260,
				53
			]
		],
		[
			[8535, 8535],
			"mapped",
			[
				51,
				8260,
				53
			]
		],
		[
			[8536, 8536],
			"mapped",
			[
				52,
				8260,
				53
			]
		],
		[
			[8537, 8537],
			"mapped",
			[
				49,
				8260,
				54
			]
		],
		[
			[8538, 8538],
			"mapped",
			[
				53,
				8260,
				54
			]
		],
		[
			[8539, 8539],
			"mapped",
			[
				49,
				8260,
				56
			]
		],
		[
			[8540, 8540],
			"mapped",
			[
				51,
				8260,
				56
			]
		],
		[
			[8541, 8541],
			"mapped",
			[
				53,
				8260,
				56
			]
		],
		[
			[8542, 8542],
			"mapped",
			[
				55,
				8260,
				56
			]
		],
		[
			[8543, 8543],
			"mapped",
			[49, 8260]
		],
		[
			[8544, 8544],
			"mapped",
			[105]
		],
		[
			[8545, 8545],
			"mapped",
			[105, 105]
		],
		[
			[8546, 8546],
			"mapped",
			[
				105,
				105,
				105
			]
		],
		[
			[8547, 8547],
			"mapped",
			[105, 118]
		],
		[
			[8548, 8548],
			"mapped",
			[118]
		],
		[
			[8549, 8549],
			"mapped",
			[118, 105]
		],
		[
			[8550, 8550],
			"mapped",
			[
				118,
				105,
				105
			]
		],
		[
			[8551, 8551],
			"mapped",
			[
				118,
				105,
				105,
				105
			]
		],
		[
			[8552, 8552],
			"mapped",
			[105, 120]
		],
		[
			[8553, 8553],
			"mapped",
			[120]
		],
		[
			[8554, 8554],
			"mapped",
			[120, 105]
		],
		[
			[8555, 8555],
			"mapped",
			[
				120,
				105,
				105
			]
		],
		[
			[8556, 8556],
			"mapped",
			[108]
		],
		[
			[8557, 8557],
			"mapped",
			[99]
		],
		[
			[8558, 8558],
			"mapped",
			[100]
		],
		[
			[8559, 8559],
			"mapped",
			[109]
		],
		[
			[8560, 8560],
			"mapped",
			[105]
		],
		[
			[8561, 8561],
			"mapped",
			[105, 105]
		],
		[
			[8562, 8562],
			"mapped",
			[
				105,
				105,
				105
			]
		],
		[
			[8563, 8563],
			"mapped",
			[105, 118]
		],
		[
			[8564, 8564],
			"mapped",
			[118]
		],
		[
			[8565, 8565],
			"mapped",
			[118, 105]
		],
		[
			[8566, 8566],
			"mapped",
			[
				118,
				105,
				105
			]
		],
		[
			[8567, 8567],
			"mapped",
			[
				118,
				105,
				105,
				105
			]
		],
		[
			[8568, 8568],
			"mapped",
			[105, 120]
		],
		[
			[8569, 8569],
			"mapped",
			[120]
		],
		[
			[8570, 8570],
			"mapped",
			[120, 105]
		],
		[
			[8571, 8571],
			"mapped",
			[
				120,
				105,
				105
			]
		],
		[
			[8572, 8572],
			"mapped",
			[108]
		],
		[
			[8573, 8573],
			"mapped",
			[99]
		],
		[
			[8574, 8574],
			"mapped",
			[100]
		],
		[
			[8575, 8575],
			"mapped",
			[109]
		],
		[
			[8576, 8578],
			"valid",
			[],
			"NV8"
		],
		[[8579, 8579], "disallowed"],
		[[8580, 8580], "valid"],
		[
			[8581, 8584],
			"valid",
			[],
			"NV8"
		],
		[
			[8585, 8585],
			"mapped",
			[
				48,
				8260,
				51
			]
		],
		[
			[8586, 8587],
			"valid",
			[],
			"NV8"
		],
		[[8588, 8591], "disallowed"],
		[
			[8592, 8682],
			"valid",
			[],
			"NV8"
		],
		[
			[8683, 8691],
			"valid",
			[],
			"NV8"
		],
		[
			[8692, 8703],
			"valid",
			[],
			"NV8"
		],
		[
			[8704, 8747],
			"valid",
			[],
			"NV8"
		],
		[
			[8748, 8748],
			"mapped",
			[8747, 8747]
		],
		[
			[8749, 8749],
			"mapped",
			[
				8747,
				8747,
				8747
			]
		],
		[
			[8750, 8750],
			"valid",
			[],
			"NV8"
		],
		[
			[8751, 8751],
			"mapped",
			[8750, 8750]
		],
		[
			[8752, 8752],
			"mapped",
			[
				8750,
				8750,
				8750
			]
		],
		[
			[8753, 8799],
			"valid",
			[],
			"NV8"
		],
		[[8800, 8800], "disallowed_STD3_valid"],
		[
			[8801, 8813],
			"valid",
			[],
			"NV8"
		],
		[[8814, 8815], "disallowed_STD3_valid"],
		[
			[8816, 8945],
			"valid",
			[],
			"NV8"
		],
		[
			[8946, 8959],
			"valid",
			[],
			"NV8"
		],
		[
			[8960, 8960],
			"valid",
			[],
			"NV8"
		],
		[
			[8961, 8961],
			"valid",
			[],
			"NV8"
		],
		[
			[8962, 9e3],
			"valid",
			[],
			"NV8"
		],
		[
			[9001, 9001],
			"mapped",
			[12296]
		],
		[
			[9002, 9002],
			"mapped",
			[12297]
		],
		[
			[9003, 9082],
			"valid",
			[],
			"NV8"
		],
		[
			[9083, 9083],
			"valid",
			[],
			"NV8"
		],
		[
			[9084, 9084],
			"valid",
			[],
			"NV8"
		],
		[
			[9085, 9114],
			"valid",
			[],
			"NV8"
		],
		[
			[9115, 9166],
			"valid",
			[],
			"NV8"
		],
		[
			[9167, 9168],
			"valid",
			[],
			"NV8"
		],
		[
			[9169, 9179],
			"valid",
			[],
			"NV8"
		],
		[
			[9180, 9191],
			"valid",
			[],
			"NV8"
		],
		[
			[9192, 9192],
			"valid",
			[],
			"NV8"
		],
		[
			[9193, 9203],
			"valid",
			[],
			"NV8"
		],
		[
			[9204, 9210],
			"valid",
			[],
			"NV8"
		],
		[[9211, 9215], "disallowed"],
		[
			[9216, 9252],
			"valid",
			[],
			"NV8"
		],
		[
			[9253, 9254],
			"valid",
			[],
			"NV8"
		],
		[[9255, 9279], "disallowed"],
		[
			[9280, 9290],
			"valid",
			[],
			"NV8"
		],
		[[9291, 9311], "disallowed"],
		[
			[9312, 9312],
			"mapped",
			[49]
		],
		[
			[9313, 9313],
			"mapped",
			[50]
		],
		[
			[9314, 9314],
			"mapped",
			[51]
		],
		[
			[9315, 9315],
			"mapped",
			[52]
		],
		[
			[9316, 9316],
			"mapped",
			[53]
		],
		[
			[9317, 9317],
			"mapped",
			[54]
		],
		[
			[9318, 9318],
			"mapped",
			[55]
		],
		[
			[9319, 9319],
			"mapped",
			[56]
		],
		[
			[9320, 9320],
			"mapped",
			[57]
		],
		[
			[9321, 9321],
			"mapped",
			[49, 48]
		],
		[
			[9322, 9322],
			"mapped",
			[49, 49]
		],
		[
			[9323, 9323],
			"mapped",
			[49, 50]
		],
		[
			[9324, 9324],
			"mapped",
			[49, 51]
		],
		[
			[9325, 9325],
			"mapped",
			[49, 52]
		],
		[
			[9326, 9326],
			"mapped",
			[49, 53]
		],
		[
			[9327, 9327],
			"mapped",
			[49, 54]
		],
		[
			[9328, 9328],
			"mapped",
			[49, 55]
		],
		[
			[9329, 9329],
			"mapped",
			[49, 56]
		],
		[
			[9330, 9330],
			"mapped",
			[49, 57]
		],
		[
			[9331, 9331],
			"mapped",
			[50, 48]
		],
		[
			[9332, 9332],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				41
			]
		],
		[
			[9333, 9333],
			"disallowed_STD3_mapped",
			[
				40,
				50,
				41
			]
		],
		[
			[9334, 9334],
			"disallowed_STD3_mapped",
			[
				40,
				51,
				41
			]
		],
		[
			[9335, 9335],
			"disallowed_STD3_mapped",
			[
				40,
				52,
				41
			]
		],
		[
			[9336, 9336],
			"disallowed_STD3_mapped",
			[
				40,
				53,
				41
			]
		],
		[
			[9337, 9337],
			"disallowed_STD3_mapped",
			[
				40,
				54,
				41
			]
		],
		[
			[9338, 9338],
			"disallowed_STD3_mapped",
			[
				40,
				55,
				41
			]
		],
		[
			[9339, 9339],
			"disallowed_STD3_mapped",
			[
				40,
				56,
				41
			]
		],
		[
			[9340, 9340],
			"disallowed_STD3_mapped",
			[
				40,
				57,
				41
			]
		],
		[
			[9341, 9341],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				48,
				41
			]
		],
		[
			[9342, 9342],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				49,
				41
			]
		],
		[
			[9343, 9343],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				50,
				41
			]
		],
		[
			[9344, 9344],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				51,
				41
			]
		],
		[
			[9345, 9345],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				52,
				41
			]
		],
		[
			[9346, 9346],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				53,
				41
			]
		],
		[
			[9347, 9347],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				54,
				41
			]
		],
		[
			[9348, 9348],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				55,
				41
			]
		],
		[
			[9349, 9349],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				56,
				41
			]
		],
		[
			[9350, 9350],
			"disallowed_STD3_mapped",
			[
				40,
				49,
				57,
				41
			]
		],
		[
			[9351, 9351],
			"disallowed_STD3_mapped",
			[
				40,
				50,
				48,
				41
			]
		],
		[[9352, 9371], "disallowed"],
		[
			[9372, 9372],
			"disallowed_STD3_mapped",
			[
				40,
				97,
				41
			]
		],
		[
			[9373, 9373],
			"disallowed_STD3_mapped",
			[
				40,
				98,
				41
			]
		],
		[
			[9374, 9374],
			"disallowed_STD3_mapped",
			[
				40,
				99,
				41
			]
		],
		[
			[9375, 9375],
			"disallowed_STD3_mapped",
			[
				40,
				100,
				41
			]
		],
		[
			[9376, 9376],
			"disallowed_STD3_mapped",
			[
				40,
				101,
				41
			]
		],
		[
			[9377, 9377],
			"disallowed_STD3_mapped",
			[
				40,
				102,
				41
			]
		],
		[
			[9378, 9378],
			"disallowed_STD3_mapped",
			[
				40,
				103,
				41
			]
		],
		[
			[9379, 9379],
			"disallowed_STD3_mapped",
			[
				40,
				104,
				41
			]
		],
		[
			[9380, 9380],
			"disallowed_STD3_mapped",
			[
				40,
				105,
				41
			]
		],
		[
			[9381, 9381],
			"disallowed_STD3_mapped",
			[
				40,
				106,
				41
			]
		],
		[
			[9382, 9382],
			"disallowed_STD3_mapped",
			[
				40,
				107,
				41
			]
		],
		[
			[9383, 9383],
			"disallowed_STD3_mapped",
			[
				40,
				108,
				41
			]
		],
		[
			[9384, 9384],
			"disallowed_STD3_mapped",
			[
				40,
				109,
				41
			]
		],
		[
			[9385, 9385],
			"disallowed_STD3_mapped",
			[
				40,
				110,
				41
			]
		],
		[
			[9386, 9386],
			"disallowed_STD3_mapped",
			[
				40,
				111,
				41
			]
		],
		[
			[9387, 9387],
			"disallowed_STD3_mapped",
			[
				40,
				112,
				41
			]
		],
		[
			[9388, 9388],
			"disallowed_STD3_mapped",
			[
				40,
				113,
				41
			]
		],
		[
			[9389, 9389],
			"disallowed_STD3_mapped",
			[
				40,
				114,
				41
			]
		],
		[
			[9390, 9390],
			"disallowed_STD3_mapped",
			[
				40,
				115,
				41
			]
		],
		[
			[9391, 9391],
			"disallowed_STD3_mapped",
			[
				40,
				116,
				41
			]
		],
		[
			[9392, 9392],
			"disallowed_STD3_mapped",
			[
				40,
				117,
				41
			]
		],
		[
			[9393, 9393],
			"disallowed_STD3_mapped",
			[
				40,
				118,
				41
			]
		],
		[
			[9394, 9394],
			"disallowed_STD3_mapped",
			[
				40,
				119,
				41
			]
		],
		[
			[9395, 9395],
			"disallowed_STD3_mapped",
			[
				40,
				120,
				41
			]
		],
		[
			[9396, 9396],
			"disallowed_STD3_mapped",
			[
				40,
				121,
				41
			]
		],
		[
			[9397, 9397],
			"disallowed_STD3_mapped",
			[
				40,
				122,
				41
			]
		],
		[
			[9398, 9398],
			"mapped",
			[97]
		],
		[
			[9399, 9399],
			"mapped",
			[98]
		],
		[
			[9400, 9400],
			"mapped",
			[99]
		],
		[
			[9401, 9401],
			"mapped",
			[100]
		],
		[
			[9402, 9402],
			"mapped",
			[101]
		],
		[
			[9403, 9403],
			"mapped",
			[102]
		],
		[
			[9404, 9404],
			"mapped",
			[103]
		],
		[
			[9405, 9405],
			"mapped",
			[104]
		],
		[
			[9406, 9406],
			"mapped",
			[105]
		],
		[
			[9407, 9407],
			"mapped",
			[106]
		],
		[
			[9408, 9408],
			"mapped",
			[107]
		],
		[
			[9409, 9409],
			"mapped",
			[108]
		],
		[
			[9410, 9410],
			"mapped",
			[109]
		],
		[
			[9411, 9411],
			"mapped",
			[110]
		],
		[
			[9412, 9412],
			"mapped",
			[111]
		],
		[
			[9413, 9413],
			"mapped",
			[112]
		],
		[
			[9414, 9414],
			"mapped",
			[113]
		],
		[
			[9415, 9415],
			"mapped",
			[114]
		],
		[
			[9416, 9416],
			"mapped",
			[115]
		],
		[
			[9417, 9417],
			"mapped",
			[116]
		],
		[
			[9418, 9418],
			"mapped",
			[117]
		],
		[
			[9419, 9419],
			"mapped",
			[118]
		],
		[
			[9420, 9420],
			"mapped",
			[119]
		],
		[
			[9421, 9421],
			"mapped",
			[120]
		],
		[
			[9422, 9422],
			"mapped",
			[121]
		],
		[
			[9423, 9423],
			"mapped",
			[122]
		],
		[
			[9424, 9424],
			"mapped",
			[97]
		],
		[
			[9425, 9425],
			"mapped",
			[98]
		],
		[
			[9426, 9426],
			"mapped",
			[99]
		],
		[
			[9427, 9427],
			"mapped",
			[100]
		],
		[
			[9428, 9428],
			"mapped",
			[101]
		],
		[
			[9429, 9429],
			"mapped",
			[102]
		],
		[
			[9430, 9430],
			"mapped",
			[103]
		],
		[
			[9431, 9431],
			"mapped",
			[104]
		],
		[
			[9432, 9432],
			"mapped",
			[105]
		],
		[
			[9433, 9433],
			"mapped",
			[106]
		],
		[
			[9434, 9434],
			"mapped",
			[107]
		],
		[
			[9435, 9435],
			"mapped",
			[108]
		],
		[
			[9436, 9436],
			"mapped",
			[109]
		],
		[
			[9437, 9437],
			"mapped",
			[110]
		],
		[
			[9438, 9438],
			"mapped",
			[111]
		],
		[
			[9439, 9439],
			"mapped",
			[112]
		],
		[
			[9440, 9440],
			"mapped",
			[113]
		],
		[
			[9441, 9441],
			"mapped",
			[114]
		],
		[
			[9442, 9442],
			"mapped",
			[115]
		],
		[
			[9443, 9443],
			"mapped",
			[116]
		],
		[
			[9444, 9444],
			"mapped",
			[117]
		],
		[
			[9445, 9445],
			"mapped",
			[118]
		],
		[
			[9446, 9446],
			"mapped",
			[119]
		],
		[
			[9447, 9447],
			"mapped",
			[120]
		],
		[
			[9448, 9448],
			"mapped",
			[121]
		],
		[
			[9449, 9449],
			"mapped",
			[122]
		],
		[
			[9450, 9450],
			"mapped",
			[48]
		],
		[
			[9451, 9470],
			"valid",
			[],
			"NV8"
		],
		[
			[9471, 9471],
			"valid",
			[],
			"NV8"
		],
		[
			[9472, 9621],
			"valid",
			[],
			"NV8"
		],
		[
			[9622, 9631],
			"valid",
			[],
			"NV8"
		],
		[
			[9632, 9711],
			"valid",
			[],
			"NV8"
		],
		[
			[9712, 9719],
			"valid",
			[],
			"NV8"
		],
		[
			[9720, 9727],
			"valid",
			[],
			"NV8"
		],
		[
			[9728, 9747],
			"valid",
			[],
			"NV8"
		],
		[
			[9748, 9749],
			"valid",
			[],
			"NV8"
		],
		[
			[9750, 9751],
			"valid",
			[],
			"NV8"
		],
		[
			[9752, 9752],
			"valid",
			[],
			"NV8"
		],
		[
			[9753, 9753],
			"valid",
			[],
			"NV8"
		],
		[
			[9754, 9839],
			"valid",
			[],
			"NV8"
		],
		[
			[9840, 9841],
			"valid",
			[],
			"NV8"
		],
		[
			[9842, 9853],
			"valid",
			[],
			"NV8"
		],
		[
			[9854, 9855],
			"valid",
			[],
			"NV8"
		],
		[
			[9856, 9865],
			"valid",
			[],
			"NV8"
		],
		[
			[9866, 9873],
			"valid",
			[],
			"NV8"
		],
		[
			[9874, 9884],
			"valid",
			[],
			"NV8"
		],
		[
			[9885, 9885],
			"valid",
			[],
			"NV8"
		],
		[
			[9886, 9887],
			"valid",
			[],
			"NV8"
		],
		[
			[9888, 9889],
			"valid",
			[],
			"NV8"
		],
		[
			[9890, 9905],
			"valid",
			[],
			"NV8"
		],
		[
			[9906, 9906],
			"valid",
			[],
			"NV8"
		],
		[
			[9907, 9916],
			"valid",
			[],
			"NV8"
		],
		[
			[9917, 9919],
			"valid",
			[],
			"NV8"
		],
		[
			[9920, 9923],
			"valid",
			[],
			"NV8"
		],
		[
			[9924, 9933],
			"valid",
			[],
			"NV8"
		],
		[
			[9934, 9934],
			"valid",
			[],
			"NV8"
		],
		[
			[9935, 9953],
			"valid",
			[],
			"NV8"
		],
		[
			[9954, 9954],
			"valid",
			[],
			"NV8"
		],
		[
			[9955, 9955],
			"valid",
			[],
			"NV8"
		],
		[
			[9956, 9959],
			"valid",
			[],
			"NV8"
		],
		[
			[9960, 9983],
			"valid",
			[],
			"NV8"
		],
		[
			[9984, 9984],
			"valid",
			[],
			"NV8"
		],
		[
			[9985, 9988],
			"valid",
			[],
			"NV8"
		],
		[
			[9989, 9989],
			"valid",
			[],
			"NV8"
		],
		[
			[9990, 9993],
			"valid",
			[],
			"NV8"
		],
		[
			[9994, 9995],
			"valid",
			[],
			"NV8"
		],
		[
			[9996, 10023],
			"valid",
			[],
			"NV8"
		],
		[
			[10024, 10024],
			"valid",
			[],
			"NV8"
		],
		[
			[10025, 10059],
			"valid",
			[],
			"NV8"
		],
		[
			[10060, 10060],
			"valid",
			[],
			"NV8"
		],
		[
			[10061, 10061],
			"valid",
			[],
			"NV8"
		],
		[
			[10062, 10062],
			"valid",
			[],
			"NV8"
		],
		[
			[10063, 10066],
			"valid",
			[],
			"NV8"
		],
		[
			[10067, 10069],
			"valid",
			[],
			"NV8"
		],
		[
			[10070, 10070],
			"valid",
			[],
			"NV8"
		],
		[
			[10071, 10071],
			"valid",
			[],
			"NV8"
		],
		[
			[10072, 10078],
			"valid",
			[],
			"NV8"
		],
		[
			[10079, 10080],
			"valid",
			[],
			"NV8"
		],
		[
			[10081, 10087],
			"valid",
			[],
			"NV8"
		],
		[
			[10088, 10101],
			"valid",
			[],
			"NV8"
		],
		[
			[10102, 10132],
			"valid",
			[],
			"NV8"
		],
		[
			[10133, 10135],
			"valid",
			[],
			"NV8"
		],
		[
			[10136, 10159],
			"valid",
			[],
			"NV8"
		],
		[
			[10160, 10160],
			"valid",
			[],
			"NV8"
		],
		[
			[10161, 10174],
			"valid",
			[],
			"NV8"
		],
		[
			[10175, 10175],
			"valid",
			[],
			"NV8"
		],
		[
			[10176, 10182],
			"valid",
			[],
			"NV8"
		],
		[
			[10183, 10186],
			"valid",
			[],
			"NV8"
		],
		[
			[10187, 10187],
			"valid",
			[],
			"NV8"
		],
		[
			[10188, 10188],
			"valid",
			[],
			"NV8"
		],
		[
			[10189, 10189],
			"valid",
			[],
			"NV8"
		],
		[
			[10190, 10191],
			"valid",
			[],
			"NV8"
		],
		[
			[10192, 10219],
			"valid",
			[],
			"NV8"
		],
		[
			[10220, 10223],
			"valid",
			[],
			"NV8"
		],
		[
			[10224, 10239],
			"valid",
			[],
			"NV8"
		],
		[
			[10240, 10495],
			"valid",
			[],
			"NV8"
		],
		[
			[10496, 10763],
			"valid",
			[],
			"NV8"
		],
		[
			[10764, 10764],
			"mapped",
			[
				8747,
				8747,
				8747,
				8747
			]
		],
		[
			[10765, 10867],
			"valid",
			[],
			"NV8"
		],
		[
			[10868, 10868],
			"disallowed_STD3_mapped",
			[
				58,
				58,
				61
			]
		],
		[
			[10869, 10869],
			"disallowed_STD3_mapped",
			[61, 61]
		],
		[
			[10870, 10870],
			"disallowed_STD3_mapped",
			[
				61,
				61,
				61
			]
		],
		[
			[10871, 10971],
			"valid",
			[],
			"NV8"
		],
		[
			[10972, 10972],
			"mapped",
			[10973, 824]
		],
		[
			[10973, 11007],
			"valid",
			[],
			"NV8"
		],
		[
			[11008, 11021],
			"valid",
			[],
			"NV8"
		],
		[
			[11022, 11027],
			"valid",
			[],
			"NV8"
		],
		[
			[11028, 11034],
			"valid",
			[],
			"NV8"
		],
		[
			[11035, 11039],
			"valid",
			[],
			"NV8"
		],
		[
			[11040, 11043],
			"valid",
			[],
			"NV8"
		],
		[
			[11044, 11084],
			"valid",
			[],
			"NV8"
		],
		[
			[11085, 11087],
			"valid",
			[],
			"NV8"
		],
		[
			[11088, 11092],
			"valid",
			[],
			"NV8"
		],
		[
			[11093, 11097],
			"valid",
			[],
			"NV8"
		],
		[
			[11098, 11123],
			"valid",
			[],
			"NV8"
		],
		[[11124, 11125], "disallowed"],
		[
			[11126, 11157],
			"valid",
			[],
			"NV8"
		],
		[[11158, 11159], "disallowed"],
		[
			[11160, 11193],
			"valid",
			[],
			"NV8"
		],
		[[11194, 11196], "disallowed"],
		[
			[11197, 11208],
			"valid",
			[],
			"NV8"
		],
		[[11209, 11209], "disallowed"],
		[
			[11210, 11217],
			"valid",
			[],
			"NV8"
		],
		[[11218, 11243], "disallowed"],
		[
			[11244, 11247],
			"valid",
			[],
			"NV8"
		],
		[[11248, 11263], "disallowed"],
		[
			[11264, 11264],
			"mapped",
			[11312]
		],
		[
			[11265, 11265],
			"mapped",
			[11313]
		],
		[
			[11266, 11266],
			"mapped",
			[11314]
		],
		[
			[11267, 11267],
			"mapped",
			[11315]
		],
		[
			[11268, 11268],
			"mapped",
			[11316]
		],
		[
			[11269, 11269],
			"mapped",
			[11317]
		],
		[
			[11270, 11270],
			"mapped",
			[11318]
		],
		[
			[11271, 11271],
			"mapped",
			[11319]
		],
		[
			[11272, 11272],
			"mapped",
			[11320]
		],
		[
			[11273, 11273],
			"mapped",
			[11321]
		],
		[
			[11274, 11274],
			"mapped",
			[11322]
		],
		[
			[11275, 11275],
			"mapped",
			[11323]
		],
		[
			[11276, 11276],
			"mapped",
			[11324]
		],
		[
			[11277, 11277],
			"mapped",
			[11325]
		],
		[
			[11278, 11278],
			"mapped",
			[11326]
		],
		[
			[11279, 11279],
			"mapped",
			[11327]
		],
		[
			[11280, 11280],
			"mapped",
			[11328]
		],
		[
			[11281, 11281],
			"mapped",
			[11329]
		],
		[
			[11282, 11282],
			"mapped",
			[11330]
		],
		[
			[11283, 11283],
			"mapped",
			[11331]
		],
		[
			[11284, 11284],
			"mapped",
			[11332]
		],
		[
			[11285, 11285],
			"mapped",
			[11333]
		],
		[
			[11286, 11286],
			"mapped",
			[11334]
		],
		[
			[11287, 11287],
			"mapped",
			[11335]
		],
		[
			[11288, 11288],
			"mapped",
			[11336]
		],
		[
			[11289, 11289],
			"mapped",
			[11337]
		],
		[
			[11290, 11290],
			"mapped",
			[11338]
		],
		[
			[11291, 11291],
			"mapped",
			[11339]
		],
		[
			[11292, 11292],
			"mapped",
			[11340]
		],
		[
			[11293, 11293],
			"mapped",
			[11341]
		],
		[
			[11294, 11294],
			"mapped",
			[11342]
		],
		[
			[11295, 11295],
			"mapped",
			[11343]
		],
		[
			[11296, 11296],
			"mapped",
			[11344]
		],
		[
			[11297, 11297],
			"mapped",
			[11345]
		],
		[
			[11298, 11298],
			"mapped",
			[11346]
		],
		[
			[11299, 11299],
			"mapped",
			[11347]
		],
		[
			[11300, 11300],
			"mapped",
			[11348]
		],
		[
			[11301, 11301],
			"mapped",
			[11349]
		],
		[
			[11302, 11302],
			"mapped",
			[11350]
		],
		[
			[11303, 11303],
			"mapped",
			[11351]
		],
		[
			[11304, 11304],
			"mapped",
			[11352]
		],
		[
			[11305, 11305],
			"mapped",
			[11353]
		],
		[
			[11306, 11306],
			"mapped",
			[11354]
		],
		[
			[11307, 11307],
			"mapped",
			[11355]
		],
		[
			[11308, 11308],
			"mapped",
			[11356]
		],
		[
			[11309, 11309],
			"mapped",
			[11357]
		],
		[
			[11310, 11310],
			"mapped",
			[11358]
		],
		[[11311, 11311], "disallowed"],
		[[11312, 11358], "valid"],
		[[11359, 11359], "disallowed"],
		[
			[11360, 11360],
			"mapped",
			[11361]
		],
		[[11361, 11361], "valid"],
		[
			[11362, 11362],
			"mapped",
			[619]
		],
		[
			[11363, 11363],
			"mapped",
			[7549]
		],
		[
			[11364, 11364],
			"mapped",
			[637]
		],
		[[11365, 11366], "valid"],
		[
			[11367, 11367],
			"mapped",
			[11368]
		],
		[[11368, 11368], "valid"],
		[
			[11369, 11369],
			"mapped",
			[11370]
		],
		[[11370, 11370], "valid"],
		[
			[11371, 11371],
			"mapped",
			[11372]
		],
		[[11372, 11372], "valid"],
		[
			[11373, 11373],
			"mapped",
			[593]
		],
		[
			[11374, 11374],
			"mapped",
			[625]
		],
		[
			[11375, 11375],
			"mapped",
			[592]
		],
		[
			[11376, 11376],
			"mapped",
			[594]
		],
		[[11377, 11377], "valid"],
		[
			[11378, 11378],
			"mapped",
			[11379]
		],
		[[11379, 11379], "valid"],
		[[11380, 11380], "valid"],
		[
			[11381, 11381],
			"mapped",
			[11382]
		],
		[[11382, 11383], "valid"],
		[[11384, 11387], "valid"],
		[
			[11388, 11388],
			"mapped",
			[106]
		],
		[
			[11389, 11389],
			"mapped",
			[118]
		],
		[
			[11390, 11390],
			"mapped",
			[575]
		],
		[
			[11391, 11391],
			"mapped",
			[576]
		],
		[
			[11392, 11392],
			"mapped",
			[11393]
		],
		[[11393, 11393], "valid"],
		[
			[11394, 11394],
			"mapped",
			[11395]
		],
		[[11395, 11395], "valid"],
		[
			[11396, 11396],
			"mapped",
			[11397]
		],
		[[11397, 11397], "valid"],
		[
			[11398, 11398],
			"mapped",
			[11399]
		],
		[[11399, 11399], "valid"],
		[
			[11400, 11400],
			"mapped",
			[11401]
		],
		[[11401, 11401], "valid"],
		[
			[11402, 11402],
			"mapped",
			[11403]
		],
		[[11403, 11403], "valid"],
		[
			[11404, 11404],
			"mapped",
			[11405]
		],
		[[11405, 11405], "valid"],
		[
			[11406, 11406],
			"mapped",
			[11407]
		],
		[[11407, 11407], "valid"],
		[
			[11408, 11408],
			"mapped",
			[11409]
		],
		[[11409, 11409], "valid"],
		[
			[11410, 11410],
			"mapped",
			[11411]
		],
		[[11411, 11411], "valid"],
		[
			[11412, 11412],
			"mapped",
			[11413]
		],
		[[11413, 11413], "valid"],
		[
			[11414, 11414],
			"mapped",
			[11415]
		],
		[[11415, 11415], "valid"],
		[
			[11416, 11416],
			"mapped",
			[11417]
		],
		[[11417, 11417], "valid"],
		[
			[11418, 11418],
			"mapped",
			[11419]
		],
		[[11419, 11419], "valid"],
		[
			[11420, 11420],
			"mapped",
			[11421]
		],
		[[11421, 11421], "valid"],
		[
			[11422, 11422],
			"mapped",
			[11423]
		],
		[[11423, 11423], "valid"],
		[
			[11424, 11424],
			"mapped",
			[11425]
		],
		[[11425, 11425], "valid"],
		[
			[11426, 11426],
			"mapped",
			[11427]
		],
		[[11427, 11427], "valid"],
		[
			[11428, 11428],
			"mapped",
			[11429]
		],
		[[11429, 11429], "valid"],
		[
			[11430, 11430],
			"mapped",
			[11431]
		],
		[[11431, 11431], "valid"],
		[
			[11432, 11432],
			"mapped",
			[11433]
		],
		[[11433, 11433], "valid"],
		[
			[11434, 11434],
			"mapped",
			[11435]
		],
		[[11435, 11435], "valid"],
		[
			[11436, 11436],
			"mapped",
			[11437]
		],
		[[11437, 11437], "valid"],
		[
			[11438, 11438],
			"mapped",
			[11439]
		],
		[[11439, 11439], "valid"],
		[
			[11440, 11440],
			"mapped",
			[11441]
		],
		[[11441, 11441], "valid"],
		[
			[11442, 11442],
			"mapped",
			[11443]
		],
		[[11443, 11443], "valid"],
		[
			[11444, 11444],
			"mapped",
			[11445]
		],
		[[11445, 11445], "valid"],
		[
			[11446, 11446],
			"mapped",
			[11447]
		],
		[[11447, 11447], "valid"],
		[
			[11448, 11448],
			"mapped",
			[11449]
		],
		[[11449, 11449], "valid"],
		[
			[11450, 11450],
			"mapped",
			[11451]
		],
		[[11451, 11451], "valid"],
		[
			[11452, 11452],
			"mapped",
			[11453]
		],
		[[11453, 11453], "valid"],
		[
			[11454, 11454],
			"mapped",
			[11455]
		],
		[[11455, 11455], "valid"],
		[
			[11456, 11456],
			"mapped",
			[11457]
		],
		[[11457, 11457], "valid"],
		[
			[11458, 11458],
			"mapped",
			[11459]
		],
		[[11459, 11459], "valid"],
		[
			[11460, 11460],
			"mapped",
			[11461]
		],
		[[11461, 11461], "valid"],
		[
			[11462, 11462],
			"mapped",
			[11463]
		],
		[[11463, 11463], "valid"],
		[
			[11464, 11464],
			"mapped",
			[11465]
		],
		[[11465, 11465], "valid"],
		[
			[11466, 11466],
			"mapped",
			[11467]
		],
		[[11467, 11467], "valid"],
		[
			[11468, 11468],
			"mapped",
			[11469]
		],
		[[11469, 11469], "valid"],
		[
			[11470, 11470],
			"mapped",
			[11471]
		],
		[[11471, 11471], "valid"],
		[
			[11472, 11472],
			"mapped",
			[11473]
		],
		[[11473, 11473], "valid"],
		[
			[11474, 11474],
			"mapped",
			[11475]
		],
		[[11475, 11475], "valid"],
		[
			[11476, 11476],
			"mapped",
			[11477]
		],
		[[11477, 11477], "valid"],
		[
			[11478, 11478],
			"mapped",
			[11479]
		],
		[[11479, 11479], "valid"],
		[
			[11480, 11480],
			"mapped",
			[11481]
		],
		[[11481, 11481], "valid"],
		[
			[11482, 11482],
			"mapped",
			[11483]
		],
		[[11483, 11483], "valid"],
		[
			[11484, 11484],
			"mapped",
			[11485]
		],
		[[11485, 11485], "valid"],
		[
			[11486, 11486],
			"mapped",
			[11487]
		],
		[[11487, 11487], "valid"],
		[
			[11488, 11488],
			"mapped",
			[11489]
		],
		[[11489, 11489], "valid"],
		[
			[11490, 11490],
			"mapped",
			[11491]
		],
		[[11491, 11492], "valid"],
		[
			[11493, 11498],
			"valid",
			[],
			"NV8"
		],
		[
			[11499, 11499],
			"mapped",
			[11500]
		],
		[[11500, 11500], "valid"],
		[
			[11501, 11501],
			"mapped",
			[11502]
		],
		[[11502, 11505], "valid"],
		[
			[11506, 11506],
			"mapped",
			[11507]
		],
		[[11507, 11507], "valid"],
		[[11508, 11512], "disallowed"],
		[
			[11513, 11519],
			"valid",
			[],
			"NV8"
		],
		[[11520, 11557], "valid"],
		[[11558, 11558], "disallowed"],
		[[11559, 11559], "valid"],
		[[11560, 11564], "disallowed"],
		[[11565, 11565], "valid"],
		[[11566, 11567], "disallowed"],
		[[11568, 11621], "valid"],
		[[11622, 11623], "valid"],
		[[11624, 11630], "disallowed"],
		[
			[11631, 11631],
			"mapped",
			[11617]
		],
		[
			[11632, 11632],
			"valid",
			[],
			"NV8"
		],
		[[11633, 11646], "disallowed"],
		[[11647, 11647], "valid"],
		[[11648, 11670], "valid"],
		[[11671, 11679], "disallowed"],
		[[11680, 11686], "valid"],
		[[11687, 11687], "disallowed"],
		[[11688, 11694], "valid"],
		[[11695, 11695], "disallowed"],
		[[11696, 11702], "valid"],
		[[11703, 11703], "disallowed"],
		[[11704, 11710], "valid"],
		[[11711, 11711], "disallowed"],
		[[11712, 11718], "valid"],
		[[11719, 11719], "disallowed"],
		[[11720, 11726], "valid"],
		[[11727, 11727], "disallowed"],
		[[11728, 11734], "valid"],
		[[11735, 11735], "disallowed"],
		[[11736, 11742], "valid"],
		[[11743, 11743], "disallowed"],
		[[11744, 11775], "valid"],
		[
			[11776, 11799],
			"valid",
			[],
			"NV8"
		],
		[
			[11800, 11803],
			"valid",
			[],
			"NV8"
		],
		[
			[11804, 11805],
			"valid",
			[],
			"NV8"
		],
		[
			[11806, 11822],
			"valid",
			[],
			"NV8"
		],
		[[11823, 11823], "valid"],
		[
			[11824, 11824],
			"valid",
			[],
			"NV8"
		],
		[
			[11825, 11825],
			"valid",
			[],
			"NV8"
		],
		[
			[11826, 11835],
			"valid",
			[],
			"NV8"
		],
		[
			[11836, 11842],
			"valid",
			[],
			"NV8"
		],
		[[11843, 11903], "disallowed"],
		[
			[11904, 11929],
			"valid",
			[],
			"NV8"
		],
		[[11930, 11930], "disallowed"],
		[
			[11931, 11934],
			"valid",
			[],
			"NV8"
		],
		[
			[11935, 11935],
			"mapped",
			[27597]
		],
		[
			[11936, 12018],
			"valid",
			[],
			"NV8"
		],
		[
			[12019, 12019],
			"mapped",
			[40863]
		],
		[[12020, 12031], "disallowed"],
		[
			[12032, 12032],
			"mapped",
			[19968]
		],
		[
			[12033, 12033],
			"mapped",
			[20008]
		],
		[
			[12034, 12034],
			"mapped",
			[20022]
		],
		[
			[12035, 12035],
			"mapped",
			[20031]
		],
		[
			[12036, 12036],
			"mapped",
			[20057]
		],
		[
			[12037, 12037],
			"mapped",
			[20101]
		],
		[
			[12038, 12038],
			"mapped",
			[20108]
		],
		[
			[12039, 12039],
			"mapped",
			[20128]
		],
		[
			[12040, 12040],
			"mapped",
			[20154]
		],
		[
			[12041, 12041],
			"mapped",
			[20799]
		],
		[
			[12042, 12042],
			"mapped",
			[20837]
		],
		[
			[12043, 12043],
			"mapped",
			[20843]
		],
		[
			[12044, 12044],
			"mapped",
			[20866]
		],
		[
			[12045, 12045],
			"mapped",
			[20886]
		],
		[
			[12046, 12046],
			"mapped",
			[20907]
		],
		[
			[12047, 12047],
			"mapped",
			[20960]
		],
		[
			[12048, 12048],
			"mapped",
			[20981]
		],
		[
			[12049, 12049],
			"mapped",
			[20992]
		],
		[
			[12050, 12050],
			"mapped",
			[21147]
		],
		[
			[12051, 12051],
			"mapped",
			[21241]
		],
		[
			[12052, 12052],
			"mapped",
			[21269]
		],
		[
			[12053, 12053],
			"mapped",
			[21274]
		],
		[
			[12054, 12054],
			"mapped",
			[21304]
		],
		[
			[12055, 12055],
			"mapped",
			[21313]
		],
		[
			[12056, 12056],
			"mapped",
			[21340]
		],
		[
			[12057, 12057],
			"mapped",
			[21353]
		],
		[
			[12058, 12058],
			"mapped",
			[21378]
		],
		[
			[12059, 12059],
			"mapped",
			[21430]
		],
		[
			[12060, 12060],
			"mapped",
			[21448]
		],
		[
			[12061, 12061],
			"mapped",
			[21475]
		],
		[
			[12062, 12062],
			"mapped",
			[22231]
		],
		[
			[12063, 12063],
			"mapped",
			[22303]
		],
		[
			[12064, 12064],
			"mapped",
			[22763]
		],
		[
			[12065, 12065],
			"mapped",
			[22786]
		],
		[
			[12066, 12066],
			"mapped",
			[22794]
		],
		[
			[12067, 12067],
			"mapped",
			[22805]
		],
		[
			[12068, 12068],
			"mapped",
			[22823]
		],
		[
			[12069, 12069],
			"mapped",
			[22899]
		],
		[
			[12070, 12070],
			"mapped",
			[23376]
		],
		[
			[12071, 12071],
			"mapped",
			[23424]
		],
		[
			[12072, 12072],
			"mapped",
			[23544]
		],
		[
			[12073, 12073],
			"mapped",
			[23567]
		],
		[
			[12074, 12074],
			"mapped",
			[23586]
		],
		[
			[12075, 12075],
			"mapped",
			[23608]
		],
		[
			[12076, 12076],
			"mapped",
			[23662]
		],
		[
			[12077, 12077],
			"mapped",
			[23665]
		],
		[
			[12078, 12078],
			"mapped",
			[24027]
		],
		[
			[12079, 12079],
			"mapped",
			[24037]
		],
		[
			[12080, 12080],
			"mapped",
			[24049]
		],
		[
			[12081, 12081],
			"mapped",
			[24062]
		],
		[
			[12082, 12082],
			"mapped",
			[24178]
		],
		[
			[12083, 12083],
			"mapped",
			[24186]
		],
		[
			[12084, 12084],
			"mapped",
			[24191]
		],
		[
			[12085, 12085],
			"mapped",
			[24308]
		],
		[
			[12086, 12086],
			"mapped",
			[24318]
		],
		[
			[12087, 12087],
			"mapped",
			[24331]
		],
		[
			[12088, 12088],
			"mapped",
			[24339]
		],
		[
			[12089, 12089],
			"mapped",
			[24400]
		],
		[
			[12090, 12090],
			"mapped",
			[24417]
		],
		[
			[12091, 12091],
			"mapped",
			[24435]
		],
		[
			[12092, 12092],
			"mapped",
			[24515]
		],
		[
			[12093, 12093],
			"mapped",
			[25096]
		],
		[
			[12094, 12094],
			"mapped",
			[25142]
		],
		[
			[12095, 12095],
			"mapped",
			[25163]
		],
		[
			[12096, 12096],
			"mapped",
			[25903]
		],
		[
			[12097, 12097],
			"mapped",
			[25908]
		],
		[
			[12098, 12098],
			"mapped",
			[25991]
		],
		[
			[12099, 12099],
			"mapped",
			[26007]
		],
		[
			[12100, 12100],
			"mapped",
			[26020]
		],
		[
			[12101, 12101],
			"mapped",
			[26041]
		],
		[
			[12102, 12102],
			"mapped",
			[26080]
		],
		[
			[12103, 12103],
			"mapped",
			[26085]
		],
		[
			[12104, 12104],
			"mapped",
			[26352]
		],
		[
			[12105, 12105],
			"mapped",
			[26376]
		],
		[
			[12106, 12106],
			"mapped",
			[26408]
		],
		[
			[12107, 12107],
			"mapped",
			[27424]
		],
		[
			[12108, 12108],
			"mapped",
			[27490]
		],
		[
			[12109, 12109],
			"mapped",
			[27513]
		],
		[
			[12110, 12110],
			"mapped",
			[27571]
		],
		[
			[12111, 12111],
			"mapped",
			[27595]
		],
		[
			[12112, 12112],
			"mapped",
			[27604]
		],
		[
			[12113, 12113],
			"mapped",
			[27611]
		],
		[
			[12114, 12114],
			"mapped",
			[27663]
		],
		[
			[12115, 12115],
			"mapped",
			[27668]
		],
		[
			[12116, 12116],
			"mapped",
			[27700]
		],
		[
			[12117, 12117],
			"mapped",
			[28779]
		],
		[
			[12118, 12118],
			"mapped",
			[29226]
		],
		[
			[12119, 12119],
			"mapped",
			[29238]
		],
		[
			[12120, 12120],
			"mapped",
			[29243]
		],
		[
			[12121, 12121],
			"mapped",
			[29247]
		],
		[
			[12122, 12122],
			"mapped",
			[29255]
		],
		[
			[12123, 12123],
			"mapped",
			[29273]
		],
		[
			[12124, 12124],
			"mapped",
			[29275]
		],
		[
			[12125, 12125],
			"mapped",
			[29356]
		],
		[
			[12126, 12126],
			"mapped",
			[29572]
		],
		[
			[12127, 12127],
			"mapped",
			[29577]
		],
		[
			[12128, 12128],
			"mapped",
			[29916]
		],
		[
			[12129, 12129],
			"mapped",
			[29926]
		],
		[
			[12130, 12130],
			"mapped",
			[29976]
		],
		[
			[12131, 12131],
			"mapped",
			[29983]
		],
		[
			[12132, 12132],
			"mapped",
			[29992]
		],
		[
			[12133, 12133],
			"mapped",
			[3e4]
		],
		[
			[12134, 12134],
			"mapped",
			[30091]
		],
		[
			[12135, 12135],
			"mapped",
			[30098]
		],
		[
			[12136, 12136],
			"mapped",
			[30326]
		],
		[
			[12137, 12137],
			"mapped",
			[30333]
		],
		[
			[12138, 12138],
			"mapped",
			[30382]
		],
		[
			[12139, 12139],
			"mapped",
			[30399]
		],
		[
			[12140, 12140],
			"mapped",
			[30446]
		],
		[
			[12141, 12141],
			"mapped",
			[30683]
		],
		[
			[12142, 12142],
			"mapped",
			[30690]
		],
		[
			[12143, 12143],
			"mapped",
			[30707]
		],
		[
			[12144, 12144],
			"mapped",
			[31034]
		],
		[
			[12145, 12145],
			"mapped",
			[31160]
		],
		[
			[12146, 12146],
			"mapped",
			[31166]
		],
		[
			[12147, 12147],
			"mapped",
			[31348]
		],
		[
			[12148, 12148],
			"mapped",
			[31435]
		],
		[
			[12149, 12149],
			"mapped",
			[31481]
		],
		[
			[12150, 12150],
			"mapped",
			[31859]
		],
		[
			[12151, 12151],
			"mapped",
			[31992]
		],
		[
			[12152, 12152],
			"mapped",
			[32566]
		],
		[
			[12153, 12153],
			"mapped",
			[32593]
		],
		[
			[12154, 12154],
			"mapped",
			[32650]
		],
		[
			[12155, 12155],
			"mapped",
			[32701]
		],
		[
			[12156, 12156],
			"mapped",
			[32769]
		],
		[
			[12157, 12157],
			"mapped",
			[32780]
		],
		[
			[12158, 12158],
			"mapped",
			[32786]
		],
		[
			[12159, 12159],
			"mapped",
			[32819]
		],
		[
			[12160, 12160],
			"mapped",
			[32895]
		],
		[
			[12161, 12161],
			"mapped",
			[32905]
		],
		[
			[12162, 12162],
			"mapped",
			[33251]
		],
		[
			[12163, 12163],
			"mapped",
			[33258]
		],
		[
			[12164, 12164],
			"mapped",
			[33267]
		],
		[
			[12165, 12165],
			"mapped",
			[33276]
		],
		[
			[12166, 12166],
			"mapped",
			[33292]
		],
		[
			[12167, 12167],
			"mapped",
			[33307]
		],
		[
			[12168, 12168],
			"mapped",
			[33311]
		],
		[
			[12169, 12169],
			"mapped",
			[33390]
		],
		[
			[12170, 12170],
			"mapped",
			[33394]
		],
		[
			[12171, 12171],
			"mapped",
			[33400]
		],
		[
			[12172, 12172],
			"mapped",
			[34381]
		],
		[
			[12173, 12173],
			"mapped",
			[34411]
		],
		[
			[12174, 12174],
			"mapped",
			[34880]
		],
		[
			[12175, 12175],
			"mapped",
			[34892]
		],
		[
			[12176, 12176],
			"mapped",
			[34915]
		],
		[
			[12177, 12177],
			"mapped",
			[35198]
		],
		[
			[12178, 12178],
			"mapped",
			[35211]
		],
		[
			[12179, 12179],
			"mapped",
			[35282]
		],
		[
			[12180, 12180],
			"mapped",
			[35328]
		],
		[
			[12181, 12181],
			"mapped",
			[35895]
		],
		[
			[12182, 12182],
			"mapped",
			[35910]
		],
		[
			[12183, 12183],
			"mapped",
			[35925]
		],
		[
			[12184, 12184],
			"mapped",
			[35960]
		],
		[
			[12185, 12185],
			"mapped",
			[35997]
		],
		[
			[12186, 12186],
			"mapped",
			[36196]
		],
		[
			[12187, 12187],
			"mapped",
			[36208]
		],
		[
			[12188, 12188],
			"mapped",
			[36275]
		],
		[
			[12189, 12189],
			"mapped",
			[36523]
		],
		[
			[12190, 12190],
			"mapped",
			[36554]
		],
		[
			[12191, 12191],
			"mapped",
			[36763]
		],
		[
			[12192, 12192],
			"mapped",
			[36784]
		],
		[
			[12193, 12193],
			"mapped",
			[36789]
		],
		[
			[12194, 12194],
			"mapped",
			[37009]
		],
		[
			[12195, 12195],
			"mapped",
			[37193]
		],
		[
			[12196, 12196],
			"mapped",
			[37318]
		],
		[
			[12197, 12197],
			"mapped",
			[37324]
		],
		[
			[12198, 12198],
			"mapped",
			[37329]
		],
		[
			[12199, 12199],
			"mapped",
			[38263]
		],
		[
			[12200, 12200],
			"mapped",
			[38272]
		],
		[
			[12201, 12201],
			"mapped",
			[38428]
		],
		[
			[12202, 12202],
			"mapped",
			[38582]
		],
		[
			[12203, 12203],
			"mapped",
			[38585]
		],
		[
			[12204, 12204],
			"mapped",
			[38632]
		],
		[
			[12205, 12205],
			"mapped",
			[38737]
		],
		[
			[12206, 12206],
			"mapped",
			[38750]
		],
		[
			[12207, 12207],
			"mapped",
			[38754]
		],
		[
			[12208, 12208],
			"mapped",
			[38761]
		],
		[
			[12209, 12209],
			"mapped",
			[38859]
		],
		[
			[12210, 12210],
			"mapped",
			[38893]
		],
		[
			[12211, 12211],
			"mapped",
			[38899]
		],
		[
			[12212, 12212],
			"mapped",
			[38913]
		],
		[
			[12213, 12213],
			"mapped",
			[39080]
		],
		[
			[12214, 12214],
			"mapped",
			[39131]
		],
		[
			[12215, 12215],
			"mapped",
			[39135]
		],
		[
			[12216, 12216],
			"mapped",
			[39318]
		],
		[
			[12217, 12217],
			"mapped",
			[39321]
		],
		[
			[12218, 12218],
			"mapped",
			[39340]
		],
		[
			[12219, 12219],
			"mapped",
			[39592]
		],
		[
			[12220, 12220],
			"mapped",
			[39640]
		],
		[
			[12221, 12221],
			"mapped",
			[39647]
		],
		[
			[12222, 12222],
			"mapped",
			[39717]
		],
		[
			[12223, 12223],
			"mapped",
			[39727]
		],
		[
			[12224, 12224],
			"mapped",
			[39730]
		],
		[
			[12225, 12225],
			"mapped",
			[39740]
		],
		[
			[12226, 12226],
			"mapped",
			[39770]
		],
		[
			[12227, 12227],
			"mapped",
			[40165]
		],
		[
			[12228, 12228],
			"mapped",
			[40565]
		],
		[
			[12229, 12229],
			"mapped",
			[40575]
		],
		[
			[12230, 12230],
			"mapped",
			[40613]
		],
		[
			[12231, 12231],
			"mapped",
			[40635]
		],
		[
			[12232, 12232],
			"mapped",
			[40643]
		],
		[
			[12233, 12233],
			"mapped",
			[40653]
		],
		[
			[12234, 12234],
			"mapped",
			[40657]
		],
		[
			[12235, 12235],
			"mapped",
			[40697]
		],
		[
			[12236, 12236],
			"mapped",
			[40701]
		],
		[
			[12237, 12237],
			"mapped",
			[40718]
		],
		[
			[12238, 12238],
			"mapped",
			[40723]
		],
		[
			[12239, 12239],
			"mapped",
			[40736]
		],
		[
			[12240, 12240],
			"mapped",
			[40763]
		],
		[
			[12241, 12241],
			"mapped",
			[40778]
		],
		[
			[12242, 12242],
			"mapped",
			[40786]
		],
		[
			[12243, 12243],
			"mapped",
			[40845]
		],
		[
			[12244, 12244],
			"mapped",
			[40860]
		],
		[
			[12245, 12245],
			"mapped",
			[40864]
		],
		[[12246, 12271], "disallowed"],
		[[12272, 12283], "disallowed"],
		[[12284, 12287], "disallowed"],
		[
			[12288, 12288],
			"disallowed_STD3_mapped",
			[32]
		],
		[
			[12289, 12289],
			"valid",
			[],
			"NV8"
		],
		[
			[12290, 12290],
			"mapped",
			[46]
		],
		[
			[12291, 12292],
			"valid",
			[],
			"NV8"
		],
		[[12293, 12295], "valid"],
		[
			[12296, 12329],
			"valid",
			[],
			"NV8"
		],
		[[12330, 12333], "valid"],
		[
			[12334, 12341],
			"valid",
			[],
			"NV8"
		],
		[
			[12342, 12342],
			"mapped",
			[12306]
		],
		[
			[12343, 12343],
			"valid",
			[],
			"NV8"
		],
		[
			[12344, 12344],
			"mapped",
			[21313]
		],
		[
			[12345, 12345],
			"mapped",
			[21316]
		],
		[
			[12346, 12346],
			"mapped",
			[21317]
		],
		[
			[12347, 12347],
			"valid",
			[],
			"NV8"
		],
		[[12348, 12348], "valid"],
		[
			[12349, 12349],
			"valid",
			[],
			"NV8"
		],
		[
			[12350, 12350],
			"valid",
			[],
			"NV8"
		],
		[
			[12351, 12351],
			"valid",
			[],
			"NV8"
		],
		[[12352, 12352], "disallowed"],
		[[12353, 12436], "valid"],
		[[12437, 12438], "valid"],
		[[12439, 12440], "disallowed"],
		[[12441, 12442], "valid"],
		[
			[12443, 12443],
			"disallowed_STD3_mapped",
			[32, 12441]
		],
		[
			[12444, 12444],
			"disallowed_STD3_mapped",
			[32, 12442]
		],
		[[12445, 12446], "valid"],
		[
			[12447, 12447],
			"mapped",
			[12424, 12426]
		],
		[
			[12448, 12448],
			"valid",
			[],
			"NV8"
		],
		[[12449, 12542], "valid"],
		[
			[12543, 12543],
			"mapped",
			[12467, 12488]
		],
		[[12544, 12548], "disallowed"],
		[[12549, 12588], "valid"],
		[[12589, 12589], "valid"],
		[[12590, 12592], "disallowed"],
		[
			[12593, 12593],
			"mapped",
			[4352]
		],
		[
			[12594, 12594],
			"mapped",
			[4353]
		],
		[
			[12595, 12595],
			"mapped",
			[4522]
		],
		[
			[12596, 12596],
			"mapped",
			[4354]
		],
		[
			[12597, 12597],
			"mapped",
			[4524]
		],
		[
			[12598, 12598],
			"mapped",
			[4525]
		],
		[
			[12599, 12599],
			"mapped",
			[4355]
		],
		[
			[12600, 12600],
			"mapped",
			[4356]
		],
		[
			[12601, 12601],
			"mapped",
			[4357]
		],
		[
			[12602, 12602],
			"mapped",
			[4528]
		],
		[
			[12603, 12603],
			"mapped",
			[4529]
		],
		[
			[12604, 12604],
			"mapped",
			[4530]
		],
		[
			[12605, 12605],
			"mapped",
			[4531]
		],
		[
			[12606, 12606],
			"mapped",
			[4532]
		],
		[
			[12607, 12607],
			"mapped",
			[4533]
		],
		[
			[12608, 12608],
			"mapped",
			[4378]
		],
		[
			[12609, 12609],
			"mapped",
			[4358]
		],
		[
			[12610, 12610],
			"mapped",
			[4359]
		],
		[
			[12611, 12611],
			"mapped",
			[4360]
		],
		[
			[12612, 12612],
			"mapped",
			[4385]
		],
		[
			[12613, 12613],
			"mapped",
			[4361]
		],
		[
			[12614, 12614],
			"mapped",
			[4362]
		],
		[
			[12615, 12615],
			"mapped",
			[4363]
		],
		[
			[12616, 12616],
			"mapped",
			[4364]
		],
		[
			[12617, 12617],
			"mapped",
			[4365]
		],
		[
			[12618, 12618],
			"mapped",
			[4366]
		],
		[
			[12619, 12619],
			"mapped",
			[4367]
		],
		[
			[12620, 12620],
			"mapped",
			[4368]
		],
		[
			[12621, 12621],
			"mapped",
			[4369]
		],
		[
			[12622, 12622],
			"mapped",
			[4370]
		],
		[
			[12623, 12623],
			"mapped",
			[4449]
		],
		[
			[12624, 12624],
			"mapped",
			[4450]
		],
		[
			[12625, 12625],
			"mapped",
			[4451]
		],
		[
			[12626, 12626],
			"mapped",
			[4452]
		],
		[
			[12627, 12627],
			"mapped",
			[4453]
		],
		[
			[12628, 12628],
			"mapped",
			[4454]
		],
		[
			[12629, 12629],
			"mapped",
			[4455]
		],
		[
			[12630, 12630],
			"mapped",
			[4456]
		],
		[
			[12631, 12631],
			"mapped",
			[4457]
		],
		[
			[12632, 12632],
			"mapped",
			[4458]
		],
		[
			[12633, 12633],
			"mapped",
			[4459]
		],
		[
			[12634, 12634],
			"mapped",
			[4460]
		],
		[
			[12635, 12635],
			"mapped",
			[4461]
		],
		[
			[12636, 12636],
			"mapped",
			[4462]
		],
		[
			[12637, 12637],
			"mapped",
			[4463]
		],
		[
			[12638, 12638],
			"mapped",
			[4464]
		],
		[
			[12639, 12639],
			"mapped",
			[4465]
		],
		[
			[12640, 12640],
			"mapped",
			[4466]
		],
		[
			[12641, 12641],
			"mapped",
			[4467]
		],
		[
			[12642, 12642],
			"mapped",
			[4468]
		],
		[
			[12643, 12643],
			"mapped",
			[4469]
		],
		[[12644, 12644], "disallowed"],
		[
			[12645, 12645],
			"mapped",
			[4372]
		],
		[
			[12646, 12646],
			"mapped",
			[4373]
		],
		[
			[12647, 12647],
			"mapped",
			[4551]
		],
		[
			[12648, 12648],
			"mapped",
			[4552]
		],
		[
			[12649, 12649],
			"mapped",
			[4556]
		],
		[
			[12650, 12650],
			"mapped",
			[4558]
		],
		[
			[12651, 12651],
			"mapped",
			[4563]
		],
		[
			[12652, 12652],
			"mapped",
			[4567]
		],
		[
			[12653, 12653],
			"mapped",
			[4569]
		],
		[
			[12654, 12654],
			"mapped",
			[4380]
		],
		[
			[12655, 12655],
			"mapped",
			[4573]
		],
		[
			[12656, 12656],
			"mapped",
			[4575]
		],
		[
			[12657, 12657],
			"mapped",
			[4381]
		],
		[
			[12658, 12658],
			"mapped",
			[4382]
		],
		[
			[12659, 12659],
			"mapped",
			[4384]
		],
		[
			[12660, 12660],
			"mapped",
			[4386]
		],
		[
			[12661, 12661],
			"mapped",
			[4387]
		],
		[
			[12662, 12662],
			"mapped",
			[4391]
		],
		[
			[12663, 12663],
			"mapped",
			[4393]
		],
		[
			[12664, 12664],
			"mapped",
			[4395]
		],
		[
			[12665, 12665],
			"mapped",
			[4396]
		],
		[
			[12666, 12666],
			"mapped",
			[4397]
		],
		[
			[12667, 12667],
			"mapped",
			[4398]
		],
		[
			[12668, 12668],
			"mapped",
			[4399]
		],
		[
			[12669, 12669],
			"mapped",
			[4402]
		],
		[
			[12670, 12670],
			"mapped",
			[4406]
		],
		[
			[12671, 12671],
			"mapped",
			[4416]
		],
		[
			[12672, 12672],
			"mapped",
			[4423]
		],
		[
			[12673, 12673],
			"mapped",
			[4428]
		],
		[
			[12674, 12674],
			"mapped",
			[4593]
		],
		[
			[12675, 12675],
			"mapped",
			[4594]
		],
		[
			[12676, 12676],
			"mapped",
			[4439]
		],
		[
			[12677, 12677],
			"mapped",
			[4440]
		],
		[
			[12678, 12678],
			"mapped",
			[4441]
		],
		[
			[12679, 12679],
			"mapped",
			[4484]
		],
		[
			[12680, 12680],
			"mapped",
			[4485]
		],
		[
			[12681, 12681],
			"mapped",
			[4488]
		],
		[
			[12682, 12682],
			"mapped",
			[4497]
		],
		[
			[12683, 12683],
			"mapped",
			[4498]
		],
		[
			[12684, 12684],
			"mapped",
			[4500]
		],
		[
			[12685, 12685],
			"mapped",
			[4510]
		],
		[
			[12686, 12686],
			"mapped",
			[4513]
		],
		[[12687, 12687], "disallowed"],
		[
			[12688, 12689],
			"valid",
			[],
			"NV8"
		],
		[
			[12690, 12690],
			"mapped",
			[19968]
		],
		[
			[12691, 12691],
			"mapped",
			[20108]
		],
		[
			[12692, 12692],
			"mapped",
			[19977]
		],
		[
			[12693, 12693],
			"mapped",
			[22235]
		],
		[
			[12694, 12694],
			"mapped",
			[19978]
		],
		[
			[12695, 12695],
			"mapped",
			[20013]
		],
		[
			[12696, 12696],
			"mapped",
			[19979]
		],
		[
			[12697, 12697],
			"mapped",
			[30002]
		],
		[
			[12698, 12698],
			"mapped",
			[20057]
		],
		[
			[12699, 12699],
			"mapped",
			[19993]
		],
		[
			[12700, 12700],
			"mapped",
			[19969]
		],
		[
			[12701, 12701],
			"mapped",
			[22825]
		],
		[
			[12702, 12702],
			"mapped",
			[22320]
		],
		[
			[12703, 12703],
			"mapped",
			[20154]
		],
		[[12704, 12727], "valid"],
		[[12728, 12730], "valid"],
		[[12731, 12735], "disallowed"],
		[
			[12736, 12751],
			"valid",
			[],
			"NV8"
		],
		[
			[12752, 12771],
			"valid",
			[],
			"NV8"
		],
		[[12772, 12783], "disallowed"],
		[[12784, 12799], "valid"],
		[
			[12800, 12800],
			"disallowed_STD3_mapped",
			[
				40,
				4352,
				41
			]
		],
		[
			[12801, 12801],
			"disallowed_STD3_mapped",
			[
				40,
				4354,
				41
			]
		],
		[
			[12802, 12802],
			"disallowed_STD3_mapped",
			[
				40,
				4355,
				41
			]
		],
		[
			[12803, 12803],
			"disallowed_STD3_mapped",
			[
				40,
				4357,
				41
			]
		],
		[
			[12804, 12804],
			"disallowed_STD3_mapped",
			[
				40,
				4358,
				41
			]
		],
		[
			[12805, 12805],
			"disallowed_STD3_mapped",
			[
				40,
				4359,
				41
			]
		],
		[
			[12806, 12806],
			"disallowed_STD3_mapped",
			[
				40,
				4361,
				41
			]
		],
		[
			[12807, 12807],
			"disallowed_STD3_mapped",
			[
				40,
				4363,
				41
			]
		],
		[
			[12808, 12808],
			"disallowed_STD3_mapped",
			[
				40,
				4364,
				41
			]
		],
		[
			[12809, 12809],
			"disallowed_STD3_mapped",
			[
				40,
				4366,
				41
			]
		],
		[
			[12810, 12810],
			"disallowed_STD3_mapped",
			[
				40,
				4367,
				41
			]
		],
		[
			[12811, 12811],
			"disallowed_STD3_mapped",
			[
				40,
				4368,
				41
			]
		],
		[
			[12812, 12812],
			"disallowed_STD3_mapped",
			[
				40,
				4369,
				41
			]
		],
		[
			[12813, 12813],
			"disallowed_STD3_mapped",
			[
				40,
				4370,
				41
			]
		],
		[
			[12814, 12814],
			"disallowed_STD3_mapped",
			[
				40,
				44032,
				41
			]
		],
		[
			[12815, 12815],
			"disallowed_STD3_mapped",
			[
				40,
				45208,
				41
			]
		],
		[
			[12816, 12816],
			"disallowed_STD3_mapped",
			[
				40,
				45796,
				41
			]
		],
		[
			[12817, 12817],
			"disallowed_STD3_mapped",
			[
				40,
				46972,
				41
			]
		],
		[
			[12818, 12818],
			"disallowed_STD3_mapped",
			[
				40,
				47560,
				41
			]
		],
		[
			[12819, 12819],
			"disallowed_STD3_mapped",
			[
				40,
				48148,
				41
			]
		],
		[
			[12820, 12820],
			"disallowed_STD3_mapped",
			[
				40,
				49324,
				41
			]
		],
		[
			[12821, 12821],
			"disallowed_STD3_mapped",
			[
				40,
				50500,
				41
			]
		],
		[
			[12822, 12822],
			"disallowed_STD3_mapped",
			[
				40,
				51088,
				41
			]
		],
		[
			[12823, 12823],
			"disallowed_STD3_mapped",
			[
				40,
				52264,
				41
			]
		],
		[
			[12824, 12824],
			"disallowed_STD3_mapped",
			[
				40,
				52852,
				41
			]
		],
		[
			[12825, 12825],
			"disallowed_STD3_mapped",
			[
				40,
				53440,
				41
			]
		],
		[
			[12826, 12826],
			"disallowed_STD3_mapped",
			[
				40,
				54028,
				41
			]
		],
		[
			[12827, 12827],
			"disallowed_STD3_mapped",
			[
				40,
				54616,
				41
			]
		],
		[
			[12828, 12828],
			"disallowed_STD3_mapped",
			[
				40,
				51452,
				41
			]
		],
		[
			[12829, 12829],
			"disallowed_STD3_mapped",
			[
				40,
				50724,
				51204,
				41
			]
		],
		[
			[12830, 12830],
			"disallowed_STD3_mapped",
			[
				40,
				50724,
				54980,
				41
			]
		],
		[[12831, 12831], "disallowed"],
		[
			[12832, 12832],
			"disallowed_STD3_mapped",
			[
				40,
				19968,
				41
			]
		],
		[
			[12833, 12833],
			"disallowed_STD3_mapped",
			[
				40,
				20108,
				41
			]
		],
		[
			[12834, 12834],
			"disallowed_STD3_mapped",
			[
				40,
				19977,
				41
			]
		],
		[
			[12835, 12835],
			"disallowed_STD3_mapped",
			[
				40,
				22235,
				41
			]
		],
		[
			[12836, 12836],
			"disallowed_STD3_mapped",
			[
				40,
				20116,
				41
			]
		],
		[
			[12837, 12837],
			"disallowed_STD3_mapped",
			[
				40,
				20845,
				41
			]
		],
		[
			[12838, 12838],
			"disallowed_STD3_mapped",
			[
				40,
				19971,
				41
			]
		],
		[
			[12839, 12839],
			"disallowed_STD3_mapped",
			[
				40,
				20843,
				41
			]
		],
		[
			[12840, 12840],
			"disallowed_STD3_mapped",
			[
				40,
				20061,
				41
			]
		],
		[
			[12841, 12841],
			"disallowed_STD3_mapped",
			[
				40,
				21313,
				41
			]
		],
		[
			[12842, 12842],
			"disallowed_STD3_mapped",
			[
				40,
				26376,
				41
			]
		],
		[
			[12843, 12843],
			"disallowed_STD3_mapped",
			[
				40,
				28779,
				41
			]
		],
		[
			[12844, 12844],
			"disallowed_STD3_mapped",
			[
				40,
				27700,
				41
			]
		],
		[
			[12845, 12845],
			"disallowed_STD3_mapped",
			[
				40,
				26408,
				41
			]
		],
		[
			[12846, 12846],
			"disallowed_STD3_mapped",
			[
				40,
				37329,
				41
			]
		],
		[
			[12847, 12847],
			"disallowed_STD3_mapped",
			[
				40,
				22303,
				41
			]
		],
		[
			[12848, 12848],
			"disallowed_STD3_mapped",
			[
				40,
				26085,
				41
			]
		],
		[
			[12849, 12849],
			"disallowed_STD3_mapped",
			[
				40,
				26666,
				41
			]
		],
		[
			[12850, 12850],
			"disallowed_STD3_mapped",
			[
				40,
				26377,
				41
			]
		],
		[
			[12851, 12851],
			"disallowed_STD3_mapped",
			[
				40,
				31038,
				41
			]
		],
		[
			[12852, 12852],
			"disallowed_STD3_mapped",
			[
				40,
				21517,
				41
			]
		],
		[
			[12853, 12853],
			"disallowed_STD3_mapped",
			[
				40,
				29305,
				41
			]
		],
		[
			[12854, 12854],
			"disallowed_STD3_mapped",
			[
				40,
				36001,
				41
			]
		],
		[
			[12855, 12855],
			"disallowed_STD3_mapped",
			[
				40,
				31069,
				41
			]
		],
		[
			[12856, 12856],
			"disallowed_STD3_mapped",
			[
				40,
				21172,
				41
			]
		],
		[
			[12857, 12857],
			"disallowed_STD3_mapped",
			[
				40,
				20195,
				41
			]
		],
		[
			[12858, 12858],
			"disallowed_STD3_mapped",
			[
				40,
				21628,
				41
			]
		],
		[
			[12859, 12859],
			"disallowed_STD3_mapped",
			[
				40,
				23398,
				41
			]
		],
		[
			[12860, 12860],
			"disallowed_STD3_mapped",
			[
				40,
				30435,
				41
			]
		],
		[
			[12861, 12861],
			"disallowed_STD3_mapped",
			[
				40,
				20225,
				41
			]
		],
		[
			[12862, 12862],
			"disallowed_STD3_mapped",
			[
				40,
				36039,
				41
			]
		],
		[
			[12863, 12863],
			"disallowed_STD3_mapped",
			[
				40,
				21332,
				41
			]
		],
		[
			[12864, 12864],
			"disallowed_STD3_mapped",
			[
				40,
				31085,
				41
			]
		],
		[
			[12865, 12865],
			"disallowed_STD3_mapped",
			[
				40,
				20241,
				41
			]
		],
		[
			[12866, 12866],
			"disallowed_STD3_mapped",
			[
				40,
				33258,
				41
			]
		],
		[
			[12867, 12867],
			"disallowed_STD3_mapped",
			[
				40,
				33267,
				41
			]
		],
		[
			[12868, 12868],
			"mapped",
			[21839]
		],
		[
			[12869, 12869],
			"mapped",
			[24188]
		],
		[
			[12870, 12870],
			"mapped",
			[25991]
		],
		[
			[12871, 12871],
			"mapped",
			[31631]
		],
		[
			[12872, 12879],
			"valid",
			[],
			"NV8"
		],
		[
			[12880, 12880],
			"mapped",
			[
				112,
				116,
				101
			]
		],
		[
			[12881, 12881],
			"mapped",
			[50, 49]
		],
		[
			[12882, 12882],
			"mapped",
			[50, 50]
		],
		[
			[12883, 12883],
			"mapped",
			[50, 51]
		],
		[
			[12884, 12884],
			"mapped",
			[50, 52]
		],
		[
			[12885, 12885],
			"mapped",
			[50, 53]
		],
		[
			[12886, 12886],
			"mapped",
			[50, 54]
		],
		[
			[12887, 12887],
			"mapped",
			[50, 55]
		],
		[
			[12888, 12888],
			"mapped",
			[50, 56]
		],
		[
			[12889, 12889],
			"mapped",
			[50, 57]
		],
		[
			[12890, 12890],
			"mapped",
			[51, 48]
		],
		[
			[12891, 12891],
			"mapped",
			[51, 49]
		],
		[
			[12892, 12892],
			"mapped",
			[51, 50]
		],
		[
			[12893, 12893],
			"mapped",
			[51, 51]
		],
		[
			[12894, 12894],
			"mapped",
			[51, 52]
		],
		[
			[12895, 12895],
			"mapped",
			[51, 53]
		],
		[
			[12896, 12896],
			"mapped",
			[4352]
		],
		[
			[12897, 12897],
			"mapped",
			[4354]
		],
		[
			[12898, 12898],
			"mapped",
			[4355]
		],
		[
			[12899, 12899],
			"mapped",
			[4357]
		],
		[
			[12900, 12900],
			"mapped",
			[4358]
		],
		[
			[12901, 12901],
			"mapped",
			[4359]
		],
		[
			[12902, 12902],
			"mapped",
			[4361]
		],
		[
			[12903, 12903],
			"mapped",
			[4363]
		],
		[
			[12904, 12904],
			"mapped",
			[4364]
		],
		[
			[12905, 12905],
			"mapped",
			[4366]
		],
		[
			[12906, 12906],
			"mapped",
			[4367]
		],
		[
			[12907, 12907],
			"mapped",
			[4368]
		],
		[
			[12908, 12908],
			"mapped",
			[4369]
		],
		[
			[12909, 12909],
			"mapped",
			[4370]
		],
		[
			[12910, 12910],
			"mapped",
			[44032]
		],
		[
			[12911, 12911],
			"mapped",
			[45208]
		],
		[
			[12912, 12912],
			"mapped",
			[45796]
		],
		[
			[12913, 12913],
			"mapped",
			[46972]
		],
		[
			[12914, 12914],
			"mapped",
			[47560]
		],
		[
			[12915, 12915],
			"mapped",
			[48148]
		],
		[
			[12916, 12916],
			"mapped",
			[49324]
		],
		[
			[12917, 12917],
			"mapped",
			[50500]
		],
		[
			[12918, 12918],
			"mapped",
			[51088]
		],
		[
			[12919, 12919],
			"mapped",
			[52264]
		],
		[
			[12920, 12920],
			"mapped",
			[52852]
		],
		[
			[12921, 12921],
			"mapped",
			[53440]
		],
		[
			[12922, 12922],
			"mapped",
			[54028]
		],
		[
			[12923, 12923],
			"mapped",
			[54616]
		],
		[
			[12924, 12924],
			"mapped",
			[52280, 44256]
		],
		[
			[12925, 12925],
			"mapped",
			[51452, 51032]
		],
		[
			[12926, 12926],
			"mapped",
			[50864]
		],
		[
			[12927, 12927],
			"valid",
			[],
			"NV8"
		],
		[
			[12928, 12928],
			"mapped",
			[19968]
		],
		[
			[12929, 12929],
			"mapped",
			[20108]
		],
		[
			[12930, 12930],
			"mapped",
			[19977]
		],
		[
			[12931, 12931],
			"mapped",
			[22235]
		],
		[
			[12932, 12932],
			"mapped",
			[20116]
		],
		[
			[12933, 12933],
			"mapped",
			[20845]
		],
		[
			[12934, 12934],
			"mapped",
			[19971]
		],
		[
			[12935, 12935],
			"mapped",
			[20843]
		],
		[
			[12936, 12936],
			"mapped",
			[20061]
		],
		[
			[12937, 12937],
			"mapped",
			[21313]
		],
		[
			[12938, 12938],
			"mapped",
			[26376]
		],
		[
			[12939, 12939],
			"mapped",
			[28779]
		],
		[
			[12940, 12940],
			"mapped",
			[27700]
		],
		[
			[12941, 12941],
			"mapped",
			[26408]
		],
		[
			[12942, 12942],
			"mapped",
			[37329]
		],
		[
			[12943, 12943],
			"mapped",
			[22303]
		],
		[
			[12944, 12944],
			"mapped",
			[26085]
		],
		[
			[12945, 12945],
			"mapped",
			[26666]
		],
		[
			[12946, 12946],
			"mapped",
			[26377]
		],
		[
			[12947, 12947],
			"mapped",
			[31038]
		],
		[
			[12948, 12948],
			"mapped",
			[21517]
		],
		[
			[12949, 12949],
			"mapped",
			[29305]
		],
		[
			[12950, 12950],
			"mapped",
			[36001]
		],
		[
			[12951, 12951],
			"mapped",
			[31069]
		],
		[
			[12952, 12952],
			"mapped",
			[21172]
		],
		[
			[12953, 12953],
			"mapped",
			[31192]
		],
		[
			[12954, 12954],
			"mapped",
			[30007]
		],
		[
			[12955, 12955],
			"mapped",
			[22899]
		],
		[
			[12956, 12956],
			"mapped",
			[36969]
		],
		[
			[12957, 12957],
			"mapped",
			[20778]
		],
		[
			[12958, 12958],
			"mapped",
			[21360]
		],
		[
			[12959, 12959],
			"mapped",
			[27880]
		],
		[
			[12960, 12960],
			"mapped",
			[38917]
		],
		[
			[12961, 12961],
			"mapped",
			[20241]
		],
		[
			[12962, 12962],
			"mapped",
			[20889]
		],
		[
			[12963, 12963],
			"mapped",
			[27491]
		],
		[
			[12964, 12964],
			"mapped",
			[19978]
		],
		[
			[12965, 12965],
			"mapped",
			[20013]
		],
		[
			[12966, 12966],
			"mapped",
			[19979]
		],
		[
			[12967, 12967],
			"mapped",
			[24038]
		],
		[
			[12968, 12968],
			"mapped",
			[21491]
		],
		[
			[12969, 12969],
			"mapped",
			[21307]
		],
		[
			[12970, 12970],
			"mapped",
			[23447]
		],
		[
			[12971, 12971],
			"mapped",
			[23398]
		],
		[
			[12972, 12972],
			"mapped",
			[30435]
		],
		[
			[12973, 12973],
			"mapped",
			[20225]
		],
		[
			[12974, 12974],
			"mapped",
			[36039]
		],
		[
			[12975, 12975],
			"mapped",
			[21332]
		],
		[
			[12976, 12976],
			"mapped",
			[22812]
		],
		[
			[12977, 12977],
			"mapped",
			[51, 54]
		],
		[
			[12978, 12978],
			"mapped",
			[51, 55]
		],
		[
			[12979, 12979],
			"mapped",
			[51, 56]
		],
		[
			[12980, 12980],
			"mapped",
			[51, 57]
		],
		[
			[12981, 12981],
			"mapped",
			[52, 48]
		],
		[
			[12982, 12982],
			"mapped",
			[52, 49]
		],
		[
			[12983, 12983],
			"mapped",
			[52, 50]
		],
		[
			[12984, 12984],
			"mapped",
			[52, 51]
		],
		[
			[12985, 12985],
			"mapped",
			[52, 52]
		],
		[
			[12986, 12986],
			"mapped",
			[52, 53]
		],
		[
			[12987, 12987],
			"mapped",
			[52, 54]
		],
		[
			[12988, 12988],
			"mapped",
			[52, 55]
		],
		[
			[12989, 12989],
			"mapped",
			[52, 56]
		],
		[
			[12990, 12990],
			"mapped",
			[52, 57]
		],
		[
			[12991, 12991],
			"mapped",
			[53, 48]
		],
		[
			[12992, 12992],
			"mapped",
			[49, 26376]
		],
		[
			[12993, 12993],
			"mapped",
			[50, 26376]
		],
		[
			[12994, 12994],
			"mapped",
			[51, 26376]
		],
		[
			[12995, 12995],
			"mapped",
			[52, 26376]
		],
		[
			[12996, 12996],
			"mapped",
			[53, 26376]
		],
		[
			[12997, 12997],
			"mapped",
			[54, 26376]
		],
		[
			[12998, 12998],
			"mapped",
			[55, 26376]
		],
		[
			[12999, 12999],
			"mapped",
			[56, 26376]
		],
		[
			[13e3, 13e3],
			"mapped",
			[57, 26376]
		],
		[
			[13001, 13001],
			"mapped",
			[
				49,
				48,
				26376
			]
		],
		[
			[13002, 13002],
			"mapped",
			[
				49,
				49,
				26376
			]
		],
		[
			[13003, 13003],
			"mapped",
			[
				49,
				50,
				26376
			]
		],
		[
			[13004, 13004],
			"mapped",
			[104, 103]
		],
		[
			[13005, 13005],
			"mapped",
			[
				101,
				114,
				103
			]
		],
		[
			[13006, 13006],
			"mapped",
			[101, 118]
		],
		[
			[13007, 13007],
			"mapped",
			[
				108,
				116,
				100
			]
		],
		[
			[13008, 13008],
			"mapped",
			[12450]
		],
		[
			[13009, 13009],
			"mapped",
			[12452]
		],
		[
			[13010, 13010],
			"mapped",
			[12454]
		],
		[
			[13011, 13011],
			"mapped",
			[12456]
		],
		[
			[13012, 13012],
			"mapped",
			[12458]
		],
		[
			[13013, 13013],
			"mapped",
			[12459]
		],
		[
			[13014, 13014],
			"mapped",
			[12461]
		],
		[
			[13015, 13015],
			"mapped",
			[12463]
		],
		[
			[13016, 13016],
			"mapped",
			[12465]
		],
		[
			[13017, 13017],
			"mapped",
			[12467]
		],
		[
			[13018, 13018],
			"mapped",
			[12469]
		],
		[
			[13019, 13019],
			"mapped",
			[12471]
		],
		[
			[13020, 13020],
			"mapped",
			[12473]
		],
		[
			[13021, 13021],
			"mapped",
			[12475]
		],
		[
			[13022, 13022],
			"mapped",
			[12477]
		],
		[
			[13023, 13023],
			"mapped",
			[12479]
		],
		[
			[13024, 13024],
			"mapped",
			[12481]
		],
		[
			[13025, 13025],
			"mapped",
			[12484]
		],
		[
			[13026, 13026],
			"mapped",
			[12486]
		],
		[
			[13027, 13027],
			"mapped",
			[12488]
		],
		[
			[13028, 13028],
			"mapped",
			[12490]
		],
		[
			[13029, 13029],
			"mapped",
			[12491]
		],
		[
			[13030, 13030],
			"mapped",
			[12492]
		],
		[
			[13031, 13031],
			"mapped",
			[12493]
		],
		[
			[13032, 13032],
			"mapped",
			[12494]
		],
		[
			[13033, 13033],
			"mapped",
			[12495]
		],
		[
			[13034, 13034],
			"mapped",
			[12498]
		],
		[
			[13035, 13035],
			"mapped",
			[12501]
		],
		[
			[13036, 13036],
			"mapped",
			[12504]
		],
		[
			[13037, 13037],
			"mapped",
			[12507]
		],
		[
			[13038, 13038],
			"mapped",
			[12510]
		],
		[
			[13039, 13039],
			"mapped",
			[12511]
		],
		[
			[13040, 13040],
			"mapped",
			[12512]
		],
		[
			[13041, 13041],
			"mapped",
			[12513]
		],
		[
			[13042, 13042],
			"mapped",
			[12514]
		],
		[
			[13043, 13043],
			"mapped",
			[12516]
		],
		[
			[13044, 13044],
			"mapped",
			[12518]
		],
		[
			[13045, 13045],
			"mapped",
			[12520]
		],
		[
			[13046, 13046],
			"mapped",
			[12521]
		],
		[
			[13047, 13047],
			"mapped",
			[12522]
		],
		[
			[13048, 13048],
			"mapped",
			[12523]
		],
		[
			[13049, 13049],
			"mapped",
			[12524]
		],
		[
			[13050, 13050],
			"mapped",
			[12525]
		],
		[
			[13051, 13051],
			"mapped",
			[12527]
		],
		[
			[13052, 13052],
			"mapped",
			[12528]
		],
		[
			[13053, 13053],
			"mapped",
			[12529]
		],
		[
			[13054, 13054],
			"mapped",
			[12530]
		],
		[[13055, 13055], "disallowed"],
		[
			[13056, 13056],
			"mapped",
			[
				12450,
				12497,
				12540,
				12488
			]
		],
		[
			[13057, 13057],
			"mapped",
			[
				12450,
				12523,
				12501,
				12449
			]
		],
		[
			[13058, 13058],
			"mapped",
			[
				12450,
				12531,
				12506,
				12450
			]
		],
		[
			[13059, 13059],
			"mapped",
			[
				12450,
				12540,
				12523
			]
		],
		[
			[13060, 13060],
			"mapped",
			[
				12452,
				12491,
				12531,
				12464
			]
		],
		[
			[13061, 13061],
			"mapped",
			[
				12452,
				12531,
				12481
			]
		],
		[
			[13062, 13062],
			"mapped",
			[
				12454,
				12457,
				12531
			]
		],
		[
			[13063, 13063],
			"mapped",
			[
				12456,
				12473,
				12463,
				12540,
				12489
			]
		],
		[
			[13064, 13064],
			"mapped",
			[
				12456,
				12540,
				12459,
				12540
			]
		],
		[
			[13065, 13065],
			"mapped",
			[
				12458,
				12531,
				12473
			]
		],
		[
			[13066, 13066],
			"mapped",
			[
				12458,
				12540,
				12512
			]
		],
		[
			[13067, 13067],
			"mapped",
			[
				12459,
				12452,
				12522
			]
		],
		[
			[13068, 13068],
			"mapped",
			[
				12459,
				12521,
				12483,
				12488
			]
		],
		[
			[13069, 13069],
			"mapped",
			[
				12459,
				12525,
				12522,
				12540
			]
		],
		[
			[13070, 13070],
			"mapped",
			[
				12460,
				12525,
				12531
			]
		],
		[
			[13071, 13071],
			"mapped",
			[
				12460,
				12531,
				12510
			]
		],
		[
			[13072, 13072],
			"mapped",
			[12462, 12460]
		],
		[
			[13073, 13073],
			"mapped",
			[
				12462,
				12491,
				12540
			]
		],
		[
			[13074, 13074],
			"mapped",
			[
				12461,
				12517,
				12522,
				12540
			]
		],
		[
			[13075, 13075],
			"mapped",
			[
				12462,
				12523,
				12480,
				12540
			]
		],
		[
			[13076, 13076],
			"mapped",
			[12461, 12525]
		],
		[
			[13077, 13077],
			"mapped",
			[
				12461,
				12525,
				12464,
				12521,
				12512
			]
		],
		[
			[13078, 13078],
			"mapped",
			[
				12461,
				12525,
				12513,
				12540,
				12488,
				12523
			]
		],
		[
			[13079, 13079],
			"mapped",
			[
				12461,
				12525,
				12527,
				12483,
				12488
			]
		],
		[
			[13080, 13080],
			"mapped",
			[
				12464,
				12521,
				12512
			]
		],
		[
			[13081, 13081],
			"mapped",
			[
				12464,
				12521,
				12512,
				12488,
				12531
			]
		],
		[
			[13082, 13082],
			"mapped",
			[
				12463,
				12523,
				12476,
				12452,
				12525
			]
		],
		[
			[13083, 13083],
			"mapped",
			[
				12463,
				12525,
				12540,
				12493
			]
		],
		[
			[13084, 13084],
			"mapped",
			[
				12465,
				12540,
				12473
			]
		],
		[
			[13085, 13085],
			"mapped",
			[
				12467,
				12523,
				12490
			]
		],
		[
			[13086, 13086],
			"mapped",
			[
				12467,
				12540,
				12509
			]
		],
		[
			[13087, 13087],
			"mapped",
			[
				12469,
				12452,
				12463,
				12523
			]
		],
		[
			[13088, 13088],
			"mapped",
			[
				12469,
				12531,
				12481,
				12540,
				12512
			]
		],
		[
			[13089, 13089],
			"mapped",
			[
				12471,
				12522,
				12531,
				12464
			]
		],
		[
			[13090, 13090],
			"mapped",
			[
				12475,
				12531,
				12481
			]
		],
		[
			[13091, 13091],
			"mapped",
			[
				12475,
				12531,
				12488
			]
		],
		[
			[13092, 13092],
			"mapped",
			[
				12480,
				12540,
				12473
			]
		],
		[
			[13093, 13093],
			"mapped",
			[12487, 12471]
		],
		[
			[13094, 13094],
			"mapped",
			[12489, 12523]
		],
		[
			[13095, 13095],
			"mapped",
			[12488, 12531]
		],
		[
			[13096, 13096],
			"mapped",
			[12490, 12494]
		],
		[
			[13097, 13097],
			"mapped",
			[
				12494,
				12483,
				12488
			]
		],
		[
			[13098, 13098],
			"mapped",
			[
				12495,
				12452,
				12484
			]
		],
		[
			[13099, 13099],
			"mapped",
			[
				12497,
				12540,
				12475,
				12531,
				12488
			]
		],
		[
			[13100, 13100],
			"mapped",
			[
				12497,
				12540,
				12484
			]
		],
		[
			[13101, 13101],
			"mapped",
			[
				12496,
				12540,
				12524,
				12523
			]
		],
		[
			[13102, 13102],
			"mapped",
			[
				12500,
				12450,
				12473,
				12488,
				12523
			]
		],
		[
			[13103, 13103],
			"mapped",
			[
				12500,
				12463,
				12523
			]
		],
		[
			[13104, 13104],
			"mapped",
			[12500, 12467]
		],
		[
			[13105, 13105],
			"mapped",
			[12499, 12523]
		],
		[
			[13106, 13106],
			"mapped",
			[
				12501,
				12449,
				12521,
				12483,
				12489
			]
		],
		[
			[13107, 13107],
			"mapped",
			[
				12501,
				12451,
				12540,
				12488
			]
		],
		[
			[13108, 13108],
			"mapped",
			[
				12502,
				12483,
				12471,
				12455,
				12523
			]
		],
		[
			[13109, 13109],
			"mapped",
			[
				12501,
				12521,
				12531
			]
		],
		[
			[13110, 13110],
			"mapped",
			[
				12504,
				12463,
				12479,
				12540,
				12523
			]
		],
		[
			[13111, 13111],
			"mapped",
			[12506, 12477]
		],
		[
			[13112, 13112],
			"mapped",
			[
				12506,
				12491,
				12498
			]
		],
		[
			[13113, 13113],
			"mapped",
			[
				12504,
				12523,
				12484
			]
		],
		[
			[13114, 13114],
			"mapped",
			[
				12506,
				12531,
				12473
			]
		],
		[
			[13115, 13115],
			"mapped",
			[
				12506,
				12540,
				12472
			]
		],
		[
			[13116, 13116],
			"mapped",
			[
				12505,
				12540,
				12479
			]
		],
		[
			[13117, 13117],
			"mapped",
			[
				12509,
				12452,
				12531,
				12488
			]
		],
		[
			[13118, 13118],
			"mapped",
			[
				12508,
				12523,
				12488
			]
		],
		[
			[13119, 13119],
			"mapped",
			[12507, 12531]
		],
		[
			[13120, 13120],
			"mapped",
			[
				12509,
				12531,
				12489
			]
		],
		[
			[13121, 13121],
			"mapped",
			[
				12507,
				12540,
				12523
			]
		],
		[
			[13122, 13122],
			"mapped",
			[
				12507,
				12540,
				12531
			]
		],
		[
			[13123, 13123],
			"mapped",
			[
				12510,
				12452,
				12463,
				12525
			]
		],
		[
			[13124, 13124],
			"mapped",
			[
				12510,
				12452,
				12523
			]
		],
		[
			[13125, 13125],
			"mapped",
			[
				12510,
				12483,
				12495
			]
		],
		[
			[13126, 13126],
			"mapped",
			[
				12510,
				12523,
				12463
			]
		],
		[
			[13127, 13127],
			"mapped",
			[
				12510,
				12531,
				12471,
				12519,
				12531
			]
		],
		[
			[13128, 13128],
			"mapped",
			[
				12511,
				12463,
				12525,
				12531
			]
		],
		[
			[13129, 13129],
			"mapped",
			[12511, 12522]
		],
		[
			[13130, 13130],
			"mapped",
			[
				12511,
				12522,
				12496,
				12540,
				12523
			]
		],
		[
			[13131, 13131],
			"mapped",
			[12513, 12460]
		],
		[
			[13132, 13132],
			"mapped",
			[
				12513,
				12460,
				12488,
				12531
			]
		],
		[
			[13133, 13133],
			"mapped",
			[
				12513,
				12540,
				12488,
				12523
			]
		],
		[
			[13134, 13134],
			"mapped",
			[
				12516,
				12540,
				12489
			]
		],
		[
			[13135, 13135],
			"mapped",
			[
				12516,
				12540,
				12523
			]
		],
		[
			[13136, 13136],
			"mapped",
			[
				12518,
				12450,
				12531
			]
		],
		[
			[13137, 13137],
			"mapped",
			[
				12522,
				12483,
				12488,
				12523
			]
		],
		[
			[13138, 13138],
			"mapped",
			[12522, 12521]
		],
		[
			[13139, 13139],
			"mapped",
			[
				12523,
				12500,
				12540
			]
		],
		[
			[13140, 13140],
			"mapped",
			[
				12523,
				12540,
				12502,
				12523
			]
		],
		[
			[13141, 13141],
			"mapped",
			[12524, 12512]
		],
		[
			[13142, 13142],
			"mapped",
			[
				12524,
				12531,
				12488,
				12466,
				12531
			]
		],
		[
			[13143, 13143],
			"mapped",
			[
				12527,
				12483,
				12488
			]
		],
		[
			[13144, 13144],
			"mapped",
			[48, 28857]
		],
		[
			[13145, 13145],
			"mapped",
			[49, 28857]
		],
		[
			[13146, 13146],
			"mapped",
			[50, 28857]
		],
		[
			[13147, 13147],
			"mapped",
			[51, 28857]
		],
		[
			[13148, 13148],
			"mapped",
			[52, 28857]
		],
		[
			[13149, 13149],
			"mapped",
			[53, 28857]
		],
		[
			[13150, 13150],
			"mapped",
			[54, 28857]
		],
		[
			[13151, 13151],
			"mapped",
			[55, 28857]
		],
		[
			[13152, 13152],
			"mapped",
			[56, 28857]
		],
		[
			[13153, 13153],
			"mapped",
			[57, 28857]
		],
		[
			[13154, 13154],
			"mapped",
			[
				49,
				48,
				28857
			]
		],
		[
			[13155, 13155],
			"mapped",
			[
				49,
				49,
				28857
			]
		],
		[
			[13156, 13156],
			"mapped",
			[
				49,
				50,
				28857
			]
		],
		[
			[13157, 13157],
			"mapped",
			[
				49,
				51,
				28857
			]
		],
		[
			[13158, 13158],
			"mapped",
			[
				49,
				52,
				28857
			]
		],
		[
			[13159, 13159],
			"mapped",
			[
				49,
				53,
				28857
			]
		],
		[
			[13160, 13160],
			"mapped",
			[
				49,
				54,
				28857
			]
		],
		[
			[13161, 13161],
			"mapped",
			[
				49,
				55,
				28857
			]
		],
		[
			[13162, 13162],
			"mapped",
			[
				49,
				56,
				28857
			]
		],
		[
			[13163, 13163],
			"mapped",
			[
				49,
				57,
				28857
			]
		],
		[
			[13164, 13164],
			"mapped",
			[
				50,
				48,
				28857
			]
		],
		[
			[13165, 13165],
			"mapped",
			[
				50,
				49,
				28857
			]
		],
		[
			[13166, 13166],
			"mapped",
			[
				50,
				50,
				28857
			]
		],
		[
			[13167, 13167],
			"mapped",
			[
				50,
				51,
				28857
			]
		],
		[
			[13168, 13168],
			"mapped",
			[
				50,
				52,
				28857
			]
		],
		[
			[13169, 13169],
			"mapped",
			[
				104,
				112,
				97
			]
		],
		[
			[13170, 13170],
			"mapped",
			[100, 97]
		],
		[
			[13171, 13171],
			"mapped",
			[97, 117]
		],
		[
			[13172, 13172],
			"mapped",
			[
				98,
				97,
				114
			]
		],
		[
			[13173, 13173],
			"mapped",
			[111, 118]
		],
		[
			[13174, 13174],
			"mapped",
			[112, 99]
		],
		[
			[13175, 13175],
			"mapped",
			[100, 109]
		],
		[
			[13176, 13176],
			"mapped",
			[
				100,
				109,
				50
			]
		],
		[
			[13177, 13177],
			"mapped",
			[
				100,
				109,
				51
			]
		],
		[
			[13178, 13178],
			"mapped",
			[105, 117]
		],
		[
			[13179, 13179],
			"mapped",
			[24179, 25104]
		],
		[
			[13180, 13180],
			"mapped",
			[26157, 21644]
		],
		[
			[13181, 13181],
			"mapped",
			[22823, 27491]
		],
		[
			[13182, 13182],
			"mapped",
			[26126, 27835]
		],
		[
			[13183, 13183],
			"mapped",
			[
				26666,
				24335,
				20250,
				31038
			]
		],
		[
			[13184, 13184],
			"mapped",
			[112, 97]
		],
		[
			[13185, 13185],
			"mapped",
			[110, 97]
		],
		[
			[13186, 13186],
			"mapped",
			[956, 97]
		],
		[
			[13187, 13187],
			"mapped",
			[109, 97]
		],
		[
			[13188, 13188],
			"mapped",
			[107, 97]
		],
		[
			[13189, 13189],
			"mapped",
			[107, 98]
		],
		[
			[13190, 13190],
			"mapped",
			[109, 98]
		],
		[
			[13191, 13191],
			"mapped",
			[103, 98]
		],
		[
			[13192, 13192],
			"mapped",
			[
				99,
				97,
				108
			]
		],
		[
			[13193, 13193],
			"mapped",
			[
				107,
				99,
				97,
				108
			]
		],
		[
			[13194, 13194],
			"mapped",
			[112, 102]
		],
		[
			[13195, 13195],
			"mapped",
			[110, 102]
		],
		[
			[13196, 13196],
			"mapped",
			[956, 102]
		],
		[
			[13197, 13197],
			"mapped",
			[956, 103]
		],
		[
			[13198, 13198],
			"mapped",
			[109, 103]
		],
		[
			[13199, 13199],
			"mapped",
			[107, 103]
		],
		[
			[13200, 13200],
			"mapped",
			[104, 122]
		],
		[
			[13201, 13201],
			"mapped",
			[
				107,
				104,
				122
			]
		],
		[
			[13202, 13202],
			"mapped",
			[
				109,
				104,
				122
			]
		],
		[
			[13203, 13203],
			"mapped",
			[
				103,
				104,
				122
			]
		],
		[
			[13204, 13204],
			"mapped",
			[
				116,
				104,
				122
			]
		],
		[
			[13205, 13205],
			"mapped",
			[956, 108]
		],
		[
			[13206, 13206],
			"mapped",
			[109, 108]
		],
		[
			[13207, 13207],
			"mapped",
			[100, 108]
		],
		[
			[13208, 13208],
			"mapped",
			[107, 108]
		],
		[
			[13209, 13209],
			"mapped",
			[102, 109]
		],
		[
			[13210, 13210],
			"mapped",
			[110, 109]
		],
		[
			[13211, 13211],
			"mapped",
			[956, 109]
		],
		[
			[13212, 13212],
			"mapped",
			[109, 109]
		],
		[
			[13213, 13213],
			"mapped",
			[99, 109]
		],
		[
			[13214, 13214],
			"mapped",
			[107, 109]
		],
		[
			[13215, 13215],
			"mapped",
			[
				109,
				109,
				50
			]
		],
		[
			[13216, 13216],
			"mapped",
			[
				99,
				109,
				50
			]
		],
		[
			[13217, 13217],
			"mapped",
			[109, 50]
		],
		[
			[13218, 13218],
			"mapped",
			[
				107,
				109,
				50
			]
		],
		[
			[13219, 13219],
			"mapped",
			[
				109,
				109,
				51
			]
		],
		[
			[13220, 13220],
			"mapped",
			[
				99,
				109,
				51
			]
		],
		[
			[13221, 13221],
			"mapped",
			[109, 51]
		],
		[
			[13222, 13222],
			"mapped",
			[
				107,
				109,
				51
			]
		],
		[
			[13223, 13223],
			"mapped",
			[
				109,
				8725,
				115
			]
		],
		[
			[13224, 13224],
			"mapped",
			[
				109,
				8725,
				115,
				50
			]
		],
		[
			[13225, 13225],
			"mapped",
			[112, 97]
		],
		[
			[13226, 13226],
			"mapped",
			[
				107,
				112,
				97
			]
		],
		[
			[13227, 13227],
			"mapped",
			[
				109,
				112,
				97
			]
		],
		[
			[13228, 13228],
			"mapped",
			[
				103,
				112,
				97
			]
		],
		[
			[13229, 13229],
			"mapped",
			[
				114,
				97,
				100
			]
		],
		[
			[13230, 13230],
			"mapped",
			[
				114,
				97,
				100,
				8725,
				115
			]
		],
		[
			[13231, 13231],
			"mapped",
			[
				114,
				97,
				100,
				8725,
				115,
				50
			]
		],
		[
			[13232, 13232],
			"mapped",
			[112, 115]
		],
		[
			[13233, 13233],
			"mapped",
			[110, 115]
		],
		[
			[13234, 13234],
			"mapped",
			[956, 115]
		],
		[
			[13235, 13235],
			"mapped",
			[109, 115]
		],
		[
			[13236, 13236],
			"mapped",
			[112, 118]
		],
		[
			[13237, 13237],
			"mapped",
			[110, 118]
		],
		[
			[13238, 13238],
			"mapped",
			[956, 118]
		],
		[
			[13239, 13239],
			"mapped",
			[109, 118]
		],
		[
			[13240, 13240],
			"mapped",
			[107, 118]
		],
		[
			[13241, 13241],
			"mapped",
			[109, 118]
		],
		[
			[13242, 13242],
			"mapped",
			[112, 119]
		],
		[
			[13243, 13243],
			"mapped",
			[110, 119]
		],
		[
			[13244, 13244],
			"mapped",
			[956, 119]
		],
		[
			[13245, 13245],
			"mapped",
			[109, 119]
		],
		[
			[13246, 13246],
			"mapped",
			[107, 119]
		],
		[
			[13247, 13247],
			"mapped",
			[109, 119]
		],
		[
			[13248, 13248],
			"mapped",
			[107, 969]
		],
		[
			[13249, 13249],
			"mapped",
			[109, 969]
		],
		[[13250, 13250], "disallowed"],
		[
			[13251, 13251],
			"mapped",
			[98, 113]
		],
		[
			[13252, 13252],
			"mapped",
			[99, 99]
		],
		[
			[13253, 13253],
			"mapped",
			[99, 100]
		],
		[
			[13254, 13254],
			"mapped",
			[
				99,
				8725,
				107,
				103
			]
		],
		[[13255, 13255], "disallowed"],
		[
			[13256, 13256],
			"mapped",
			[100, 98]
		],
		[
			[13257, 13257],
			"mapped",
			[103, 121]
		],
		[
			[13258, 13258],
			"mapped",
			[104, 97]
		],
		[
			[13259, 13259],
			"mapped",
			[104, 112]
		],
		[
			[13260, 13260],
			"mapped",
			[105, 110]
		],
		[
			[13261, 13261],
			"mapped",
			[107, 107]
		],
		[
			[13262, 13262],
			"mapped",
			[107, 109]
		],
		[
			[13263, 13263],
			"mapped",
			[107, 116]
		],
		[
			[13264, 13264],
			"mapped",
			[108, 109]
		],
		[
			[13265, 13265],
			"mapped",
			[108, 110]
		],
		[
			[13266, 13266],
			"mapped",
			[
				108,
				111,
				103
			]
		],
		[
			[13267, 13267],
			"mapped",
			[108, 120]
		],
		[
			[13268, 13268],
			"mapped",
			[109, 98]
		],
		[
			[13269, 13269],
			"mapped",
			[
				109,
				105,
				108
			]
		],
		[
			[13270, 13270],
			"mapped",
			[
				109,
				111,
				108
			]
		],
		[
			[13271, 13271],
			"mapped",
			[112, 104]
		],
		[[13272, 13272], "disallowed"],
		[
			[13273, 13273],
			"mapped",
			[
				112,
				112,
				109
			]
		],
		[
			[13274, 13274],
			"mapped",
			[112, 114]
		],
		[
			[13275, 13275],
			"mapped",
			[115, 114]
		],
		[
			[13276, 13276],
			"mapped",
			[115, 118]
		],
		[
			[13277, 13277],
			"mapped",
			[119, 98]
		],
		[
			[13278, 13278],
			"mapped",
			[
				118,
				8725,
				109
			]
		],
		[
			[13279, 13279],
			"mapped",
			[
				97,
				8725,
				109
			]
		],
		[
			[13280, 13280],
			"mapped",
			[49, 26085]
		],
		[
			[13281, 13281],
			"mapped",
			[50, 26085]
		],
		[
			[13282, 13282],
			"mapped",
			[51, 26085]
		],
		[
			[13283, 13283],
			"mapped",
			[52, 26085]
		],
		[
			[13284, 13284],
			"mapped",
			[53, 26085]
		],
		[
			[13285, 13285],
			"mapped",
			[54, 26085]
		],
		[
			[13286, 13286],
			"mapped",
			[55, 26085]
		],
		[
			[13287, 13287],
			"mapped",
			[56, 26085]
		],
		[
			[13288, 13288],
			"mapped",
			[57, 26085]
		],
		[
			[13289, 13289],
			"mapped",
			[
				49,
				48,
				26085
			]
		],
		[
			[13290, 13290],
			"mapped",
			[
				49,
				49,
				26085
			]
		],
		[
			[13291, 13291],
			"mapped",
			[
				49,
				50,
				26085
			]
		],
		[
			[13292, 13292],
			"mapped",
			[
				49,
				51,
				26085
			]
		],
		[
			[13293, 13293],
			"mapped",
			[
				49,
				52,
				26085
			]
		],
		[
			[13294, 13294],
			"mapped",
			[
				49,
				53,
				26085
			]
		],
		[
			[13295, 13295],
			"mapped",
			[
				49,
				54,
				26085
			]
		],
		[
			[13296, 13296],
			"mapped",
			[
				49,
				55,
				26085
			]
		],
		[
			[13297, 13297],
			"mapped",
			[
				49,
				56,
				26085
			]
		],
		[
			[13298, 13298],
			"mapped",
			[
				49,
				57,
				26085
			]
		],
		[
			[13299, 13299],
			"mapped",
			[
				50,
				48,
				26085
			]
		],
		[
			[13300, 13300],
			"mapped",
			[
				50,
				49,
				26085
			]
		],
		[
			[13301, 13301],
			"mapped",
			[
				50,
				50,
				26085
			]
		],
		[
			[13302, 13302],
			"mapped",
			[
				50,
				51,
				26085
			]
		],
		[
			[13303, 13303],
			"mapped",
			[
				50,
				52,
				26085
			]
		],
		[
			[13304, 13304],
			"mapped",
			[
				50,
				53,
				26085
			]
		],
		[
			[13305, 13305],
			"mapped",
			[
				50,
				54,
				26085
			]
		],
		[
			[13306, 13306],
			"mapped",
			[
				50,
				55,
				26085
			]
		],
		[
			[13307, 13307],
			"mapped",
			[
				50,
				56,
				26085
			]
		],
		[
			[13308, 13308],
			"mapped",
			[
				50,
				57,
				26085
			]
		],
		[
			[13309, 13309],
			"mapped",
			[
				51,
				48,
				26085
			]
		],
		[
			[13310, 13310],
			"mapped",
			[
				51,
				49,
				26085
			]
		],
		[
			[13311, 13311],
			"mapped",
			[
				103,
				97,
				108
			]
		],
		[[13312, 19893], "valid"],
		[[19894, 19903], "disallowed"],
		[
			[19904, 19967],
			"valid",
			[],
			"NV8"
		],
		[[19968, 40869], "valid"],
		[[40870, 40891], "valid"],
		[[40892, 40899], "valid"],
		[[40900, 40907], "valid"],
		[[40908, 40908], "valid"],
		[[40909, 40917], "valid"],
		[[40918, 40959], "disallowed"],
		[[40960, 42124], "valid"],
		[[42125, 42127], "disallowed"],
		[
			[42128, 42145],
			"valid",
			[],
			"NV8"
		],
		[
			[42146, 42147],
			"valid",
			[],
			"NV8"
		],
		[
			[42148, 42163],
			"valid",
			[],
			"NV8"
		],
		[
			[42164, 42164],
			"valid",
			[],
			"NV8"
		],
		[
			[42165, 42176],
			"valid",
			[],
			"NV8"
		],
		[
			[42177, 42177],
			"valid",
			[],
			"NV8"
		],
		[
			[42178, 42180],
			"valid",
			[],
			"NV8"
		],
		[
			[42181, 42181],
			"valid",
			[],
			"NV8"
		],
		[
			[42182, 42182],
			"valid",
			[],
			"NV8"
		],
		[[42183, 42191], "disallowed"],
		[[42192, 42237], "valid"],
		[
			[42238, 42239],
			"valid",
			[],
			"NV8"
		],
		[[42240, 42508], "valid"],
		[
			[42509, 42511],
			"valid",
			[],
			"NV8"
		],
		[[42512, 42539], "valid"],
		[[42540, 42559], "disallowed"],
		[
			[42560, 42560],
			"mapped",
			[42561]
		],
		[[42561, 42561], "valid"],
		[
			[42562, 42562],
			"mapped",
			[42563]
		],
		[[42563, 42563], "valid"],
		[
			[42564, 42564],
			"mapped",
			[42565]
		],
		[[42565, 42565], "valid"],
		[
			[42566, 42566],
			"mapped",
			[42567]
		],
		[[42567, 42567], "valid"],
		[
			[42568, 42568],
			"mapped",
			[42569]
		],
		[[42569, 42569], "valid"],
		[
			[42570, 42570],
			"mapped",
			[42571]
		],
		[[42571, 42571], "valid"],
		[
			[42572, 42572],
			"mapped",
			[42573]
		],
		[[42573, 42573], "valid"],
		[
			[42574, 42574],
			"mapped",
			[42575]
		],
		[[42575, 42575], "valid"],
		[
			[42576, 42576],
			"mapped",
			[42577]
		],
		[[42577, 42577], "valid"],
		[
			[42578, 42578],
			"mapped",
			[42579]
		],
		[[42579, 42579], "valid"],
		[
			[42580, 42580],
			"mapped",
			[42581]
		],
		[[42581, 42581], "valid"],
		[
			[42582, 42582],
			"mapped",
			[42583]
		],
		[[42583, 42583], "valid"],
		[
			[42584, 42584],
			"mapped",
			[42585]
		],
		[[42585, 42585], "valid"],
		[
			[42586, 42586],
			"mapped",
			[42587]
		],
		[[42587, 42587], "valid"],
		[
			[42588, 42588],
			"mapped",
			[42589]
		],
		[[42589, 42589], "valid"],
		[
			[42590, 42590],
			"mapped",
			[42591]
		],
		[[42591, 42591], "valid"],
		[
			[42592, 42592],
			"mapped",
			[42593]
		],
		[[42593, 42593], "valid"],
		[
			[42594, 42594],
			"mapped",
			[42595]
		],
		[[42595, 42595], "valid"],
		[
			[42596, 42596],
			"mapped",
			[42597]
		],
		[[42597, 42597], "valid"],
		[
			[42598, 42598],
			"mapped",
			[42599]
		],
		[[42599, 42599], "valid"],
		[
			[42600, 42600],
			"mapped",
			[42601]
		],
		[[42601, 42601], "valid"],
		[
			[42602, 42602],
			"mapped",
			[42603]
		],
		[[42603, 42603], "valid"],
		[
			[42604, 42604],
			"mapped",
			[42605]
		],
		[[42605, 42607], "valid"],
		[
			[42608, 42611],
			"valid",
			[],
			"NV8"
		],
		[[42612, 42619], "valid"],
		[[42620, 42621], "valid"],
		[
			[42622, 42622],
			"valid",
			[],
			"NV8"
		],
		[[42623, 42623], "valid"],
		[
			[42624, 42624],
			"mapped",
			[42625]
		],
		[[42625, 42625], "valid"],
		[
			[42626, 42626],
			"mapped",
			[42627]
		],
		[[42627, 42627], "valid"],
		[
			[42628, 42628],
			"mapped",
			[42629]
		],
		[[42629, 42629], "valid"],
		[
			[42630, 42630],
			"mapped",
			[42631]
		],
		[[42631, 42631], "valid"],
		[
			[42632, 42632],
			"mapped",
			[42633]
		],
		[[42633, 42633], "valid"],
		[
			[42634, 42634],
			"mapped",
			[42635]
		],
		[[42635, 42635], "valid"],
		[
			[42636, 42636],
			"mapped",
			[42637]
		],
		[[42637, 42637], "valid"],
		[
			[42638, 42638],
			"mapped",
			[42639]
		],
		[[42639, 42639], "valid"],
		[
			[42640, 42640],
			"mapped",
			[42641]
		],
		[[42641, 42641], "valid"],
		[
			[42642, 42642],
			"mapped",
			[42643]
		],
		[[42643, 42643], "valid"],
		[
			[42644, 42644],
			"mapped",
			[42645]
		],
		[[42645, 42645], "valid"],
		[
			[42646, 42646],
			"mapped",
			[42647]
		],
		[[42647, 42647], "valid"],
		[
			[42648, 42648],
			"mapped",
			[42649]
		],
		[[42649, 42649], "valid"],
		[
			[42650, 42650],
			"mapped",
			[42651]
		],
		[[42651, 42651], "valid"],
		[
			[42652, 42652],
			"mapped",
			[1098]
		],
		[
			[42653, 42653],
			"mapped",
			[1100]
		],
		[[42654, 42654], "valid"],
		[[42655, 42655], "valid"],
		[[42656, 42725], "valid"],
		[
			[42726, 42735],
			"valid",
			[],
			"NV8"
		],
		[[42736, 42737], "valid"],
		[
			[42738, 42743],
			"valid",
			[],
			"NV8"
		],
		[[42744, 42751], "disallowed"],
		[
			[42752, 42774],
			"valid",
			[],
			"NV8"
		],
		[[42775, 42778], "valid"],
		[[42779, 42783], "valid"],
		[
			[42784, 42785],
			"valid",
			[],
			"NV8"
		],
		[
			[42786, 42786],
			"mapped",
			[42787]
		],
		[[42787, 42787], "valid"],
		[
			[42788, 42788],
			"mapped",
			[42789]
		],
		[[42789, 42789], "valid"],
		[
			[42790, 42790],
			"mapped",
			[42791]
		],
		[[42791, 42791], "valid"],
		[
			[42792, 42792],
			"mapped",
			[42793]
		],
		[[42793, 42793], "valid"],
		[
			[42794, 42794],
			"mapped",
			[42795]
		],
		[[42795, 42795], "valid"],
		[
			[42796, 42796],
			"mapped",
			[42797]
		],
		[[42797, 42797], "valid"],
		[
			[42798, 42798],
			"mapped",
			[42799]
		],
		[[42799, 42801], "valid"],
		[
			[42802, 42802],
			"mapped",
			[42803]
		],
		[[42803, 42803], "valid"],
		[
			[42804, 42804],
			"mapped",
			[42805]
		],
		[[42805, 42805], "valid"],
		[
			[42806, 42806],
			"mapped",
			[42807]
		],
		[[42807, 42807], "valid"],
		[
			[42808, 42808],
			"mapped",
			[42809]
		],
		[[42809, 42809], "valid"],
		[
			[42810, 42810],
			"mapped",
			[42811]
		],
		[[42811, 42811], "valid"],
		[
			[42812, 42812],
			"mapped",
			[42813]
		],
		[[42813, 42813], "valid"],
		[
			[42814, 42814],
			"mapped",
			[42815]
		],
		[[42815, 42815], "valid"],
		[
			[42816, 42816],
			"mapped",
			[42817]
		],
		[[42817, 42817], "valid"],
		[
			[42818, 42818],
			"mapped",
			[42819]
		],
		[[42819, 42819], "valid"],
		[
			[42820, 42820],
			"mapped",
			[42821]
		],
		[[42821, 42821], "valid"],
		[
			[42822, 42822],
			"mapped",
			[42823]
		],
		[[42823, 42823], "valid"],
		[
			[42824, 42824],
			"mapped",
			[42825]
		],
		[[42825, 42825], "valid"],
		[
			[42826, 42826],
			"mapped",
			[42827]
		],
		[[42827, 42827], "valid"],
		[
			[42828, 42828],
			"mapped",
			[42829]
		],
		[[42829, 42829], "valid"],
		[
			[42830, 42830],
			"mapped",
			[42831]
		],
		[[42831, 42831], "valid"],
		[
			[42832, 42832],
			"mapped",
			[42833]
		],
		[[42833, 42833], "valid"],
		[
			[42834, 42834],
			"mapped",
			[42835]
		],
		[[42835, 42835], "valid"],
		[
			[42836, 42836],
			"mapped",
			[42837]
		],
		[[42837, 42837], "valid"],
		[
			[42838, 42838],
			"mapped",
			[42839]
		],
		[[42839, 42839], "valid"],
		[
			[42840, 42840],
			"mapped",
			[42841]
		],
		[[42841, 42841], "valid"],
		[
			[42842, 42842],
			"mapped",
			[42843]
		],
		[[42843, 42843], "valid"],
		[
			[42844, 42844],
			"mapped",
			[42845]
		],
		[[42845, 42845], "valid"],
		[
			[42846, 42846],
			"mapped",
			[42847]
		],
		[[42847, 42847], "valid"],
		[
			[42848, 42848],
			"mapped",
			[42849]
		],
		[[42849, 42849], "valid"],
		[
			[42850, 42850],
			"mapped",
			[42851]
		],
		[[42851, 42851], "valid"],
		[
			[42852, 42852],
			"mapped",
			[42853]
		],
		[[42853, 42853], "valid"],
		[
			[42854, 42854],
			"mapped",
			[42855]
		],
		[[42855, 42855], "valid"],
		[
			[42856, 42856],
			"mapped",
			[42857]
		],
		[[42857, 42857], "valid"],
		[
			[42858, 42858],
			"mapped",
			[42859]
		],
		[[42859, 42859], "valid"],
		[
			[42860, 42860],
			"mapped",
			[42861]
		],
		[[42861, 42861], "valid"],
		[
			[42862, 42862],
			"mapped",
			[42863]
		],
		[[42863, 42863], "valid"],
		[
			[42864, 42864],
			"mapped",
			[42863]
		],
		[[42865, 42872], "valid"],
		[
			[42873, 42873],
			"mapped",
			[42874]
		],
		[[42874, 42874], "valid"],
		[
			[42875, 42875],
			"mapped",
			[42876]
		],
		[[42876, 42876], "valid"],
		[
			[42877, 42877],
			"mapped",
			[7545]
		],
		[
			[42878, 42878],
			"mapped",
			[42879]
		],
		[[42879, 42879], "valid"],
		[
			[42880, 42880],
			"mapped",
			[42881]
		],
		[[42881, 42881], "valid"],
		[
			[42882, 42882],
			"mapped",
			[42883]
		],
		[[42883, 42883], "valid"],
		[
			[42884, 42884],
			"mapped",
			[42885]
		],
		[[42885, 42885], "valid"],
		[
			[42886, 42886],
			"mapped",
			[42887]
		],
		[[42887, 42888], "valid"],
		[
			[42889, 42890],
			"valid",
			[],
			"NV8"
		],
		[
			[42891, 42891],
			"mapped",
			[42892]
		],
		[[42892, 42892], "valid"],
		[
			[42893, 42893],
			"mapped",
			[613]
		],
		[[42894, 42894], "valid"],
		[[42895, 42895], "valid"],
		[
			[42896, 42896],
			"mapped",
			[42897]
		],
		[[42897, 42897], "valid"],
		[
			[42898, 42898],
			"mapped",
			[42899]
		],
		[[42899, 42899], "valid"],
		[[42900, 42901], "valid"],
		[
			[42902, 42902],
			"mapped",
			[42903]
		],
		[[42903, 42903], "valid"],
		[
			[42904, 42904],
			"mapped",
			[42905]
		],
		[[42905, 42905], "valid"],
		[
			[42906, 42906],
			"mapped",
			[42907]
		],
		[[42907, 42907], "valid"],
		[
			[42908, 42908],
			"mapped",
			[42909]
		],
		[[42909, 42909], "valid"],
		[
			[42910, 42910],
			"mapped",
			[42911]
		],
		[[42911, 42911], "valid"],
		[
			[42912, 42912],
			"mapped",
			[42913]
		],
		[[42913, 42913], "valid"],
		[
			[42914, 42914],
			"mapped",
			[42915]
		],
		[[42915, 42915], "valid"],
		[
			[42916, 42916],
			"mapped",
			[42917]
		],
		[[42917, 42917], "valid"],
		[
			[42918, 42918],
			"mapped",
			[42919]
		],
		[[42919, 42919], "valid"],
		[
			[42920, 42920],
			"mapped",
			[42921]
		],
		[[42921, 42921], "valid"],
		[
			[42922, 42922],
			"mapped",
			[614]
		],
		[
			[42923, 42923],
			"mapped",
			[604]
		],
		[
			[42924, 42924],
			"mapped",
			[609]
		],
		[
			[42925, 42925],
			"mapped",
			[620]
		],
		[[42926, 42927], "disallowed"],
		[
			[42928, 42928],
			"mapped",
			[670]
		],
		[
			[42929, 42929],
			"mapped",
			[647]
		],
		[
			[42930, 42930],
			"mapped",
			[669]
		],
		[
			[42931, 42931],
			"mapped",
			[43859]
		],
		[
			[42932, 42932],
			"mapped",
			[42933]
		],
		[[42933, 42933], "valid"],
		[
			[42934, 42934],
			"mapped",
			[42935]
		],
		[[42935, 42935], "valid"],
		[[42936, 42998], "disallowed"],
		[[42999, 42999], "valid"],
		[
			[43e3, 43e3],
			"mapped",
			[295]
		],
		[
			[43001, 43001],
			"mapped",
			[339]
		],
		[[43002, 43002], "valid"],
		[[43003, 43007], "valid"],
		[[43008, 43047], "valid"],
		[
			[43048, 43051],
			"valid",
			[],
			"NV8"
		],
		[[43052, 43055], "disallowed"],
		[
			[43056, 43065],
			"valid",
			[],
			"NV8"
		],
		[[43066, 43071], "disallowed"],
		[[43072, 43123], "valid"],
		[
			[43124, 43127],
			"valid",
			[],
			"NV8"
		],
		[[43128, 43135], "disallowed"],
		[[43136, 43204], "valid"],
		[[43205, 43213], "disallowed"],
		[
			[43214, 43215],
			"valid",
			[],
			"NV8"
		],
		[[43216, 43225], "valid"],
		[[43226, 43231], "disallowed"],
		[[43232, 43255], "valid"],
		[
			[43256, 43258],
			"valid",
			[],
			"NV8"
		],
		[[43259, 43259], "valid"],
		[
			[43260, 43260],
			"valid",
			[],
			"NV8"
		],
		[[43261, 43261], "valid"],
		[[43262, 43263], "disallowed"],
		[[43264, 43309], "valid"],
		[
			[43310, 43311],
			"valid",
			[],
			"NV8"
		],
		[[43312, 43347], "valid"],
		[[43348, 43358], "disallowed"],
		[
			[43359, 43359],
			"valid",
			[],
			"NV8"
		],
		[
			[43360, 43388],
			"valid",
			[],
			"NV8"
		],
		[[43389, 43391], "disallowed"],
		[[43392, 43456], "valid"],
		[
			[43457, 43469],
			"valid",
			[],
			"NV8"
		],
		[[43470, 43470], "disallowed"],
		[[43471, 43481], "valid"],
		[[43482, 43485], "disallowed"],
		[
			[43486, 43487],
			"valid",
			[],
			"NV8"
		],
		[[43488, 43518], "valid"],
		[[43519, 43519], "disallowed"],
		[[43520, 43574], "valid"],
		[[43575, 43583], "disallowed"],
		[[43584, 43597], "valid"],
		[[43598, 43599], "disallowed"],
		[[43600, 43609], "valid"],
		[[43610, 43611], "disallowed"],
		[
			[43612, 43615],
			"valid",
			[],
			"NV8"
		],
		[[43616, 43638], "valid"],
		[
			[43639, 43641],
			"valid",
			[],
			"NV8"
		],
		[[43642, 43643], "valid"],
		[[43644, 43647], "valid"],
		[[43648, 43714], "valid"],
		[[43715, 43738], "disallowed"],
		[[43739, 43741], "valid"],
		[
			[43742, 43743],
			"valid",
			[],
			"NV8"
		],
		[[43744, 43759], "valid"],
		[
			[43760, 43761],
			"valid",
			[],
			"NV8"
		],
		[[43762, 43766], "valid"],
		[[43767, 43776], "disallowed"],
		[[43777, 43782], "valid"],
		[[43783, 43784], "disallowed"],
		[[43785, 43790], "valid"],
		[[43791, 43792], "disallowed"],
		[[43793, 43798], "valid"],
		[[43799, 43807], "disallowed"],
		[[43808, 43814], "valid"],
		[[43815, 43815], "disallowed"],
		[[43816, 43822], "valid"],
		[[43823, 43823], "disallowed"],
		[[43824, 43866], "valid"],
		[
			[43867, 43867],
			"valid",
			[],
			"NV8"
		],
		[
			[43868, 43868],
			"mapped",
			[42791]
		],
		[
			[43869, 43869],
			"mapped",
			[43831]
		],
		[
			[43870, 43870],
			"mapped",
			[619]
		],
		[
			[43871, 43871],
			"mapped",
			[43858]
		],
		[[43872, 43875], "valid"],
		[[43876, 43877], "valid"],
		[[43878, 43887], "disallowed"],
		[
			[43888, 43888],
			"mapped",
			[5024]
		],
		[
			[43889, 43889],
			"mapped",
			[5025]
		],
		[
			[43890, 43890],
			"mapped",
			[5026]
		],
		[
			[43891, 43891],
			"mapped",
			[5027]
		],
		[
			[43892, 43892],
			"mapped",
			[5028]
		],
		[
			[43893, 43893],
			"mapped",
			[5029]
		],
		[
			[43894, 43894],
			"mapped",
			[5030]
		],
		[
			[43895, 43895],
			"mapped",
			[5031]
		],
		[
			[43896, 43896],
			"mapped",
			[5032]
		],
		[
			[43897, 43897],
			"mapped",
			[5033]
		],
		[
			[43898, 43898],
			"mapped",
			[5034]
		],
		[
			[43899, 43899],
			"mapped",
			[5035]
		],
		[
			[43900, 43900],
			"mapped",
			[5036]
		],
		[
			[43901, 43901],
			"mapped",
			[5037]
		],
		[
			[43902, 43902],
			"mapped",
			[5038]
		],
		[
			[43903, 43903],
			"mapped",
			[5039]
		],
		[
			[43904, 43904],
			"mapped",
			[5040]
		],
		[
			[43905, 43905],
			"mapped",
			[5041]
		],
		[
			[43906, 43906],
			"mapped",
			[5042]
		],
		[
			[43907, 43907],
			"mapped",
			[5043]
		],
		[
			[43908, 43908],
			"mapped",
			[5044]
		],
		[
			[43909, 43909],
			"mapped",
			[5045]
		],
		[
			[43910, 43910],
			"mapped",
			[5046]
		],
		[
			[43911, 43911],
			"mapped",
			[5047]
		],
		[
			[43912, 43912],
			"mapped",
			[5048]
		],
		[
			[43913, 43913],
			"mapped",
			[5049]
		],
		[
			[43914, 43914],
			"mapped",
			[5050]
		],
		[
			[43915, 43915],
			"mapped",
			[5051]
		],
		[
			[43916, 43916],
			"mapped",
			[5052]
		],
		[
			[43917, 43917],
			"mapped",
			[5053]
		],
		[
			[43918, 43918],
			"mapped",
			[5054]
		],
		[
			[43919, 43919],
			"mapped",
			[5055]
		],
		[
			[43920, 43920],
			"mapped",
			[5056]
		],
		[
			[43921, 43921],
			"mapped",
			[5057]
		],
		[
			[43922, 43922],
			"mapped",
			[5058]
		],
		[
			[43923, 43923],
			"mapped",
			[5059]
		],
		[
			[43924, 43924],
			"mapped",
			[5060]
		],
		[
			[43925, 43925],
			"mapped",
			[5061]
		],
		[
			[43926, 43926],
			"mapped",
			[5062]
		],
		[
			[43927, 43927],
			"mapped",
			[5063]
		],
		[
			[43928, 43928],
			"mapped",
			[5064]
		],
		[
			[43929, 43929],
			"mapped",
			[5065]
		],
		[
			[43930, 43930],
			"mapped",
			[5066]
		],
		[
			[43931, 43931],
			"mapped",
			[5067]
		],
		[
			[43932, 43932],
			"mapped",
			[5068]
		],
		[
			[43933, 43933],
			"mapped",
			[5069]
		],
		[
			[43934, 43934],
			"mapped",
			[5070]
		],
		[
			[43935, 43935],
			"mapped",
			[5071]
		],
		[
			[43936, 43936],
			"mapped",
			[5072]
		],
		[
			[43937, 43937],
			"mapped",
			[5073]
		],
		[
			[43938, 43938],
			"mapped",
			[5074]
		],
		[
			[43939, 43939],
			"mapped",
			[5075]
		],
		[
			[43940, 43940],
			"mapped",
			[5076]
		],
		[
			[43941, 43941],
			"mapped",
			[5077]
		],
		[
			[43942, 43942],
			"mapped",
			[5078]
		],
		[
			[43943, 43943],
			"mapped",
			[5079]
		],
		[
			[43944, 43944],
			"mapped",
			[5080]
		],
		[
			[43945, 43945],
			"mapped",
			[5081]
		],
		[
			[43946, 43946],
			"mapped",
			[5082]
		],
		[
			[43947, 43947],
			"mapped",
			[5083]
		],
		[
			[43948, 43948],
			"mapped",
			[5084]
		],
		[
			[43949, 43949],
			"mapped",
			[5085]
		],
		[
			[43950, 43950],
			"mapped",
			[5086]
		],
		[
			[43951, 43951],
			"mapped",
			[5087]
		],
		[
			[43952, 43952],
			"mapped",
			[5088]
		],
		[
			[43953, 43953],
			"mapped",
			[5089]
		],
		[
			[43954, 43954],
			"mapped",
			[5090]
		],
		[
			[43955, 43955],
			"mapped",
			[5091]
		],
		[
			[43956, 43956],
			"mapped",
			[5092]
		],
		[
			[43957, 43957],
			"mapped",
			[5093]
		],
		[
			[43958, 43958],
			"mapped",
			[5094]
		],
		[
			[43959, 43959],
			"mapped",
			[5095]
		],
		[
			[43960, 43960],
			"mapped",
			[5096]
		],
		[
			[43961, 43961],
			"mapped",
			[5097]
		],
		[
			[43962, 43962],
			"mapped",
			[5098]
		],
		[
			[43963, 43963],
			"mapped",
			[5099]
		],
		[
			[43964, 43964],
			"mapped",
			[5100]
		],
		[
			[43965, 43965],
			"mapped",
			[5101]
		],
		[
			[43966, 43966],
			"mapped",
			[5102]
		],
		[
			[43967, 43967],
			"mapped",
			[5103]
		],
		[[43968, 44010], "valid"],
		[
			[44011, 44011],
			"valid",
			[],
			"NV8"
		],
		[[44012, 44013], "valid"],
		[[44014, 44015], "disallowed"],
		[[44016, 44025], "valid"],
		[[44026, 44031], "disallowed"],
		[[44032, 55203], "valid"],
		[[55204, 55215], "disallowed"],
		[
			[55216, 55238],
			"valid",
			[],
			"NV8"
		],
		[[55239, 55242], "disallowed"],
		[
			[55243, 55291],
			"valid",
			[],
			"NV8"
		],
		[[55292, 55295], "disallowed"],
		[[55296, 57343], "disallowed"],
		[[57344, 63743], "disallowed"],
		[
			[63744, 63744],
			"mapped",
			[35912]
		],
		[
			[63745, 63745],
			"mapped",
			[26356]
		],
		[
			[63746, 63746],
			"mapped",
			[36554]
		],
		[
			[63747, 63747],
			"mapped",
			[36040]
		],
		[
			[63748, 63748],
			"mapped",
			[28369]
		],
		[
			[63749, 63749],
			"mapped",
			[20018]
		],
		[
			[63750, 63750],
			"mapped",
			[21477]
		],
		[
			[63751, 63752],
			"mapped",
			[40860]
		],
		[
			[63753, 63753],
			"mapped",
			[22865]
		],
		[
			[63754, 63754],
			"mapped",
			[37329]
		],
		[
			[63755, 63755],
			"mapped",
			[21895]
		],
		[
			[63756, 63756],
			"mapped",
			[22856]
		],
		[
			[63757, 63757],
			"mapped",
			[25078]
		],
		[
			[63758, 63758],
			"mapped",
			[30313]
		],
		[
			[63759, 63759],
			"mapped",
			[32645]
		],
		[
			[63760, 63760],
			"mapped",
			[34367]
		],
		[
			[63761, 63761],
			"mapped",
			[34746]
		],
		[
			[63762, 63762],
			"mapped",
			[35064]
		],
		[
			[63763, 63763],
			"mapped",
			[37007]
		],
		[
			[63764, 63764],
			"mapped",
			[27138]
		],
		[
			[63765, 63765],
			"mapped",
			[27931]
		],
		[
			[63766, 63766],
			"mapped",
			[28889]
		],
		[
			[63767, 63767],
			"mapped",
			[29662]
		],
		[
			[63768, 63768],
			"mapped",
			[33853]
		],
		[
			[63769, 63769],
			"mapped",
			[37226]
		],
		[
			[63770, 63770],
			"mapped",
			[39409]
		],
		[
			[63771, 63771],
			"mapped",
			[20098]
		],
		[
			[63772, 63772],
			"mapped",
			[21365]
		],
		[
			[63773, 63773],
			"mapped",
			[27396]
		],
		[
			[63774, 63774],
			"mapped",
			[29211]
		],
		[
			[63775, 63775],
			"mapped",
			[34349]
		],
		[
			[63776, 63776],
			"mapped",
			[40478]
		],
		[
			[63777, 63777],
			"mapped",
			[23888]
		],
		[
			[63778, 63778],
			"mapped",
			[28651]
		],
		[
			[63779, 63779],
			"mapped",
			[34253]
		],
		[
			[63780, 63780],
			"mapped",
			[35172]
		],
		[
			[63781, 63781],
			"mapped",
			[25289]
		],
		[
			[63782, 63782],
			"mapped",
			[33240]
		],
		[
			[63783, 63783],
			"mapped",
			[34847]
		],
		[
			[63784, 63784],
			"mapped",
			[24266]
		],
		[
			[63785, 63785],
			"mapped",
			[26391]
		],
		[
			[63786, 63786],
			"mapped",
			[28010]
		],
		[
			[63787, 63787],
			"mapped",
			[29436]
		],
		[
			[63788, 63788],
			"mapped",
			[37070]
		],
		[
			[63789, 63789],
			"mapped",
			[20358]
		],
		[
			[63790, 63790],
			"mapped",
			[20919]
		],
		[
			[63791, 63791],
			"mapped",
			[21214]
		],
		[
			[63792, 63792],
			"mapped",
			[25796]
		],
		[
			[63793, 63793],
			"mapped",
			[27347]
		],
		[
			[63794, 63794],
			"mapped",
			[29200]
		],
		[
			[63795, 63795],
			"mapped",
			[30439]
		],
		[
			[63796, 63796],
			"mapped",
			[32769]
		],
		[
			[63797, 63797],
			"mapped",
			[34310]
		],
		[
			[63798, 63798],
			"mapped",
			[34396]
		],
		[
			[63799, 63799],
			"mapped",
			[36335]
		],
		[
			[63800, 63800],
			"mapped",
			[38706]
		],
		[
			[63801, 63801],
			"mapped",
			[39791]
		],
		[
			[63802, 63802],
			"mapped",
			[40442]
		],
		[
			[63803, 63803],
			"mapped",
			[30860]
		],
		[
			[63804, 63804],
			"mapped",
			[31103]
		],
		[
			[63805, 63805],
			"mapped",
			[32160]
		],
		[
			[63806, 63806],
			"mapped",
			[33737]
		],
		[
			[63807, 63807],
			"mapped",
			[37636]
		],
		[
			[63808, 63808],
			"mapped",
			[40575]
		],
		[
			[63809, 63809],
			"mapped",
			[35542]
		],
		[
			[63810, 63810],
			"mapped",
			[22751]
		],
		[
			[63811, 63811],
			"mapped",
			[24324]
		],
		[
			[63812, 63812],
			"mapped",
			[31840]
		],
		[
			[63813, 63813],
			"mapped",
			[32894]
		],
		[
			[63814, 63814],
			"mapped",
			[29282]
		],
		[
			[63815, 63815],
			"mapped",
			[30922]
		],
		[
			[63816, 63816],
			"mapped",
			[36034]
		],
		[
			[63817, 63817],
			"mapped",
			[38647]
		],
		[
			[63818, 63818],
			"mapped",
			[22744]
		],
		[
			[63819, 63819],
			"mapped",
			[23650]
		],
		[
			[63820, 63820],
			"mapped",
			[27155]
		],
		[
			[63821, 63821],
			"mapped",
			[28122]
		],
		[
			[63822, 63822],
			"mapped",
			[28431]
		],
		[
			[63823, 63823],
			"mapped",
			[32047]
		],
		[
			[63824, 63824],
			"mapped",
			[32311]
		],
		[
			[63825, 63825],
			"mapped",
			[38475]
		],
		[
			[63826, 63826],
			"mapped",
			[21202]
		],
		[
			[63827, 63827],
			"mapped",
			[32907]
		],
		[
			[63828, 63828],
			"mapped",
			[20956]
		],
		[
			[63829, 63829],
			"mapped",
			[20940]
		],
		[
			[63830, 63830],
			"mapped",
			[31260]
		],
		[
			[63831, 63831],
			"mapped",
			[32190]
		],
		[
			[63832, 63832],
			"mapped",
			[33777]
		],
		[
			[63833, 63833],
			"mapped",
			[38517]
		],
		[
			[63834, 63834],
			"mapped",
			[35712]
		],
		[
			[63835, 63835],
			"mapped",
			[25295]
		],
		[
			[63836, 63836],
			"mapped",
			[27138]
		],
		[
			[63837, 63837],
			"mapped",
			[35582]
		],
		[
			[63838, 63838],
			"mapped",
			[20025]
		],
		[
			[63839, 63839],
			"mapped",
			[23527]
		],
		[
			[63840, 63840],
			"mapped",
			[24594]
		],
		[
			[63841, 63841],
			"mapped",
			[29575]
		],
		[
			[63842, 63842],
			"mapped",
			[30064]
		],
		[
			[63843, 63843],
			"mapped",
			[21271]
		],
		[
			[63844, 63844],
			"mapped",
			[30971]
		],
		[
			[63845, 63845],
			"mapped",
			[20415]
		],
		[
			[63846, 63846],
			"mapped",
			[24489]
		],
		[
			[63847, 63847],
			"mapped",
			[19981]
		],
		[
			[63848, 63848],
			"mapped",
			[27852]
		],
		[
			[63849, 63849],
			"mapped",
			[25976]
		],
		[
			[63850, 63850],
			"mapped",
			[32034]
		],
		[
			[63851, 63851],
			"mapped",
			[21443]
		],
		[
			[63852, 63852],
			"mapped",
			[22622]
		],
		[
			[63853, 63853],
			"mapped",
			[30465]
		],
		[
			[63854, 63854],
			"mapped",
			[33865]
		],
		[
			[63855, 63855],
			"mapped",
			[35498]
		],
		[
			[63856, 63856],
			"mapped",
			[27578]
		],
		[
			[63857, 63857],
			"mapped",
			[36784]
		],
		[
			[63858, 63858],
			"mapped",
			[27784]
		],
		[
			[63859, 63859],
			"mapped",
			[25342]
		],
		[
			[63860, 63860],
			"mapped",
			[33509]
		],
		[
			[63861, 63861],
			"mapped",
			[25504]
		],
		[
			[63862, 63862],
			"mapped",
			[30053]
		],
		[
			[63863, 63863],
			"mapped",
			[20142]
		],
		[
			[63864, 63864],
			"mapped",
			[20841]
		],
		[
			[63865, 63865],
			"mapped",
			[20937]
		],
		[
			[63866, 63866],
			"mapped",
			[26753]
		],
		[
			[63867, 63867],
			"mapped",
			[31975]
		],
		[
			[63868, 63868],
			"mapped",
			[33391]
		],
		[
			[63869, 63869],
			"mapped",
			[35538]
		],
		[
			[63870, 63870],
			"mapped",
			[37327]
		],
		[
			[63871, 63871],
			"mapped",
			[21237]
		],
		[
			[63872, 63872],
			"mapped",
			[21570]
		],
		[
			[63873, 63873],
			"mapped",
			[22899]
		],
		[
			[63874, 63874],
			"mapped",
			[24300]
		],
		[
			[63875, 63875],
			"mapped",
			[26053]
		],
		[
			[63876, 63876],
			"mapped",
			[28670]
		],
		[
			[63877, 63877],
			"mapped",
			[31018]
		],
		[
			[63878, 63878],
			"mapped",
			[38317]
		],
		[
			[63879, 63879],
			"mapped",
			[39530]
		],
		[
			[63880, 63880],
			"mapped",
			[40599]
		],
		[
			[63881, 63881],
			"mapped",
			[40654]
		],
		[
			[63882, 63882],
			"mapped",
			[21147]
		],
		[
			[63883, 63883],
			"mapped",
			[26310]
		],
		[
			[63884, 63884],
			"mapped",
			[27511]
		],
		[
			[63885, 63885],
			"mapped",
			[36706]
		],
		[
			[63886, 63886],
			"mapped",
			[24180]
		],
		[
			[63887, 63887],
			"mapped",
			[24976]
		],
		[
			[63888, 63888],
			"mapped",
			[25088]
		],
		[
			[63889, 63889],
			"mapped",
			[25754]
		],
		[
			[63890, 63890],
			"mapped",
			[28451]
		],
		[
			[63891, 63891],
			"mapped",
			[29001]
		],
		[
			[63892, 63892],
			"mapped",
			[29833]
		],
		[
			[63893, 63893],
			"mapped",
			[31178]
		],
		[
			[63894, 63894],
			"mapped",
			[32244]
		],
		[
			[63895, 63895],
			"mapped",
			[32879]
		],
		[
			[63896, 63896],
			"mapped",
			[36646]
		],
		[
			[63897, 63897],
			"mapped",
			[34030]
		],
		[
			[63898, 63898],
			"mapped",
			[36899]
		],
		[
			[63899, 63899],
			"mapped",
			[37706]
		],
		[
			[63900, 63900],
			"mapped",
			[21015]
		],
		[
			[63901, 63901],
			"mapped",
			[21155]
		],
		[
			[63902, 63902],
			"mapped",
			[21693]
		],
		[
			[63903, 63903],
			"mapped",
			[28872]
		],
		[
			[63904, 63904],
			"mapped",
			[35010]
		],
		[
			[63905, 63905],
			"mapped",
			[35498]
		],
		[
			[63906, 63906],
			"mapped",
			[24265]
		],
		[
			[63907, 63907],
			"mapped",
			[24565]
		],
		[
			[63908, 63908],
			"mapped",
			[25467]
		],
		[
			[63909, 63909],
			"mapped",
			[27566]
		],
		[
			[63910, 63910],
			"mapped",
			[31806]
		],
		[
			[63911, 63911],
			"mapped",
			[29557]
		],
		[
			[63912, 63912],
			"mapped",
			[20196]
		],
		[
			[63913, 63913],
			"mapped",
			[22265]
		],
		[
			[63914, 63914],
			"mapped",
			[23527]
		],
		[
			[63915, 63915],
			"mapped",
			[23994]
		],
		[
			[63916, 63916],
			"mapped",
			[24604]
		],
		[
			[63917, 63917],
			"mapped",
			[29618]
		],
		[
			[63918, 63918],
			"mapped",
			[29801]
		],
		[
			[63919, 63919],
			"mapped",
			[32666]
		],
		[
			[63920, 63920],
			"mapped",
			[32838]
		],
		[
			[63921, 63921],
			"mapped",
			[37428]
		],
		[
			[63922, 63922],
			"mapped",
			[38646]
		],
		[
			[63923, 63923],
			"mapped",
			[38728]
		],
		[
			[63924, 63924],
			"mapped",
			[38936]
		],
		[
			[63925, 63925],
			"mapped",
			[20363]
		],
		[
			[63926, 63926],
			"mapped",
			[31150]
		],
		[
			[63927, 63927],
			"mapped",
			[37300]
		],
		[
			[63928, 63928],
			"mapped",
			[38584]
		],
		[
			[63929, 63929],
			"mapped",
			[24801]
		],
		[
			[63930, 63930],
			"mapped",
			[20102]
		],
		[
			[63931, 63931],
			"mapped",
			[20698]
		],
		[
			[63932, 63932],
			"mapped",
			[23534]
		],
		[
			[63933, 63933],
			"mapped",
			[23615]
		],
		[
			[63934, 63934],
			"mapped",
			[26009]
		],
		[
			[63935, 63935],
			"mapped",
			[27138]
		],
		[
			[63936, 63936],
			"mapped",
			[29134]
		],
		[
			[63937, 63937],
			"mapped",
			[30274]
		],
		[
			[63938, 63938],
			"mapped",
			[34044]
		],
		[
			[63939, 63939],
			"mapped",
			[36988]
		],
		[
			[63940, 63940],
			"mapped",
			[40845]
		],
		[
			[63941, 63941],
			"mapped",
			[26248]
		],
		[
			[63942, 63942],
			"mapped",
			[38446]
		],
		[
			[63943, 63943],
			"mapped",
			[21129]
		],
		[
			[63944, 63944],
			"mapped",
			[26491]
		],
		[
			[63945, 63945],
			"mapped",
			[26611]
		],
		[
			[63946, 63946],
			"mapped",
			[27969]
		],
		[
			[63947, 63947],
			"mapped",
			[28316]
		],
		[
			[63948, 63948],
			"mapped",
			[29705]
		],
		[
			[63949, 63949],
			"mapped",
			[30041]
		],
		[
			[63950, 63950],
			"mapped",
			[30827]
		],
		[
			[63951, 63951],
			"mapped",
			[32016]
		],
		[
			[63952, 63952],
			"mapped",
			[39006]
		],
		[
			[63953, 63953],
			"mapped",
			[20845]
		],
		[
			[63954, 63954],
			"mapped",
			[25134]
		],
		[
			[63955, 63955],
			"mapped",
			[38520]
		],
		[
			[63956, 63956],
			"mapped",
			[20523]
		],
		[
			[63957, 63957],
			"mapped",
			[23833]
		],
		[
			[63958, 63958],
			"mapped",
			[28138]
		],
		[
			[63959, 63959],
			"mapped",
			[36650]
		],
		[
			[63960, 63960],
			"mapped",
			[24459]
		],
		[
			[63961, 63961],
			"mapped",
			[24900]
		],
		[
			[63962, 63962],
			"mapped",
			[26647]
		],
		[
			[63963, 63963],
			"mapped",
			[29575]
		],
		[
			[63964, 63964],
			"mapped",
			[38534]
		],
		[
			[63965, 63965],
			"mapped",
			[21033]
		],
		[
			[63966, 63966],
			"mapped",
			[21519]
		],
		[
			[63967, 63967],
			"mapped",
			[23653]
		],
		[
			[63968, 63968],
			"mapped",
			[26131]
		],
		[
			[63969, 63969],
			"mapped",
			[26446]
		],
		[
			[63970, 63970],
			"mapped",
			[26792]
		],
		[
			[63971, 63971],
			"mapped",
			[27877]
		],
		[
			[63972, 63972],
			"mapped",
			[29702]
		],
		[
			[63973, 63973],
			"mapped",
			[30178]
		],
		[
			[63974, 63974],
			"mapped",
			[32633]
		],
		[
			[63975, 63975],
			"mapped",
			[35023]
		],
		[
			[63976, 63976],
			"mapped",
			[35041]
		],
		[
			[63977, 63977],
			"mapped",
			[37324]
		],
		[
			[63978, 63978],
			"mapped",
			[38626]
		],
		[
			[63979, 63979],
			"mapped",
			[21311]
		],
		[
			[63980, 63980],
			"mapped",
			[28346]
		],
		[
			[63981, 63981],
			"mapped",
			[21533]
		],
		[
			[63982, 63982],
			"mapped",
			[29136]
		],
		[
			[63983, 63983],
			"mapped",
			[29848]
		],
		[
			[63984, 63984],
			"mapped",
			[34298]
		],
		[
			[63985, 63985],
			"mapped",
			[38563]
		],
		[
			[63986, 63986],
			"mapped",
			[40023]
		],
		[
			[63987, 63987],
			"mapped",
			[40607]
		],
		[
			[63988, 63988],
			"mapped",
			[26519]
		],
		[
			[63989, 63989],
			"mapped",
			[28107]
		],
		[
			[63990, 63990],
			"mapped",
			[33256]
		],
		[
			[63991, 63991],
			"mapped",
			[31435]
		],
		[
			[63992, 63992],
			"mapped",
			[31520]
		],
		[
			[63993, 63993],
			"mapped",
			[31890]
		],
		[
			[63994, 63994],
			"mapped",
			[29376]
		],
		[
			[63995, 63995],
			"mapped",
			[28825]
		],
		[
			[63996, 63996],
			"mapped",
			[35672]
		],
		[
			[63997, 63997],
			"mapped",
			[20160]
		],
		[
			[63998, 63998],
			"mapped",
			[33590]
		],
		[
			[63999, 63999],
			"mapped",
			[21050]
		],
		[
			[64e3, 64e3],
			"mapped",
			[20999]
		],
		[
			[64001, 64001],
			"mapped",
			[24230]
		],
		[
			[64002, 64002],
			"mapped",
			[25299]
		],
		[
			[64003, 64003],
			"mapped",
			[31958]
		],
		[
			[64004, 64004],
			"mapped",
			[23429]
		],
		[
			[64005, 64005],
			"mapped",
			[27934]
		],
		[
			[64006, 64006],
			"mapped",
			[26292]
		],
		[
			[64007, 64007],
			"mapped",
			[36667]
		],
		[
			[64008, 64008],
			"mapped",
			[34892]
		],
		[
			[64009, 64009],
			"mapped",
			[38477]
		],
		[
			[64010, 64010],
			"mapped",
			[35211]
		],
		[
			[64011, 64011],
			"mapped",
			[24275]
		],
		[
			[64012, 64012],
			"mapped",
			[20800]
		],
		[
			[64013, 64013],
			"mapped",
			[21952]
		],
		[[64014, 64015], "valid"],
		[
			[64016, 64016],
			"mapped",
			[22618]
		],
		[[64017, 64017], "valid"],
		[
			[64018, 64018],
			"mapped",
			[26228]
		],
		[[64019, 64020], "valid"],
		[
			[64021, 64021],
			"mapped",
			[20958]
		],
		[
			[64022, 64022],
			"mapped",
			[29482]
		],
		[
			[64023, 64023],
			"mapped",
			[30410]
		],
		[
			[64024, 64024],
			"mapped",
			[31036]
		],
		[
			[64025, 64025],
			"mapped",
			[31070]
		],
		[
			[64026, 64026],
			"mapped",
			[31077]
		],
		[
			[64027, 64027],
			"mapped",
			[31119]
		],
		[
			[64028, 64028],
			"mapped",
			[38742]
		],
		[
			[64029, 64029],
			"mapped",
			[31934]
		],
		[
			[64030, 64030],
			"mapped",
			[32701]
		],
		[[64031, 64031], "valid"],
		[
			[64032, 64032],
			"mapped",
			[34322]
		],
		[[64033, 64033], "valid"],
		[
			[64034, 64034],
			"mapped",
			[35576]
		],
		[[64035, 64036], "valid"],
		[
			[64037, 64037],
			"mapped",
			[36920]
		],
		[
			[64038, 64038],
			"mapped",
			[37117]
		],
		[[64039, 64041], "valid"],
		[
			[64042, 64042],
			"mapped",
			[39151]
		],
		[
			[64043, 64043],
			"mapped",
			[39164]
		],
		[
			[64044, 64044],
			"mapped",
			[39208]
		],
		[
			[64045, 64045],
			"mapped",
			[40372]
		],
		[
			[64046, 64046],
			"mapped",
			[37086]
		],
		[
			[64047, 64047],
			"mapped",
			[38583]
		],
		[
			[64048, 64048],
			"mapped",
			[20398]
		],
		[
			[64049, 64049],
			"mapped",
			[20711]
		],
		[
			[64050, 64050],
			"mapped",
			[20813]
		],
		[
			[64051, 64051],
			"mapped",
			[21193]
		],
		[
			[64052, 64052],
			"mapped",
			[21220]
		],
		[
			[64053, 64053],
			"mapped",
			[21329]
		],
		[
			[64054, 64054],
			"mapped",
			[21917]
		],
		[
			[64055, 64055],
			"mapped",
			[22022]
		],
		[
			[64056, 64056],
			"mapped",
			[22120]
		],
		[
			[64057, 64057],
			"mapped",
			[22592]
		],
		[
			[64058, 64058],
			"mapped",
			[22696]
		],
		[
			[64059, 64059],
			"mapped",
			[23652]
		],
		[
			[64060, 64060],
			"mapped",
			[23662]
		],
		[
			[64061, 64061],
			"mapped",
			[24724]
		],
		[
			[64062, 64062],
			"mapped",
			[24936]
		],
		[
			[64063, 64063],
			"mapped",
			[24974]
		],
		[
			[64064, 64064],
			"mapped",
			[25074]
		],
		[
			[64065, 64065],
			"mapped",
			[25935]
		],
		[
			[64066, 64066],
			"mapped",
			[26082]
		],
		[
			[64067, 64067],
			"mapped",
			[26257]
		],
		[
			[64068, 64068],
			"mapped",
			[26757]
		],
		[
			[64069, 64069],
			"mapped",
			[28023]
		],
		[
			[64070, 64070],
			"mapped",
			[28186]
		],
		[
			[64071, 64071],
			"mapped",
			[28450]
		],
		[
			[64072, 64072],
			"mapped",
			[29038]
		],
		[
			[64073, 64073],
			"mapped",
			[29227]
		],
		[
			[64074, 64074],
			"mapped",
			[29730]
		],
		[
			[64075, 64075],
			"mapped",
			[30865]
		],
		[
			[64076, 64076],
			"mapped",
			[31038]
		],
		[
			[64077, 64077],
			"mapped",
			[31049]
		],
		[
			[64078, 64078],
			"mapped",
			[31048]
		],
		[
			[64079, 64079],
			"mapped",
			[31056]
		],
		[
			[64080, 64080],
			"mapped",
			[31062]
		],
		[
			[64081, 64081],
			"mapped",
			[31069]
		],
		[
			[64082, 64082],
			"mapped",
			[31117]
		],
		[
			[64083, 64083],
			"mapped",
			[31118]
		],
		[
			[64084, 64084],
			"mapped",
			[31296]
		],
		[
			[64085, 64085],
			"mapped",
			[31361]
		],
		[
			[64086, 64086],
			"mapped",
			[31680]
		],
		[
			[64087, 64087],
			"mapped",
			[32244]
		],
		[
			[64088, 64088],
			"mapped",
			[32265]
		],
		[
			[64089, 64089],
			"mapped",
			[32321]
		],
		[
			[64090, 64090],
			"mapped",
			[32626]
		],
		[
			[64091, 64091],
			"mapped",
			[32773]
		],
		[
			[64092, 64092],
			"mapped",
			[33261]
		],
		[
			[64093, 64094],
			"mapped",
			[33401]
		],
		[
			[64095, 64095],
			"mapped",
			[33879]
		],
		[
			[64096, 64096],
			"mapped",
			[35088]
		],
		[
			[64097, 64097],
			"mapped",
			[35222]
		],
		[
			[64098, 64098],
			"mapped",
			[35585]
		],
		[
			[64099, 64099],
			"mapped",
			[35641]
		],
		[
			[64100, 64100],
			"mapped",
			[36051]
		],
		[
			[64101, 64101],
			"mapped",
			[36104]
		],
		[
			[64102, 64102],
			"mapped",
			[36790]
		],
		[
			[64103, 64103],
			"mapped",
			[36920]
		],
		[
			[64104, 64104],
			"mapped",
			[38627]
		],
		[
			[64105, 64105],
			"mapped",
			[38911]
		],
		[
			[64106, 64106],
			"mapped",
			[38971]
		],
		[
			[64107, 64107],
			"mapped",
			[24693]
		],
		[
			[64108, 64108],
			"mapped",
			[148206]
		],
		[
			[64109, 64109],
			"mapped",
			[33304]
		],
		[[64110, 64111], "disallowed"],
		[
			[64112, 64112],
			"mapped",
			[20006]
		],
		[
			[64113, 64113],
			"mapped",
			[20917]
		],
		[
			[64114, 64114],
			"mapped",
			[20840]
		],
		[
			[64115, 64115],
			"mapped",
			[20352]
		],
		[
			[64116, 64116],
			"mapped",
			[20805]
		],
		[
			[64117, 64117],
			"mapped",
			[20864]
		],
		[
			[64118, 64118],
			"mapped",
			[21191]
		],
		[
			[64119, 64119],
			"mapped",
			[21242]
		],
		[
			[64120, 64120],
			"mapped",
			[21917]
		],
		[
			[64121, 64121],
			"mapped",
			[21845]
		],
		[
			[64122, 64122],
			"mapped",
			[21913]
		],
		[
			[64123, 64123],
			"mapped",
			[21986]
		],
		[
			[64124, 64124],
			"mapped",
			[22618]
		],
		[
			[64125, 64125],
			"mapped",
			[22707]
		],
		[
			[64126, 64126],
			"mapped",
			[22852]
		],
		[
			[64127, 64127],
			"mapped",
			[22868]
		],
		[
			[64128, 64128],
			"mapped",
			[23138]
		],
		[
			[64129, 64129],
			"mapped",
			[23336]
		],
		[
			[64130, 64130],
			"mapped",
			[24274]
		],
		[
			[64131, 64131],
			"mapped",
			[24281]
		],
		[
			[64132, 64132],
			"mapped",
			[24425]
		],
		[
			[64133, 64133],
			"mapped",
			[24493]
		],
		[
			[64134, 64134],
			"mapped",
			[24792]
		],
		[
			[64135, 64135],
			"mapped",
			[24910]
		],
		[
			[64136, 64136],
			"mapped",
			[24840]
		],
		[
			[64137, 64137],
			"mapped",
			[24974]
		],
		[
			[64138, 64138],
			"mapped",
			[24928]
		],
		[
			[64139, 64139],
			"mapped",
			[25074]
		],
		[
			[64140, 64140],
			"mapped",
			[25140]
		],
		[
			[64141, 64141],
			"mapped",
			[25540]
		],
		[
			[64142, 64142],
			"mapped",
			[25628]
		],
		[
			[64143, 64143],
			"mapped",
			[25682]
		],
		[
			[64144, 64144],
			"mapped",
			[25942]
		],
		[
			[64145, 64145],
			"mapped",
			[26228]
		],
		[
			[64146, 64146],
			"mapped",
			[26391]
		],
		[
			[64147, 64147],
			"mapped",
			[26395]
		],
		[
			[64148, 64148],
			"mapped",
			[26454]
		],
		[
			[64149, 64149],
			"mapped",
			[27513]
		],
		[
			[64150, 64150],
			"mapped",
			[27578]
		],
		[
			[64151, 64151],
			"mapped",
			[27969]
		],
		[
			[64152, 64152],
			"mapped",
			[28379]
		],
		[
			[64153, 64153],
			"mapped",
			[28363]
		],
		[
			[64154, 64154],
			"mapped",
			[28450]
		],
		[
			[64155, 64155],
			"mapped",
			[28702]
		],
		[
			[64156, 64156],
			"mapped",
			[29038]
		],
		[
			[64157, 64157],
			"mapped",
			[30631]
		],
		[
			[64158, 64158],
			"mapped",
			[29237]
		],
		[
			[64159, 64159],
			"mapped",
			[29359]
		],
		[
			[64160, 64160],
			"mapped",
			[29482]
		],
		[
			[64161, 64161],
			"mapped",
			[29809]
		],
		[
			[64162, 64162],
			"mapped",
			[29958]
		],
		[
			[64163, 64163],
			"mapped",
			[30011]
		],
		[
			[64164, 64164],
			"mapped",
			[30237]
		],
		[
			[64165, 64165],
			"mapped",
			[30239]
		],
		[
			[64166, 64166],
			"mapped",
			[30410]
		],
		[
			[64167, 64167],
			"mapped",
			[30427]
		],
		[
			[64168, 64168],
			"mapped",
			[30452]
		],
		[
			[64169, 64169],
			"mapped",
			[30538]
		],
		[
			[64170, 64170],
			"mapped",
			[30528]
		],
		[
			[64171, 64171],
			"mapped",
			[30924]
		],
		[
			[64172, 64172],
			"mapped",
			[31409]
		],
		[
			[64173, 64173],
			"mapped",
			[31680]
		],
		[
			[64174, 64174],
			"mapped",
			[31867]
		],
		[
			[64175, 64175],
			"mapped",
			[32091]
		],
		[
			[64176, 64176],
			"mapped",
			[32244]
		],
		[
			[64177, 64177],
			"mapped",
			[32574]
		],
		[
			[64178, 64178],
			"mapped",
			[32773]
		],
		[
			[64179, 64179],
			"mapped",
			[33618]
		],
		[
			[64180, 64180],
			"mapped",
			[33775]
		],
		[
			[64181, 64181],
			"mapped",
			[34681]
		],
		[
			[64182, 64182],
			"mapped",
			[35137]
		],
		[
			[64183, 64183],
			"mapped",
			[35206]
		],
		[
			[64184, 64184],
			"mapped",
			[35222]
		],
		[
			[64185, 64185],
			"mapped",
			[35519]
		],
		[
			[64186, 64186],
			"mapped",
			[35576]
		],
		[
			[64187, 64187],
			"mapped",
			[35531]
		],
		[
			[64188, 64188],
			"mapped",
			[35585]
		],
		[
			[64189, 64189],
			"mapped",
			[35582]
		],
		[
			[64190, 64190],
			"mapped",
			[35565]
		],
		[
			[64191, 64191],
			"mapped",
			[35641]
		],
		[
			[64192, 64192],
			"mapped",
			[35722]
		],
		[
			[64193, 64193],
			"mapped",
			[36104]
		],
		[
			[64194, 64194],
			"mapped",
			[36664]
		],
		[
			[64195, 64195],
			"mapped",
			[36978]
		],
		[
			[64196, 64196],
			"mapped",
			[37273]
		],
		[
			[64197, 64197],
			"mapped",
			[37494]
		],
		[
			[64198, 64198],
			"mapped",
			[38524]
		],
		[
			[64199, 64199],
			"mapped",
			[38627]
		],
		[
			[64200, 64200],
			"mapped",
			[38742]
		],
		[
			[64201, 64201],
			"mapped",
			[38875]
		],
		[
			[64202, 64202],
			"mapped",
			[38911]
		],
		[
			[64203, 64203],
			"mapped",
			[38923]
		],
		[
			[64204, 64204],
			"mapped",
			[38971]
		],
		[
			[64205, 64205],
			"mapped",
			[39698]
		],
		[
			[64206, 64206],
			"mapped",
			[40860]
		],
		[
			[64207, 64207],
			"mapped",
			[141386]
		],
		[
			[64208, 64208],
			"mapped",
			[141380]
		],
		[
			[64209, 64209],
			"mapped",
			[144341]
		],
		[
			[64210, 64210],
			"mapped",
			[15261]
		],
		[
			[64211, 64211],
			"mapped",
			[16408]
		],
		[
			[64212, 64212],
			"mapped",
			[16441]
		],
		[
			[64213, 64213],
			"mapped",
			[152137]
		],
		[
			[64214, 64214],
			"mapped",
			[154832]
		],
		[
			[64215, 64215],
			"mapped",
			[163539]
		],
		[
			[64216, 64216],
			"mapped",
			[40771]
		],
		[
			[64217, 64217],
			"mapped",
			[40846]
		],
		[[64218, 64255], "disallowed"],
		[
			[64256, 64256],
			"mapped",
			[102, 102]
		],
		[
			[64257, 64257],
			"mapped",
			[102, 105]
		],
		[
			[64258, 64258],
			"mapped",
			[102, 108]
		],
		[
			[64259, 64259],
			"mapped",
			[
				102,
				102,
				105
			]
		],
		[
			[64260, 64260],
			"mapped",
			[
				102,
				102,
				108
			]
		],
		[
			[64261, 64262],
			"mapped",
			[115, 116]
		],
		[[64263, 64274], "disallowed"],
		[
			[64275, 64275],
			"mapped",
			[1396, 1398]
		],
		[
			[64276, 64276],
			"mapped",
			[1396, 1381]
		],
		[
			[64277, 64277],
			"mapped",
			[1396, 1387]
		],
		[
			[64278, 64278],
			"mapped",
			[1406, 1398]
		],
		[
			[64279, 64279],
			"mapped",
			[1396, 1389]
		],
		[[64280, 64284], "disallowed"],
		[
			[64285, 64285],
			"mapped",
			[1497, 1460]
		],
		[[64286, 64286], "valid"],
		[
			[64287, 64287],
			"mapped",
			[1522, 1463]
		],
		[
			[64288, 64288],
			"mapped",
			[1506]
		],
		[
			[64289, 64289],
			"mapped",
			[1488]
		],
		[
			[64290, 64290],
			"mapped",
			[1491]
		],
		[
			[64291, 64291],
			"mapped",
			[1492]
		],
		[
			[64292, 64292],
			"mapped",
			[1499]
		],
		[
			[64293, 64293],
			"mapped",
			[1500]
		],
		[
			[64294, 64294],
			"mapped",
			[1501]
		],
		[
			[64295, 64295],
			"mapped",
			[1512]
		],
		[
			[64296, 64296],
			"mapped",
			[1514]
		],
		[
			[64297, 64297],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[64298, 64298],
			"mapped",
			[1513, 1473]
		],
		[
			[64299, 64299],
			"mapped",
			[1513, 1474]
		],
		[
			[64300, 64300],
			"mapped",
			[
				1513,
				1468,
				1473
			]
		],
		[
			[64301, 64301],
			"mapped",
			[
				1513,
				1468,
				1474
			]
		],
		[
			[64302, 64302],
			"mapped",
			[1488, 1463]
		],
		[
			[64303, 64303],
			"mapped",
			[1488, 1464]
		],
		[
			[64304, 64304],
			"mapped",
			[1488, 1468]
		],
		[
			[64305, 64305],
			"mapped",
			[1489, 1468]
		],
		[
			[64306, 64306],
			"mapped",
			[1490, 1468]
		],
		[
			[64307, 64307],
			"mapped",
			[1491, 1468]
		],
		[
			[64308, 64308],
			"mapped",
			[1492, 1468]
		],
		[
			[64309, 64309],
			"mapped",
			[1493, 1468]
		],
		[
			[64310, 64310],
			"mapped",
			[1494, 1468]
		],
		[[64311, 64311], "disallowed"],
		[
			[64312, 64312],
			"mapped",
			[1496, 1468]
		],
		[
			[64313, 64313],
			"mapped",
			[1497, 1468]
		],
		[
			[64314, 64314],
			"mapped",
			[1498, 1468]
		],
		[
			[64315, 64315],
			"mapped",
			[1499, 1468]
		],
		[
			[64316, 64316],
			"mapped",
			[1500, 1468]
		],
		[[64317, 64317], "disallowed"],
		[
			[64318, 64318],
			"mapped",
			[1502, 1468]
		],
		[[64319, 64319], "disallowed"],
		[
			[64320, 64320],
			"mapped",
			[1504, 1468]
		],
		[
			[64321, 64321],
			"mapped",
			[1505, 1468]
		],
		[[64322, 64322], "disallowed"],
		[
			[64323, 64323],
			"mapped",
			[1507, 1468]
		],
		[
			[64324, 64324],
			"mapped",
			[1508, 1468]
		],
		[[64325, 64325], "disallowed"],
		[
			[64326, 64326],
			"mapped",
			[1510, 1468]
		],
		[
			[64327, 64327],
			"mapped",
			[1511, 1468]
		],
		[
			[64328, 64328],
			"mapped",
			[1512, 1468]
		],
		[
			[64329, 64329],
			"mapped",
			[1513, 1468]
		],
		[
			[64330, 64330],
			"mapped",
			[1514, 1468]
		],
		[
			[64331, 64331],
			"mapped",
			[1493, 1465]
		],
		[
			[64332, 64332],
			"mapped",
			[1489, 1471]
		],
		[
			[64333, 64333],
			"mapped",
			[1499, 1471]
		],
		[
			[64334, 64334],
			"mapped",
			[1508, 1471]
		],
		[
			[64335, 64335],
			"mapped",
			[1488, 1500]
		],
		[
			[64336, 64337],
			"mapped",
			[1649]
		],
		[
			[64338, 64341],
			"mapped",
			[1659]
		],
		[
			[64342, 64345],
			"mapped",
			[1662]
		],
		[
			[64346, 64349],
			"mapped",
			[1664]
		],
		[
			[64350, 64353],
			"mapped",
			[1658]
		],
		[
			[64354, 64357],
			"mapped",
			[1663]
		],
		[
			[64358, 64361],
			"mapped",
			[1657]
		],
		[
			[64362, 64365],
			"mapped",
			[1700]
		],
		[
			[64366, 64369],
			"mapped",
			[1702]
		],
		[
			[64370, 64373],
			"mapped",
			[1668]
		],
		[
			[64374, 64377],
			"mapped",
			[1667]
		],
		[
			[64378, 64381],
			"mapped",
			[1670]
		],
		[
			[64382, 64385],
			"mapped",
			[1671]
		],
		[
			[64386, 64387],
			"mapped",
			[1677]
		],
		[
			[64388, 64389],
			"mapped",
			[1676]
		],
		[
			[64390, 64391],
			"mapped",
			[1678]
		],
		[
			[64392, 64393],
			"mapped",
			[1672]
		],
		[
			[64394, 64395],
			"mapped",
			[1688]
		],
		[
			[64396, 64397],
			"mapped",
			[1681]
		],
		[
			[64398, 64401],
			"mapped",
			[1705]
		],
		[
			[64402, 64405],
			"mapped",
			[1711]
		],
		[
			[64406, 64409],
			"mapped",
			[1715]
		],
		[
			[64410, 64413],
			"mapped",
			[1713]
		],
		[
			[64414, 64415],
			"mapped",
			[1722]
		],
		[
			[64416, 64419],
			"mapped",
			[1723]
		],
		[
			[64420, 64421],
			"mapped",
			[1728]
		],
		[
			[64422, 64425],
			"mapped",
			[1729]
		],
		[
			[64426, 64429],
			"mapped",
			[1726]
		],
		[
			[64430, 64431],
			"mapped",
			[1746]
		],
		[
			[64432, 64433],
			"mapped",
			[1747]
		],
		[
			[64434, 64449],
			"valid",
			[],
			"NV8"
		],
		[[64450, 64466], "disallowed"],
		[
			[64467, 64470],
			"mapped",
			[1709]
		],
		[
			[64471, 64472],
			"mapped",
			[1735]
		],
		[
			[64473, 64474],
			"mapped",
			[1734]
		],
		[
			[64475, 64476],
			"mapped",
			[1736]
		],
		[
			[64477, 64477],
			"mapped",
			[1735, 1652]
		],
		[
			[64478, 64479],
			"mapped",
			[1739]
		],
		[
			[64480, 64481],
			"mapped",
			[1733]
		],
		[
			[64482, 64483],
			"mapped",
			[1737]
		],
		[
			[64484, 64487],
			"mapped",
			[1744]
		],
		[
			[64488, 64489],
			"mapped",
			[1609]
		],
		[
			[64490, 64491],
			"mapped",
			[1574, 1575]
		],
		[
			[64492, 64493],
			"mapped",
			[1574, 1749]
		],
		[
			[64494, 64495],
			"mapped",
			[1574, 1608]
		],
		[
			[64496, 64497],
			"mapped",
			[1574, 1735]
		],
		[
			[64498, 64499],
			"mapped",
			[1574, 1734]
		],
		[
			[64500, 64501],
			"mapped",
			[1574, 1736]
		],
		[
			[64502, 64504],
			"mapped",
			[1574, 1744]
		],
		[
			[64505, 64507],
			"mapped",
			[1574, 1609]
		],
		[
			[64508, 64511],
			"mapped",
			[1740]
		],
		[
			[64512, 64512],
			"mapped",
			[1574, 1580]
		],
		[
			[64513, 64513],
			"mapped",
			[1574, 1581]
		],
		[
			[64514, 64514],
			"mapped",
			[1574, 1605]
		],
		[
			[64515, 64515],
			"mapped",
			[1574, 1609]
		],
		[
			[64516, 64516],
			"mapped",
			[1574, 1610]
		],
		[
			[64517, 64517],
			"mapped",
			[1576, 1580]
		],
		[
			[64518, 64518],
			"mapped",
			[1576, 1581]
		],
		[
			[64519, 64519],
			"mapped",
			[1576, 1582]
		],
		[
			[64520, 64520],
			"mapped",
			[1576, 1605]
		],
		[
			[64521, 64521],
			"mapped",
			[1576, 1609]
		],
		[
			[64522, 64522],
			"mapped",
			[1576, 1610]
		],
		[
			[64523, 64523],
			"mapped",
			[1578, 1580]
		],
		[
			[64524, 64524],
			"mapped",
			[1578, 1581]
		],
		[
			[64525, 64525],
			"mapped",
			[1578, 1582]
		],
		[
			[64526, 64526],
			"mapped",
			[1578, 1605]
		],
		[
			[64527, 64527],
			"mapped",
			[1578, 1609]
		],
		[
			[64528, 64528],
			"mapped",
			[1578, 1610]
		],
		[
			[64529, 64529],
			"mapped",
			[1579, 1580]
		],
		[
			[64530, 64530],
			"mapped",
			[1579, 1605]
		],
		[
			[64531, 64531],
			"mapped",
			[1579, 1609]
		],
		[
			[64532, 64532],
			"mapped",
			[1579, 1610]
		],
		[
			[64533, 64533],
			"mapped",
			[1580, 1581]
		],
		[
			[64534, 64534],
			"mapped",
			[1580, 1605]
		],
		[
			[64535, 64535],
			"mapped",
			[1581, 1580]
		],
		[
			[64536, 64536],
			"mapped",
			[1581, 1605]
		],
		[
			[64537, 64537],
			"mapped",
			[1582, 1580]
		],
		[
			[64538, 64538],
			"mapped",
			[1582, 1581]
		],
		[
			[64539, 64539],
			"mapped",
			[1582, 1605]
		],
		[
			[64540, 64540],
			"mapped",
			[1587, 1580]
		],
		[
			[64541, 64541],
			"mapped",
			[1587, 1581]
		],
		[
			[64542, 64542],
			"mapped",
			[1587, 1582]
		],
		[
			[64543, 64543],
			"mapped",
			[1587, 1605]
		],
		[
			[64544, 64544],
			"mapped",
			[1589, 1581]
		],
		[
			[64545, 64545],
			"mapped",
			[1589, 1605]
		],
		[
			[64546, 64546],
			"mapped",
			[1590, 1580]
		],
		[
			[64547, 64547],
			"mapped",
			[1590, 1581]
		],
		[
			[64548, 64548],
			"mapped",
			[1590, 1582]
		],
		[
			[64549, 64549],
			"mapped",
			[1590, 1605]
		],
		[
			[64550, 64550],
			"mapped",
			[1591, 1581]
		],
		[
			[64551, 64551],
			"mapped",
			[1591, 1605]
		],
		[
			[64552, 64552],
			"mapped",
			[1592, 1605]
		],
		[
			[64553, 64553],
			"mapped",
			[1593, 1580]
		],
		[
			[64554, 64554],
			"mapped",
			[1593, 1605]
		],
		[
			[64555, 64555],
			"mapped",
			[1594, 1580]
		],
		[
			[64556, 64556],
			"mapped",
			[1594, 1605]
		],
		[
			[64557, 64557],
			"mapped",
			[1601, 1580]
		],
		[
			[64558, 64558],
			"mapped",
			[1601, 1581]
		],
		[
			[64559, 64559],
			"mapped",
			[1601, 1582]
		],
		[
			[64560, 64560],
			"mapped",
			[1601, 1605]
		],
		[
			[64561, 64561],
			"mapped",
			[1601, 1609]
		],
		[
			[64562, 64562],
			"mapped",
			[1601, 1610]
		],
		[
			[64563, 64563],
			"mapped",
			[1602, 1581]
		],
		[
			[64564, 64564],
			"mapped",
			[1602, 1605]
		],
		[
			[64565, 64565],
			"mapped",
			[1602, 1609]
		],
		[
			[64566, 64566],
			"mapped",
			[1602, 1610]
		],
		[
			[64567, 64567],
			"mapped",
			[1603, 1575]
		],
		[
			[64568, 64568],
			"mapped",
			[1603, 1580]
		],
		[
			[64569, 64569],
			"mapped",
			[1603, 1581]
		],
		[
			[64570, 64570],
			"mapped",
			[1603, 1582]
		],
		[
			[64571, 64571],
			"mapped",
			[1603, 1604]
		],
		[
			[64572, 64572],
			"mapped",
			[1603, 1605]
		],
		[
			[64573, 64573],
			"mapped",
			[1603, 1609]
		],
		[
			[64574, 64574],
			"mapped",
			[1603, 1610]
		],
		[
			[64575, 64575],
			"mapped",
			[1604, 1580]
		],
		[
			[64576, 64576],
			"mapped",
			[1604, 1581]
		],
		[
			[64577, 64577],
			"mapped",
			[1604, 1582]
		],
		[
			[64578, 64578],
			"mapped",
			[1604, 1605]
		],
		[
			[64579, 64579],
			"mapped",
			[1604, 1609]
		],
		[
			[64580, 64580],
			"mapped",
			[1604, 1610]
		],
		[
			[64581, 64581],
			"mapped",
			[1605, 1580]
		],
		[
			[64582, 64582],
			"mapped",
			[1605, 1581]
		],
		[
			[64583, 64583],
			"mapped",
			[1605, 1582]
		],
		[
			[64584, 64584],
			"mapped",
			[1605, 1605]
		],
		[
			[64585, 64585],
			"mapped",
			[1605, 1609]
		],
		[
			[64586, 64586],
			"mapped",
			[1605, 1610]
		],
		[
			[64587, 64587],
			"mapped",
			[1606, 1580]
		],
		[
			[64588, 64588],
			"mapped",
			[1606, 1581]
		],
		[
			[64589, 64589],
			"mapped",
			[1606, 1582]
		],
		[
			[64590, 64590],
			"mapped",
			[1606, 1605]
		],
		[
			[64591, 64591],
			"mapped",
			[1606, 1609]
		],
		[
			[64592, 64592],
			"mapped",
			[1606, 1610]
		],
		[
			[64593, 64593],
			"mapped",
			[1607, 1580]
		],
		[
			[64594, 64594],
			"mapped",
			[1607, 1605]
		],
		[
			[64595, 64595],
			"mapped",
			[1607, 1609]
		],
		[
			[64596, 64596],
			"mapped",
			[1607, 1610]
		],
		[
			[64597, 64597],
			"mapped",
			[1610, 1580]
		],
		[
			[64598, 64598],
			"mapped",
			[1610, 1581]
		],
		[
			[64599, 64599],
			"mapped",
			[1610, 1582]
		],
		[
			[64600, 64600],
			"mapped",
			[1610, 1605]
		],
		[
			[64601, 64601],
			"mapped",
			[1610, 1609]
		],
		[
			[64602, 64602],
			"mapped",
			[1610, 1610]
		],
		[
			[64603, 64603],
			"mapped",
			[1584, 1648]
		],
		[
			[64604, 64604],
			"mapped",
			[1585, 1648]
		],
		[
			[64605, 64605],
			"mapped",
			[1609, 1648]
		],
		[
			[64606, 64606],
			"disallowed_STD3_mapped",
			[
				32,
				1612,
				1617
			]
		],
		[
			[64607, 64607],
			"disallowed_STD3_mapped",
			[
				32,
				1613,
				1617
			]
		],
		[
			[64608, 64608],
			"disallowed_STD3_mapped",
			[
				32,
				1614,
				1617
			]
		],
		[
			[64609, 64609],
			"disallowed_STD3_mapped",
			[
				32,
				1615,
				1617
			]
		],
		[
			[64610, 64610],
			"disallowed_STD3_mapped",
			[
				32,
				1616,
				1617
			]
		],
		[
			[64611, 64611],
			"disallowed_STD3_mapped",
			[
				32,
				1617,
				1648
			]
		],
		[
			[64612, 64612],
			"mapped",
			[1574, 1585]
		],
		[
			[64613, 64613],
			"mapped",
			[1574, 1586]
		],
		[
			[64614, 64614],
			"mapped",
			[1574, 1605]
		],
		[
			[64615, 64615],
			"mapped",
			[1574, 1606]
		],
		[
			[64616, 64616],
			"mapped",
			[1574, 1609]
		],
		[
			[64617, 64617],
			"mapped",
			[1574, 1610]
		],
		[
			[64618, 64618],
			"mapped",
			[1576, 1585]
		],
		[
			[64619, 64619],
			"mapped",
			[1576, 1586]
		],
		[
			[64620, 64620],
			"mapped",
			[1576, 1605]
		],
		[
			[64621, 64621],
			"mapped",
			[1576, 1606]
		],
		[
			[64622, 64622],
			"mapped",
			[1576, 1609]
		],
		[
			[64623, 64623],
			"mapped",
			[1576, 1610]
		],
		[
			[64624, 64624],
			"mapped",
			[1578, 1585]
		],
		[
			[64625, 64625],
			"mapped",
			[1578, 1586]
		],
		[
			[64626, 64626],
			"mapped",
			[1578, 1605]
		],
		[
			[64627, 64627],
			"mapped",
			[1578, 1606]
		],
		[
			[64628, 64628],
			"mapped",
			[1578, 1609]
		],
		[
			[64629, 64629],
			"mapped",
			[1578, 1610]
		],
		[
			[64630, 64630],
			"mapped",
			[1579, 1585]
		],
		[
			[64631, 64631],
			"mapped",
			[1579, 1586]
		],
		[
			[64632, 64632],
			"mapped",
			[1579, 1605]
		],
		[
			[64633, 64633],
			"mapped",
			[1579, 1606]
		],
		[
			[64634, 64634],
			"mapped",
			[1579, 1609]
		],
		[
			[64635, 64635],
			"mapped",
			[1579, 1610]
		],
		[
			[64636, 64636],
			"mapped",
			[1601, 1609]
		],
		[
			[64637, 64637],
			"mapped",
			[1601, 1610]
		],
		[
			[64638, 64638],
			"mapped",
			[1602, 1609]
		],
		[
			[64639, 64639],
			"mapped",
			[1602, 1610]
		],
		[
			[64640, 64640],
			"mapped",
			[1603, 1575]
		],
		[
			[64641, 64641],
			"mapped",
			[1603, 1604]
		],
		[
			[64642, 64642],
			"mapped",
			[1603, 1605]
		],
		[
			[64643, 64643],
			"mapped",
			[1603, 1609]
		],
		[
			[64644, 64644],
			"mapped",
			[1603, 1610]
		],
		[
			[64645, 64645],
			"mapped",
			[1604, 1605]
		],
		[
			[64646, 64646],
			"mapped",
			[1604, 1609]
		],
		[
			[64647, 64647],
			"mapped",
			[1604, 1610]
		],
		[
			[64648, 64648],
			"mapped",
			[1605, 1575]
		],
		[
			[64649, 64649],
			"mapped",
			[1605, 1605]
		],
		[
			[64650, 64650],
			"mapped",
			[1606, 1585]
		],
		[
			[64651, 64651],
			"mapped",
			[1606, 1586]
		],
		[
			[64652, 64652],
			"mapped",
			[1606, 1605]
		],
		[
			[64653, 64653],
			"mapped",
			[1606, 1606]
		],
		[
			[64654, 64654],
			"mapped",
			[1606, 1609]
		],
		[
			[64655, 64655],
			"mapped",
			[1606, 1610]
		],
		[
			[64656, 64656],
			"mapped",
			[1609, 1648]
		],
		[
			[64657, 64657],
			"mapped",
			[1610, 1585]
		],
		[
			[64658, 64658],
			"mapped",
			[1610, 1586]
		],
		[
			[64659, 64659],
			"mapped",
			[1610, 1605]
		],
		[
			[64660, 64660],
			"mapped",
			[1610, 1606]
		],
		[
			[64661, 64661],
			"mapped",
			[1610, 1609]
		],
		[
			[64662, 64662],
			"mapped",
			[1610, 1610]
		],
		[
			[64663, 64663],
			"mapped",
			[1574, 1580]
		],
		[
			[64664, 64664],
			"mapped",
			[1574, 1581]
		],
		[
			[64665, 64665],
			"mapped",
			[1574, 1582]
		],
		[
			[64666, 64666],
			"mapped",
			[1574, 1605]
		],
		[
			[64667, 64667],
			"mapped",
			[1574, 1607]
		],
		[
			[64668, 64668],
			"mapped",
			[1576, 1580]
		],
		[
			[64669, 64669],
			"mapped",
			[1576, 1581]
		],
		[
			[64670, 64670],
			"mapped",
			[1576, 1582]
		],
		[
			[64671, 64671],
			"mapped",
			[1576, 1605]
		],
		[
			[64672, 64672],
			"mapped",
			[1576, 1607]
		],
		[
			[64673, 64673],
			"mapped",
			[1578, 1580]
		],
		[
			[64674, 64674],
			"mapped",
			[1578, 1581]
		],
		[
			[64675, 64675],
			"mapped",
			[1578, 1582]
		],
		[
			[64676, 64676],
			"mapped",
			[1578, 1605]
		],
		[
			[64677, 64677],
			"mapped",
			[1578, 1607]
		],
		[
			[64678, 64678],
			"mapped",
			[1579, 1605]
		],
		[
			[64679, 64679],
			"mapped",
			[1580, 1581]
		],
		[
			[64680, 64680],
			"mapped",
			[1580, 1605]
		],
		[
			[64681, 64681],
			"mapped",
			[1581, 1580]
		],
		[
			[64682, 64682],
			"mapped",
			[1581, 1605]
		],
		[
			[64683, 64683],
			"mapped",
			[1582, 1580]
		],
		[
			[64684, 64684],
			"mapped",
			[1582, 1605]
		],
		[
			[64685, 64685],
			"mapped",
			[1587, 1580]
		],
		[
			[64686, 64686],
			"mapped",
			[1587, 1581]
		],
		[
			[64687, 64687],
			"mapped",
			[1587, 1582]
		],
		[
			[64688, 64688],
			"mapped",
			[1587, 1605]
		],
		[
			[64689, 64689],
			"mapped",
			[1589, 1581]
		],
		[
			[64690, 64690],
			"mapped",
			[1589, 1582]
		],
		[
			[64691, 64691],
			"mapped",
			[1589, 1605]
		],
		[
			[64692, 64692],
			"mapped",
			[1590, 1580]
		],
		[
			[64693, 64693],
			"mapped",
			[1590, 1581]
		],
		[
			[64694, 64694],
			"mapped",
			[1590, 1582]
		],
		[
			[64695, 64695],
			"mapped",
			[1590, 1605]
		],
		[
			[64696, 64696],
			"mapped",
			[1591, 1581]
		],
		[
			[64697, 64697],
			"mapped",
			[1592, 1605]
		],
		[
			[64698, 64698],
			"mapped",
			[1593, 1580]
		],
		[
			[64699, 64699],
			"mapped",
			[1593, 1605]
		],
		[
			[64700, 64700],
			"mapped",
			[1594, 1580]
		],
		[
			[64701, 64701],
			"mapped",
			[1594, 1605]
		],
		[
			[64702, 64702],
			"mapped",
			[1601, 1580]
		],
		[
			[64703, 64703],
			"mapped",
			[1601, 1581]
		],
		[
			[64704, 64704],
			"mapped",
			[1601, 1582]
		],
		[
			[64705, 64705],
			"mapped",
			[1601, 1605]
		],
		[
			[64706, 64706],
			"mapped",
			[1602, 1581]
		],
		[
			[64707, 64707],
			"mapped",
			[1602, 1605]
		],
		[
			[64708, 64708],
			"mapped",
			[1603, 1580]
		],
		[
			[64709, 64709],
			"mapped",
			[1603, 1581]
		],
		[
			[64710, 64710],
			"mapped",
			[1603, 1582]
		],
		[
			[64711, 64711],
			"mapped",
			[1603, 1604]
		],
		[
			[64712, 64712],
			"mapped",
			[1603, 1605]
		],
		[
			[64713, 64713],
			"mapped",
			[1604, 1580]
		],
		[
			[64714, 64714],
			"mapped",
			[1604, 1581]
		],
		[
			[64715, 64715],
			"mapped",
			[1604, 1582]
		],
		[
			[64716, 64716],
			"mapped",
			[1604, 1605]
		],
		[
			[64717, 64717],
			"mapped",
			[1604, 1607]
		],
		[
			[64718, 64718],
			"mapped",
			[1605, 1580]
		],
		[
			[64719, 64719],
			"mapped",
			[1605, 1581]
		],
		[
			[64720, 64720],
			"mapped",
			[1605, 1582]
		],
		[
			[64721, 64721],
			"mapped",
			[1605, 1605]
		],
		[
			[64722, 64722],
			"mapped",
			[1606, 1580]
		],
		[
			[64723, 64723],
			"mapped",
			[1606, 1581]
		],
		[
			[64724, 64724],
			"mapped",
			[1606, 1582]
		],
		[
			[64725, 64725],
			"mapped",
			[1606, 1605]
		],
		[
			[64726, 64726],
			"mapped",
			[1606, 1607]
		],
		[
			[64727, 64727],
			"mapped",
			[1607, 1580]
		],
		[
			[64728, 64728],
			"mapped",
			[1607, 1605]
		],
		[
			[64729, 64729],
			"mapped",
			[1607, 1648]
		],
		[
			[64730, 64730],
			"mapped",
			[1610, 1580]
		],
		[
			[64731, 64731],
			"mapped",
			[1610, 1581]
		],
		[
			[64732, 64732],
			"mapped",
			[1610, 1582]
		],
		[
			[64733, 64733],
			"mapped",
			[1610, 1605]
		],
		[
			[64734, 64734],
			"mapped",
			[1610, 1607]
		],
		[
			[64735, 64735],
			"mapped",
			[1574, 1605]
		],
		[
			[64736, 64736],
			"mapped",
			[1574, 1607]
		],
		[
			[64737, 64737],
			"mapped",
			[1576, 1605]
		],
		[
			[64738, 64738],
			"mapped",
			[1576, 1607]
		],
		[
			[64739, 64739],
			"mapped",
			[1578, 1605]
		],
		[
			[64740, 64740],
			"mapped",
			[1578, 1607]
		],
		[
			[64741, 64741],
			"mapped",
			[1579, 1605]
		],
		[
			[64742, 64742],
			"mapped",
			[1579, 1607]
		],
		[
			[64743, 64743],
			"mapped",
			[1587, 1605]
		],
		[
			[64744, 64744],
			"mapped",
			[1587, 1607]
		],
		[
			[64745, 64745],
			"mapped",
			[1588, 1605]
		],
		[
			[64746, 64746],
			"mapped",
			[1588, 1607]
		],
		[
			[64747, 64747],
			"mapped",
			[1603, 1604]
		],
		[
			[64748, 64748],
			"mapped",
			[1603, 1605]
		],
		[
			[64749, 64749],
			"mapped",
			[1604, 1605]
		],
		[
			[64750, 64750],
			"mapped",
			[1606, 1605]
		],
		[
			[64751, 64751],
			"mapped",
			[1606, 1607]
		],
		[
			[64752, 64752],
			"mapped",
			[1610, 1605]
		],
		[
			[64753, 64753],
			"mapped",
			[1610, 1607]
		],
		[
			[64754, 64754],
			"mapped",
			[
				1600,
				1614,
				1617
			]
		],
		[
			[64755, 64755],
			"mapped",
			[
				1600,
				1615,
				1617
			]
		],
		[
			[64756, 64756],
			"mapped",
			[
				1600,
				1616,
				1617
			]
		],
		[
			[64757, 64757],
			"mapped",
			[1591, 1609]
		],
		[
			[64758, 64758],
			"mapped",
			[1591, 1610]
		],
		[
			[64759, 64759],
			"mapped",
			[1593, 1609]
		],
		[
			[64760, 64760],
			"mapped",
			[1593, 1610]
		],
		[
			[64761, 64761],
			"mapped",
			[1594, 1609]
		],
		[
			[64762, 64762],
			"mapped",
			[1594, 1610]
		],
		[
			[64763, 64763],
			"mapped",
			[1587, 1609]
		],
		[
			[64764, 64764],
			"mapped",
			[1587, 1610]
		],
		[
			[64765, 64765],
			"mapped",
			[1588, 1609]
		],
		[
			[64766, 64766],
			"mapped",
			[1588, 1610]
		],
		[
			[64767, 64767],
			"mapped",
			[1581, 1609]
		],
		[
			[64768, 64768],
			"mapped",
			[1581, 1610]
		],
		[
			[64769, 64769],
			"mapped",
			[1580, 1609]
		],
		[
			[64770, 64770],
			"mapped",
			[1580, 1610]
		],
		[
			[64771, 64771],
			"mapped",
			[1582, 1609]
		],
		[
			[64772, 64772],
			"mapped",
			[1582, 1610]
		],
		[
			[64773, 64773],
			"mapped",
			[1589, 1609]
		],
		[
			[64774, 64774],
			"mapped",
			[1589, 1610]
		],
		[
			[64775, 64775],
			"mapped",
			[1590, 1609]
		],
		[
			[64776, 64776],
			"mapped",
			[1590, 1610]
		],
		[
			[64777, 64777],
			"mapped",
			[1588, 1580]
		],
		[
			[64778, 64778],
			"mapped",
			[1588, 1581]
		],
		[
			[64779, 64779],
			"mapped",
			[1588, 1582]
		],
		[
			[64780, 64780],
			"mapped",
			[1588, 1605]
		],
		[
			[64781, 64781],
			"mapped",
			[1588, 1585]
		],
		[
			[64782, 64782],
			"mapped",
			[1587, 1585]
		],
		[
			[64783, 64783],
			"mapped",
			[1589, 1585]
		],
		[
			[64784, 64784],
			"mapped",
			[1590, 1585]
		],
		[
			[64785, 64785],
			"mapped",
			[1591, 1609]
		],
		[
			[64786, 64786],
			"mapped",
			[1591, 1610]
		],
		[
			[64787, 64787],
			"mapped",
			[1593, 1609]
		],
		[
			[64788, 64788],
			"mapped",
			[1593, 1610]
		],
		[
			[64789, 64789],
			"mapped",
			[1594, 1609]
		],
		[
			[64790, 64790],
			"mapped",
			[1594, 1610]
		],
		[
			[64791, 64791],
			"mapped",
			[1587, 1609]
		],
		[
			[64792, 64792],
			"mapped",
			[1587, 1610]
		],
		[
			[64793, 64793],
			"mapped",
			[1588, 1609]
		],
		[
			[64794, 64794],
			"mapped",
			[1588, 1610]
		],
		[
			[64795, 64795],
			"mapped",
			[1581, 1609]
		],
		[
			[64796, 64796],
			"mapped",
			[1581, 1610]
		],
		[
			[64797, 64797],
			"mapped",
			[1580, 1609]
		],
		[
			[64798, 64798],
			"mapped",
			[1580, 1610]
		],
		[
			[64799, 64799],
			"mapped",
			[1582, 1609]
		],
		[
			[64800, 64800],
			"mapped",
			[1582, 1610]
		],
		[
			[64801, 64801],
			"mapped",
			[1589, 1609]
		],
		[
			[64802, 64802],
			"mapped",
			[1589, 1610]
		],
		[
			[64803, 64803],
			"mapped",
			[1590, 1609]
		],
		[
			[64804, 64804],
			"mapped",
			[1590, 1610]
		],
		[
			[64805, 64805],
			"mapped",
			[1588, 1580]
		],
		[
			[64806, 64806],
			"mapped",
			[1588, 1581]
		],
		[
			[64807, 64807],
			"mapped",
			[1588, 1582]
		],
		[
			[64808, 64808],
			"mapped",
			[1588, 1605]
		],
		[
			[64809, 64809],
			"mapped",
			[1588, 1585]
		],
		[
			[64810, 64810],
			"mapped",
			[1587, 1585]
		],
		[
			[64811, 64811],
			"mapped",
			[1589, 1585]
		],
		[
			[64812, 64812],
			"mapped",
			[1590, 1585]
		],
		[
			[64813, 64813],
			"mapped",
			[1588, 1580]
		],
		[
			[64814, 64814],
			"mapped",
			[1588, 1581]
		],
		[
			[64815, 64815],
			"mapped",
			[1588, 1582]
		],
		[
			[64816, 64816],
			"mapped",
			[1588, 1605]
		],
		[
			[64817, 64817],
			"mapped",
			[1587, 1607]
		],
		[
			[64818, 64818],
			"mapped",
			[1588, 1607]
		],
		[
			[64819, 64819],
			"mapped",
			[1591, 1605]
		],
		[
			[64820, 64820],
			"mapped",
			[1587, 1580]
		],
		[
			[64821, 64821],
			"mapped",
			[1587, 1581]
		],
		[
			[64822, 64822],
			"mapped",
			[1587, 1582]
		],
		[
			[64823, 64823],
			"mapped",
			[1588, 1580]
		],
		[
			[64824, 64824],
			"mapped",
			[1588, 1581]
		],
		[
			[64825, 64825],
			"mapped",
			[1588, 1582]
		],
		[
			[64826, 64826],
			"mapped",
			[1591, 1605]
		],
		[
			[64827, 64827],
			"mapped",
			[1592, 1605]
		],
		[
			[64828, 64829],
			"mapped",
			[1575, 1611]
		],
		[
			[64830, 64831],
			"valid",
			[],
			"NV8"
		],
		[[64832, 64847], "disallowed"],
		[
			[64848, 64848],
			"mapped",
			[
				1578,
				1580,
				1605
			]
		],
		[
			[64849, 64850],
			"mapped",
			[
				1578,
				1581,
				1580
			]
		],
		[
			[64851, 64851],
			"mapped",
			[
				1578,
				1581,
				1605
			]
		],
		[
			[64852, 64852],
			"mapped",
			[
				1578,
				1582,
				1605
			]
		],
		[
			[64853, 64853],
			"mapped",
			[
				1578,
				1605,
				1580
			]
		],
		[
			[64854, 64854],
			"mapped",
			[
				1578,
				1605,
				1581
			]
		],
		[
			[64855, 64855],
			"mapped",
			[
				1578,
				1605,
				1582
			]
		],
		[
			[64856, 64857],
			"mapped",
			[
				1580,
				1605,
				1581
			]
		],
		[
			[64858, 64858],
			"mapped",
			[
				1581,
				1605,
				1610
			]
		],
		[
			[64859, 64859],
			"mapped",
			[
				1581,
				1605,
				1609
			]
		],
		[
			[64860, 64860],
			"mapped",
			[
				1587,
				1581,
				1580
			]
		],
		[
			[64861, 64861],
			"mapped",
			[
				1587,
				1580,
				1581
			]
		],
		[
			[64862, 64862],
			"mapped",
			[
				1587,
				1580,
				1609
			]
		],
		[
			[64863, 64864],
			"mapped",
			[
				1587,
				1605,
				1581
			]
		],
		[
			[64865, 64865],
			"mapped",
			[
				1587,
				1605,
				1580
			]
		],
		[
			[64866, 64867],
			"mapped",
			[
				1587,
				1605,
				1605
			]
		],
		[
			[64868, 64869],
			"mapped",
			[
				1589,
				1581,
				1581
			]
		],
		[
			[64870, 64870],
			"mapped",
			[
				1589,
				1605,
				1605
			]
		],
		[
			[64871, 64872],
			"mapped",
			[
				1588,
				1581,
				1605
			]
		],
		[
			[64873, 64873],
			"mapped",
			[
				1588,
				1580,
				1610
			]
		],
		[
			[64874, 64875],
			"mapped",
			[
				1588,
				1605,
				1582
			]
		],
		[
			[64876, 64877],
			"mapped",
			[
				1588,
				1605,
				1605
			]
		],
		[
			[64878, 64878],
			"mapped",
			[
				1590,
				1581,
				1609
			]
		],
		[
			[64879, 64880],
			"mapped",
			[
				1590,
				1582,
				1605
			]
		],
		[
			[64881, 64882],
			"mapped",
			[
				1591,
				1605,
				1581
			]
		],
		[
			[64883, 64883],
			"mapped",
			[
				1591,
				1605,
				1605
			]
		],
		[
			[64884, 64884],
			"mapped",
			[
				1591,
				1605,
				1610
			]
		],
		[
			[64885, 64885],
			"mapped",
			[
				1593,
				1580,
				1605
			]
		],
		[
			[64886, 64887],
			"mapped",
			[
				1593,
				1605,
				1605
			]
		],
		[
			[64888, 64888],
			"mapped",
			[
				1593,
				1605,
				1609
			]
		],
		[
			[64889, 64889],
			"mapped",
			[
				1594,
				1605,
				1605
			]
		],
		[
			[64890, 64890],
			"mapped",
			[
				1594,
				1605,
				1610
			]
		],
		[
			[64891, 64891],
			"mapped",
			[
				1594,
				1605,
				1609
			]
		],
		[
			[64892, 64893],
			"mapped",
			[
				1601,
				1582,
				1605
			]
		],
		[
			[64894, 64894],
			"mapped",
			[
				1602,
				1605,
				1581
			]
		],
		[
			[64895, 64895],
			"mapped",
			[
				1602,
				1605,
				1605
			]
		],
		[
			[64896, 64896],
			"mapped",
			[
				1604,
				1581,
				1605
			]
		],
		[
			[64897, 64897],
			"mapped",
			[
				1604,
				1581,
				1610
			]
		],
		[
			[64898, 64898],
			"mapped",
			[
				1604,
				1581,
				1609
			]
		],
		[
			[64899, 64900],
			"mapped",
			[
				1604,
				1580,
				1580
			]
		],
		[
			[64901, 64902],
			"mapped",
			[
				1604,
				1582,
				1605
			]
		],
		[
			[64903, 64904],
			"mapped",
			[
				1604,
				1605,
				1581
			]
		],
		[
			[64905, 64905],
			"mapped",
			[
				1605,
				1581,
				1580
			]
		],
		[
			[64906, 64906],
			"mapped",
			[
				1605,
				1581,
				1605
			]
		],
		[
			[64907, 64907],
			"mapped",
			[
				1605,
				1581,
				1610
			]
		],
		[
			[64908, 64908],
			"mapped",
			[
				1605,
				1580,
				1581
			]
		],
		[
			[64909, 64909],
			"mapped",
			[
				1605,
				1580,
				1605
			]
		],
		[
			[64910, 64910],
			"mapped",
			[
				1605,
				1582,
				1580
			]
		],
		[
			[64911, 64911],
			"mapped",
			[
				1605,
				1582,
				1605
			]
		],
		[[64912, 64913], "disallowed"],
		[
			[64914, 64914],
			"mapped",
			[
				1605,
				1580,
				1582
			]
		],
		[
			[64915, 64915],
			"mapped",
			[
				1607,
				1605,
				1580
			]
		],
		[
			[64916, 64916],
			"mapped",
			[
				1607,
				1605,
				1605
			]
		],
		[
			[64917, 64917],
			"mapped",
			[
				1606,
				1581,
				1605
			]
		],
		[
			[64918, 64918],
			"mapped",
			[
				1606,
				1581,
				1609
			]
		],
		[
			[64919, 64920],
			"mapped",
			[
				1606,
				1580,
				1605
			]
		],
		[
			[64921, 64921],
			"mapped",
			[
				1606,
				1580,
				1609
			]
		],
		[
			[64922, 64922],
			"mapped",
			[
				1606,
				1605,
				1610
			]
		],
		[
			[64923, 64923],
			"mapped",
			[
				1606,
				1605,
				1609
			]
		],
		[
			[64924, 64925],
			"mapped",
			[
				1610,
				1605,
				1605
			]
		],
		[
			[64926, 64926],
			"mapped",
			[
				1576,
				1582,
				1610
			]
		],
		[
			[64927, 64927],
			"mapped",
			[
				1578,
				1580,
				1610
			]
		],
		[
			[64928, 64928],
			"mapped",
			[
				1578,
				1580,
				1609
			]
		],
		[
			[64929, 64929],
			"mapped",
			[
				1578,
				1582,
				1610
			]
		],
		[
			[64930, 64930],
			"mapped",
			[
				1578,
				1582,
				1609
			]
		],
		[
			[64931, 64931],
			"mapped",
			[
				1578,
				1605,
				1610
			]
		],
		[
			[64932, 64932],
			"mapped",
			[
				1578,
				1605,
				1609
			]
		],
		[
			[64933, 64933],
			"mapped",
			[
				1580,
				1605,
				1610
			]
		],
		[
			[64934, 64934],
			"mapped",
			[
				1580,
				1581,
				1609
			]
		],
		[
			[64935, 64935],
			"mapped",
			[
				1580,
				1605,
				1609
			]
		],
		[
			[64936, 64936],
			"mapped",
			[
				1587,
				1582,
				1609
			]
		],
		[
			[64937, 64937],
			"mapped",
			[
				1589,
				1581,
				1610
			]
		],
		[
			[64938, 64938],
			"mapped",
			[
				1588,
				1581,
				1610
			]
		],
		[
			[64939, 64939],
			"mapped",
			[
				1590,
				1581,
				1610
			]
		],
		[
			[64940, 64940],
			"mapped",
			[
				1604,
				1580,
				1610
			]
		],
		[
			[64941, 64941],
			"mapped",
			[
				1604,
				1605,
				1610
			]
		],
		[
			[64942, 64942],
			"mapped",
			[
				1610,
				1581,
				1610
			]
		],
		[
			[64943, 64943],
			"mapped",
			[
				1610,
				1580,
				1610
			]
		],
		[
			[64944, 64944],
			"mapped",
			[
				1610,
				1605,
				1610
			]
		],
		[
			[64945, 64945],
			"mapped",
			[
				1605,
				1605,
				1610
			]
		],
		[
			[64946, 64946],
			"mapped",
			[
				1602,
				1605,
				1610
			]
		],
		[
			[64947, 64947],
			"mapped",
			[
				1606,
				1581,
				1610
			]
		],
		[
			[64948, 64948],
			"mapped",
			[
				1602,
				1605,
				1581
			]
		],
		[
			[64949, 64949],
			"mapped",
			[
				1604,
				1581,
				1605
			]
		],
		[
			[64950, 64950],
			"mapped",
			[
				1593,
				1605,
				1610
			]
		],
		[
			[64951, 64951],
			"mapped",
			[
				1603,
				1605,
				1610
			]
		],
		[
			[64952, 64952],
			"mapped",
			[
				1606,
				1580,
				1581
			]
		],
		[
			[64953, 64953],
			"mapped",
			[
				1605,
				1582,
				1610
			]
		],
		[
			[64954, 64954],
			"mapped",
			[
				1604,
				1580,
				1605
			]
		],
		[
			[64955, 64955],
			"mapped",
			[
				1603,
				1605,
				1605
			]
		],
		[
			[64956, 64956],
			"mapped",
			[
				1604,
				1580,
				1605
			]
		],
		[
			[64957, 64957],
			"mapped",
			[
				1606,
				1580,
				1581
			]
		],
		[
			[64958, 64958],
			"mapped",
			[
				1580,
				1581,
				1610
			]
		],
		[
			[64959, 64959],
			"mapped",
			[
				1581,
				1580,
				1610
			]
		],
		[
			[64960, 64960],
			"mapped",
			[
				1605,
				1580,
				1610
			]
		],
		[
			[64961, 64961],
			"mapped",
			[
				1601,
				1605,
				1610
			]
		],
		[
			[64962, 64962],
			"mapped",
			[
				1576,
				1581,
				1610
			]
		],
		[
			[64963, 64963],
			"mapped",
			[
				1603,
				1605,
				1605
			]
		],
		[
			[64964, 64964],
			"mapped",
			[
				1593,
				1580,
				1605
			]
		],
		[
			[64965, 64965],
			"mapped",
			[
				1589,
				1605,
				1605
			]
		],
		[
			[64966, 64966],
			"mapped",
			[
				1587,
				1582,
				1610
			]
		],
		[
			[64967, 64967],
			"mapped",
			[
				1606,
				1580,
				1610
			]
		],
		[[64968, 64975], "disallowed"],
		[[64976, 65007], "disallowed"],
		[
			[65008, 65008],
			"mapped",
			[
				1589,
				1604,
				1746
			]
		],
		[
			[65009, 65009],
			"mapped",
			[
				1602,
				1604,
				1746
			]
		],
		[
			[65010, 65010],
			"mapped",
			[
				1575,
				1604,
				1604,
				1607
			]
		],
		[
			[65011, 65011],
			"mapped",
			[
				1575,
				1603,
				1576,
				1585
			]
		],
		[
			[65012, 65012],
			"mapped",
			[
				1605,
				1581,
				1605,
				1583
			]
		],
		[
			[65013, 65013],
			"mapped",
			[
				1589,
				1604,
				1593,
				1605
			]
		],
		[
			[65014, 65014],
			"mapped",
			[
				1585,
				1587,
				1608,
				1604
			]
		],
		[
			[65015, 65015],
			"mapped",
			[
				1593,
				1604,
				1610,
				1607
			]
		],
		[
			[65016, 65016],
			"mapped",
			[
				1608,
				1587,
				1604,
				1605
			]
		],
		[
			[65017, 65017],
			"mapped",
			[
				1589,
				1604,
				1609
			]
		],
		[
			[65018, 65018],
			"disallowed_STD3_mapped",
			[
				1589,
				1604,
				1609,
				32,
				1575,
				1604,
				1604,
				1607,
				32,
				1593,
				1604,
				1610,
				1607,
				32,
				1608,
				1587,
				1604,
				1605
			]
		],
		[
			[65019, 65019],
			"disallowed_STD3_mapped",
			[
				1580,
				1604,
				32,
				1580,
				1604,
				1575,
				1604,
				1607
			]
		],
		[
			[65020, 65020],
			"mapped",
			[
				1585,
				1740,
				1575,
				1604
			]
		],
		[
			[65021, 65021],
			"valid",
			[],
			"NV8"
		],
		[[65022, 65023], "disallowed"],
		[[65024, 65039], "ignored"],
		[
			[65040, 65040],
			"disallowed_STD3_mapped",
			[44]
		],
		[
			[65041, 65041],
			"mapped",
			[12289]
		],
		[[65042, 65042], "disallowed"],
		[
			[65043, 65043],
			"disallowed_STD3_mapped",
			[58]
		],
		[
			[65044, 65044],
			"disallowed_STD3_mapped",
			[59]
		],
		[
			[65045, 65045],
			"disallowed_STD3_mapped",
			[33]
		],
		[
			[65046, 65046],
			"disallowed_STD3_mapped",
			[63]
		],
		[
			[65047, 65047],
			"mapped",
			[12310]
		],
		[
			[65048, 65048],
			"mapped",
			[12311]
		],
		[[65049, 65049], "disallowed"],
		[[65050, 65055], "disallowed"],
		[[65056, 65059], "valid"],
		[[65060, 65062], "valid"],
		[[65063, 65069], "valid"],
		[[65070, 65071], "valid"],
		[[65072, 65072], "disallowed"],
		[
			[65073, 65073],
			"mapped",
			[8212]
		],
		[
			[65074, 65074],
			"mapped",
			[8211]
		],
		[
			[65075, 65076],
			"disallowed_STD3_mapped",
			[95]
		],
		[
			[65077, 65077],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[65078, 65078],
			"disallowed_STD3_mapped",
			[41]
		],
		[
			[65079, 65079],
			"disallowed_STD3_mapped",
			[123]
		],
		[
			[65080, 65080],
			"disallowed_STD3_mapped",
			[125]
		],
		[
			[65081, 65081],
			"mapped",
			[12308]
		],
		[
			[65082, 65082],
			"mapped",
			[12309]
		],
		[
			[65083, 65083],
			"mapped",
			[12304]
		],
		[
			[65084, 65084],
			"mapped",
			[12305]
		],
		[
			[65085, 65085],
			"mapped",
			[12298]
		],
		[
			[65086, 65086],
			"mapped",
			[12299]
		],
		[
			[65087, 65087],
			"mapped",
			[12296]
		],
		[
			[65088, 65088],
			"mapped",
			[12297]
		],
		[
			[65089, 65089],
			"mapped",
			[12300]
		],
		[
			[65090, 65090],
			"mapped",
			[12301]
		],
		[
			[65091, 65091],
			"mapped",
			[12302]
		],
		[
			[65092, 65092],
			"mapped",
			[12303]
		],
		[
			[65093, 65094],
			"valid",
			[],
			"NV8"
		],
		[
			[65095, 65095],
			"disallowed_STD3_mapped",
			[91]
		],
		[
			[65096, 65096],
			"disallowed_STD3_mapped",
			[93]
		],
		[
			[65097, 65100],
			"disallowed_STD3_mapped",
			[32, 773]
		],
		[
			[65101, 65103],
			"disallowed_STD3_mapped",
			[95]
		],
		[
			[65104, 65104],
			"disallowed_STD3_mapped",
			[44]
		],
		[
			[65105, 65105],
			"mapped",
			[12289]
		],
		[[65106, 65106], "disallowed"],
		[[65107, 65107], "disallowed"],
		[
			[65108, 65108],
			"disallowed_STD3_mapped",
			[59]
		],
		[
			[65109, 65109],
			"disallowed_STD3_mapped",
			[58]
		],
		[
			[65110, 65110],
			"disallowed_STD3_mapped",
			[63]
		],
		[
			[65111, 65111],
			"disallowed_STD3_mapped",
			[33]
		],
		[
			[65112, 65112],
			"mapped",
			[8212]
		],
		[
			[65113, 65113],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[65114, 65114],
			"disallowed_STD3_mapped",
			[41]
		],
		[
			[65115, 65115],
			"disallowed_STD3_mapped",
			[123]
		],
		[
			[65116, 65116],
			"disallowed_STD3_mapped",
			[125]
		],
		[
			[65117, 65117],
			"mapped",
			[12308]
		],
		[
			[65118, 65118],
			"mapped",
			[12309]
		],
		[
			[65119, 65119],
			"disallowed_STD3_mapped",
			[35]
		],
		[
			[65120, 65120],
			"disallowed_STD3_mapped",
			[38]
		],
		[
			[65121, 65121],
			"disallowed_STD3_mapped",
			[42]
		],
		[
			[65122, 65122],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[65123, 65123],
			"mapped",
			[45]
		],
		[
			[65124, 65124],
			"disallowed_STD3_mapped",
			[60]
		],
		[
			[65125, 65125],
			"disallowed_STD3_mapped",
			[62]
		],
		[
			[65126, 65126],
			"disallowed_STD3_mapped",
			[61]
		],
		[[65127, 65127], "disallowed"],
		[
			[65128, 65128],
			"disallowed_STD3_mapped",
			[92]
		],
		[
			[65129, 65129],
			"disallowed_STD3_mapped",
			[36]
		],
		[
			[65130, 65130],
			"disallowed_STD3_mapped",
			[37]
		],
		[
			[65131, 65131],
			"disallowed_STD3_mapped",
			[64]
		],
		[[65132, 65135], "disallowed"],
		[
			[65136, 65136],
			"disallowed_STD3_mapped",
			[32, 1611]
		],
		[
			[65137, 65137],
			"mapped",
			[1600, 1611]
		],
		[
			[65138, 65138],
			"disallowed_STD3_mapped",
			[32, 1612]
		],
		[[65139, 65139], "valid"],
		[
			[65140, 65140],
			"disallowed_STD3_mapped",
			[32, 1613]
		],
		[[65141, 65141], "disallowed"],
		[
			[65142, 65142],
			"disallowed_STD3_mapped",
			[32, 1614]
		],
		[
			[65143, 65143],
			"mapped",
			[1600, 1614]
		],
		[
			[65144, 65144],
			"disallowed_STD3_mapped",
			[32, 1615]
		],
		[
			[65145, 65145],
			"mapped",
			[1600, 1615]
		],
		[
			[65146, 65146],
			"disallowed_STD3_mapped",
			[32, 1616]
		],
		[
			[65147, 65147],
			"mapped",
			[1600, 1616]
		],
		[
			[65148, 65148],
			"disallowed_STD3_mapped",
			[32, 1617]
		],
		[
			[65149, 65149],
			"mapped",
			[1600, 1617]
		],
		[
			[65150, 65150],
			"disallowed_STD3_mapped",
			[32, 1618]
		],
		[
			[65151, 65151],
			"mapped",
			[1600, 1618]
		],
		[
			[65152, 65152],
			"mapped",
			[1569]
		],
		[
			[65153, 65154],
			"mapped",
			[1570]
		],
		[
			[65155, 65156],
			"mapped",
			[1571]
		],
		[
			[65157, 65158],
			"mapped",
			[1572]
		],
		[
			[65159, 65160],
			"mapped",
			[1573]
		],
		[
			[65161, 65164],
			"mapped",
			[1574]
		],
		[
			[65165, 65166],
			"mapped",
			[1575]
		],
		[
			[65167, 65170],
			"mapped",
			[1576]
		],
		[
			[65171, 65172],
			"mapped",
			[1577]
		],
		[
			[65173, 65176],
			"mapped",
			[1578]
		],
		[
			[65177, 65180],
			"mapped",
			[1579]
		],
		[
			[65181, 65184],
			"mapped",
			[1580]
		],
		[
			[65185, 65188],
			"mapped",
			[1581]
		],
		[
			[65189, 65192],
			"mapped",
			[1582]
		],
		[
			[65193, 65194],
			"mapped",
			[1583]
		],
		[
			[65195, 65196],
			"mapped",
			[1584]
		],
		[
			[65197, 65198],
			"mapped",
			[1585]
		],
		[
			[65199, 65200],
			"mapped",
			[1586]
		],
		[
			[65201, 65204],
			"mapped",
			[1587]
		],
		[
			[65205, 65208],
			"mapped",
			[1588]
		],
		[
			[65209, 65212],
			"mapped",
			[1589]
		],
		[
			[65213, 65216],
			"mapped",
			[1590]
		],
		[
			[65217, 65220],
			"mapped",
			[1591]
		],
		[
			[65221, 65224],
			"mapped",
			[1592]
		],
		[
			[65225, 65228],
			"mapped",
			[1593]
		],
		[
			[65229, 65232],
			"mapped",
			[1594]
		],
		[
			[65233, 65236],
			"mapped",
			[1601]
		],
		[
			[65237, 65240],
			"mapped",
			[1602]
		],
		[
			[65241, 65244],
			"mapped",
			[1603]
		],
		[
			[65245, 65248],
			"mapped",
			[1604]
		],
		[
			[65249, 65252],
			"mapped",
			[1605]
		],
		[
			[65253, 65256],
			"mapped",
			[1606]
		],
		[
			[65257, 65260],
			"mapped",
			[1607]
		],
		[
			[65261, 65262],
			"mapped",
			[1608]
		],
		[
			[65263, 65264],
			"mapped",
			[1609]
		],
		[
			[65265, 65268],
			"mapped",
			[1610]
		],
		[
			[65269, 65270],
			"mapped",
			[1604, 1570]
		],
		[
			[65271, 65272],
			"mapped",
			[1604, 1571]
		],
		[
			[65273, 65274],
			"mapped",
			[1604, 1573]
		],
		[
			[65275, 65276],
			"mapped",
			[1604, 1575]
		],
		[[65277, 65278], "disallowed"],
		[[65279, 65279], "ignored"],
		[[65280, 65280], "disallowed"],
		[
			[65281, 65281],
			"disallowed_STD3_mapped",
			[33]
		],
		[
			[65282, 65282],
			"disallowed_STD3_mapped",
			[34]
		],
		[
			[65283, 65283],
			"disallowed_STD3_mapped",
			[35]
		],
		[
			[65284, 65284],
			"disallowed_STD3_mapped",
			[36]
		],
		[
			[65285, 65285],
			"disallowed_STD3_mapped",
			[37]
		],
		[
			[65286, 65286],
			"disallowed_STD3_mapped",
			[38]
		],
		[
			[65287, 65287],
			"disallowed_STD3_mapped",
			[39]
		],
		[
			[65288, 65288],
			"disallowed_STD3_mapped",
			[40]
		],
		[
			[65289, 65289],
			"disallowed_STD3_mapped",
			[41]
		],
		[
			[65290, 65290],
			"disallowed_STD3_mapped",
			[42]
		],
		[
			[65291, 65291],
			"disallowed_STD3_mapped",
			[43]
		],
		[
			[65292, 65292],
			"disallowed_STD3_mapped",
			[44]
		],
		[
			[65293, 65293],
			"mapped",
			[45]
		],
		[
			[65294, 65294],
			"mapped",
			[46]
		],
		[
			[65295, 65295],
			"disallowed_STD3_mapped",
			[47]
		],
		[
			[65296, 65296],
			"mapped",
			[48]
		],
		[
			[65297, 65297],
			"mapped",
			[49]
		],
		[
			[65298, 65298],
			"mapped",
			[50]
		],
		[
			[65299, 65299],
			"mapped",
			[51]
		],
		[
			[65300, 65300],
			"mapped",
			[52]
		],
		[
			[65301, 65301],
			"mapped",
			[53]
		],
		[
			[65302, 65302],
			"mapped",
			[54]
		],
		[
			[65303, 65303],
			"mapped",
			[55]
		],
		[
			[65304, 65304],
			"mapped",
			[56]
		],
		[
			[65305, 65305],
			"mapped",
			[57]
		],
		[
			[65306, 65306],
			"disallowed_STD3_mapped",
			[58]
		],
		[
			[65307, 65307],
			"disallowed_STD3_mapped",
			[59]
		],
		[
			[65308, 65308],
			"disallowed_STD3_mapped",
			[60]
		],
		[
			[65309, 65309],
			"disallowed_STD3_mapped",
			[61]
		],
		[
			[65310, 65310],
			"disallowed_STD3_mapped",
			[62]
		],
		[
			[65311, 65311],
			"disallowed_STD3_mapped",
			[63]
		],
		[
			[65312, 65312],
			"disallowed_STD3_mapped",
			[64]
		],
		[
			[65313, 65313],
			"mapped",
			[97]
		],
		[
			[65314, 65314],
			"mapped",
			[98]
		],
		[
			[65315, 65315],
			"mapped",
			[99]
		],
		[
			[65316, 65316],
			"mapped",
			[100]
		],
		[
			[65317, 65317],
			"mapped",
			[101]
		],
		[
			[65318, 65318],
			"mapped",
			[102]
		],
		[
			[65319, 65319],
			"mapped",
			[103]
		],
		[
			[65320, 65320],
			"mapped",
			[104]
		],
		[
			[65321, 65321],
			"mapped",
			[105]
		],
		[
			[65322, 65322],
			"mapped",
			[106]
		],
		[
			[65323, 65323],
			"mapped",
			[107]
		],
		[
			[65324, 65324],
			"mapped",
			[108]
		],
		[
			[65325, 65325],
			"mapped",
			[109]
		],
		[
			[65326, 65326],
			"mapped",
			[110]
		],
		[
			[65327, 65327],
			"mapped",
			[111]
		],
		[
			[65328, 65328],
			"mapped",
			[112]
		],
		[
			[65329, 65329],
			"mapped",
			[113]
		],
		[
			[65330, 65330],
			"mapped",
			[114]
		],
		[
			[65331, 65331],
			"mapped",
			[115]
		],
		[
			[65332, 65332],
			"mapped",
			[116]
		],
		[
			[65333, 65333],
			"mapped",
			[117]
		],
		[
			[65334, 65334],
			"mapped",
			[118]
		],
		[
			[65335, 65335],
			"mapped",
			[119]
		],
		[
			[65336, 65336],
			"mapped",
			[120]
		],
		[
			[65337, 65337],
			"mapped",
			[121]
		],
		[
			[65338, 65338],
			"mapped",
			[122]
		],
		[
			[65339, 65339],
			"disallowed_STD3_mapped",
			[91]
		],
		[
			[65340, 65340],
			"disallowed_STD3_mapped",
			[92]
		],
		[
			[65341, 65341],
			"disallowed_STD3_mapped",
			[93]
		],
		[
			[65342, 65342],
			"disallowed_STD3_mapped",
			[94]
		],
		[
			[65343, 65343],
			"disallowed_STD3_mapped",
			[95]
		],
		[
			[65344, 65344],
			"disallowed_STD3_mapped",
			[96]
		],
		[
			[65345, 65345],
			"mapped",
			[97]
		],
		[
			[65346, 65346],
			"mapped",
			[98]
		],
		[
			[65347, 65347],
			"mapped",
			[99]
		],
		[
			[65348, 65348],
			"mapped",
			[100]
		],
		[
			[65349, 65349],
			"mapped",
			[101]
		],
		[
			[65350, 65350],
			"mapped",
			[102]
		],
		[
			[65351, 65351],
			"mapped",
			[103]
		],
		[
			[65352, 65352],
			"mapped",
			[104]
		],
		[
			[65353, 65353],
			"mapped",
			[105]
		],
		[
			[65354, 65354],
			"mapped",
			[106]
		],
		[
			[65355, 65355],
			"mapped",
			[107]
		],
		[
			[65356, 65356],
			"mapped",
			[108]
		],
		[
			[65357, 65357],
			"mapped",
			[109]
		],
		[
			[65358, 65358],
			"mapped",
			[110]
		],
		[
			[65359, 65359],
			"mapped",
			[111]
		],
		[
			[65360, 65360],
			"mapped",
			[112]
		],
		[
			[65361, 65361],
			"mapped",
			[113]
		],
		[
			[65362, 65362],
			"mapped",
			[114]
		],
		[
			[65363, 65363],
			"mapped",
			[115]
		],
		[
			[65364, 65364],
			"mapped",
			[116]
		],
		[
			[65365, 65365],
			"mapped",
			[117]
		],
		[
			[65366, 65366],
			"mapped",
			[118]
		],
		[
			[65367, 65367],
			"mapped",
			[119]
		],
		[
			[65368, 65368],
			"mapped",
			[120]
		],
		[
			[65369, 65369],
			"mapped",
			[121]
		],
		[
			[65370, 65370],
			"mapped",
			[122]
		],
		[
			[65371, 65371],
			"disallowed_STD3_mapped",
			[123]
		],
		[
			[65372, 65372],
			"disallowed_STD3_mapped",
			[124]
		],
		[
			[65373, 65373],
			"disallowed_STD3_mapped",
			[125]
		],
		[
			[65374, 65374],
			"disallowed_STD3_mapped",
			[126]
		],
		[
			[65375, 65375],
			"mapped",
			[10629]
		],
		[
			[65376, 65376],
			"mapped",
			[10630]
		],
		[
			[65377, 65377],
			"mapped",
			[46]
		],
		[
			[65378, 65378],
			"mapped",
			[12300]
		],
		[
			[65379, 65379],
			"mapped",
			[12301]
		],
		[
			[65380, 65380],
			"mapped",
			[12289]
		],
		[
			[65381, 65381],
			"mapped",
			[12539]
		],
		[
			[65382, 65382],
			"mapped",
			[12530]
		],
		[
			[65383, 65383],
			"mapped",
			[12449]
		],
		[
			[65384, 65384],
			"mapped",
			[12451]
		],
		[
			[65385, 65385],
			"mapped",
			[12453]
		],
		[
			[65386, 65386],
			"mapped",
			[12455]
		],
		[
			[65387, 65387],
			"mapped",
			[12457]
		],
		[
			[65388, 65388],
			"mapped",
			[12515]
		],
		[
			[65389, 65389],
			"mapped",
			[12517]
		],
		[
			[65390, 65390],
			"mapped",
			[12519]
		],
		[
			[65391, 65391],
			"mapped",
			[12483]
		],
		[
			[65392, 65392],
			"mapped",
			[12540]
		],
		[
			[65393, 65393],
			"mapped",
			[12450]
		],
		[
			[65394, 65394],
			"mapped",
			[12452]
		],
		[
			[65395, 65395],
			"mapped",
			[12454]
		],
		[
			[65396, 65396],
			"mapped",
			[12456]
		],
		[
			[65397, 65397],
			"mapped",
			[12458]
		],
		[
			[65398, 65398],
			"mapped",
			[12459]
		],
		[
			[65399, 65399],
			"mapped",
			[12461]
		],
		[
			[65400, 65400],
			"mapped",
			[12463]
		],
		[
			[65401, 65401],
			"mapped",
			[12465]
		],
		[
			[65402, 65402],
			"mapped",
			[12467]
		],
		[
			[65403, 65403],
			"mapped",
			[12469]
		],
		[
			[65404, 65404],
			"mapped",
			[12471]
		],
		[
			[65405, 65405],
			"mapped",
			[12473]
		],
		[
			[65406, 65406],
			"mapped",
			[12475]
		],
		[
			[65407, 65407],
			"mapped",
			[12477]
		],
		[
			[65408, 65408],
			"mapped",
			[12479]
		],
		[
			[65409, 65409],
			"mapped",
			[12481]
		],
		[
			[65410, 65410],
			"mapped",
			[12484]
		],
		[
			[65411, 65411],
			"mapped",
			[12486]
		],
		[
			[65412, 65412],
			"mapped",
			[12488]
		],
		[
			[65413, 65413],
			"mapped",
			[12490]
		],
		[
			[65414, 65414],
			"mapped",
			[12491]
		],
		[
			[65415, 65415],
			"mapped",
			[12492]
		],
		[
			[65416, 65416],
			"mapped",
			[12493]
		],
		[
			[65417, 65417],
			"mapped",
			[12494]
		],
		[
			[65418, 65418],
			"mapped",
			[12495]
		],
		[
			[65419, 65419],
			"mapped",
			[12498]
		],
		[
			[65420, 65420],
			"mapped",
			[12501]
		],
		[
			[65421, 65421],
			"mapped",
			[12504]
		],
		[
			[65422, 65422],
			"mapped",
			[12507]
		],
		[
			[65423, 65423],
			"mapped",
			[12510]
		],
		[
			[65424, 65424],
			"mapped",
			[12511]
		],
		[
			[65425, 65425],
			"mapped",
			[12512]
		],
		[
			[65426, 65426],
			"mapped",
			[12513]
		],
		[
			[65427, 65427],
			"mapped",
			[12514]
		],
		[
			[65428, 65428],
			"mapped",
			[12516]
		],
		[
			[65429, 65429],
			"mapped",
			[12518]
		],
		[
			[65430, 65430],
			"mapped",
			[12520]
		],
		[
			[65431, 65431],
			"mapped",
			[12521]
		],
		[
			[65432, 65432],
			"mapped",
			[12522]
		],
		[
			[65433, 65433],
			"mapped",
			[12523]
		],
		[
			[65434, 65434],
			"mapped",
			[12524]
		],
		[
			[65435, 65435],
			"mapped",
			[12525]
		],
		[
			[65436, 65436],
			"mapped",
			[12527]
		],
		[
			[65437, 65437],
			"mapped",
			[12531]
		],
		[
			[65438, 65438],
			"mapped",
			[12441]
		],
		[
			[65439, 65439],
			"mapped",
			[12442]
		],
		[[65440, 65440], "disallowed"],
		[
			[65441, 65441],
			"mapped",
			[4352]
		],
		[
			[65442, 65442],
			"mapped",
			[4353]
		],
		[
			[65443, 65443],
			"mapped",
			[4522]
		],
		[
			[65444, 65444],
			"mapped",
			[4354]
		],
		[
			[65445, 65445],
			"mapped",
			[4524]
		],
		[
			[65446, 65446],
			"mapped",
			[4525]
		],
		[
			[65447, 65447],
			"mapped",
			[4355]
		],
		[
			[65448, 65448],
			"mapped",
			[4356]
		],
		[
			[65449, 65449],
			"mapped",
			[4357]
		],
		[
			[65450, 65450],
			"mapped",
			[4528]
		],
		[
			[65451, 65451],
			"mapped",
			[4529]
		],
		[
			[65452, 65452],
			"mapped",
			[4530]
		],
		[
			[65453, 65453],
			"mapped",
			[4531]
		],
		[
			[65454, 65454],
			"mapped",
			[4532]
		],
		[
			[65455, 65455],
			"mapped",
			[4533]
		],
		[
			[65456, 65456],
			"mapped",
			[4378]
		],
		[
			[65457, 65457],
			"mapped",
			[4358]
		],
		[
			[65458, 65458],
			"mapped",
			[4359]
		],
		[
			[65459, 65459],
			"mapped",
			[4360]
		],
		[
			[65460, 65460],
			"mapped",
			[4385]
		],
		[
			[65461, 65461],
			"mapped",
			[4361]
		],
		[
			[65462, 65462],
			"mapped",
			[4362]
		],
		[
			[65463, 65463],
			"mapped",
			[4363]
		],
		[
			[65464, 65464],
			"mapped",
			[4364]
		],
		[
			[65465, 65465],
			"mapped",
			[4365]
		],
		[
			[65466, 65466],
			"mapped",
			[4366]
		],
		[
			[65467, 65467],
			"mapped",
			[4367]
		],
		[
			[65468, 65468],
			"mapped",
			[4368]
		],
		[
			[65469, 65469],
			"mapped",
			[4369]
		],
		[
			[65470, 65470],
			"mapped",
			[4370]
		],
		[[65471, 65473], "disallowed"],
		[
			[65474, 65474],
			"mapped",
			[4449]
		],
		[
			[65475, 65475],
			"mapped",
			[4450]
		],
		[
			[65476, 65476],
			"mapped",
			[4451]
		],
		[
			[65477, 65477],
			"mapped",
			[4452]
		],
		[
			[65478, 65478],
			"mapped",
			[4453]
		],
		[
			[65479, 65479],
			"mapped",
			[4454]
		],
		[[65480, 65481], "disallowed"],
		[
			[65482, 65482],
			"mapped",
			[4455]
		],
		[
			[65483, 65483],
			"mapped",
			[4456]
		],
		[
			[65484, 65484],
			"mapped",
			[4457]
		],
		[
			[65485, 65485],
			"mapped",
			[4458]
		],
		[
			[65486, 65486],
			"mapped",
			[4459]
		],
		[
			[65487, 65487],
			"mapped",
			[4460]
		],
		[[65488, 65489], "disallowed"],
		[
			[65490, 65490],
			"mapped",
			[4461]
		],
		[
			[65491, 65491],
			"mapped",
			[4462]
		],
		[
			[65492, 65492],
			"mapped",
			[4463]
		],
		[
			[65493, 65493],
			"mapped",
			[4464]
		],
		[
			[65494, 65494],
			"mapped",
			[4465]
		],
		[
			[65495, 65495],
			"mapped",
			[4466]
		],
		[[65496, 65497], "disallowed"],
		[
			[65498, 65498],
			"mapped",
			[4467]
		],
		[
			[65499, 65499],
			"mapped",
			[4468]
		],
		[
			[65500, 65500],
			"mapped",
			[4469]
		],
		[[65501, 65503], "disallowed"],
		[
			[65504, 65504],
			"mapped",
			[162]
		],
		[
			[65505, 65505],
			"mapped",
			[163]
		],
		[
			[65506, 65506],
			"mapped",
			[172]
		],
		[
			[65507, 65507],
			"disallowed_STD3_mapped",
			[32, 772]
		],
		[
			[65508, 65508],
			"mapped",
			[166]
		],
		[
			[65509, 65509],
			"mapped",
			[165]
		],
		[
			[65510, 65510],
			"mapped",
			[8361]
		],
		[[65511, 65511], "disallowed"],
		[
			[65512, 65512],
			"mapped",
			[9474]
		],
		[
			[65513, 65513],
			"mapped",
			[8592]
		],
		[
			[65514, 65514],
			"mapped",
			[8593]
		],
		[
			[65515, 65515],
			"mapped",
			[8594]
		],
		[
			[65516, 65516],
			"mapped",
			[8595]
		],
		[
			[65517, 65517],
			"mapped",
			[9632]
		],
		[
			[65518, 65518],
			"mapped",
			[9675]
		],
		[[65519, 65528], "disallowed"],
		[[65529, 65531], "disallowed"],
		[[65532, 65532], "disallowed"],
		[[65533, 65533], "disallowed"],
		[[65534, 65535], "disallowed"],
		[[65536, 65547], "valid"],
		[[65548, 65548], "disallowed"],
		[[65549, 65574], "valid"],
		[[65575, 65575], "disallowed"],
		[[65576, 65594], "valid"],
		[[65595, 65595], "disallowed"],
		[[65596, 65597], "valid"],
		[[65598, 65598], "disallowed"],
		[[65599, 65613], "valid"],
		[[65614, 65615], "disallowed"],
		[[65616, 65629], "valid"],
		[[65630, 65663], "disallowed"],
		[[65664, 65786], "valid"],
		[[65787, 65791], "disallowed"],
		[
			[65792, 65794],
			"valid",
			[],
			"NV8"
		],
		[[65795, 65798], "disallowed"],
		[
			[65799, 65843],
			"valid",
			[],
			"NV8"
		],
		[[65844, 65846], "disallowed"],
		[
			[65847, 65855],
			"valid",
			[],
			"NV8"
		],
		[
			[65856, 65930],
			"valid",
			[],
			"NV8"
		],
		[
			[65931, 65932],
			"valid",
			[],
			"NV8"
		],
		[[65933, 65935], "disallowed"],
		[
			[65936, 65947],
			"valid",
			[],
			"NV8"
		],
		[[65948, 65951], "disallowed"],
		[
			[65952, 65952],
			"valid",
			[],
			"NV8"
		],
		[[65953, 65999], "disallowed"],
		[
			[66e3, 66044],
			"valid",
			[],
			"NV8"
		],
		[[66045, 66045], "valid"],
		[[66046, 66175], "disallowed"],
		[[66176, 66204], "valid"],
		[[66205, 66207], "disallowed"],
		[[66208, 66256], "valid"],
		[[66257, 66271], "disallowed"],
		[[66272, 66272], "valid"],
		[
			[66273, 66299],
			"valid",
			[],
			"NV8"
		],
		[[66300, 66303], "disallowed"],
		[[66304, 66334], "valid"],
		[[66335, 66335], "valid"],
		[
			[66336, 66339],
			"valid",
			[],
			"NV8"
		],
		[[66340, 66351], "disallowed"],
		[[66352, 66368], "valid"],
		[
			[66369, 66369],
			"valid",
			[],
			"NV8"
		],
		[[66370, 66377], "valid"],
		[
			[66378, 66378],
			"valid",
			[],
			"NV8"
		],
		[[66379, 66383], "disallowed"],
		[[66384, 66426], "valid"],
		[[66427, 66431], "disallowed"],
		[[66432, 66461], "valid"],
		[[66462, 66462], "disallowed"],
		[
			[66463, 66463],
			"valid",
			[],
			"NV8"
		],
		[[66464, 66499], "valid"],
		[[66500, 66503], "disallowed"],
		[[66504, 66511], "valid"],
		[
			[66512, 66517],
			"valid",
			[],
			"NV8"
		],
		[[66518, 66559], "disallowed"],
		[
			[66560, 66560],
			"mapped",
			[66600]
		],
		[
			[66561, 66561],
			"mapped",
			[66601]
		],
		[
			[66562, 66562],
			"mapped",
			[66602]
		],
		[
			[66563, 66563],
			"mapped",
			[66603]
		],
		[
			[66564, 66564],
			"mapped",
			[66604]
		],
		[
			[66565, 66565],
			"mapped",
			[66605]
		],
		[
			[66566, 66566],
			"mapped",
			[66606]
		],
		[
			[66567, 66567],
			"mapped",
			[66607]
		],
		[
			[66568, 66568],
			"mapped",
			[66608]
		],
		[
			[66569, 66569],
			"mapped",
			[66609]
		],
		[
			[66570, 66570],
			"mapped",
			[66610]
		],
		[
			[66571, 66571],
			"mapped",
			[66611]
		],
		[
			[66572, 66572],
			"mapped",
			[66612]
		],
		[
			[66573, 66573],
			"mapped",
			[66613]
		],
		[
			[66574, 66574],
			"mapped",
			[66614]
		],
		[
			[66575, 66575],
			"mapped",
			[66615]
		],
		[
			[66576, 66576],
			"mapped",
			[66616]
		],
		[
			[66577, 66577],
			"mapped",
			[66617]
		],
		[
			[66578, 66578],
			"mapped",
			[66618]
		],
		[
			[66579, 66579],
			"mapped",
			[66619]
		],
		[
			[66580, 66580],
			"mapped",
			[66620]
		],
		[
			[66581, 66581],
			"mapped",
			[66621]
		],
		[
			[66582, 66582],
			"mapped",
			[66622]
		],
		[
			[66583, 66583],
			"mapped",
			[66623]
		],
		[
			[66584, 66584],
			"mapped",
			[66624]
		],
		[
			[66585, 66585],
			"mapped",
			[66625]
		],
		[
			[66586, 66586],
			"mapped",
			[66626]
		],
		[
			[66587, 66587],
			"mapped",
			[66627]
		],
		[
			[66588, 66588],
			"mapped",
			[66628]
		],
		[
			[66589, 66589],
			"mapped",
			[66629]
		],
		[
			[66590, 66590],
			"mapped",
			[66630]
		],
		[
			[66591, 66591],
			"mapped",
			[66631]
		],
		[
			[66592, 66592],
			"mapped",
			[66632]
		],
		[
			[66593, 66593],
			"mapped",
			[66633]
		],
		[
			[66594, 66594],
			"mapped",
			[66634]
		],
		[
			[66595, 66595],
			"mapped",
			[66635]
		],
		[
			[66596, 66596],
			"mapped",
			[66636]
		],
		[
			[66597, 66597],
			"mapped",
			[66637]
		],
		[
			[66598, 66598],
			"mapped",
			[66638]
		],
		[
			[66599, 66599],
			"mapped",
			[66639]
		],
		[[66600, 66637], "valid"],
		[[66638, 66717], "valid"],
		[[66718, 66719], "disallowed"],
		[[66720, 66729], "valid"],
		[[66730, 66815], "disallowed"],
		[[66816, 66855], "valid"],
		[[66856, 66863], "disallowed"],
		[[66864, 66915], "valid"],
		[[66916, 66926], "disallowed"],
		[
			[66927, 66927],
			"valid",
			[],
			"NV8"
		],
		[[66928, 67071], "disallowed"],
		[[67072, 67382], "valid"],
		[[67383, 67391], "disallowed"],
		[[67392, 67413], "valid"],
		[[67414, 67423], "disallowed"],
		[[67424, 67431], "valid"],
		[[67432, 67583], "disallowed"],
		[[67584, 67589], "valid"],
		[[67590, 67591], "disallowed"],
		[[67592, 67592], "valid"],
		[[67593, 67593], "disallowed"],
		[[67594, 67637], "valid"],
		[[67638, 67638], "disallowed"],
		[[67639, 67640], "valid"],
		[[67641, 67643], "disallowed"],
		[[67644, 67644], "valid"],
		[[67645, 67646], "disallowed"],
		[[67647, 67647], "valid"],
		[[67648, 67669], "valid"],
		[[67670, 67670], "disallowed"],
		[
			[67671, 67679],
			"valid",
			[],
			"NV8"
		],
		[[67680, 67702], "valid"],
		[
			[67703, 67711],
			"valid",
			[],
			"NV8"
		],
		[[67712, 67742], "valid"],
		[[67743, 67750], "disallowed"],
		[
			[67751, 67759],
			"valid",
			[],
			"NV8"
		],
		[[67760, 67807], "disallowed"],
		[[67808, 67826], "valid"],
		[[67827, 67827], "disallowed"],
		[[67828, 67829], "valid"],
		[[67830, 67834], "disallowed"],
		[
			[67835, 67839],
			"valid",
			[],
			"NV8"
		],
		[[67840, 67861], "valid"],
		[
			[67862, 67865],
			"valid",
			[],
			"NV8"
		],
		[
			[67866, 67867],
			"valid",
			[],
			"NV8"
		],
		[[67868, 67870], "disallowed"],
		[
			[67871, 67871],
			"valid",
			[],
			"NV8"
		],
		[[67872, 67897], "valid"],
		[[67898, 67902], "disallowed"],
		[
			[67903, 67903],
			"valid",
			[],
			"NV8"
		],
		[[67904, 67967], "disallowed"],
		[[67968, 68023], "valid"],
		[[68024, 68027], "disallowed"],
		[
			[68028, 68029],
			"valid",
			[],
			"NV8"
		],
		[[68030, 68031], "valid"],
		[
			[68032, 68047],
			"valid",
			[],
			"NV8"
		],
		[[68048, 68049], "disallowed"],
		[
			[68050, 68095],
			"valid",
			[],
			"NV8"
		],
		[[68096, 68099], "valid"],
		[[68100, 68100], "disallowed"],
		[[68101, 68102], "valid"],
		[[68103, 68107], "disallowed"],
		[[68108, 68115], "valid"],
		[[68116, 68116], "disallowed"],
		[[68117, 68119], "valid"],
		[[68120, 68120], "disallowed"],
		[[68121, 68147], "valid"],
		[[68148, 68151], "disallowed"],
		[[68152, 68154], "valid"],
		[[68155, 68158], "disallowed"],
		[[68159, 68159], "valid"],
		[
			[68160, 68167],
			"valid",
			[],
			"NV8"
		],
		[[68168, 68175], "disallowed"],
		[
			[68176, 68184],
			"valid",
			[],
			"NV8"
		],
		[[68185, 68191], "disallowed"],
		[[68192, 68220], "valid"],
		[
			[68221, 68223],
			"valid",
			[],
			"NV8"
		],
		[[68224, 68252], "valid"],
		[
			[68253, 68255],
			"valid",
			[],
			"NV8"
		],
		[[68256, 68287], "disallowed"],
		[[68288, 68295], "valid"],
		[
			[68296, 68296],
			"valid",
			[],
			"NV8"
		],
		[[68297, 68326], "valid"],
		[[68327, 68330], "disallowed"],
		[
			[68331, 68342],
			"valid",
			[],
			"NV8"
		],
		[[68343, 68351], "disallowed"],
		[[68352, 68405], "valid"],
		[[68406, 68408], "disallowed"],
		[
			[68409, 68415],
			"valid",
			[],
			"NV8"
		],
		[[68416, 68437], "valid"],
		[[68438, 68439], "disallowed"],
		[
			[68440, 68447],
			"valid",
			[],
			"NV8"
		],
		[[68448, 68466], "valid"],
		[[68467, 68471], "disallowed"],
		[
			[68472, 68479],
			"valid",
			[],
			"NV8"
		],
		[[68480, 68497], "valid"],
		[[68498, 68504], "disallowed"],
		[
			[68505, 68508],
			"valid",
			[],
			"NV8"
		],
		[[68509, 68520], "disallowed"],
		[
			[68521, 68527],
			"valid",
			[],
			"NV8"
		],
		[[68528, 68607], "disallowed"],
		[[68608, 68680], "valid"],
		[[68681, 68735], "disallowed"],
		[
			[68736, 68736],
			"mapped",
			[68800]
		],
		[
			[68737, 68737],
			"mapped",
			[68801]
		],
		[
			[68738, 68738],
			"mapped",
			[68802]
		],
		[
			[68739, 68739],
			"mapped",
			[68803]
		],
		[
			[68740, 68740],
			"mapped",
			[68804]
		],
		[
			[68741, 68741],
			"mapped",
			[68805]
		],
		[
			[68742, 68742],
			"mapped",
			[68806]
		],
		[
			[68743, 68743],
			"mapped",
			[68807]
		],
		[
			[68744, 68744],
			"mapped",
			[68808]
		],
		[
			[68745, 68745],
			"mapped",
			[68809]
		],
		[
			[68746, 68746],
			"mapped",
			[68810]
		],
		[
			[68747, 68747],
			"mapped",
			[68811]
		],
		[
			[68748, 68748],
			"mapped",
			[68812]
		],
		[
			[68749, 68749],
			"mapped",
			[68813]
		],
		[
			[68750, 68750],
			"mapped",
			[68814]
		],
		[
			[68751, 68751],
			"mapped",
			[68815]
		],
		[
			[68752, 68752],
			"mapped",
			[68816]
		],
		[
			[68753, 68753],
			"mapped",
			[68817]
		],
		[
			[68754, 68754],
			"mapped",
			[68818]
		],
		[
			[68755, 68755],
			"mapped",
			[68819]
		],
		[
			[68756, 68756],
			"mapped",
			[68820]
		],
		[
			[68757, 68757],
			"mapped",
			[68821]
		],
		[
			[68758, 68758],
			"mapped",
			[68822]
		],
		[
			[68759, 68759],
			"mapped",
			[68823]
		],
		[
			[68760, 68760],
			"mapped",
			[68824]
		],
		[
			[68761, 68761],
			"mapped",
			[68825]
		],
		[
			[68762, 68762],
			"mapped",
			[68826]
		],
		[
			[68763, 68763],
			"mapped",
			[68827]
		],
		[
			[68764, 68764],
			"mapped",
			[68828]
		],
		[
			[68765, 68765],
			"mapped",
			[68829]
		],
		[
			[68766, 68766],
			"mapped",
			[68830]
		],
		[
			[68767, 68767],
			"mapped",
			[68831]
		],
		[
			[68768, 68768],
			"mapped",
			[68832]
		],
		[
			[68769, 68769],
			"mapped",
			[68833]
		],
		[
			[68770, 68770],
			"mapped",
			[68834]
		],
		[
			[68771, 68771],
			"mapped",
			[68835]
		],
		[
			[68772, 68772],
			"mapped",
			[68836]
		],
		[
			[68773, 68773],
			"mapped",
			[68837]
		],
		[
			[68774, 68774],
			"mapped",
			[68838]
		],
		[
			[68775, 68775],
			"mapped",
			[68839]
		],
		[
			[68776, 68776],
			"mapped",
			[68840]
		],
		[
			[68777, 68777],
			"mapped",
			[68841]
		],
		[
			[68778, 68778],
			"mapped",
			[68842]
		],
		[
			[68779, 68779],
			"mapped",
			[68843]
		],
		[
			[68780, 68780],
			"mapped",
			[68844]
		],
		[
			[68781, 68781],
			"mapped",
			[68845]
		],
		[
			[68782, 68782],
			"mapped",
			[68846]
		],
		[
			[68783, 68783],
			"mapped",
			[68847]
		],
		[
			[68784, 68784],
			"mapped",
			[68848]
		],
		[
			[68785, 68785],
			"mapped",
			[68849]
		],
		[
			[68786, 68786],
			"mapped",
			[68850]
		],
		[[68787, 68799], "disallowed"],
		[[68800, 68850], "valid"],
		[[68851, 68857], "disallowed"],
		[
			[68858, 68863],
			"valid",
			[],
			"NV8"
		],
		[[68864, 69215], "disallowed"],
		[
			[69216, 69246],
			"valid",
			[],
			"NV8"
		],
		[[69247, 69631], "disallowed"],
		[[69632, 69702], "valid"],
		[
			[69703, 69709],
			"valid",
			[],
			"NV8"
		],
		[[69710, 69713], "disallowed"],
		[
			[69714, 69733],
			"valid",
			[],
			"NV8"
		],
		[[69734, 69743], "valid"],
		[[69744, 69758], "disallowed"],
		[[69759, 69759], "valid"],
		[[69760, 69818], "valid"],
		[
			[69819, 69820],
			"valid",
			[],
			"NV8"
		],
		[[69821, 69821], "disallowed"],
		[
			[69822, 69825],
			"valid",
			[],
			"NV8"
		],
		[[69826, 69839], "disallowed"],
		[[69840, 69864], "valid"],
		[[69865, 69871], "disallowed"],
		[[69872, 69881], "valid"],
		[[69882, 69887], "disallowed"],
		[[69888, 69940], "valid"],
		[[69941, 69941], "disallowed"],
		[[69942, 69951], "valid"],
		[
			[69952, 69955],
			"valid",
			[],
			"NV8"
		],
		[[69956, 69967], "disallowed"],
		[[69968, 70003], "valid"],
		[
			[70004, 70005],
			"valid",
			[],
			"NV8"
		],
		[[70006, 70006], "valid"],
		[[70007, 70015], "disallowed"],
		[[70016, 70084], "valid"],
		[
			[70085, 70088],
			"valid",
			[],
			"NV8"
		],
		[
			[70089, 70089],
			"valid",
			[],
			"NV8"
		],
		[[70090, 70092], "valid"],
		[
			[70093, 70093],
			"valid",
			[],
			"NV8"
		],
		[[70094, 70095], "disallowed"],
		[[70096, 70105], "valid"],
		[[70106, 70106], "valid"],
		[
			[70107, 70107],
			"valid",
			[],
			"NV8"
		],
		[[70108, 70108], "valid"],
		[
			[70109, 70111],
			"valid",
			[],
			"NV8"
		],
		[[70112, 70112], "disallowed"],
		[
			[70113, 70132],
			"valid",
			[],
			"NV8"
		],
		[[70133, 70143], "disallowed"],
		[[70144, 70161], "valid"],
		[[70162, 70162], "disallowed"],
		[[70163, 70199], "valid"],
		[
			[70200, 70205],
			"valid",
			[],
			"NV8"
		],
		[[70206, 70271], "disallowed"],
		[[70272, 70278], "valid"],
		[[70279, 70279], "disallowed"],
		[[70280, 70280], "valid"],
		[[70281, 70281], "disallowed"],
		[[70282, 70285], "valid"],
		[[70286, 70286], "disallowed"],
		[[70287, 70301], "valid"],
		[[70302, 70302], "disallowed"],
		[[70303, 70312], "valid"],
		[
			[70313, 70313],
			"valid",
			[],
			"NV8"
		],
		[[70314, 70319], "disallowed"],
		[[70320, 70378], "valid"],
		[[70379, 70383], "disallowed"],
		[[70384, 70393], "valid"],
		[[70394, 70399], "disallowed"],
		[[70400, 70400], "valid"],
		[[70401, 70403], "valid"],
		[[70404, 70404], "disallowed"],
		[[70405, 70412], "valid"],
		[[70413, 70414], "disallowed"],
		[[70415, 70416], "valid"],
		[[70417, 70418], "disallowed"],
		[[70419, 70440], "valid"],
		[[70441, 70441], "disallowed"],
		[[70442, 70448], "valid"],
		[[70449, 70449], "disallowed"],
		[[70450, 70451], "valid"],
		[[70452, 70452], "disallowed"],
		[[70453, 70457], "valid"],
		[[70458, 70459], "disallowed"],
		[[70460, 70468], "valid"],
		[[70469, 70470], "disallowed"],
		[[70471, 70472], "valid"],
		[[70473, 70474], "disallowed"],
		[[70475, 70477], "valid"],
		[[70478, 70479], "disallowed"],
		[[70480, 70480], "valid"],
		[[70481, 70486], "disallowed"],
		[[70487, 70487], "valid"],
		[[70488, 70492], "disallowed"],
		[[70493, 70499], "valid"],
		[[70500, 70501], "disallowed"],
		[[70502, 70508], "valid"],
		[[70509, 70511], "disallowed"],
		[[70512, 70516], "valid"],
		[[70517, 70783], "disallowed"],
		[[70784, 70853], "valid"],
		[
			[70854, 70854],
			"valid",
			[],
			"NV8"
		],
		[[70855, 70855], "valid"],
		[[70856, 70863], "disallowed"],
		[[70864, 70873], "valid"],
		[[70874, 71039], "disallowed"],
		[[71040, 71093], "valid"],
		[[71094, 71095], "disallowed"],
		[[71096, 71104], "valid"],
		[
			[71105, 71113],
			"valid",
			[],
			"NV8"
		],
		[
			[71114, 71127],
			"valid",
			[],
			"NV8"
		],
		[[71128, 71133], "valid"],
		[[71134, 71167], "disallowed"],
		[[71168, 71232], "valid"],
		[
			[71233, 71235],
			"valid",
			[],
			"NV8"
		],
		[[71236, 71236], "valid"],
		[[71237, 71247], "disallowed"],
		[[71248, 71257], "valid"],
		[[71258, 71295], "disallowed"],
		[[71296, 71351], "valid"],
		[[71352, 71359], "disallowed"],
		[[71360, 71369], "valid"],
		[[71370, 71423], "disallowed"],
		[[71424, 71449], "valid"],
		[[71450, 71452], "disallowed"],
		[[71453, 71467], "valid"],
		[[71468, 71471], "disallowed"],
		[[71472, 71481], "valid"],
		[
			[71482, 71487],
			"valid",
			[],
			"NV8"
		],
		[[71488, 71839], "disallowed"],
		[
			[71840, 71840],
			"mapped",
			[71872]
		],
		[
			[71841, 71841],
			"mapped",
			[71873]
		],
		[
			[71842, 71842],
			"mapped",
			[71874]
		],
		[
			[71843, 71843],
			"mapped",
			[71875]
		],
		[
			[71844, 71844],
			"mapped",
			[71876]
		],
		[
			[71845, 71845],
			"mapped",
			[71877]
		],
		[
			[71846, 71846],
			"mapped",
			[71878]
		],
		[
			[71847, 71847],
			"mapped",
			[71879]
		],
		[
			[71848, 71848],
			"mapped",
			[71880]
		],
		[
			[71849, 71849],
			"mapped",
			[71881]
		],
		[
			[71850, 71850],
			"mapped",
			[71882]
		],
		[
			[71851, 71851],
			"mapped",
			[71883]
		],
		[
			[71852, 71852],
			"mapped",
			[71884]
		],
		[
			[71853, 71853],
			"mapped",
			[71885]
		],
		[
			[71854, 71854],
			"mapped",
			[71886]
		],
		[
			[71855, 71855],
			"mapped",
			[71887]
		],
		[
			[71856, 71856],
			"mapped",
			[71888]
		],
		[
			[71857, 71857],
			"mapped",
			[71889]
		],
		[
			[71858, 71858],
			"mapped",
			[71890]
		],
		[
			[71859, 71859],
			"mapped",
			[71891]
		],
		[
			[71860, 71860],
			"mapped",
			[71892]
		],
		[
			[71861, 71861],
			"mapped",
			[71893]
		],
		[
			[71862, 71862],
			"mapped",
			[71894]
		],
		[
			[71863, 71863],
			"mapped",
			[71895]
		],
		[
			[71864, 71864],
			"mapped",
			[71896]
		],
		[
			[71865, 71865],
			"mapped",
			[71897]
		],
		[
			[71866, 71866],
			"mapped",
			[71898]
		],
		[
			[71867, 71867],
			"mapped",
			[71899]
		],
		[
			[71868, 71868],
			"mapped",
			[71900]
		],
		[
			[71869, 71869],
			"mapped",
			[71901]
		],
		[
			[71870, 71870],
			"mapped",
			[71902]
		],
		[
			[71871, 71871],
			"mapped",
			[71903]
		],
		[[71872, 71913], "valid"],
		[
			[71914, 71922],
			"valid",
			[],
			"NV8"
		],
		[[71923, 71934], "disallowed"],
		[[71935, 71935], "valid"],
		[[71936, 72383], "disallowed"],
		[[72384, 72440], "valid"],
		[[72441, 73727], "disallowed"],
		[[73728, 74606], "valid"],
		[[74607, 74648], "valid"],
		[[74649, 74649], "valid"],
		[[74650, 74751], "disallowed"],
		[
			[74752, 74850],
			"valid",
			[],
			"NV8"
		],
		[
			[74851, 74862],
			"valid",
			[],
			"NV8"
		],
		[[74863, 74863], "disallowed"],
		[
			[74864, 74867],
			"valid",
			[],
			"NV8"
		],
		[
			[74868, 74868],
			"valid",
			[],
			"NV8"
		],
		[[74869, 74879], "disallowed"],
		[[74880, 75075], "valid"],
		[[75076, 77823], "disallowed"],
		[[77824, 78894], "valid"],
		[[78895, 82943], "disallowed"],
		[[82944, 83526], "valid"],
		[[83527, 92159], "disallowed"],
		[[92160, 92728], "valid"],
		[[92729, 92735], "disallowed"],
		[[92736, 92766], "valid"],
		[[92767, 92767], "disallowed"],
		[[92768, 92777], "valid"],
		[[92778, 92781], "disallowed"],
		[
			[92782, 92783],
			"valid",
			[],
			"NV8"
		],
		[[92784, 92879], "disallowed"],
		[[92880, 92909], "valid"],
		[[92910, 92911], "disallowed"],
		[[92912, 92916], "valid"],
		[
			[92917, 92917],
			"valid",
			[],
			"NV8"
		],
		[[92918, 92927], "disallowed"],
		[[92928, 92982], "valid"],
		[
			[92983, 92991],
			"valid",
			[],
			"NV8"
		],
		[[92992, 92995], "valid"],
		[
			[92996, 92997],
			"valid",
			[],
			"NV8"
		],
		[[92998, 93007], "disallowed"],
		[[93008, 93017], "valid"],
		[[93018, 93018], "disallowed"],
		[
			[93019, 93025],
			"valid",
			[],
			"NV8"
		],
		[[93026, 93026], "disallowed"],
		[[93027, 93047], "valid"],
		[[93048, 93052], "disallowed"],
		[[93053, 93071], "valid"],
		[[93072, 93951], "disallowed"],
		[[93952, 94020], "valid"],
		[[94021, 94031], "disallowed"],
		[[94032, 94078], "valid"],
		[[94079, 94094], "disallowed"],
		[[94095, 94111], "valid"],
		[[94112, 110591], "disallowed"],
		[[110592, 110593], "valid"],
		[[110594, 113663], "disallowed"],
		[[113664, 113770], "valid"],
		[[113771, 113775], "disallowed"],
		[[113776, 113788], "valid"],
		[[113789, 113791], "disallowed"],
		[[113792, 113800], "valid"],
		[[113801, 113807], "disallowed"],
		[[113808, 113817], "valid"],
		[[113818, 113819], "disallowed"],
		[
			[113820, 113820],
			"valid",
			[],
			"NV8"
		],
		[[113821, 113822], "valid"],
		[
			[113823, 113823],
			"valid",
			[],
			"NV8"
		],
		[[113824, 113827], "ignored"],
		[[113828, 118783], "disallowed"],
		[
			[118784, 119029],
			"valid",
			[],
			"NV8"
		],
		[[119030, 119039], "disallowed"],
		[
			[119040, 119078],
			"valid",
			[],
			"NV8"
		],
		[[119079, 119080], "disallowed"],
		[
			[119081, 119081],
			"valid",
			[],
			"NV8"
		],
		[
			[119082, 119133],
			"valid",
			[],
			"NV8"
		],
		[
			[119134, 119134],
			"mapped",
			[119127, 119141]
		],
		[
			[119135, 119135],
			"mapped",
			[119128, 119141]
		],
		[
			[119136, 119136],
			"mapped",
			[
				119128,
				119141,
				119150
			]
		],
		[
			[119137, 119137],
			"mapped",
			[
				119128,
				119141,
				119151
			]
		],
		[
			[119138, 119138],
			"mapped",
			[
				119128,
				119141,
				119152
			]
		],
		[
			[119139, 119139],
			"mapped",
			[
				119128,
				119141,
				119153
			]
		],
		[
			[119140, 119140],
			"mapped",
			[
				119128,
				119141,
				119154
			]
		],
		[
			[119141, 119154],
			"valid",
			[],
			"NV8"
		],
		[[119155, 119162], "disallowed"],
		[
			[119163, 119226],
			"valid",
			[],
			"NV8"
		],
		[
			[119227, 119227],
			"mapped",
			[119225, 119141]
		],
		[
			[119228, 119228],
			"mapped",
			[119226, 119141]
		],
		[
			[119229, 119229],
			"mapped",
			[
				119225,
				119141,
				119150
			]
		],
		[
			[119230, 119230],
			"mapped",
			[
				119226,
				119141,
				119150
			]
		],
		[
			[119231, 119231],
			"mapped",
			[
				119225,
				119141,
				119151
			]
		],
		[
			[119232, 119232],
			"mapped",
			[
				119226,
				119141,
				119151
			]
		],
		[
			[119233, 119261],
			"valid",
			[],
			"NV8"
		],
		[
			[119262, 119272],
			"valid",
			[],
			"NV8"
		],
		[[119273, 119295], "disallowed"],
		[
			[119296, 119365],
			"valid",
			[],
			"NV8"
		],
		[[119366, 119551], "disallowed"],
		[
			[119552, 119638],
			"valid",
			[],
			"NV8"
		],
		[[119639, 119647], "disallowed"],
		[
			[119648, 119665],
			"valid",
			[],
			"NV8"
		],
		[[119666, 119807], "disallowed"],
		[
			[119808, 119808],
			"mapped",
			[97]
		],
		[
			[119809, 119809],
			"mapped",
			[98]
		],
		[
			[119810, 119810],
			"mapped",
			[99]
		],
		[
			[119811, 119811],
			"mapped",
			[100]
		],
		[
			[119812, 119812],
			"mapped",
			[101]
		],
		[
			[119813, 119813],
			"mapped",
			[102]
		],
		[
			[119814, 119814],
			"mapped",
			[103]
		],
		[
			[119815, 119815],
			"mapped",
			[104]
		],
		[
			[119816, 119816],
			"mapped",
			[105]
		],
		[
			[119817, 119817],
			"mapped",
			[106]
		],
		[
			[119818, 119818],
			"mapped",
			[107]
		],
		[
			[119819, 119819],
			"mapped",
			[108]
		],
		[
			[119820, 119820],
			"mapped",
			[109]
		],
		[
			[119821, 119821],
			"mapped",
			[110]
		],
		[
			[119822, 119822],
			"mapped",
			[111]
		],
		[
			[119823, 119823],
			"mapped",
			[112]
		],
		[
			[119824, 119824],
			"mapped",
			[113]
		],
		[
			[119825, 119825],
			"mapped",
			[114]
		],
		[
			[119826, 119826],
			"mapped",
			[115]
		],
		[
			[119827, 119827],
			"mapped",
			[116]
		],
		[
			[119828, 119828],
			"mapped",
			[117]
		],
		[
			[119829, 119829],
			"mapped",
			[118]
		],
		[
			[119830, 119830],
			"mapped",
			[119]
		],
		[
			[119831, 119831],
			"mapped",
			[120]
		],
		[
			[119832, 119832],
			"mapped",
			[121]
		],
		[
			[119833, 119833],
			"mapped",
			[122]
		],
		[
			[119834, 119834],
			"mapped",
			[97]
		],
		[
			[119835, 119835],
			"mapped",
			[98]
		],
		[
			[119836, 119836],
			"mapped",
			[99]
		],
		[
			[119837, 119837],
			"mapped",
			[100]
		],
		[
			[119838, 119838],
			"mapped",
			[101]
		],
		[
			[119839, 119839],
			"mapped",
			[102]
		],
		[
			[119840, 119840],
			"mapped",
			[103]
		],
		[
			[119841, 119841],
			"mapped",
			[104]
		],
		[
			[119842, 119842],
			"mapped",
			[105]
		],
		[
			[119843, 119843],
			"mapped",
			[106]
		],
		[
			[119844, 119844],
			"mapped",
			[107]
		],
		[
			[119845, 119845],
			"mapped",
			[108]
		],
		[
			[119846, 119846],
			"mapped",
			[109]
		],
		[
			[119847, 119847],
			"mapped",
			[110]
		],
		[
			[119848, 119848],
			"mapped",
			[111]
		],
		[
			[119849, 119849],
			"mapped",
			[112]
		],
		[
			[119850, 119850],
			"mapped",
			[113]
		],
		[
			[119851, 119851],
			"mapped",
			[114]
		],
		[
			[119852, 119852],
			"mapped",
			[115]
		],
		[
			[119853, 119853],
			"mapped",
			[116]
		],
		[
			[119854, 119854],
			"mapped",
			[117]
		],
		[
			[119855, 119855],
			"mapped",
			[118]
		],
		[
			[119856, 119856],
			"mapped",
			[119]
		],
		[
			[119857, 119857],
			"mapped",
			[120]
		],
		[
			[119858, 119858],
			"mapped",
			[121]
		],
		[
			[119859, 119859],
			"mapped",
			[122]
		],
		[
			[119860, 119860],
			"mapped",
			[97]
		],
		[
			[119861, 119861],
			"mapped",
			[98]
		],
		[
			[119862, 119862],
			"mapped",
			[99]
		],
		[
			[119863, 119863],
			"mapped",
			[100]
		],
		[
			[119864, 119864],
			"mapped",
			[101]
		],
		[
			[119865, 119865],
			"mapped",
			[102]
		],
		[
			[119866, 119866],
			"mapped",
			[103]
		],
		[
			[119867, 119867],
			"mapped",
			[104]
		],
		[
			[119868, 119868],
			"mapped",
			[105]
		],
		[
			[119869, 119869],
			"mapped",
			[106]
		],
		[
			[119870, 119870],
			"mapped",
			[107]
		],
		[
			[119871, 119871],
			"mapped",
			[108]
		],
		[
			[119872, 119872],
			"mapped",
			[109]
		],
		[
			[119873, 119873],
			"mapped",
			[110]
		],
		[
			[119874, 119874],
			"mapped",
			[111]
		],
		[
			[119875, 119875],
			"mapped",
			[112]
		],
		[
			[119876, 119876],
			"mapped",
			[113]
		],
		[
			[119877, 119877],
			"mapped",
			[114]
		],
		[
			[119878, 119878],
			"mapped",
			[115]
		],
		[
			[119879, 119879],
			"mapped",
			[116]
		],
		[
			[119880, 119880],
			"mapped",
			[117]
		],
		[
			[119881, 119881],
			"mapped",
			[118]
		],
		[
			[119882, 119882],
			"mapped",
			[119]
		],
		[
			[119883, 119883],
			"mapped",
			[120]
		],
		[
			[119884, 119884],
			"mapped",
			[121]
		],
		[
			[119885, 119885],
			"mapped",
			[122]
		],
		[
			[119886, 119886],
			"mapped",
			[97]
		],
		[
			[119887, 119887],
			"mapped",
			[98]
		],
		[
			[119888, 119888],
			"mapped",
			[99]
		],
		[
			[119889, 119889],
			"mapped",
			[100]
		],
		[
			[119890, 119890],
			"mapped",
			[101]
		],
		[
			[119891, 119891],
			"mapped",
			[102]
		],
		[
			[119892, 119892],
			"mapped",
			[103]
		],
		[[119893, 119893], "disallowed"],
		[
			[119894, 119894],
			"mapped",
			[105]
		],
		[
			[119895, 119895],
			"mapped",
			[106]
		],
		[
			[119896, 119896],
			"mapped",
			[107]
		],
		[
			[119897, 119897],
			"mapped",
			[108]
		],
		[
			[119898, 119898],
			"mapped",
			[109]
		],
		[
			[119899, 119899],
			"mapped",
			[110]
		],
		[
			[119900, 119900],
			"mapped",
			[111]
		],
		[
			[119901, 119901],
			"mapped",
			[112]
		],
		[
			[119902, 119902],
			"mapped",
			[113]
		],
		[
			[119903, 119903],
			"mapped",
			[114]
		],
		[
			[119904, 119904],
			"mapped",
			[115]
		],
		[
			[119905, 119905],
			"mapped",
			[116]
		],
		[
			[119906, 119906],
			"mapped",
			[117]
		],
		[
			[119907, 119907],
			"mapped",
			[118]
		],
		[
			[119908, 119908],
			"mapped",
			[119]
		],
		[
			[119909, 119909],
			"mapped",
			[120]
		],
		[
			[119910, 119910],
			"mapped",
			[121]
		],
		[
			[119911, 119911],
			"mapped",
			[122]
		],
		[
			[119912, 119912],
			"mapped",
			[97]
		],
		[
			[119913, 119913],
			"mapped",
			[98]
		],
		[
			[119914, 119914],
			"mapped",
			[99]
		],
		[
			[119915, 119915],
			"mapped",
			[100]
		],
		[
			[119916, 119916],
			"mapped",
			[101]
		],
		[
			[119917, 119917],
			"mapped",
			[102]
		],
		[
			[119918, 119918],
			"mapped",
			[103]
		],
		[
			[119919, 119919],
			"mapped",
			[104]
		],
		[
			[119920, 119920],
			"mapped",
			[105]
		],
		[
			[119921, 119921],
			"mapped",
			[106]
		],
		[
			[119922, 119922],
			"mapped",
			[107]
		],
		[
			[119923, 119923],
			"mapped",
			[108]
		],
		[
			[119924, 119924],
			"mapped",
			[109]
		],
		[
			[119925, 119925],
			"mapped",
			[110]
		],
		[
			[119926, 119926],
			"mapped",
			[111]
		],
		[
			[119927, 119927],
			"mapped",
			[112]
		],
		[
			[119928, 119928],
			"mapped",
			[113]
		],
		[
			[119929, 119929],
			"mapped",
			[114]
		],
		[
			[119930, 119930],
			"mapped",
			[115]
		],
		[
			[119931, 119931],
			"mapped",
			[116]
		],
		[
			[119932, 119932],
			"mapped",
			[117]
		],
		[
			[119933, 119933],
			"mapped",
			[118]
		],
		[
			[119934, 119934],
			"mapped",
			[119]
		],
		[
			[119935, 119935],
			"mapped",
			[120]
		],
		[
			[119936, 119936],
			"mapped",
			[121]
		],
		[
			[119937, 119937],
			"mapped",
			[122]
		],
		[
			[119938, 119938],
			"mapped",
			[97]
		],
		[
			[119939, 119939],
			"mapped",
			[98]
		],
		[
			[119940, 119940],
			"mapped",
			[99]
		],
		[
			[119941, 119941],
			"mapped",
			[100]
		],
		[
			[119942, 119942],
			"mapped",
			[101]
		],
		[
			[119943, 119943],
			"mapped",
			[102]
		],
		[
			[119944, 119944],
			"mapped",
			[103]
		],
		[
			[119945, 119945],
			"mapped",
			[104]
		],
		[
			[119946, 119946],
			"mapped",
			[105]
		],
		[
			[119947, 119947],
			"mapped",
			[106]
		],
		[
			[119948, 119948],
			"mapped",
			[107]
		],
		[
			[119949, 119949],
			"mapped",
			[108]
		],
		[
			[119950, 119950],
			"mapped",
			[109]
		],
		[
			[119951, 119951],
			"mapped",
			[110]
		],
		[
			[119952, 119952],
			"mapped",
			[111]
		],
		[
			[119953, 119953],
			"mapped",
			[112]
		],
		[
			[119954, 119954],
			"mapped",
			[113]
		],
		[
			[119955, 119955],
			"mapped",
			[114]
		],
		[
			[119956, 119956],
			"mapped",
			[115]
		],
		[
			[119957, 119957],
			"mapped",
			[116]
		],
		[
			[119958, 119958],
			"mapped",
			[117]
		],
		[
			[119959, 119959],
			"mapped",
			[118]
		],
		[
			[119960, 119960],
			"mapped",
			[119]
		],
		[
			[119961, 119961],
			"mapped",
			[120]
		],
		[
			[119962, 119962],
			"mapped",
			[121]
		],
		[
			[119963, 119963],
			"mapped",
			[122]
		],
		[
			[119964, 119964],
			"mapped",
			[97]
		],
		[[119965, 119965], "disallowed"],
		[
			[119966, 119966],
			"mapped",
			[99]
		],
		[
			[119967, 119967],
			"mapped",
			[100]
		],
		[[119968, 119969], "disallowed"],
		[
			[119970, 119970],
			"mapped",
			[103]
		],
		[[119971, 119972], "disallowed"],
		[
			[119973, 119973],
			"mapped",
			[106]
		],
		[
			[119974, 119974],
			"mapped",
			[107]
		],
		[[119975, 119976], "disallowed"],
		[
			[119977, 119977],
			"mapped",
			[110]
		],
		[
			[119978, 119978],
			"mapped",
			[111]
		],
		[
			[119979, 119979],
			"mapped",
			[112]
		],
		[
			[119980, 119980],
			"mapped",
			[113]
		],
		[[119981, 119981], "disallowed"],
		[
			[119982, 119982],
			"mapped",
			[115]
		],
		[
			[119983, 119983],
			"mapped",
			[116]
		],
		[
			[119984, 119984],
			"mapped",
			[117]
		],
		[
			[119985, 119985],
			"mapped",
			[118]
		],
		[
			[119986, 119986],
			"mapped",
			[119]
		],
		[
			[119987, 119987],
			"mapped",
			[120]
		],
		[
			[119988, 119988],
			"mapped",
			[121]
		],
		[
			[119989, 119989],
			"mapped",
			[122]
		],
		[
			[119990, 119990],
			"mapped",
			[97]
		],
		[
			[119991, 119991],
			"mapped",
			[98]
		],
		[
			[119992, 119992],
			"mapped",
			[99]
		],
		[
			[119993, 119993],
			"mapped",
			[100]
		],
		[[119994, 119994], "disallowed"],
		[
			[119995, 119995],
			"mapped",
			[102]
		],
		[[119996, 119996], "disallowed"],
		[
			[119997, 119997],
			"mapped",
			[104]
		],
		[
			[119998, 119998],
			"mapped",
			[105]
		],
		[
			[119999, 119999],
			"mapped",
			[106]
		],
		[
			[12e4, 12e4],
			"mapped",
			[107]
		],
		[
			[120001, 120001],
			"mapped",
			[108]
		],
		[
			[120002, 120002],
			"mapped",
			[109]
		],
		[
			[120003, 120003],
			"mapped",
			[110]
		],
		[[120004, 120004], "disallowed"],
		[
			[120005, 120005],
			"mapped",
			[112]
		],
		[
			[120006, 120006],
			"mapped",
			[113]
		],
		[
			[120007, 120007],
			"mapped",
			[114]
		],
		[
			[120008, 120008],
			"mapped",
			[115]
		],
		[
			[120009, 120009],
			"mapped",
			[116]
		],
		[
			[120010, 120010],
			"mapped",
			[117]
		],
		[
			[120011, 120011],
			"mapped",
			[118]
		],
		[
			[120012, 120012],
			"mapped",
			[119]
		],
		[
			[120013, 120013],
			"mapped",
			[120]
		],
		[
			[120014, 120014],
			"mapped",
			[121]
		],
		[
			[120015, 120015],
			"mapped",
			[122]
		],
		[
			[120016, 120016],
			"mapped",
			[97]
		],
		[
			[120017, 120017],
			"mapped",
			[98]
		],
		[
			[120018, 120018],
			"mapped",
			[99]
		],
		[
			[120019, 120019],
			"mapped",
			[100]
		],
		[
			[120020, 120020],
			"mapped",
			[101]
		],
		[
			[120021, 120021],
			"mapped",
			[102]
		],
		[
			[120022, 120022],
			"mapped",
			[103]
		],
		[
			[120023, 120023],
			"mapped",
			[104]
		],
		[
			[120024, 120024],
			"mapped",
			[105]
		],
		[
			[120025, 120025],
			"mapped",
			[106]
		],
		[
			[120026, 120026],
			"mapped",
			[107]
		],
		[
			[120027, 120027],
			"mapped",
			[108]
		],
		[
			[120028, 120028],
			"mapped",
			[109]
		],
		[
			[120029, 120029],
			"mapped",
			[110]
		],
		[
			[120030, 120030],
			"mapped",
			[111]
		],
		[
			[120031, 120031],
			"mapped",
			[112]
		],
		[
			[120032, 120032],
			"mapped",
			[113]
		],
		[
			[120033, 120033],
			"mapped",
			[114]
		],
		[
			[120034, 120034],
			"mapped",
			[115]
		],
		[
			[120035, 120035],
			"mapped",
			[116]
		],
		[
			[120036, 120036],
			"mapped",
			[117]
		],
		[
			[120037, 120037],
			"mapped",
			[118]
		],
		[
			[120038, 120038],
			"mapped",
			[119]
		],
		[
			[120039, 120039],
			"mapped",
			[120]
		],
		[
			[120040, 120040],
			"mapped",
			[121]
		],
		[
			[120041, 120041],
			"mapped",
			[122]
		],
		[
			[120042, 120042],
			"mapped",
			[97]
		],
		[
			[120043, 120043],
			"mapped",
			[98]
		],
		[
			[120044, 120044],
			"mapped",
			[99]
		],
		[
			[120045, 120045],
			"mapped",
			[100]
		],
		[
			[120046, 120046],
			"mapped",
			[101]
		],
		[
			[120047, 120047],
			"mapped",
			[102]
		],
		[
			[120048, 120048],
			"mapped",
			[103]
		],
		[
			[120049, 120049],
			"mapped",
			[104]
		],
		[
			[120050, 120050],
			"mapped",
			[105]
		],
		[
			[120051, 120051],
			"mapped",
			[106]
		],
		[
			[120052, 120052],
			"mapped",
			[107]
		],
		[
			[120053, 120053],
			"mapped",
			[108]
		],
		[
			[120054, 120054],
			"mapped",
			[109]
		],
		[
			[120055, 120055],
			"mapped",
			[110]
		],
		[
			[120056, 120056],
			"mapped",
			[111]
		],
		[
			[120057, 120057],
			"mapped",
			[112]
		],
		[
			[120058, 120058],
			"mapped",
			[113]
		],
		[
			[120059, 120059],
			"mapped",
			[114]
		],
		[
			[120060, 120060],
			"mapped",
			[115]
		],
		[
			[120061, 120061],
			"mapped",
			[116]
		],
		[
			[120062, 120062],
			"mapped",
			[117]
		],
		[
			[120063, 120063],
			"mapped",
			[118]
		],
		[
			[120064, 120064],
			"mapped",
			[119]
		],
		[
			[120065, 120065],
			"mapped",
			[120]
		],
		[
			[120066, 120066],
			"mapped",
			[121]
		],
		[
			[120067, 120067],
			"mapped",
			[122]
		],
		[
			[120068, 120068],
			"mapped",
			[97]
		],
		[
			[120069, 120069],
			"mapped",
			[98]
		],
		[[120070, 120070], "disallowed"],
		[
			[120071, 120071],
			"mapped",
			[100]
		],
		[
			[120072, 120072],
			"mapped",
			[101]
		],
		[
			[120073, 120073],
			"mapped",
			[102]
		],
		[
			[120074, 120074],
			"mapped",
			[103]
		],
		[[120075, 120076], "disallowed"],
		[
			[120077, 120077],
			"mapped",
			[106]
		],
		[
			[120078, 120078],
			"mapped",
			[107]
		],
		[
			[120079, 120079],
			"mapped",
			[108]
		],
		[
			[120080, 120080],
			"mapped",
			[109]
		],
		[
			[120081, 120081],
			"mapped",
			[110]
		],
		[
			[120082, 120082],
			"mapped",
			[111]
		],
		[
			[120083, 120083],
			"mapped",
			[112]
		],
		[
			[120084, 120084],
			"mapped",
			[113]
		],
		[[120085, 120085], "disallowed"],
		[
			[120086, 120086],
			"mapped",
			[115]
		],
		[
			[120087, 120087],
			"mapped",
			[116]
		],
		[
			[120088, 120088],
			"mapped",
			[117]
		],
		[
			[120089, 120089],
			"mapped",
			[118]
		],
		[
			[120090, 120090],
			"mapped",
			[119]
		],
		[
			[120091, 120091],
			"mapped",
			[120]
		],
		[
			[120092, 120092],
			"mapped",
			[121]
		],
		[[120093, 120093], "disallowed"],
		[
			[120094, 120094],
			"mapped",
			[97]
		],
		[
			[120095, 120095],
			"mapped",
			[98]
		],
		[
			[120096, 120096],
			"mapped",
			[99]
		],
		[
			[120097, 120097],
			"mapped",
			[100]
		],
		[
			[120098, 120098],
			"mapped",
			[101]
		],
		[
			[120099, 120099],
			"mapped",
			[102]
		],
		[
			[120100, 120100],
			"mapped",
			[103]
		],
		[
			[120101, 120101],
			"mapped",
			[104]
		],
		[
			[120102, 120102],
			"mapped",
			[105]
		],
		[
			[120103, 120103],
			"mapped",
			[106]
		],
		[
			[120104, 120104],
			"mapped",
			[107]
		],
		[
			[120105, 120105],
			"mapped",
			[108]
		],
		[
			[120106, 120106],
			"mapped",
			[109]
		],
		[
			[120107, 120107],
			"mapped",
			[110]
		],
		[
			[120108, 120108],
			"mapped",
			[111]
		],
		[
			[120109, 120109],
			"mapped",
			[112]
		],
		[
			[120110, 120110],
			"mapped",
			[113]
		],
		[
			[120111, 120111],
			"mapped",
			[114]
		],
		[
			[120112, 120112],
			"mapped",
			[115]
		],
		[
			[120113, 120113],
			"mapped",
			[116]
		],
		[
			[120114, 120114],
			"mapped",
			[117]
		],
		[
			[120115, 120115],
			"mapped",
			[118]
		],
		[
			[120116, 120116],
			"mapped",
			[119]
		],
		[
			[120117, 120117],
			"mapped",
			[120]
		],
		[
			[120118, 120118],
			"mapped",
			[121]
		],
		[
			[120119, 120119],
			"mapped",
			[122]
		],
		[
			[120120, 120120],
			"mapped",
			[97]
		],
		[
			[120121, 120121],
			"mapped",
			[98]
		],
		[[120122, 120122], "disallowed"],
		[
			[120123, 120123],
			"mapped",
			[100]
		],
		[
			[120124, 120124],
			"mapped",
			[101]
		],
		[
			[120125, 120125],
			"mapped",
			[102]
		],
		[
			[120126, 120126],
			"mapped",
			[103]
		],
		[[120127, 120127], "disallowed"],
		[
			[120128, 120128],
			"mapped",
			[105]
		],
		[
			[120129, 120129],
			"mapped",
			[106]
		],
		[
			[120130, 120130],
			"mapped",
			[107]
		],
		[
			[120131, 120131],
			"mapped",
			[108]
		],
		[
			[120132, 120132],
			"mapped",
			[109]
		],
		[[120133, 120133], "disallowed"],
		[
			[120134, 120134],
			"mapped",
			[111]
		],
		[[120135, 120137], "disallowed"],
		[
			[120138, 120138],
			"mapped",
			[115]
		],
		[
			[120139, 120139],
			"mapped",
			[116]
		],
		[
			[120140, 120140],
			"mapped",
			[117]
		],
		[
			[120141, 120141],
			"mapped",
			[118]
		],
		[
			[120142, 120142],
			"mapped",
			[119]
		],
		[
			[120143, 120143],
			"mapped",
			[120]
		],
		[
			[120144, 120144],
			"mapped",
			[121]
		],
		[[120145, 120145], "disallowed"],
		[
			[120146, 120146],
			"mapped",
			[97]
		],
		[
			[120147, 120147],
			"mapped",
			[98]
		],
		[
			[120148, 120148],
			"mapped",
			[99]
		],
		[
			[120149, 120149],
			"mapped",
			[100]
		],
		[
			[120150, 120150],
			"mapped",
			[101]
		],
		[
			[120151, 120151],
			"mapped",
			[102]
		],
		[
			[120152, 120152],
			"mapped",
			[103]
		],
		[
			[120153, 120153],
			"mapped",
			[104]
		],
		[
			[120154, 120154],
			"mapped",
			[105]
		],
		[
			[120155, 120155],
			"mapped",
			[106]
		],
		[
			[120156, 120156],
			"mapped",
			[107]
		],
		[
			[120157, 120157],
			"mapped",
			[108]
		],
		[
			[120158, 120158],
			"mapped",
			[109]
		],
		[
			[120159, 120159],
			"mapped",
			[110]
		],
		[
			[120160, 120160],
			"mapped",
			[111]
		],
		[
			[120161, 120161],
			"mapped",
			[112]
		],
		[
			[120162, 120162],
			"mapped",
			[113]
		],
		[
			[120163, 120163],
			"mapped",
			[114]
		],
		[
			[120164, 120164],
			"mapped",
			[115]
		],
		[
			[120165, 120165],
			"mapped",
			[116]
		],
		[
			[120166, 120166],
			"mapped",
			[117]
		],
		[
			[120167, 120167],
			"mapped",
			[118]
		],
		[
			[120168, 120168],
			"mapped",
			[119]
		],
		[
			[120169, 120169],
			"mapped",
			[120]
		],
		[
			[120170, 120170],
			"mapped",
			[121]
		],
		[
			[120171, 120171],
			"mapped",
			[122]
		],
		[
			[120172, 120172],
			"mapped",
			[97]
		],
		[
			[120173, 120173],
			"mapped",
			[98]
		],
		[
			[120174, 120174],
			"mapped",
			[99]
		],
		[
			[120175, 120175],
			"mapped",
			[100]
		],
		[
			[120176, 120176],
			"mapped",
			[101]
		],
		[
			[120177, 120177],
			"mapped",
			[102]
		],
		[
			[120178, 120178],
			"mapped",
			[103]
		],
		[
			[120179, 120179],
			"mapped",
			[104]
		],
		[
			[120180, 120180],
			"mapped",
			[105]
		],
		[
			[120181, 120181],
			"mapped",
			[106]
		],
		[
			[120182, 120182],
			"mapped",
			[107]
		],
		[
			[120183, 120183],
			"mapped",
			[108]
		],
		[
			[120184, 120184],
			"mapped",
			[109]
		],
		[
			[120185, 120185],
			"mapped",
			[110]
		],
		[
			[120186, 120186],
			"mapped",
			[111]
		],
		[
			[120187, 120187],
			"mapped",
			[112]
		],
		[
			[120188, 120188],
			"mapped",
			[113]
		],
		[
			[120189, 120189],
			"mapped",
			[114]
		],
		[
			[120190, 120190],
			"mapped",
			[115]
		],
		[
			[120191, 120191],
			"mapped",
			[116]
		],
		[
			[120192, 120192],
			"mapped",
			[117]
		],
		[
			[120193, 120193],
			"mapped",
			[118]
		],
		[
			[120194, 120194],
			"mapped",
			[119]
		],
		[
			[120195, 120195],
			"mapped",
			[120]
		],
		[
			[120196, 120196],
			"mapped",
			[121]
		],
		[
			[120197, 120197],
			"mapped",
			[122]
		],
		[
			[120198, 120198],
			"mapped",
			[97]
		],
		[
			[120199, 120199],
			"mapped",
			[98]
		],
		[
			[120200, 120200],
			"mapped",
			[99]
		],
		[
			[120201, 120201],
			"mapped",
			[100]
		],
		[
			[120202, 120202],
			"mapped",
			[101]
		],
		[
			[120203, 120203],
			"mapped",
			[102]
		],
		[
			[120204, 120204],
			"mapped",
			[103]
		],
		[
			[120205, 120205],
			"mapped",
			[104]
		],
		[
			[120206, 120206],
			"mapped",
			[105]
		],
		[
			[120207, 120207],
			"mapped",
			[106]
		],
		[
			[120208, 120208],
			"mapped",
			[107]
		],
		[
			[120209, 120209],
			"mapped",
			[108]
		],
		[
			[120210, 120210],
			"mapped",
			[109]
		],
		[
			[120211, 120211],
			"mapped",
			[110]
		],
		[
			[120212, 120212],
			"mapped",
			[111]
		],
		[
			[120213, 120213],
			"mapped",
			[112]
		],
		[
			[120214, 120214],
			"mapped",
			[113]
		],
		[
			[120215, 120215],
			"mapped",
			[114]
		],
		[
			[120216, 120216],
			"mapped",
			[115]
		],
		[
			[120217, 120217],
			"mapped",
			[116]
		],
		[
			[120218, 120218],
			"mapped",
			[117]
		],
		[
			[120219, 120219],
			"mapped",
			[118]
		],
		[
			[120220, 120220],
			"mapped",
			[119]
		],
		[
			[120221, 120221],
			"mapped",
			[120]
		],
		[
			[120222, 120222],
			"mapped",
			[121]
		],
		[
			[120223, 120223],
			"mapped",
			[122]
		],
		[
			[120224, 120224],
			"mapped",
			[97]
		],
		[
			[120225, 120225],
			"mapped",
			[98]
		],
		[
			[120226, 120226],
			"mapped",
			[99]
		],
		[
			[120227, 120227],
			"mapped",
			[100]
		],
		[
			[120228, 120228],
			"mapped",
			[101]
		],
		[
			[120229, 120229],
			"mapped",
			[102]
		],
		[
			[120230, 120230],
			"mapped",
			[103]
		],
		[
			[120231, 120231],
			"mapped",
			[104]
		],
		[
			[120232, 120232],
			"mapped",
			[105]
		],
		[
			[120233, 120233],
			"mapped",
			[106]
		],
		[
			[120234, 120234],
			"mapped",
			[107]
		],
		[
			[120235, 120235],
			"mapped",
			[108]
		],
		[
			[120236, 120236],
			"mapped",
			[109]
		],
		[
			[120237, 120237],
			"mapped",
			[110]
		],
		[
			[120238, 120238],
			"mapped",
			[111]
		],
		[
			[120239, 120239],
			"mapped",
			[112]
		],
		[
			[120240, 120240],
			"mapped",
			[113]
		],
		[
			[120241, 120241],
			"mapped",
			[114]
		],
		[
			[120242, 120242],
			"mapped",
			[115]
		],
		[
			[120243, 120243],
			"mapped",
			[116]
		],
		[
			[120244, 120244],
			"mapped",
			[117]
		],
		[
			[120245, 120245],
			"mapped",
			[118]
		],
		[
			[120246, 120246],
			"mapped",
			[119]
		],
		[
			[120247, 120247],
			"mapped",
			[120]
		],
		[
			[120248, 120248],
			"mapped",
			[121]
		],
		[
			[120249, 120249],
			"mapped",
			[122]
		],
		[
			[120250, 120250],
			"mapped",
			[97]
		],
		[
			[120251, 120251],
			"mapped",
			[98]
		],
		[
			[120252, 120252],
			"mapped",
			[99]
		],
		[
			[120253, 120253],
			"mapped",
			[100]
		],
		[
			[120254, 120254],
			"mapped",
			[101]
		],
		[
			[120255, 120255],
			"mapped",
			[102]
		],
		[
			[120256, 120256],
			"mapped",
			[103]
		],
		[
			[120257, 120257],
			"mapped",
			[104]
		],
		[
			[120258, 120258],
			"mapped",
			[105]
		],
		[
			[120259, 120259],
			"mapped",
			[106]
		],
		[
			[120260, 120260],
			"mapped",
			[107]
		],
		[
			[120261, 120261],
			"mapped",
			[108]
		],
		[
			[120262, 120262],
			"mapped",
			[109]
		],
		[
			[120263, 120263],
			"mapped",
			[110]
		],
		[
			[120264, 120264],
			"mapped",
			[111]
		],
		[
			[120265, 120265],
			"mapped",
			[112]
		],
		[
			[120266, 120266],
			"mapped",
			[113]
		],
		[
			[120267, 120267],
			"mapped",
			[114]
		],
		[
			[120268, 120268],
			"mapped",
			[115]
		],
		[
			[120269, 120269],
			"mapped",
			[116]
		],
		[
			[120270, 120270],
			"mapped",
			[117]
		],
		[
			[120271, 120271],
			"mapped",
			[118]
		],
		[
			[120272, 120272],
			"mapped",
			[119]
		],
		[
			[120273, 120273],
			"mapped",
			[120]
		],
		[
			[120274, 120274],
			"mapped",
			[121]
		],
		[
			[120275, 120275],
			"mapped",
			[122]
		],
		[
			[120276, 120276],
			"mapped",
			[97]
		],
		[
			[120277, 120277],
			"mapped",
			[98]
		],
		[
			[120278, 120278],
			"mapped",
			[99]
		],
		[
			[120279, 120279],
			"mapped",
			[100]
		],
		[
			[120280, 120280],
			"mapped",
			[101]
		],
		[
			[120281, 120281],
			"mapped",
			[102]
		],
		[
			[120282, 120282],
			"mapped",
			[103]
		],
		[
			[120283, 120283],
			"mapped",
			[104]
		],
		[
			[120284, 120284],
			"mapped",
			[105]
		],
		[
			[120285, 120285],
			"mapped",
			[106]
		],
		[
			[120286, 120286],
			"mapped",
			[107]
		],
		[
			[120287, 120287],
			"mapped",
			[108]
		],
		[
			[120288, 120288],
			"mapped",
			[109]
		],
		[
			[120289, 120289],
			"mapped",
			[110]
		],
		[
			[120290, 120290],
			"mapped",
			[111]
		],
		[
			[120291, 120291],
			"mapped",
			[112]
		],
		[
			[120292, 120292],
			"mapped",
			[113]
		],
		[
			[120293, 120293],
			"mapped",
			[114]
		],
		[
			[120294, 120294],
			"mapped",
			[115]
		],
		[
			[120295, 120295],
			"mapped",
			[116]
		],
		[
			[120296, 120296],
			"mapped",
			[117]
		],
		[
			[120297, 120297],
			"mapped",
			[118]
		],
		[
			[120298, 120298],
			"mapped",
			[119]
		],
		[
			[120299, 120299],
			"mapped",
			[120]
		],
		[
			[120300, 120300],
			"mapped",
			[121]
		],
		[
			[120301, 120301],
			"mapped",
			[122]
		],
		[
			[120302, 120302],
			"mapped",
			[97]
		],
		[
			[120303, 120303],
			"mapped",
			[98]
		],
		[
			[120304, 120304],
			"mapped",
			[99]
		],
		[
			[120305, 120305],
			"mapped",
			[100]
		],
		[
			[120306, 120306],
			"mapped",
			[101]
		],
		[
			[120307, 120307],
			"mapped",
			[102]
		],
		[
			[120308, 120308],
			"mapped",
			[103]
		],
		[
			[120309, 120309],
			"mapped",
			[104]
		],
		[
			[120310, 120310],
			"mapped",
			[105]
		],
		[
			[120311, 120311],
			"mapped",
			[106]
		],
		[
			[120312, 120312],
			"mapped",
			[107]
		],
		[
			[120313, 120313],
			"mapped",
			[108]
		],
		[
			[120314, 120314],
			"mapped",
			[109]
		],
		[
			[120315, 120315],
			"mapped",
			[110]
		],
		[
			[120316, 120316],
			"mapped",
			[111]
		],
		[
			[120317, 120317],
			"mapped",
			[112]
		],
		[
			[120318, 120318],
			"mapped",
			[113]
		],
		[
			[120319, 120319],
			"mapped",
			[114]
		],
		[
			[120320, 120320],
			"mapped",
			[115]
		],
		[
			[120321, 120321],
			"mapped",
			[116]
		],
		[
			[120322, 120322],
			"mapped",
			[117]
		],
		[
			[120323, 120323],
			"mapped",
			[118]
		],
		[
			[120324, 120324],
			"mapped",
			[119]
		],
		[
			[120325, 120325],
			"mapped",
			[120]
		],
		[
			[120326, 120326],
			"mapped",
			[121]
		],
		[
			[120327, 120327],
			"mapped",
			[122]
		],
		[
			[120328, 120328],
			"mapped",
			[97]
		],
		[
			[120329, 120329],
			"mapped",
			[98]
		],
		[
			[120330, 120330],
			"mapped",
			[99]
		],
		[
			[120331, 120331],
			"mapped",
			[100]
		],
		[
			[120332, 120332],
			"mapped",
			[101]
		],
		[
			[120333, 120333],
			"mapped",
			[102]
		],
		[
			[120334, 120334],
			"mapped",
			[103]
		],
		[
			[120335, 120335],
			"mapped",
			[104]
		],
		[
			[120336, 120336],
			"mapped",
			[105]
		],
		[
			[120337, 120337],
			"mapped",
			[106]
		],
		[
			[120338, 120338],
			"mapped",
			[107]
		],
		[
			[120339, 120339],
			"mapped",
			[108]
		],
		[
			[120340, 120340],
			"mapped",
			[109]
		],
		[
			[120341, 120341],
			"mapped",
			[110]
		],
		[
			[120342, 120342],
			"mapped",
			[111]
		],
		[
			[120343, 120343],
			"mapped",
			[112]
		],
		[
			[120344, 120344],
			"mapped",
			[113]
		],
		[
			[120345, 120345],
			"mapped",
			[114]
		],
		[
			[120346, 120346],
			"mapped",
			[115]
		],
		[
			[120347, 120347],
			"mapped",
			[116]
		],
		[
			[120348, 120348],
			"mapped",
			[117]
		],
		[
			[120349, 120349],
			"mapped",
			[118]
		],
		[
			[120350, 120350],
			"mapped",
			[119]
		],
		[
			[120351, 120351],
			"mapped",
			[120]
		],
		[
			[120352, 120352],
			"mapped",
			[121]
		],
		[
			[120353, 120353],
			"mapped",
			[122]
		],
		[
			[120354, 120354],
			"mapped",
			[97]
		],
		[
			[120355, 120355],
			"mapped",
			[98]
		],
		[
			[120356, 120356],
			"mapped",
			[99]
		],
		[
			[120357, 120357],
			"mapped",
			[100]
		],
		[
			[120358, 120358],
			"mapped",
			[101]
		],
		[
			[120359, 120359],
			"mapped",
			[102]
		],
		[
			[120360, 120360],
			"mapped",
			[103]
		],
		[
			[120361, 120361],
			"mapped",
			[104]
		],
		[
			[120362, 120362],
			"mapped",
			[105]
		],
		[
			[120363, 120363],
			"mapped",
			[106]
		],
		[
			[120364, 120364],
			"mapped",
			[107]
		],
		[
			[120365, 120365],
			"mapped",
			[108]
		],
		[
			[120366, 120366],
			"mapped",
			[109]
		],
		[
			[120367, 120367],
			"mapped",
			[110]
		],
		[
			[120368, 120368],
			"mapped",
			[111]
		],
		[
			[120369, 120369],
			"mapped",
			[112]
		],
		[
			[120370, 120370],
			"mapped",
			[113]
		],
		[
			[120371, 120371],
			"mapped",
			[114]
		],
		[
			[120372, 120372],
			"mapped",
			[115]
		],
		[
			[120373, 120373],
			"mapped",
			[116]
		],
		[
			[120374, 120374],
			"mapped",
			[117]
		],
		[
			[120375, 120375],
			"mapped",
			[118]
		],
		[
			[120376, 120376],
			"mapped",
			[119]
		],
		[
			[120377, 120377],
			"mapped",
			[120]
		],
		[
			[120378, 120378],
			"mapped",
			[121]
		],
		[
			[120379, 120379],
			"mapped",
			[122]
		],
		[
			[120380, 120380],
			"mapped",
			[97]
		],
		[
			[120381, 120381],
			"mapped",
			[98]
		],
		[
			[120382, 120382],
			"mapped",
			[99]
		],
		[
			[120383, 120383],
			"mapped",
			[100]
		],
		[
			[120384, 120384],
			"mapped",
			[101]
		],
		[
			[120385, 120385],
			"mapped",
			[102]
		],
		[
			[120386, 120386],
			"mapped",
			[103]
		],
		[
			[120387, 120387],
			"mapped",
			[104]
		],
		[
			[120388, 120388],
			"mapped",
			[105]
		],
		[
			[120389, 120389],
			"mapped",
			[106]
		],
		[
			[120390, 120390],
			"mapped",
			[107]
		],
		[
			[120391, 120391],
			"mapped",
			[108]
		],
		[
			[120392, 120392],
			"mapped",
			[109]
		],
		[
			[120393, 120393],
			"mapped",
			[110]
		],
		[
			[120394, 120394],
			"mapped",
			[111]
		],
		[
			[120395, 120395],
			"mapped",
			[112]
		],
		[
			[120396, 120396],
			"mapped",
			[113]
		],
		[
			[120397, 120397],
			"mapped",
			[114]
		],
		[
			[120398, 120398],
			"mapped",
			[115]
		],
		[
			[120399, 120399],
			"mapped",
			[116]
		],
		[
			[120400, 120400],
			"mapped",
			[117]
		],
		[
			[120401, 120401],
			"mapped",
			[118]
		],
		[
			[120402, 120402],
			"mapped",
			[119]
		],
		[
			[120403, 120403],
			"mapped",
			[120]
		],
		[
			[120404, 120404],
			"mapped",
			[121]
		],
		[
			[120405, 120405],
			"mapped",
			[122]
		],
		[
			[120406, 120406],
			"mapped",
			[97]
		],
		[
			[120407, 120407],
			"mapped",
			[98]
		],
		[
			[120408, 120408],
			"mapped",
			[99]
		],
		[
			[120409, 120409],
			"mapped",
			[100]
		],
		[
			[120410, 120410],
			"mapped",
			[101]
		],
		[
			[120411, 120411],
			"mapped",
			[102]
		],
		[
			[120412, 120412],
			"mapped",
			[103]
		],
		[
			[120413, 120413],
			"mapped",
			[104]
		],
		[
			[120414, 120414],
			"mapped",
			[105]
		],
		[
			[120415, 120415],
			"mapped",
			[106]
		],
		[
			[120416, 120416],
			"mapped",
			[107]
		],
		[
			[120417, 120417],
			"mapped",
			[108]
		],
		[
			[120418, 120418],
			"mapped",
			[109]
		],
		[
			[120419, 120419],
			"mapped",
			[110]
		],
		[
			[120420, 120420],
			"mapped",
			[111]
		],
		[
			[120421, 120421],
			"mapped",
			[112]
		],
		[
			[120422, 120422],
			"mapped",
			[113]
		],
		[
			[120423, 120423],
			"mapped",
			[114]
		],
		[
			[120424, 120424],
			"mapped",
			[115]
		],
		[
			[120425, 120425],
			"mapped",
			[116]
		],
		[
			[120426, 120426],
			"mapped",
			[117]
		],
		[
			[120427, 120427],
			"mapped",
			[118]
		],
		[
			[120428, 120428],
			"mapped",
			[119]
		],
		[
			[120429, 120429],
			"mapped",
			[120]
		],
		[
			[120430, 120430],
			"mapped",
			[121]
		],
		[
			[120431, 120431],
			"mapped",
			[122]
		],
		[
			[120432, 120432],
			"mapped",
			[97]
		],
		[
			[120433, 120433],
			"mapped",
			[98]
		],
		[
			[120434, 120434],
			"mapped",
			[99]
		],
		[
			[120435, 120435],
			"mapped",
			[100]
		],
		[
			[120436, 120436],
			"mapped",
			[101]
		],
		[
			[120437, 120437],
			"mapped",
			[102]
		],
		[
			[120438, 120438],
			"mapped",
			[103]
		],
		[
			[120439, 120439],
			"mapped",
			[104]
		],
		[
			[120440, 120440],
			"mapped",
			[105]
		],
		[
			[120441, 120441],
			"mapped",
			[106]
		],
		[
			[120442, 120442],
			"mapped",
			[107]
		],
		[
			[120443, 120443],
			"mapped",
			[108]
		],
		[
			[120444, 120444],
			"mapped",
			[109]
		],
		[
			[120445, 120445],
			"mapped",
			[110]
		],
		[
			[120446, 120446],
			"mapped",
			[111]
		],
		[
			[120447, 120447],
			"mapped",
			[112]
		],
		[
			[120448, 120448],
			"mapped",
			[113]
		],
		[
			[120449, 120449],
			"mapped",
			[114]
		],
		[
			[120450, 120450],
			"mapped",
			[115]
		],
		[
			[120451, 120451],
			"mapped",
			[116]
		],
		[
			[120452, 120452],
			"mapped",
			[117]
		],
		[
			[120453, 120453],
			"mapped",
			[118]
		],
		[
			[120454, 120454],
			"mapped",
			[119]
		],
		[
			[120455, 120455],
			"mapped",
			[120]
		],
		[
			[120456, 120456],
			"mapped",
			[121]
		],
		[
			[120457, 120457],
			"mapped",
			[122]
		],
		[
			[120458, 120458],
			"mapped",
			[97]
		],
		[
			[120459, 120459],
			"mapped",
			[98]
		],
		[
			[120460, 120460],
			"mapped",
			[99]
		],
		[
			[120461, 120461],
			"mapped",
			[100]
		],
		[
			[120462, 120462],
			"mapped",
			[101]
		],
		[
			[120463, 120463],
			"mapped",
			[102]
		],
		[
			[120464, 120464],
			"mapped",
			[103]
		],
		[
			[120465, 120465],
			"mapped",
			[104]
		],
		[
			[120466, 120466],
			"mapped",
			[105]
		],
		[
			[120467, 120467],
			"mapped",
			[106]
		],
		[
			[120468, 120468],
			"mapped",
			[107]
		],
		[
			[120469, 120469],
			"mapped",
			[108]
		],
		[
			[120470, 120470],
			"mapped",
			[109]
		],
		[
			[120471, 120471],
			"mapped",
			[110]
		],
		[
			[120472, 120472],
			"mapped",
			[111]
		],
		[
			[120473, 120473],
			"mapped",
			[112]
		],
		[
			[120474, 120474],
			"mapped",
			[113]
		],
		[
			[120475, 120475],
			"mapped",
			[114]
		],
		[
			[120476, 120476],
			"mapped",
			[115]
		],
		[
			[120477, 120477],
			"mapped",
			[116]
		],
		[
			[120478, 120478],
			"mapped",
			[117]
		],
		[
			[120479, 120479],
			"mapped",
			[118]
		],
		[
			[120480, 120480],
			"mapped",
			[119]
		],
		[
			[120481, 120481],
			"mapped",
			[120]
		],
		[
			[120482, 120482],
			"mapped",
			[121]
		],
		[
			[120483, 120483],
			"mapped",
			[122]
		],
		[
			[120484, 120484],
			"mapped",
			[305]
		],
		[
			[120485, 120485],
			"mapped",
			[567]
		],
		[[120486, 120487], "disallowed"],
		[
			[120488, 120488],
			"mapped",
			[945]
		],
		[
			[120489, 120489],
			"mapped",
			[946]
		],
		[
			[120490, 120490],
			"mapped",
			[947]
		],
		[
			[120491, 120491],
			"mapped",
			[948]
		],
		[
			[120492, 120492],
			"mapped",
			[949]
		],
		[
			[120493, 120493],
			"mapped",
			[950]
		],
		[
			[120494, 120494],
			"mapped",
			[951]
		],
		[
			[120495, 120495],
			"mapped",
			[952]
		],
		[
			[120496, 120496],
			"mapped",
			[953]
		],
		[
			[120497, 120497],
			"mapped",
			[954]
		],
		[
			[120498, 120498],
			"mapped",
			[955]
		],
		[
			[120499, 120499],
			"mapped",
			[956]
		],
		[
			[120500, 120500],
			"mapped",
			[957]
		],
		[
			[120501, 120501],
			"mapped",
			[958]
		],
		[
			[120502, 120502],
			"mapped",
			[959]
		],
		[
			[120503, 120503],
			"mapped",
			[960]
		],
		[
			[120504, 120504],
			"mapped",
			[961]
		],
		[
			[120505, 120505],
			"mapped",
			[952]
		],
		[
			[120506, 120506],
			"mapped",
			[963]
		],
		[
			[120507, 120507],
			"mapped",
			[964]
		],
		[
			[120508, 120508],
			"mapped",
			[965]
		],
		[
			[120509, 120509],
			"mapped",
			[966]
		],
		[
			[120510, 120510],
			"mapped",
			[967]
		],
		[
			[120511, 120511],
			"mapped",
			[968]
		],
		[
			[120512, 120512],
			"mapped",
			[969]
		],
		[
			[120513, 120513],
			"mapped",
			[8711]
		],
		[
			[120514, 120514],
			"mapped",
			[945]
		],
		[
			[120515, 120515],
			"mapped",
			[946]
		],
		[
			[120516, 120516],
			"mapped",
			[947]
		],
		[
			[120517, 120517],
			"mapped",
			[948]
		],
		[
			[120518, 120518],
			"mapped",
			[949]
		],
		[
			[120519, 120519],
			"mapped",
			[950]
		],
		[
			[120520, 120520],
			"mapped",
			[951]
		],
		[
			[120521, 120521],
			"mapped",
			[952]
		],
		[
			[120522, 120522],
			"mapped",
			[953]
		],
		[
			[120523, 120523],
			"mapped",
			[954]
		],
		[
			[120524, 120524],
			"mapped",
			[955]
		],
		[
			[120525, 120525],
			"mapped",
			[956]
		],
		[
			[120526, 120526],
			"mapped",
			[957]
		],
		[
			[120527, 120527],
			"mapped",
			[958]
		],
		[
			[120528, 120528],
			"mapped",
			[959]
		],
		[
			[120529, 120529],
			"mapped",
			[960]
		],
		[
			[120530, 120530],
			"mapped",
			[961]
		],
		[
			[120531, 120532],
			"mapped",
			[963]
		],
		[
			[120533, 120533],
			"mapped",
			[964]
		],
		[
			[120534, 120534],
			"mapped",
			[965]
		],
		[
			[120535, 120535],
			"mapped",
			[966]
		],
		[
			[120536, 120536],
			"mapped",
			[967]
		],
		[
			[120537, 120537],
			"mapped",
			[968]
		],
		[
			[120538, 120538],
			"mapped",
			[969]
		],
		[
			[120539, 120539],
			"mapped",
			[8706]
		],
		[
			[120540, 120540],
			"mapped",
			[949]
		],
		[
			[120541, 120541],
			"mapped",
			[952]
		],
		[
			[120542, 120542],
			"mapped",
			[954]
		],
		[
			[120543, 120543],
			"mapped",
			[966]
		],
		[
			[120544, 120544],
			"mapped",
			[961]
		],
		[
			[120545, 120545],
			"mapped",
			[960]
		],
		[
			[120546, 120546],
			"mapped",
			[945]
		],
		[
			[120547, 120547],
			"mapped",
			[946]
		],
		[
			[120548, 120548],
			"mapped",
			[947]
		],
		[
			[120549, 120549],
			"mapped",
			[948]
		],
		[
			[120550, 120550],
			"mapped",
			[949]
		],
		[
			[120551, 120551],
			"mapped",
			[950]
		],
		[
			[120552, 120552],
			"mapped",
			[951]
		],
		[
			[120553, 120553],
			"mapped",
			[952]
		],
		[
			[120554, 120554],
			"mapped",
			[953]
		],
		[
			[120555, 120555],
			"mapped",
			[954]
		],
		[
			[120556, 120556],
			"mapped",
			[955]
		],
		[
			[120557, 120557],
			"mapped",
			[956]
		],
		[
			[120558, 120558],
			"mapped",
			[957]
		],
		[
			[120559, 120559],
			"mapped",
			[958]
		],
		[
			[120560, 120560],
			"mapped",
			[959]
		],
		[
			[120561, 120561],
			"mapped",
			[960]
		],
		[
			[120562, 120562],
			"mapped",
			[961]
		],
		[
			[120563, 120563],
			"mapped",
			[952]
		],
		[
			[120564, 120564],
			"mapped",
			[963]
		],
		[
			[120565, 120565],
			"mapped",
			[964]
		],
		[
			[120566, 120566],
			"mapped",
			[965]
		],
		[
			[120567, 120567],
			"mapped",
			[966]
		],
		[
			[120568, 120568],
			"mapped",
			[967]
		],
		[
			[120569, 120569],
			"mapped",
			[968]
		],
		[
			[120570, 120570],
			"mapped",
			[969]
		],
		[
			[120571, 120571],
			"mapped",
			[8711]
		],
		[
			[120572, 120572],
			"mapped",
			[945]
		],
		[
			[120573, 120573],
			"mapped",
			[946]
		],
		[
			[120574, 120574],
			"mapped",
			[947]
		],
		[
			[120575, 120575],
			"mapped",
			[948]
		],
		[
			[120576, 120576],
			"mapped",
			[949]
		],
		[
			[120577, 120577],
			"mapped",
			[950]
		],
		[
			[120578, 120578],
			"mapped",
			[951]
		],
		[
			[120579, 120579],
			"mapped",
			[952]
		],
		[
			[120580, 120580],
			"mapped",
			[953]
		],
		[
			[120581, 120581],
			"mapped",
			[954]
		],
		[
			[120582, 120582],
			"mapped",
			[955]
		],
		[
			[120583, 120583],
			"mapped",
			[956]
		],
		[
			[120584, 120584],
			"mapped",
			[957]
		],
		[
			[120585, 120585],
			"mapped",
			[958]
		],
		[
			[120586, 120586],
			"mapped",
			[959]
		],
		[
			[120587, 120587],
			"mapped",
			[960]
		],
		[
			[120588, 120588],
			"mapped",
			[961]
		],
		[
			[120589, 120590],
			"mapped",
			[963]
		],
		[
			[120591, 120591],
			"mapped",
			[964]
		],
		[
			[120592, 120592],
			"mapped",
			[965]
		],
		[
			[120593, 120593],
			"mapped",
			[966]
		],
		[
			[120594, 120594],
			"mapped",
			[967]
		],
		[
			[120595, 120595],
			"mapped",
			[968]
		],
		[
			[120596, 120596],
			"mapped",
			[969]
		],
		[
			[120597, 120597],
			"mapped",
			[8706]
		],
		[
			[120598, 120598],
			"mapped",
			[949]
		],
		[
			[120599, 120599],
			"mapped",
			[952]
		],
		[
			[120600, 120600],
			"mapped",
			[954]
		],
		[
			[120601, 120601],
			"mapped",
			[966]
		],
		[
			[120602, 120602],
			"mapped",
			[961]
		],
		[
			[120603, 120603],
			"mapped",
			[960]
		],
		[
			[120604, 120604],
			"mapped",
			[945]
		],
		[
			[120605, 120605],
			"mapped",
			[946]
		],
		[
			[120606, 120606],
			"mapped",
			[947]
		],
		[
			[120607, 120607],
			"mapped",
			[948]
		],
		[
			[120608, 120608],
			"mapped",
			[949]
		],
		[
			[120609, 120609],
			"mapped",
			[950]
		],
		[
			[120610, 120610],
			"mapped",
			[951]
		],
		[
			[120611, 120611],
			"mapped",
			[952]
		],
		[
			[120612, 120612],
			"mapped",
			[953]
		],
		[
			[120613, 120613],
			"mapped",
			[954]
		],
		[
			[120614, 120614],
			"mapped",
			[955]
		],
		[
			[120615, 120615],
			"mapped",
			[956]
		],
		[
			[120616, 120616],
			"mapped",
			[957]
		],
		[
			[120617, 120617],
			"mapped",
			[958]
		],
		[
			[120618, 120618],
			"mapped",
			[959]
		],
		[
			[120619, 120619],
			"mapped",
			[960]
		],
		[
			[120620, 120620],
			"mapped",
			[961]
		],
		[
			[120621, 120621],
			"mapped",
			[952]
		],
		[
			[120622, 120622],
			"mapped",
			[963]
		],
		[
			[120623, 120623],
			"mapped",
			[964]
		],
		[
			[120624, 120624],
			"mapped",
			[965]
		],
		[
			[120625, 120625],
			"mapped",
			[966]
		],
		[
			[120626, 120626],
			"mapped",
			[967]
		],
		[
			[120627, 120627],
			"mapped",
			[968]
		],
		[
			[120628, 120628],
			"mapped",
			[969]
		],
		[
			[120629, 120629],
			"mapped",
			[8711]
		],
		[
			[120630, 120630],
			"mapped",
			[945]
		],
		[
			[120631, 120631],
			"mapped",
			[946]
		],
		[
			[120632, 120632],
			"mapped",
			[947]
		],
		[
			[120633, 120633],
			"mapped",
			[948]
		],
		[
			[120634, 120634],
			"mapped",
			[949]
		],
		[
			[120635, 120635],
			"mapped",
			[950]
		],
		[
			[120636, 120636],
			"mapped",
			[951]
		],
		[
			[120637, 120637],
			"mapped",
			[952]
		],
		[
			[120638, 120638],
			"mapped",
			[953]
		],
		[
			[120639, 120639],
			"mapped",
			[954]
		],
		[
			[120640, 120640],
			"mapped",
			[955]
		],
		[
			[120641, 120641],
			"mapped",
			[956]
		],
		[
			[120642, 120642],
			"mapped",
			[957]
		],
		[
			[120643, 120643],
			"mapped",
			[958]
		],
		[
			[120644, 120644],
			"mapped",
			[959]
		],
		[
			[120645, 120645],
			"mapped",
			[960]
		],
		[
			[120646, 120646],
			"mapped",
			[961]
		],
		[
			[120647, 120648],
			"mapped",
			[963]
		],
		[
			[120649, 120649],
			"mapped",
			[964]
		],
		[
			[120650, 120650],
			"mapped",
			[965]
		],
		[
			[120651, 120651],
			"mapped",
			[966]
		],
		[
			[120652, 120652],
			"mapped",
			[967]
		],
		[
			[120653, 120653],
			"mapped",
			[968]
		],
		[
			[120654, 120654],
			"mapped",
			[969]
		],
		[
			[120655, 120655],
			"mapped",
			[8706]
		],
		[
			[120656, 120656],
			"mapped",
			[949]
		],
		[
			[120657, 120657],
			"mapped",
			[952]
		],
		[
			[120658, 120658],
			"mapped",
			[954]
		],
		[
			[120659, 120659],
			"mapped",
			[966]
		],
		[
			[120660, 120660],
			"mapped",
			[961]
		],
		[
			[120661, 120661],
			"mapped",
			[960]
		],
		[
			[120662, 120662],
			"mapped",
			[945]
		],
		[
			[120663, 120663],
			"mapped",
			[946]
		],
		[
			[120664, 120664],
			"mapped",
			[947]
		],
		[
			[120665, 120665],
			"mapped",
			[948]
		],
		[
			[120666, 120666],
			"mapped",
			[949]
		],
		[
			[120667, 120667],
			"mapped",
			[950]
		],
		[
			[120668, 120668],
			"mapped",
			[951]
		],
		[
			[120669, 120669],
			"mapped",
			[952]
		],
		[
			[120670, 120670],
			"mapped",
			[953]
		],
		[
			[120671, 120671],
			"mapped",
			[954]
		],
		[
			[120672, 120672],
			"mapped",
			[955]
		],
		[
			[120673, 120673],
			"mapped",
			[956]
		],
		[
			[120674, 120674],
			"mapped",
			[957]
		],
		[
			[120675, 120675],
			"mapped",
			[958]
		],
		[
			[120676, 120676],
			"mapped",
			[959]
		],
		[
			[120677, 120677],
			"mapped",
			[960]
		],
		[
			[120678, 120678],
			"mapped",
			[961]
		],
		[
			[120679, 120679],
			"mapped",
			[952]
		],
		[
			[120680, 120680],
			"mapped",
			[963]
		],
		[
			[120681, 120681],
			"mapped",
			[964]
		],
		[
			[120682, 120682],
			"mapped",
			[965]
		],
		[
			[120683, 120683],
			"mapped",
			[966]
		],
		[
			[120684, 120684],
			"mapped",
			[967]
		],
		[
			[120685, 120685],
			"mapped",
			[968]
		],
		[
			[120686, 120686],
			"mapped",
			[969]
		],
		[
			[120687, 120687],
			"mapped",
			[8711]
		],
		[
			[120688, 120688],
			"mapped",
			[945]
		],
		[
			[120689, 120689],
			"mapped",
			[946]
		],
		[
			[120690, 120690],
			"mapped",
			[947]
		],
		[
			[120691, 120691],
			"mapped",
			[948]
		],
		[
			[120692, 120692],
			"mapped",
			[949]
		],
		[
			[120693, 120693],
			"mapped",
			[950]
		],
		[
			[120694, 120694],
			"mapped",
			[951]
		],
		[
			[120695, 120695],
			"mapped",
			[952]
		],
		[
			[120696, 120696],
			"mapped",
			[953]
		],
		[
			[120697, 120697],
			"mapped",
			[954]
		],
		[
			[120698, 120698],
			"mapped",
			[955]
		],
		[
			[120699, 120699],
			"mapped",
			[956]
		],
		[
			[120700, 120700],
			"mapped",
			[957]
		],
		[
			[120701, 120701],
			"mapped",
			[958]
		],
		[
			[120702, 120702],
			"mapped",
			[959]
		],
		[
			[120703, 120703],
			"mapped",
			[960]
		],
		[
			[120704, 120704],
			"mapped",
			[961]
		],
		[
			[120705, 120706],
			"mapped",
			[963]
		],
		[
			[120707, 120707],
			"mapped",
			[964]
		],
		[
			[120708, 120708],
			"mapped",
			[965]
		],
		[
			[120709, 120709],
			"mapped",
			[966]
		],
		[
			[120710, 120710],
			"mapped",
			[967]
		],
		[
			[120711, 120711],
			"mapped",
			[968]
		],
		[
			[120712, 120712],
			"mapped",
			[969]
		],
		[
			[120713, 120713],
			"mapped",
			[8706]
		],
		[
			[120714, 120714],
			"mapped",
			[949]
		],
		[
			[120715, 120715],
			"mapped",
			[952]
		],
		[
			[120716, 120716],
			"mapped",
			[954]
		],
		[
			[120717, 120717],
			"mapped",
			[966]
		],
		[
			[120718, 120718],
			"mapped",
			[961]
		],
		[
			[120719, 120719],
			"mapped",
			[960]
		],
		[
			[120720, 120720],
			"mapped",
			[945]
		],
		[
			[120721, 120721],
			"mapped",
			[946]
		],
		[
			[120722, 120722],
			"mapped",
			[947]
		],
		[
			[120723, 120723],
			"mapped",
			[948]
		],
		[
			[120724, 120724],
			"mapped",
			[949]
		],
		[
			[120725, 120725],
			"mapped",
			[950]
		],
		[
			[120726, 120726],
			"mapped",
			[951]
		],
		[
			[120727, 120727],
			"mapped",
			[952]
		],
		[
			[120728, 120728],
			"mapped",
			[953]
		],
		[
			[120729, 120729],
			"mapped",
			[954]
		],
		[
			[120730, 120730],
			"mapped",
			[955]
		],
		[
			[120731, 120731],
			"mapped",
			[956]
		],
		[
			[120732, 120732],
			"mapped",
			[957]
		],
		[
			[120733, 120733],
			"mapped",
			[958]
		],
		[
			[120734, 120734],
			"mapped",
			[959]
		],
		[
			[120735, 120735],
			"mapped",
			[960]
		],
		[
			[120736, 120736],
			"mapped",
			[961]
		],
		[
			[120737, 120737],
			"mapped",
			[952]
		],
		[
			[120738, 120738],
			"mapped",
			[963]
		],
		[
			[120739, 120739],
			"mapped",
			[964]
		],
		[
			[120740, 120740],
			"mapped",
			[965]
		],
		[
			[120741, 120741],
			"mapped",
			[966]
		],
		[
			[120742, 120742],
			"mapped",
			[967]
		],
		[
			[120743, 120743],
			"mapped",
			[968]
		],
		[
			[120744, 120744],
			"mapped",
			[969]
		],
		[
			[120745, 120745],
			"mapped",
			[8711]
		],
		[
			[120746, 120746],
			"mapped",
			[945]
		],
		[
			[120747, 120747],
			"mapped",
			[946]
		],
		[
			[120748, 120748],
			"mapped",
			[947]
		],
		[
			[120749, 120749],
			"mapped",
			[948]
		],
		[
			[120750, 120750],
			"mapped",
			[949]
		],
		[
			[120751, 120751],
			"mapped",
			[950]
		],
		[
			[120752, 120752],
			"mapped",
			[951]
		],
		[
			[120753, 120753],
			"mapped",
			[952]
		],
		[
			[120754, 120754],
			"mapped",
			[953]
		],
		[
			[120755, 120755],
			"mapped",
			[954]
		],
		[
			[120756, 120756],
			"mapped",
			[955]
		],
		[
			[120757, 120757],
			"mapped",
			[956]
		],
		[
			[120758, 120758],
			"mapped",
			[957]
		],
		[
			[120759, 120759],
			"mapped",
			[958]
		],
		[
			[120760, 120760],
			"mapped",
			[959]
		],
		[
			[120761, 120761],
			"mapped",
			[960]
		],
		[
			[120762, 120762],
			"mapped",
			[961]
		],
		[
			[120763, 120764],
			"mapped",
			[963]
		],
		[
			[120765, 120765],
			"mapped",
			[964]
		],
		[
			[120766, 120766],
			"mapped",
			[965]
		],
		[
			[120767, 120767],
			"mapped",
			[966]
		],
		[
			[120768, 120768],
			"mapped",
			[967]
		],
		[
			[120769, 120769],
			"mapped",
			[968]
		],
		[
			[120770, 120770],
			"mapped",
			[969]
		],
		[
			[120771, 120771],
			"mapped",
			[8706]
		],
		[
			[120772, 120772],
			"mapped",
			[949]
		],
		[
			[120773, 120773],
			"mapped",
			[952]
		],
		[
			[120774, 120774],
			"mapped",
			[954]
		],
		[
			[120775, 120775],
			"mapped",
			[966]
		],
		[
			[120776, 120776],
			"mapped",
			[961]
		],
		[
			[120777, 120777],
			"mapped",
			[960]
		],
		[
			[120778, 120779],
			"mapped",
			[989]
		],
		[[120780, 120781], "disallowed"],
		[
			[120782, 120782],
			"mapped",
			[48]
		],
		[
			[120783, 120783],
			"mapped",
			[49]
		],
		[
			[120784, 120784],
			"mapped",
			[50]
		],
		[
			[120785, 120785],
			"mapped",
			[51]
		],
		[
			[120786, 120786],
			"mapped",
			[52]
		],
		[
			[120787, 120787],
			"mapped",
			[53]
		],
		[
			[120788, 120788],
			"mapped",
			[54]
		],
		[
			[120789, 120789],
			"mapped",
			[55]
		],
		[
			[120790, 120790],
			"mapped",
			[56]
		],
		[
			[120791, 120791],
			"mapped",
			[57]
		],
		[
			[120792, 120792],
			"mapped",
			[48]
		],
		[
			[120793, 120793],
			"mapped",
			[49]
		],
		[
			[120794, 120794],
			"mapped",
			[50]
		],
		[
			[120795, 120795],
			"mapped",
			[51]
		],
		[
			[120796, 120796],
			"mapped",
			[52]
		],
		[
			[120797, 120797],
			"mapped",
			[53]
		],
		[
			[120798, 120798],
			"mapped",
			[54]
		],
		[
			[120799, 120799],
			"mapped",
			[55]
		],
		[
			[120800, 120800],
			"mapped",
			[56]
		],
		[
			[120801, 120801],
			"mapped",
			[57]
		],
		[
			[120802, 120802],
			"mapped",
			[48]
		],
		[
			[120803, 120803],
			"mapped",
			[49]
		],
		[
			[120804, 120804],
			"mapped",
			[50]
		],
		[
			[120805, 120805],
			"mapped",
			[51]
		],
		[
			[120806, 120806],
			"mapped",
			[52]
		],
		[
			[120807, 120807],
			"mapped",
			[53]
		],
		[
			[120808, 120808],
			"mapped",
			[54]
		],
		[
			[120809, 120809],
			"mapped",
			[55]
		],
		[
			[120810, 120810],
			"mapped",
			[56]
		],
		[
			[120811, 120811],
			"mapped",
			[57]
		],
		[
			[120812, 120812],
			"mapped",
			[48]
		],
		[
			[120813, 120813],
			"mapped",
			[49]
		],
		[
			[120814, 120814],
			"mapped",
			[50]
		],
		[
			[120815, 120815],
			"mapped",
			[51]
		],
		[
			[120816, 120816],
			"mapped",
			[52]
		],
		[
			[120817, 120817],
			"mapped",
			[53]
		],
		[
			[120818, 120818],
			"mapped",
			[54]
		],
		[
			[120819, 120819],
			"mapped",
			[55]
		],
		[
			[120820, 120820],
			"mapped",
			[56]
		],
		[
			[120821, 120821],
			"mapped",
			[57]
		],
		[
			[120822, 120822],
			"mapped",
			[48]
		],
		[
			[120823, 120823],
			"mapped",
			[49]
		],
		[
			[120824, 120824],
			"mapped",
			[50]
		],
		[
			[120825, 120825],
			"mapped",
			[51]
		],
		[
			[120826, 120826],
			"mapped",
			[52]
		],
		[
			[120827, 120827],
			"mapped",
			[53]
		],
		[
			[120828, 120828],
			"mapped",
			[54]
		],
		[
			[120829, 120829],
			"mapped",
			[55]
		],
		[
			[120830, 120830],
			"mapped",
			[56]
		],
		[
			[120831, 120831],
			"mapped",
			[57]
		],
		[
			[120832, 121343],
			"valid",
			[],
			"NV8"
		],
		[[121344, 121398], "valid"],
		[
			[121399, 121402],
			"valid",
			[],
			"NV8"
		],
		[[121403, 121452], "valid"],
		[
			[121453, 121460],
			"valid",
			[],
			"NV8"
		],
		[[121461, 121461], "valid"],
		[
			[121462, 121475],
			"valid",
			[],
			"NV8"
		],
		[[121476, 121476], "valid"],
		[
			[121477, 121483],
			"valid",
			[],
			"NV8"
		],
		[[121484, 121498], "disallowed"],
		[[121499, 121503], "valid"],
		[[121504, 121504], "disallowed"],
		[[121505, 121519], "valid"],
		[[121520, 124927], "disallowed"],
		[[124928, 125124], "valid"],
		[[125125, 125126], "disallowed"],
		[
			[125127, 125135],
			"valid",
			[],
			"NV8"
		],
		[[125136, 125142], "valid"],
		[[125143, 126463], "disallowed"],
		[
			[126464, 126464],
			"mapped",
			[1575]
		],
		[
			[126465, 126465],
			"mapped",
			[1576]
		],
		[
			[126466, 126466],
			"mapped",
			[1580]
		],
		[
			[126467, 126467],
			"mapped",
			[1583]
		],
		[[126468, 126468], "disallowed"],
		[
			[126469, 126469],
			"mapped",
			[1608]
		],
		[
			[126470, 126470],
			"mapped",
			[1586]
		],
		[
			[126471, 126471],
			"mapped",
			[1581]
		],
		[
			[126472, 126472],
			"mapped",
			[1591]
		],
		[
			[126473, 126473],
			"mapped",
			[1610]
		],
		[
			[126474, 126474],
			"mapped",
			[1603]
		],
		[
			[126475, 126475],
			"mapped",
			[1604]
		],
		[
			[126476, 126476],
			"mapped",
			[1605]
		],
		[
			[126477, 126477],
			"mapped",
			[1606]
		],
		[
			[126478, 126478],
			"mapped",
			[1587]
		],
		[
			[126479, 126479],
			"mapped",
			[1593]
		],
		[
			[126480, 126480],
			"mapped",
			[1601]
		],
		[
			[126481, 126481],
			"mapped",
			[1589]
		],
		[
			[126482, 126482],
			"mapped",
			[1602]
		],
		[
			[126483, 126483],
			"mapped",
			[1585]
		],
		[
			[126484, 126484],
			"mapped",
			[1588]
		],
		[
			[126485, 126485],
			"mapped",
			[1578]
		],
		[
			[126486, 126486],
			"mapped",
			[1579]
		],
		[
			[126487, 126487],
			"mapped",
			[1582]
		],
		[
			[126488, 126488],
			"mapped",
			[1584]
		],
		[
			[126489, 126489],
			"mapped",
			[1590]
		],
		[
			[126490, 126490],
			"mapped",
			[1592]
		],
		[
			[126491, 126491],
			"mapped",
			[1594]
		],
		[
			[126492, 126492],
			"mapped",
			[1646]
		],
		[
			[126493, 126493],
			"mapped",
			[1722]
		],
		[
			[126494, 126494],
			"mapped",
			[1697]
		],
		[
			[126495, 126495],
			"mapped",
			[1647]
		],
		[[126496, 126496], "disallowed"],
		[
			[126497, 126497],
			"mapped",
			[1576]
		],
		[
			[126498, 126498],
			"mapped",
			[1580]
		],
		[[126499, 126499], "disallowed"],
		[
			[126500, 126500],
			"mapped",
			[1607]
		],
		[[126501, 126502], "disallowed"],
		[
			[126503, 126503],
			"mapped",
			[1581]
		],
		[[126504, 126504], "disallowed"],
		[
			[126505, 126505],
			"mapped",
			[1610]
		],
		[
			[126506, 126506],
			"mapped",
			[1603]
		],
		[
			[126507, 126507],
			"mapped",
			[1604]
		],
		[
			[126508, 126508],
			"mapped",
			[1605]
		],
		[
			[126509, 126509],
			"mapped",
			[1606]
		],
		[
			[126510, 126510],
			"mapped",
			[1587]
		],
		[
			[126511, 126511],
			"mapped",
			[1593]
		],
		[
			[126512, 126512],
			"mapped",
			[1601]
		],
		[
			[126513, 126513],
			"mapped",
			[1589]
		],
		[
			[126514, 126514],
			"mapped",
			[1602]
		],
		[[126515, 126515], "disallowed"],
		[
			[126516, 126516],
			"mapped",
			[1588]
		],
		[
			[126517, 126517],
			"mapped",
			[1578]
		],
		[
			[126518, 126518],
			"mapped",
			[1579]
		],
		[
			[126519, 126519],
			"mapped",
			[1582]
		],
		[[126520, 126520], "disallowed"],
		[
			[126521, 126521],
			"mapped",
			[1590]
		],
		[[126522, 126522], "disallowed"],
		[
			[126523, 126523],
			"mapped",
			[1594]
		],
		[[126524, 126529], "disallowed"],
		[
			[126530, 126530],
			"mapped",
			[1580]
		],
		[[126531, 126534], "disallowed"],
		[
			[126535, 126535],
			"mapped",
			[1581]
		],
		[[126536, 126536], "disallowed"],
		[
			[126537, 126537],
			"mapped",
			[1610]
		],
		[[126538, 126538], "disallowed"],
		[
			[126539, 126539],
			"mapped",
			[1604]
		],
		[[126540, 126540], "disallowed"],
		[
			[126541, 126541],
			"mapped",
			[1606]
		],
		[
			[126542, 126542],
			"mapped",
			[1587]
		],
		[
			[126543, 126543],
			"mapped",
			[1593]
		],
		[[126544, 126544], "disallowed"],
		[
			[126545, 126545],
			"mapped",
			[1589]
		],
		[
			[126546, 126546],
			"mapped",
			[1602]
		],
		[[126547, 126547], "disallowed"],
		[
			[126548, 126548],
			"mapped",
			[1588]
		],
		[[126549, 126550], "disallowed"],
		[
			[126551, 126551],
			"mapped",
			[1582]
		],
		[[126552, 126552], "disallowed"],
		[
			[126553, 126553],
			"mapped",
			[1590]
		],
		[[126554, 126554], "disallowed"],
		[
			[126555, 126555],
			"mapped",
			[1594]
		],
		[[126556, 126556], "disallowed"],
		[
			[126557, 126557],
			"mapped",
			[1722]
		],
		[[126558, 126558], "disallowed"],
		[
			[126559, 126559],
			"mapped",
			[1647]
		],
		[[126560, 126560], "disallowed"],
		[
			[126561, 126561],
			"mapped",
			[1576]
		],
		[
			[126562, 126562],
			"mapped",
			[1580]
		],
		[[126563, 126563], "disallowed"],
		[
			[126564, 126564],
			"mapped",
			[1607]
		],
		[[126565, 126566], "disallowed"],
		[
			[126567, 126567],
			"mapped",
			[1581]
		],
		[
			[126568, 126568],
			"mapped",
			[1591]
		],
		[
			[126569, 126569],
			"mapped",
			[1610]
		],
		[
			[126570, 126570],
			"mapped",
			[1603]
		],
		[[126571, 126571], "disallowed"],
		[
			[126572, 126572],
			"mapped",
			[1605]
		],
		[
			[126573, 126573],
			"mapped",
			[1606]
		],
		[
			[126574, 126574],
			"mapped",
			[1587]
		],
		[
			[126575, 126575],
			"mapped",
			[1593]
		],
		[
			[126576, 126576],
			"mapped",
			[1601]
		],
		[
			[126577, 126577],
			"mapped",
			[1589]
		],
		[
			[126578, 126578],
			"mapped",
			[1602]
		],
		[[126579, 126579], "disallowed"],
		[
			[126580, 126580],
			"mapped",
			[1588]
		],
		[
			[126581, 126581],
			"mapped",
			[1578]
		],
		[
			[126582, 126582],
			"mapped",
			[1579]
		],
		[
			[126583, 126583],
			"mapped",
			[1582]
		],
		[[126584, 126584], "disallowed"],
		[
			[126585, 126585],
			"mapped",
			[1590]
		],
		[
			[126586, 126586],
			"mapped",
			[1592]
		],
		[
			[126587, 126587],
			"mapped",
			[1594]
		],
		[
			[126588, 126588],
			"mapped",
			[1646]
		],
		[[126589, 126589], "disallowed"],
		[
			[126590, 126590],
			"mapped",
			[1697]
		],
		[[126591, 126591], "disallowed"],
		[
			[126592, 126592],
			"mapped",
			[1575]
		],
		[
			[126593, 126593],
			"mapped",
			[1576]
		],
		[
			[126594, 126594],
			"mapped",
			[1580]
		],
		[
			[126595, 126595],
			"mapped",
			[1583]
		],
		[
			[126596, 126596],
			"mapped",
			[1607]
		],
		[
			[126597, 126597],
			"mapped",
			[1608]
		],
		[
			[126598, 126598],
			"mapped",
			[1586]
		],
		[
			[126599, 126599],
			"mapped",
			[1581]
		],
		[
			[126600, 126600],
			"mapped",
			[1591]
		],
		[
			[126601, 126601],
			"mapped",
			[1610]
		],
		[[126602, 126602], "disallowed"],
		[
			[126603, 126603],
			"mapped",
			[1604]
		],
		[
			[126604, 126604],
			"mapped",
			[1605]
		],
		[
			[126605, 126605],
			"mapped",
			[1606]
		],
		[
			[126606, 126606],
			"mapped",
			[1587]
		],
		[
			[126607, 126607],
			"mapped",
			[1593]
		],
		[
			[126608, 126608],
			"mapped",
			[1601]
		],
		[
			[126609, 126609],
			"mapped",
			[1589]
		],
		[
			[126610, 126610],
			"mapped",
			[1602]
		],
		[
			[126611, 126611],
			"mapped",
			[1585]
		],
		[
			[126612, 126612],
			"mapped",
			[1588]
		],
		[
			[126613, 126613],
			"mapped",
			[1578]
		],
		[
			[126614, 126614],
			"mapped",
			[1579]
		],
		[
			[126615, 126615],
			"mapped",
			[1582]
		],
		[
			[126616, 126616],
			"mapped",
			[1584]
		],
		[
			[126617, 126617],
			"mapped",
			[1590]
		],
		[
			[126618, 126618],
			"mapped",
			[1592]
		],
		[
			[126619, 126619],
			"mapped",
			[1594]
		],
		[[126620, 126624], "disallowed"],
		[
			[126625, 126625],
			"mapped",
			[1576]
		],
		[
			[126626, 126626],
			"mapped",
			[1580]
		],
		[
			[126627, 126627],
			"mapped",
			[1583]
		],
		[[126628, 126628], "disallowed"],
		[
			[126629, 126629],
			"mapped",
			[1608]
		],
		[
			[126630, 126630],
			"mapped",
			[1586]
		],
		[
			[126631, 126631],
			"mapped",
			[1581]
		],
		[
			[126632, 126632],
			"mapped",
			[1591]
		],
		[
			[126633, 126633],
			"mapped",
			[1610]
		],
		[[126634, 126634], "disallowed"],
		[
			[126635, 126635],
			"mapped",
			[1604]
		],
		[
			[126636, 126636],
			"mapped",
			[1605]
		],
		[
			[126637, 126637],
			"mapped",
			[1606]
		],
		[
			[126638, 126638],
			"mapped",
			[1587]
		],
		[
			[126639, 126639],
			"mapped",
			[1593]
		],
		[
			[126640, 126640],
			"mapped",
			[1601]
		],
		[
			[126641, 126641],
			"mapped",
			[1589]
		],
		[
			[126642, 126642],
			"mapped",
			[1602]
		],
		[
			[126643, 126643],
			"mapped",
			[1585]
		],
		[
			[126644, 126644],
			"mapped",
			[1588]
		],
		[
			[126645, 126645],
			"mapped",
			[1578]
		],
		[
			[126646, 126646],
			"mapped",
			[1579]
		],
		[
			[126647, 126647],
			"mapped",
			[1582]
		],
		[
			[126648, 126648],
			"mapped",
			[1584]
		],
		[
			[126649, 126649],
			"mapped",
			[1590]
		],
		[
			[126650, 126650],
			"mapped",
			[1592]
		],
		[
			[126651, 126651],
			"mapped",
			[1594]
		],
		[[126652, 126703], "disallowed"],
		[
			[126704, 126705],
			"valid",
			[],
			"NV8"
		],
		[[126706, 126975], "disallowed"],
		[
			[126976, 127019],
			"valid",
			[],
			"NV8"
		],
		[[127020, 127023], "disallowed"],
		[
			[127024, 127123],
			"valid",
			[],
			"NV8"
		],
		[[127124, 127135], "disallowed"],
		[
			[127136, 127150],
			"valid",
			[],
			"NV8"
		],
		[[127151, 127152], "disallowed"],
		[
			[127153, 127166],
			"valid",
			[],
			"NV8"
		],
		[
			[127167, 127167],
			"valid",
			[],
			"NV8"
		],
		[[127168, 127168], "disallowed"],
		[
			[127169, 127183],
			"valid",
			[],
			"NV8"
		],
		[[127184, 127184], "disallowed"],
		[
			[127185, 127199],
			"valid",
			[],
			"NV8"
		],
		[
			[127200, 127221],
			"valid",
			[],
			"NV8"
		],
		[[127222, 127231], "disallowed"],
		[[127232, 127232], "disallowed"],
		[
			[127233, 127233],
			"disallowed_STD3_mapped",
			[48, 44]
		],
		[
			[127234, 127234],
			"disallowed_STD3_mapped",
			[49, 44]
		],
		[
			[127235, 127235],
			"disallowed_STD3_mapped",
			[50, 44]
		],
		[
			[127236, 127236],
			"disallowed_STD3_mapped",
			[51, 44]
		],
		[
			[127237, 127237],
			"disallowed_STD3_mapped",
			[52, 44]
		],
		[
			[127238, 127238],
			"disallowed_STD3_mapped",
			[53, 44]
		],
		[
			[127239, 127239],
			"disallowed_STD3_mapped",
			[54, 44]
		],
		[
			[127240, 127240],
			"disallowed_STD3_mapped",
			[55, 44]
		],
		[
			[127241, 127241],
			"disallowed_STD3_mapped",
			[56, 44]
		],
		[
			[127242, 127242],
			"disallowed_STD3_mapped",
			[57, 44]
		],
		[
			[127243, 127244],
			"valid",
			[],
			"NV8"
		],
		[[127245, 127247], "disallowed"],
		[
			[127248, 127248],
			"disallowed_STD3_mapped",
			[
				40,
				97,
				41
			]
		],
		[
			[127249, 127249],
			"disallowed_STD3_mapped",
			[
				40,
				98,
				41
			]
		],
		[
			[127250, 127250],
			"disallowed_STD3_mapped",
			[
				40,
				99,
				41
			]
		],
		[
			[127251, 127251],
			"disallowed_STD3_mapped",
			[
				40,
				100,
				41
			]
		],
		[
			[127252, 127252],
			"disallowed_STD3_mapped",
			[
				40,
				101,
				41
			]
		],
		[
			[127253, 127253],
			"disallowed_STD3_mapped",
			[
				40,
				102,
				41
			]
		],
		[
			[127254, 127254],
			"disallowed_STD3_mapped",
			[
				40,
				103,
				41
			]
		],
		[
			[127255, 127255],
			"disallowed_STD3_mapped",
			[
				40,
				104,
				41
			]
		],
		[
			[127256, 127256],
			"disallowed_STD3_mapped",
			[
				40,
				105,
				41
			]
		],
		[
			[127257, 127257],
			"disallowed_STD3_mapped",
			[
				40,
				106,
				41
			]
		],
		[
			[127258, 127258],
			"disallowed_STD3_mapped",
			[
				40,
				107,
				41
			]
		],
		[
			[127259, 127259],
			"disallowed_STD3_mapped",
			[
				40,
				108,
				41
			]
		],
		[
			[127260, 127260],
			"disallowed_STD3_mapped",
			[
				40,
				109,
				41
			]
		],
		[
			[127261, 127261],
			"disallowed_STD3_mapped",
			[
				40,
				110,
				41
			]
		],
		[
			[127262, 127262],
			"disallowed_STD3_mapped",
			[
				40,
				111,
				41
			]
		],
		[
			[127263, 127263],
			"disallowed_STD3_mapped",
			[
				40,
				112,
				41
			]
		],
		[
			[127264, 127264],
			"disallowed_STD3_mapped",
			[
				40,
				113,
				41
			]
		],
		[
			[127265, 127265],
			"disallowed_STD3_mapped",
			[
				40,
				114,
				41
			]
		],
		[
			[127266, 127266],
			"disallowed_STD3_mapped",
			[
				40,
				115,
				41
			]
		],
		[
			[127267, 127267],
			"disallowed_STD3_mapped",
			[
				40,
				116,
				41
			]
		],
		[
			[127268, 127268],
			"disallowed_STD3_mapped",
			[
				40,
				117,
				41
			]
		],
		[
			[127269, 127269],
			"disallowed_STD3_mapped",
			[
				40,
				118,
				41
			]
		],
		[
			[127270, 127270],
			"disallowed_STD3_mapped",
			[
				40,
				119,
				41
			]
		],
		[
			[127271, 127271],
			"disallowed_STD3_mapped",
			[
				40,
				120,
				41
			]
		],
		[
			[127272, 127272],
			"disallowed_STD3_mapped",
			[
				40,
				121,
				41
			]
		],
		[
			[127273, 127273],
			"disallowed_STD3_mapped",
			[
				40,
				122,
				41
			]
		],
		[
			[127274, 127274],
			"mapped",
			[
				12308,
				115,
				12309
			]
		],
		[
			[127275, 127275],
			"mapped",
			[99]
		],
		[
			[127276, 127276],
			"mapped",
			[114]
		],
		[
			[127277, 127277],
			"mapped",
			[99, 100]
		],
		[
			[127278, 127278],
			"mapped",
			[119, 122]
		],
		[[127279, 127279], "disallowed"],
		[
			[127280, 127280],
			"mapped",
			[97]
		],
		[
			[127281, 127281],
			"mapped",
			[98]
		],
		[
			[127282, 127282],
			"mapped",
			[99]
		],
		[
			[127283, 127283],
			"mapped",
			[100]
		],
		[
			[127284, 127284],
			"mapped",
			[101]
		],
		[
			[127285, 127285],
			"mapped",
			[102]
		],
		[
			[127286, 127286],
			"mapped",
			[103]
		],
		[
			[127287, 127287],
			"mapped",
			[104]
		],
		[
			[127288, 127288],
			"mapped",
			[105]
		],
		[
			[127289, 127289],
			"mapped",
			[106]
		],
		[
			[127290, 127290],
			"mapped",
			[107]
		],
		[
			[127291, 127291],
			"mapped",
			[108]
		],
		[
			[127292, 127292],
			"mapped",
			[109]
		],
		[
			[127293, 127293],
			"mapped",
			[110]
		],
		[
			[127294, 127294],
			"mapped",
			[111]
		],
		[
			[127295, 127295],
			"mapped",
			[112]
		],
		[
			[127296, 127296],
			"mapped",
			[113]
		],
		[
			[127297, 127297],
			"mapped",
			[114]
		],
		[
			[127298, 127298],
			"mapped",
			[115]
		],
		[
			[127299, 127299],
			"mapped",
			[116]
		],
		[
			[127300, 127300],
			"mapped",
			[117]
		],
		[
			[127301, 127301],
			"mapped",
			[118]
		],
		[
			[127302, 127302],
			"mapped",
			[119]
		],
		[
			[127303, 127303],
			"mapped",
			[120]
		],
		[
			[127304, 127304],
			"mapped",
			[121]
		],
		[
			[127305, 127305],
			"mapped",
			[122]
		],
		[
			[127306, 127306],
			"mapped",
			[104, 118]
		],
		[
			[127307, 127307],
			"mapped",
			[109, 118]
		],
		[
			[127308, 127308],
			"mapped",
			[115, 100]
		],
		[
			[127309, 127309],
			"mapped",
			[115, 115]
		],
		[
			[127310, 127310],
			"mapped",
			[
				112,
				112,
				118
			]
		],
		[
			[127311, 127311],
			"mapped",
			[119, 99]
		],
		[
			[127312, 127318],
			"valid",
			[],
			"NV8"
		],
		[
			[127319, 127319],
			"valid",
			[],
			"NV8"
		],
		[
			[127320, 127326],
			"valid",
			[],
			"NV8"
		],
		[
			[127327, 127327],
			"valid",
			[],
			"NV8"
		],
		[
			[127328, 127337],
			"valid",
			[],
			"NV8"
		],
		[
			[127338, 127338],
			"mapped",
			[109, 99]
		],
		[
			[127339, 127339],
			"mapped",
			[109, 100]
		],
		[[127340, 127343], "disallowed"],
		[
			[127344, 127352],
			"valid",
			[],
			"NV8"
		],
		[
			[127353, 127353],
			"valid",
			[],
			"NV8"
		],
		[
			[127354, 127354],
			"valid",
			[],
			"NV8"
		],
		[
			[127355, 127356],
			"valid",
			[],
			"NV8"
		],
		[
			[127357, 127358],
			"valid",
			[],
			"NV8"
		],
		[
			[127359, 127359],
			"valid",
			[],
			"NV8"
		],
		[
			[127360, 127369],
			"valid",
			[],
			"NV8"
		],
		[
			[127370, 127373],
			"valid",
			[],
			"NV8"
		],
		[
			[127374, 127375],
			"valid",
			[],
			"NV8"
		],
		[
			[127376, 127376],
			"mapped",
			[100, 106]
		],
		[
			[127377, 127386],
			"valid",
			[],
			"NV8"
		],
		[[127387, 127461], "disallowed"],
		[
			[127462, 127487],
			"valid",
			[],
			"NV8"
		],
		[
			[127488, 127488],
			"mapped",
			[12411, 12363]
		],
		[
			[127489, 127489],
			"mapped",
			[12467, 12467]
		],
		[
			[127490, 127490],
			"mapped",
			[12469]
		],
		[[127491, 127503], "disallowed"],
		[
			[127504, 127504],
			"mapped",
			[25163]
		],
		[
			[127505, 127505],
			"mapped",
			[23383]
		],
		[
			[127506, 127506],
			"mapped",
			[21452]
		],
		[
			[127507, 127507],
			"mapped",
			[12487]
		],
		[
			[127508, 127508],
			"mapped",
			[20108]
		],
		[
			[127509, 127509],
			"mapped",
			[22810]
		],
		[
			[127510, 127510],
			"mapped",
			[35299]
		],
		[
			[127511, 127511],
			"mapped",
			[22825]
		],
		[
			[127512, 127512],
			"mapped",
			[20132]
		],
		[
			[127513, 127513],
			"mapped",
			[26144]
		],
		[
			[127514, 127514],
			"mapped",
			[28961]
		],
		[
			[127515, 127515],
			"mapped",
			[26009]
		],
		[
			[127516, 127516],
			"mapped",
			[21069]
		],
		[
			[127517, 127517],
			"mapped",
			[24460]
		],
		[
			[127518, 127518],
			"mapped",
			[20877]
		],
		[
			[127519, 127519],
			"mapped",
			[26032]
		],
		[
			[127520, 127520],
			"mapped",
			[21021]
		],
		[
			[127521, 127521],
			"mapped",
			[32066]
		],
		[
			[127522, 127522],
			"mapped",
			[29983]
		],
		[
			[127523, 127523],
			"mapped",
			[36009]
		],
		[
			[127524, 127524],
			"mapped",
			[22768]
		],
		[
			[127525, 127525],
			"mapped",
			[21561]
		],
		[
			[127526, 127526],
			"mapped",
			[28436]
		],
		[
			[127527, 127527],
			"mapped",
			[25237]
		],
		[
			[127528, 127528],
			"mapped",
			[25429]
		],
		[
			[127529, 127529],
			"mapped",
			[19968]
		],
		[
			[127530, 127530],
			"mapped",
			[19977]
		],
		[
			[127531, 127531],
			"mapped",
			[36938]
		],
		[
			[127532, 127532],
			"mapped",
			[24038]
		],
		[
			[127533, 127533],
			"mapped",
			[20013]
		],
		[
			[127534, 127534],
			"mapped",
			[21491]
		],
		[
			[127535, 127535],
			"mapped",
			[25351]
		],
		[
			[127536, 127536],
			"mapped",
			[36208]
		],
		[
			[127537, 127537],
			"mapped",
			[25171]
		],
		[
			[127538, 127538],
			"mapped",
			[31105]
		],
		[
			[127539, 127539],
			"mapped",
			[31354]
		],
		[
			[127540, 127540],
			"mapped",
			[21512]
		],
		[
			[127541, 127541],
			"mapped",
			[28288]
		],
		[
			[127542, 127542],
			"mapped",
			[26377]
		],
		[
			[127543, 127543],
			"mapped",
			[26376]
		],
		[
			[127544, 127544],
			"mapped",
			[30003]
		],
		[
			[127545, 127545],
			"mapped",
			[21106]
		],
		[
			[127546, 127546],
			"mapped",
			[21942]
		],
		[[127547, 127551], "disallowed"],
		[
			[127552, 127552],
			"mapped",
			[
				12308,
				26412,
				12309
			]
		],
		[
			[127553, 127553],
			"mapped",
			[
				12308,
				19977,
				12309
			]
		],
		[
			[127554, 127554],
			"mapped",
			[
				12308,
				20108,
				12309
			]
		],
		[
			[127555, 127555],
			"mapped",
			[
				12308,
				23433,
				12309
			]
		],
		[
			[127556, 127556],
			"mapped",
			[
				12308,
				28857,
				12309
			]
		],
		[
			[127557, 127557],
			"mapped",
			[
				12308,
				25171,
				12309
			]
		],
		[
			[127558, 127558],
			"mapped",
			[
				12308,
				30423,
				12309
			]
		],
		[
			[127559, 127559],
			"mapped",
			[
				12308,
				21213,
				12309
			]
		],
		[
			[127560, 127560],
			"mapped",
			[
				12308,
				25943,
				12309
			]
		],
		[[127561, 127567], "disallowed"],
		[
			[127568, 127568],
			"mapped",
			[24471]
		],
		[
			[127569, 127569],
			"mapped",
			[21487]
		],
		[[127570, 127743], "disallowed"],
		[
			[127744, 127776],
			"valid",
			[],
			"NV8"
		],
		[
			[127777, 127788],
			"valid",
			[],
			"NV8"
		],
		[
			[127789, 127791],
			"valid",
			[],
			"NV8"
		],
		[
			[127792, 127797],
			"valid",
			[],
			"NV8"
		],
		[
			[127798, 127798],
			"valid",
			[],
			"NV8"
		],
		[
			[127799, 127868],
			"valid",
			[],
			"NV8"
		],
		[
			[127869, 127869],
			"valid",
			[],
			"NV8"
		],
		[
			[127870, 127871],
			"valid",
			[],
			"NV8"
		],
		[
			[127872, 127891],
			"valid",
			[],
			"NV8"
		],
		[
			[127892, 127903],
			"valid",
			[],
			"NV8"
		],
		[
			[127904, 127940],
			"valid",
			[],
			"NV8"
		],
		[
			[127941, 127941],
			"valid",
			[],
			"NV8"
		],
		[
			[127942, 127946],
			"valid",
			[],
			"NV8"
		],
		[
			[127947, 127950],
			"valid",
			[],
			"NV8"
		],
		[
			[127951, 127955],
			"valid",
			[],
			"NV8"
		],
		[
			[127956, 127967],
			"valid",
			[],
			"NV8"
		],
		[
			[127968, 127984],
			"valid",
			[],
			"NV8"
		],
		[
			[127985, 127991],
			"valid",
			[],
			"NV8"
		],
		[
			[127992, 127999],
			"valid",
			[],
			"NV8"
		],
		[
			[128e3, 128062],
			"valid",
			[],
			"NV8"
		],
		[
			[128063, 128063],
			"valid",
			[],
			"NV8"
		],
		[
			[128064, 128064],
			"valid",
			[],
			"NV8"
		],
		[
			[128065, 128065],
			"valid",
			[],
			"NV8"
		],
		[
			[128066, 128247],
			"valid",
			[],
			"NV8"
		],
		[
			[128248, 128248],
			"valid",
			[],
			"NV8"
		],
		[
			[128249, 128252],
			"valid",
			[],
			"NV8"
		],
		[
			[128253, 128254],
			"valid",
			[],
			"NV8"
		],
		[
			[128255, 128255],
			"valid",
			[],
			"NV8"
		],
		[
			[128256, 128317],
			"valid",
			[],
			"NV8"
		],
		[
			[128318, 128319],
			"valid",
			[],
			"NV8"
		],
		[
			[128320, 128323],
			"valid",
			[],
			"NV8"
		],
		[
			[128324, 128330],
			"valid",
			[],
			"NV8"
		],
		[
			[128331, 128335],
			"valid",
			[],
			"NV8"
		],
		[
			[128336, 128359],
			"valid",
			[],
			"NV8"
		],
		[
			[128360, 128377],
			"valid",
			[],
			"NV8"
		],
		[[128378, 128378], "disallowed"],
		[
			[128379, 128419],
			"valid",
			[],
			"NV8"
		],
		[[128420, 128420], "disallowed"],
		[
			[128421, 128506],
			"valid",
			[],
			"NV8"
		],
		[
			[128507, 128511],
			"valid",
			[],
			"NV8"
		],
		[
			[128512, 128512],
			"valid",
			[],
			"NV8"
		],
		[
			[128513, 128528],
			"valid",
			[],
			"NV8"
		],
		[
			[128529, 128529],
			"valid",
			[],
			"NV8"
		],
		[
			[128530, 128532],
			"valid",
			[],
			"NV8"
		],
		[
			[128533, 128533],
			"valid",
			[],
			"NV8"
		],
		[
			[128534, 128534],
			"valid",
			[],
			"NV8"
		],
		[
			[128535, 128535],
			"valid",
			[],
			"NV8"
		],
		[
			[128536, 128536],
			"valid",
			[],
			"NV8"
		],
		[
			[128537, 128537],
			"valid",
			[],
			"NV8"
		],
		[
			[128538, 128538],
			"valid",
			[],
			"NV8"
		],
		[
			[128539, 128539],
			"valid",
			[],
			"NV8"
		],
		[
			[128540, 128542],
			"valid",
			[],
			"NV8"
		],
		[
			[128543, 128543],
			"valid",
			[],
			"NV8"
		],
		[
			[128544, 128549],
			"valid",
			[],
			"NV8"
		],
		[
			[128550, 128551],
			"valid",
			[],
			"NV8"
		],
		[
			[128552, 128555],
			"valid",
			[],
			"NV8"
		],
		[
			[128556, 128556],
			"valid",
			[],
			"NV8"
		],
		[
			[128557, 128557],
			"valid",
			[],
			"NV8"
		],
		[
			[128558, 128559],
			"valid",
			[],
			"NV8"
		],
		[
			[128560, 128563],
			"valid",
			[],
			"NV8"
		],
		[
			[128564, 128564],
			"valid",
			[],
			"NV8"
		],
		[
			[128565, 128576],
			"valid",
			[],
			"NV8"
		],
		[
			[128577, 128578],
			"valid",
			[],
			"NV8"
		],
		[
			[128579, 128580],
			"valid",
			[],
			"NV8"
		],
		[
			[128581, 128591],
			"valid",
			[],
			"NV8"
		],
		[
			[128592, 128639],
			"valid",
			[],
			"NV8"
		],
		[
			[128640, 128709],
			"valid",
			[],
			"NV8"
		],
		[
			[128710, 128719],
			"valid",
			[],
			"NV8"
		],
		[
			[128720, 128720],
			"valid",
			[],
			"NV8"
		],
		[[128721, 128735], "disallowed"],
		[
			[128736, 128748],
			"valid",
			[],
			"NV8"
		],
		[[128749, 128751], "disallowed"],
		[
			[128752, 128755],
			"valid",
			[],
			"NV8"
		],
		[[128756, 128767], "disallowed"],
		[
			[128768, 128883],
			"valid",
			[],
			"NV8"
		],
		[[128884, 128895], "disallowed"],
		[
			[128896, 128980],
			"valid",
			[],
			"NV8"
		],
		[[128981, 129023], "disallowed"],
		[
			[129024, 129035],
			"valid",
			[],
			"NV8"
		],
		[[129036, 129039], "disallowed"],
		[
			[129040, 129095],
			"valid",
			[],
			"NV8"
		],
		[[129096, 129103], "disallowed"],
		[
			[129104, 129113],
			"valid",
			[],
			"NV8"
		],
		[[129114, 129119], "disallowed"],
		[
			[129120, 129159],
			"valid",
			[],
			"NV8"
		],
		[[129160, 129167], "disallowed"],
		[
			[129168, 129197],
			"valid",
			[],
			"NV8"
		],
		[[129198, 129295], "disallowed"],
		[
			[129296, 129304],
			"valid",
			[],
			"NV8"
		],
		[[129305, 129407], "disallowed"],
		[
			[129408, 129412],
			"valid",
			[],
			"NV8"
		],
		[[129413, 129471], "disallowed"],
		[
			[129472, 129472],
			"valid",
			[],
			"NV8"
		],
		[[129473, 131069], "disallowed"],
		[[131070, 131071], "disallowed"],
		[[131072, 173782], "valid"],
		[[173783, 173823], "disallowed"],
		[[173824, 177972], "valid"],
		[[177973, 177983], "disallowed"],
		[[177984, 178205], "valid"],
		[[178206, 178207], "disallowed"],
		[[178208, 183969], "valid"],
		[[183970, 194559], "disallowed"],
		[
			[194560, 194560],
			"mapped",
			[20029]
		],
		[
			[194561, 194561],
			"mapped",
			[20024]
		],
		[
			[194562, 194562],
			"mapped",
			[20033]
		],
		[
			[194563, 194563],
			"mapped",
			[131362]
		],
		[
			[194564, 194564],
			"mapped",
			[20320]
		],
		[
			[194565, 194565],
			"mapped",
			[20398]
		],
		[
			[194566, 194566],
			"mapped",
			[20411]
		],
		[
			[194567, 194567],
			"mapped",
			[20482]
		],
		[
			[194568, 194568],
			"mapped",
			[20602]
		],
		[
			[194569, 194569],
			"mapped",
			[20633]
		],
		[
			[194570, 194570],
			"mapped",
			[20711]
		],
		[
			[194571, 194571],
			"mapped",
			[20687]
		],
		[
			[194572, 194572],
			"mapped",
			[13470]
		],
		[
			[194573, 194573],
			"mapped",
			[132666]
		],
		[
			[194574, 194574],
			"mapped",
			[20813]
		],
		[
			[194575, 194575],
			"mapped",
			[20820]
		],
		[
			[194576, 194576],
			"mapped",
			[20836]
		],
		[
			[194577, 194577],
			"mapped",
			[20855]
		],
		[
			[194578, 194578],
			"mapped",
			[132380]
		],
		[
			[194579, 194579],
			"mapped",
			[13497]
		],
		[
			[194580, 194580],
			"mapped",
			[20839]
		],
		[
			[194581, 194581],
			"mapped",
			[20877]
		],
		[
			[194582, 194582],
			"mapped",
			[132427]
		],
		[
			[194583, 194583],
			"mapped",
			[20887]
		],
		[
			[194584, 194584],
			"mapped",
			[20900]
		],
		[
			[194585, 194585],
			"mapped",
			[20172]
		],
		[
			[194586, 194586],
			"mapped",
			[20908]
		],
		[
			[194587, 194587],
			"mapped",
			[20917]
		],
		[
			[194588, 194588],
			"mapped",
			[168415]
		],
		[
			[194589, 194589],
			"mapped",
			[20981]
		],
		[
			[194590, 194590],
			"mapped",
			[20995]
		],
		[
			[194591, 194591],
			"mapped",
			[13535]
		],
		[
			[194592, 194592],
			"mapped",
			[21051]
		],
		[
			[194593, 194593],
			"mapped",
			[21062]
		],
		[
			[194594, 194594],
			"mapped",
			[21106]
		],
		[
			[194595, 194595],
			"mapped",
			[21111]
		],
		[
			[194596, 194596],
			"mapped",
			[13589]
		],
		[
			[194597, 194597],
			"mapped",
			[21191]
		],
		[
			[194598, 194598],
			"mapped",
			[21193]
		],
		[
			[194599, 194599],
			"mapped",
			[21220]
		],
		[
			[194600, 194600],
			"mapped",
			[21242]
		],
		[
			[194601, 194601],
			"mapped",
			[21253]
		],
		[
			[194602, 194602],
			"mapped",
			[21254]
		],
		[
			[194603, 194603],
			"mapped",
			[21271]
		],
		[
			[194604, 194604],
			"mapped",
			[21321]
		],
		[
			[194605, 194605],
			"mapped",
			[21329]
		],
		[
			[194606, 194606],
			"mapped",
			[21338]
		],
		[
			[194607, 194607],
			"mapped",
			[21363]
		],
		[
			[194608, 194608],
			"mapped",
			[21373]
		],
		[
			[194609, 194611],
			"mapped",
			[21375]
		],
		[
			[194612, 194612],
			"mapped",
			[133676]
		],
		[
			[194613, 194613],
			"mapped",
			[28784]
		],
		[
			[194614, 194614],
			"mapped",
			[21450]
		],
		[
			[194615, 194615],
			"mapped",
			[21471]
		],
		[
			[194616, 194616],
			"mapped",
			[133987]
		],
		[
			[194617, 194617],
			"mapped",
			[21483]
		],
		[
			[194618, 194618],
			"mapped",
			[21489]
		],
		[
			[194619, 194619],
			"mapped",
			[21510]
		],
		[
			[194620, 194620],
			"mapped",
			[21662]
		],
		[
			[194621, 194621],
			"mapped",
			[21560]
		],
		[
			[194622, 194622],
			"mapped",
			[21576]
		],
		[
			[194623, 194623],
			"mapped",
			[21608]
		],
		[
			[194624, 194624],
			"mapped",
			[21666]
		],
		[
			[194625, 194625],
			"mapped",
			[21750]
		],
		[
			[194626, 194626],
			"mapped",
			[21776]
		],
		[
			[194627, 194627],
			"mapped",
			[21843]
		],
		[
			[194628, 194628],
			"mapped",
			[21859]
		],
		[
			[194629, 194630],
			"mapped",
			[21892]
		],
		[
			[194631, 194631],
			"mapped",
			[21913]
		],
		[
			[194632, 194632],
			"mapped",
			[21931]
		],
		[
			[194633, 194633],
			"mapped",
			[21939]
		],
		[
			[194634, 194634],
			"mapped",
			[21954]
		],
		[
			[194635, 194635],
			"mapped",
			[22294]
		],
		[
			[194636, 194636],
			"mapped",
			[22022]
		],
		[
			[194637, 194637],
			"mapped",
			[22295]
		],
		[
			[194638, 194638],
			"mapped",
			[22097]
		],
		[
			[194639, 194639],
			"mapped",
			[22132]
		],
		[
			[194640, 194640],
			"mapped",
			[20999]
		],
		[
			[194641, 194641],
			"mapped",
			[22766]
		],
		[
			[194642, 194642],
			"mapped",
			[22478]
		],
		[
			[194643, 194643],
			"mapped",
			[22516]
		],
		[
			[194644, 194644],
			"mapped",
			[22541]
		],
		[
			[194645, 194645],
			"mapped",
			[22411]
		],
		[
			[194646, 194646],
			"mapped",
			[22578]
		],
		[
			[194647, 194647],
			"mapped",
			[22577]
		],
		[
			[194648, 194648],
			"mapped",
			[22700]
		],
		[
			[194649, 194649],
			"mapped",
			[136420]
		],
		[
			[194650, 194650],
			"mapped",
			[22770]
		],
		[
			[194651, 194651],
			"mapped",
			[22775]
		],
		[
			[194652, 194652],
			"mapped",
			[22790]
		],
		[
			[194653, 194653],
			"mapped",
			[22810]
		],
		[
			[194654, 194654],
			"mapped",
			[22818]
		],
		[
			[194655, 194655],
			"mapped",
			[22882]
		],
		[
			[194656, 194656],
			"mapped",
			[136872]
		],
		[
			[194657, 194657],
			"mapped",
			[136938]
		],
		[
			[194658, 194658],
			"mapped",
			[23020]
		],
		[
			[194659, 194659],
			"mapped",
			[23067]
		],
		[
			[194660, 194660],
			"mapped",
			[23079]
		],
		[
			[194661, 194661],
			"mapped",
			[23e3]
		],
		[
			[194662, 194662],
			"mapped",
			[23142]
		],
		[
			[194663, 194663],
			"mapped",
			[14062]
		],
		[[194664, 194664], "disallowed"],
		[
			[194665, 194665],
			"mapped",
			[23304]
		],
		[
			[194666, 194667],
			"mapped",
			[23358]
		],
		[
			[194668, 194668],
			"mapped",
			[137672]
		],
		[
			[194669, 194669],
			"mapped",
			[23491]
		],
		[
			[194670, 194670],
			"mapped",
			[23512]
		],
		[
			[194671, 194671],
			"mapped",
			[23527]
		],
		[
			[194672, 194672],
			"mapped",
			[23539]
		],
		[
			[194673, 194673],
			"mapped",
			[138008]
		],
		[
			[194674, 194674],
			"mapped",
			[23551]
		],
		[
			[194675, 194675],
			"mapped",
			[23558]
		],
		[[194676, 194676], "disallowed"],
		[
			[194677, 194677],
			"mapped",
			[23586]
		],
		[
			[194678, 194678],
			"mapped",
			[14209]
		],
		[
			[194679, 194679],
			"mapped",
			[23648]
		],
		[
			[194680, 194680],
			"mapped",
			[23662]
		],
		[
			[194681, 194681],
			"mapped",
			[23744]
		],
		[
			[194682, 194682],
			"mapped",
			[23693]
		],
		[
			[194683, 194683],
			"mapped",
			[138724]
		],
		[
			[194684, 194684],
			"mapped",
			[23875]
		],
		[
			[194685, 194685],
			"mapped",
			[138726]
		],
		[
			[194686, 194686],
			"mapped",
			[23918]
		],
		[
			[194687, 194687],
			"mapped",
			[23915]
		],
		[
			[194688, 194688],
			"mapped",
			[23932]
		],
		[
			[194689, 194689],
			"mapped",
			[24033]
		],
		[
			[194690, 194690],
			"mapped",
			[24034]
		],
		[
			[194691, 194691],
			"mapped",
			[14383]
		],
		[
			[194692, 194692],
			"mapped",
			[24061]
		],
		[
			[194693, 194693],
			"mapped",
			[24104]
		],
		[
			[194694, 194694],
			"mapped",
			[24125]
		],
		[
			[194695, 194695],
			"mapped",
			[24169]
		],
		[
			[194696, 194696],
			"mapped",
			[14434]
		],
		[
			[194697, 194697],
			"mapped",
			[139651]
		],
		[
			[194698, 194698],
			"mapped",
			[14460]
		],
		[
			[194699, 194699],
			"mapped",
			[24240]
		],
		[
			[194700, 194700],
			"mapped",
			[24243]
		],
		[
			[194701, 194701],
			"mapped",
			[24246]
		],
		[
			[194702, 194702],
			"mapped",
			[24266]
		],
		[
			[194703, 194703],
			"mapped",
			[172946]
		],
		[
			[194704, 194704],
			"mapped",
			[24318]
		],
		[
			[194705, 194706],
			"mapped",
			[140081]
		],
		[
			[194707, 194707],
			"mapped",
			[33281]
		],
		[
			[194708, 194709],
			"mapped",
			[24354]
		],
		[
			[194710, 194710],
			"mapped",
			[14535]
		],
		[
			[194711, 194711],
			"mapped",
			[144056]
		],
		[
			[194712, 194712],
			"mapped",
			[156122]
		],
		[
			[194713, 194713],
			"mapped",
			[24418]
		],
		[
			[194714, 194714],
			"mapped",
			[24427]
		],
		[
			[194715, 194715],
			"mapped",
			[14563]
		],
		[
			[194716, 194716],
			"mapped",
			[24474]
		],
		[
			[194717, 194717],
			"mapped",
			[24525]
		],
		[
			[194718, 194718],
			"mapped",
			[24535]
		],
		[
			[194719, 194719],
			"mapped",
			[24569]
		],
		[
			[194720, 194720],
			"mapped",
			[24705]
		],
		[
			[194721, 194721],
			"mapped",
			[14650]
		],
		[
			[194722, 194722],
			"mapped",
			[14620]
		],
		[
			[194723, 194723],
			"mapped",
			[24724]
		],
		[
			[194724, 194724],
			"mapped",
			[141012]
		],
		[
			[194725, 194725],
			"mapped",
			[24775]
		],
		[
			[194726, 194726],
			"mapped",
			[24904]
		],
		[
			[194727, 194727],
			"mapped",
			[24908]
		],
		[
			[194728, 194728],
			"mapped",
			[24910]
		],
		[
			[194729, 194729],
			"mapped",
			[24908]
		],
		[
			[194730, 194730],
			"mapped",
			[24954]
		],
		[
			[194731, 194731],
			"mapped",
			[24974]
		],
		[
			[194732, 194732],
			"mapped",
			[25010]
		],
		[
			[194733, 194733],
			"mapped",
			[24996]
		],
		[
			[194734, 194734],
			"mapped",
			[25007]
		],
		[
			[194735, 194735],
			"mapped",
			[25054]
		],
		[
			[194736, 194736],
			"mapped",
			[25074]
		],
		[
			[194737, 194737],
			"mapped",
			[25078]
		],
		[
			[194738, 194738],
			"mapped",
			[25104]
		],
		[
			[194739, 194739],
			"mapped",
			[25115]
		],
		[
			[194740, 194740],
			"mapped",
			[25181]
		],
		[
			[194741, 194741],
			"mapped",
			[25265]
		],
		[
			[194742, 194742],
			"mapped",
			[25300]
		],
		[
			[194743, 194743],
			"mapped",
			[25424]
		],
		[
			[194744, 194744],
			"mapped",
			[142092]
		],
		[
			[194745, 194745],
			"mapped",
			[25405]
		],
		[
			[194746, 194746],
			"mapped",
			[25340]
		],
		[
			[194747, 194747],
			"mapped",
			[25448]
		],
		[
			[194748, 194748],
			"mapped",
			[25475]
		],
		[
			[194749, 194749],
			"mapped",
			[25572]
		],
		[
			[194750, 194750],
			"mapped",
			[142321]
		],
		[
			[194751, 194751],
			"mapped",
			[25634]
		],
		[
			[194752, 194752],
			"mapped",
			[25541]
		],
		[
			[194753, 194753],
			"mapped",
			[25513]
		],
		[
			[194754, 194754],
			"mapped",
			[14894]
		],
		[
			[194755, 194755],
			"mapped",
			[25705]
		],
		[
			[194756, 194756],
			"mapped",
			[25726]
		],
		[
			[194757, 194757],
			"mapped",
			[25757]
		],
		[
			[194758, 194758],
			"mapped",
			[25719]
		],
		[
			[194759, 194759],
			"mapped",
			[14956]
		],
		[
			[194760, 194760],
			"mapped",
			[25935]
		],
		[
			[194761, 194761],
			"mapped",
			[25964]
		],
		[
			[194762, 194762],
			"mapped",
			[143370]
		],
		[
			[194763, 194763],
			"mapped",
			[26083]
		],
		[
			[194764, 194764],
			"mapped",
			[26360]
		],
		[
			[194765, 194765],
			"mapped",
			[26185]
		],
		[
			[194766, 194766],
			"mapped",
			[15129]
		],
		[
			[194767, 194767],
			"mapped",
			[26257]
		],
		[
			[194768, 194768],
			"mapped",
			[15112]
		],
		[
			[194769, 194769],
			"mapped",
			[15076]
		],
		[
			[194770, 194770],
			"mapped",
			[20882]
		],
		[
			[194771, 194771],
			"mapped",
			[20885]
		],
		[
			[194772, 194772],
			"mapped",
			[26368]
		],
		[
			[194773, 194773],
			"mapped",
			[26268]
		],
		[
			[194774, 194774],
			"mapped",
			[32941]
		],
		[
			[194775, 194775],
			"mapped",
			[17369]
		],
		[
			[194776, 194776],
			"mapped",
			[26391]
		],
		[
			[194777, 194777],
			"mapped",
			[26395]
		],
		[
			[194778, 194778],
			"mapped",
			[26401]
		],
		[
			[194779, 194779],
			"mapped",
			[26462]
		],
		[
			[194780, 194780],
			"mapped",
			[26451]
		],
		[
			[194781, 194781],
			"mapped",
			[144323]
		],
		[
			[194782, 194782],
			"mapped",
			[15177]
		],
		[
			[194783, 194783],
			"mapped",
			[26618]
		],
		[
			[194784, 194784],
			"mapped",
			[26501]
		],
		[
			[194785, 194785],
			"mapped",
			[26706]
		],
		[
			[194786, 194786],
			"mapped",
			[26757]
		],
		[
			[194787, 194787],
			"mapped",
			[144493]
		],
		[
			[194788, 194788],
			"mapped",
			[26766]
		],
		[
			[194789, 194789],
			"mapped",
			[26655]
		],
		[
			[194790, 194790],
			"mapped",
			[26900]
		],
		[
			[194791, 194791],
			"mapped",
			[15261]
		],
		[
			[194792, 194792],
			"mapped",
			[26946]
		],
		[
			[194793, 194793],
			"mapped",
			[27043]
		],
		[
			[194794, 194794],
			"mapped",
			[27114]
		],
		[
			[194795, 194795],
			"mapped",
			[27304]
		],
		[
			[194796, 194796],
			"mapped",
			[145059]
		],
		[
			[194797, 194797],
			"mapped",
			[27355]
		],
		[
			[194798, 194798],
			"mapped",
			[15384]
		],
		[
			[194799, 194799],
			"mapped",
			[27425]
		],
		[
			[194800, 194800],
			"mapped",
			[145575]
		],
		[
			[194801, 194801],
			"mapped",
			[27476]
		],
		[
			[194802, 194802],
			"mapped",
			[15438]
		],
		[
			[194803, 194803],
			"mapped",
			[27506]
		],
		[
			[194804, 194804],
			"mapped",
			[27551]
		],
		[
			[194805, 194805],
			"mapped",
			[27578]
		],
		[
			[194806, 194806],
			"mapped",
			[27579]
		],
		[
			[194807, 194807],
			"mapped",
			[146061]
		],
		[
			[194808, 194808],
			"mapped",
			[138507]
		],
		[
			[194809, 194809],
			"mapped",
			[146170]
		],
		[
			[194810, 194810],
			"mapped",
			[27726]
		],
		[
			[194811, 194811],
			"mapped",
			[146620]
		],
		[
			[194812, 194812],
			"mapped",
			[27839]
		],
		[
			[194813, 194813],
			"mapped",
			[27853]
		],
		[
			[194814, 194814],
			"mapped",
			[27751]
		],
		[
			[194815, 194815],
			"mapped",
			[27926]
		],
		[
			[194816, 194816],
			"mapped",
			[27966]
		],
		[
			[194817, 194817],
			"mapped",
			[28023]
		],
		[
			[194818, 194818],
			"mapped",
			[27969]
		],
		[
			[194819, 194819],
			"mapped",
			[28009]
		],
		[
			[194820, 194820],
			"mapped",
			[28024]
		],
		[
			[194821, 194821],
			"mapped",
			[28037]
		],
		[
			[194822, 194822],
			"mapped",
			[146718]
		],
		[
			[194823, 194823],
			"mapped",
			[27956]
		],
		[
			[194824, 194824],
			"mapped",
			[28207]
		],
		[
			[194825, 194825],
			"mapped",
			[28270]
		],
		[
			[194826, 194826],
			"mapped",
			[15667]
		],
		[
			[194827, 194827],
			"mapped",
			[28363]
		],
		[
			[194828, 194828],
			"mapped",
			[28359]
		],
		[
			[194829, 194829],
			"mapped",
			[147153]
		],
		[
			[194830, 194830],
			"mapped",
			[28153]
		],
		[
			[194831, 194831],
			"mapped",
			[28526]
		],
		[
			[194832, 194832],
			"mapped",
			[147294]
		],
		[
			[194833, 194833],
			"mapped",
			[147342]
		],
		[
			[194834, 194834],
			"mapped",
			[28614]
		],
		[
			[194835, 194835],
			"mapped",
			[28729]
		],
		[
			[194836, 194836],
			"mapped",
			[28702]
		],
		[
			[194837, 194837],
			"mapped",
			[28699]
		],
		[
			[194838, 194838],
			"mapped",
			[15766]
		],
		[
			[194839, 194839],
			"mapped",
			[28746]
		],
		[
			[194840, 194840],
			"mapped",
			[28797]
		],
		[
			[194841, 194841],
			"mapped",
			[28791]
		],
		[
			[194842, 194842],
			"mapped",
			[28845]
		],
		[
			[194843, 194843],
			"mapped",
			[132389]
		],
		[
			[194844, 194844],
			"mapped",
			[28997]
		],
		[
			[194845, 194845],
			"mapped",
			[148067]
		],
		[
			[194846, 194846],
			"mapped",
			[29084]
		],
		[[194847, 194847], "disallowed"],
		[
			[194848, 194848],
			"mapped",
			[29224]
		],
		[
			[194849, 194849],
			"mapped",
			[29237]
		],
		[
			[194850, 194850],
			"mapped",
			[29264]
		],
		[
			[194851, 194851],
			"mapped",
			[149e3]
		],
		[
			[194852, 194852],
			"mapped",
			[29312]
		],
		[
			[194853, 194853],
			"mapped",
			[29333]
		],
		[
			[194854, 194854],
			"mapped",
			[149301]
		],
		[
			[194855, 194855],
			"mapped",
			[149524]
		],
		[
			[194856, 194856],
			"mapped",
			[29562]
		],
		[
			[194857, 194857],
			"mapped",
			[29579]
		],
		[
			[194858, 194858],
			"mapped",
			[16044]
		],
		[
			[194859, 194859],
			"mapped",
			[29605]
		],
		[
			[194860, 194861],
			"mapped",
			[16056]
		],
		[
			[194862, 194862],
			"mapped",
			[29767]
		],
		[
			[194863, 194863],
			"mapped",
			[29788]
		],
		[
			[194864, 194864],
			"mapped",
			[29809]
		],
		[
			[194865, 194865],
			"mapped",
			[29829]
		],
		[
			[194866, 194866],
			"mapped",
			[29898]
		],
		[
			[194867, 194867],
			"mapped",
			[16155]
		],
		[
			[194868, 194868],
			"mapped",
			[29988]
		],
		[
			[194869, 194869],
			"mapped",
			[150582]
		],
		[
			[194870, 194870],
			"mapped",
			[30014]
		],
		[
			[194871, 194871],
			"mapped",
			[150674]
		],
		[
			[194872, 194872],
			"mapped",
			[30064]
		],
		[
			[194873, 194873],
			"mapped",
			[139679]
		],
		[
			[194874, 194874],
			"mapped",
			[30224]
		],
		[
			[194875, 194875],
			"mapped",
			[151457]
		],
		[
			[194876, 194876],
			"mapped",
			[151480]
		],
		[
			[194877, 194877],
			"mapped",
			[151620]
		],
		[
			[194878, 194878],
			"mapped",
			[16380]
		],
		[
			[194879, 194879],
			"mapped",
			[16392]
		],
		[
			[194880, 194880],
			"mapped",
			[30452]
		],
		[
			[194881, 194881],
			"mapped",
			[151795]
		],
		[
			[194882, 194882],
			"mapped",
			[151794]
		],
		[
			[194883, 194883],
			"mapped",
			[151833]
		],
		[
			[194884, 194884],
			"mapped",
			[151859]
		],
		[
			[194885, 194885],
			"mapped",
			[30494]
		],
		[
			[194886, 194887],
			"mapped",
			[30495]
		],
		[
			[194888, 194888],
			"mapped",
			[30538]
		],
		[
			[194889, 194889],
			"mapped",
			[16441]
		],
		[
			[194890, 194890],
			"mapped",
			[30603]
		],
		[
			[194891, 194891],
			"mapped",
			[16454]
		],
		[
			[194892, 194892],
			"mapped",
			[16534]
		],
		[
			[194893, 194893],
			"mapped",
			[152605]
		],
		[
			[194894, 194894],
			"mapped",
			[30798]
		],
		[
			[194895, 194895],
			"mapped",
			[30860]
		],
		[
			[194896, 194896],
			"mapped",
			[30924]
		],
		[
			[194897, 194897],
			"mapped",
			[16611]
		],
		[
			[194898, 194898],
			"mapped",
			[153126]
		],
		[
			[194899, 194899],
			"mapped",
			[31062]
		],
		[
			[194900, 194900],
			"mapped",
			[153242]
		],
		[
			[194901, 194901],
			"mapped",
			[153285]
		],
		[
			[194902, 194902],
			"mapped",
			[31119]
		],
		[
			[194903, 194903],
			"mapped",
			[31211]
		],
		[
			[194904, 194904],
			"mapped",
			[16687]
		],
		[
			[194905, 194905],
			"mapped",
			[31296]
		],
		[
			[194906, 194906],
			"mapped",
			[31306]
		],
		[
			[194907, 194907],
			"mapped",
			[31311]
		],
		[
			[194908, 194908],
			"mapped",
			[153980]
		],
		[
			[194909, 194910],
			"mapped",
			[154279]
		],
		[[194911, 194911], "disallowed"],
		[
			[194912, 194912],
			"mapped",
			[16898]
		],
		[
			[194913, 194913],
			"mapped",
			[154539]
		],
		[
			[194914, 194914],
			"mapped",
			[31686]
		],
		[
			[194915, 194915],
			"mapped",
			[31689]
		],
		[
			[194916, 194916],
			"mapped",
			[16935]
		],
		[
			[194917, 194917],
			"mapped",
			[154752]
		],
		[
			[194918, 194918],
			"mapped",
			[31954]
		],
		[
			[194919, 194919],
			"mapped",
			[17056]
		],
		[
			[194920, 194920],
			"mapped",
			[31976]
		],
		[
			[194921, 194921],
			"mapped",
			[31971]
		],
		[
			[194922, 194922],
			"mapped",
			[32e3]
		],
		[
			[194923, 194923],
			"mapped",
			[155526]
		],
		[
			[194924, 194924],
			"mapped",
			[32099]
		],
		[
			[194925, 194925],
			"mapped",
			[17153]
		],
		[
			[194926, 194926],
			"mapped",
			[32199]
		],
		[
			[194927, 194927],
			"mapped",
			[32258]
		],
		[
			[194928, 194928],
			"mapped",
			[32325]
		],
		[
			[194929, 194929],
			"mapped",
			[17204]
		],
		[
			[194930, 194930],
			"mapped",
			[156200]
		],
		[
			[194931, 194931],
			"mapped",
			[156231]
		],
		[
			[194932, 194932],
			"mapped",
			[17241]
		],
		[
			[194933, 194933],
			"mapped",
			[156377]
		],
		[
			[194934, 194934],
			"mapped",
			[32634]
		],
		[
			[194935, 194935],
			"mapped",
			[156478]
		],
		[
			[194936, 194936],
			"mapped",
			[32661]
		],
		[
			[194937, 194937],
			"mapped",
			[32762]
		],
		[
			[194938, 194938],
			"mapped",
			[32773]
		],
		[
			[194939, 194939],
			"mapped",
			[156890]
		],
		[
			[194940, 194940],
			"mapped",
			[156963]
		],
		[
			[194941, 194941],
			"mapped",
			[32864]
		],
		[
			[194942, 194942],
			"mapped",
			[157096]
		],
		[
			[194943, 194943],
			"mapped",
			[32880]
		],
		[
			[194944, 194944],
			"mapped",
			[144223]
		],
		[
			[194945, 194945],
			"mapped",
			[17365]
		],
		[
			[194946, 194946],
			"mapped",
			[32946]
		],
		[
			[194947, 194947],
			"mapped",
			[33027]
		],
		[
			[194948, 194948],
			"mapped",
			[17419]
		],
		[
			[194949, 194949],
			"mapped",
			[33086]
		],
		[
			[194950, 194950],
			"mapped",
			[23221]
		],
		[
			[194951, 194951],
			"mapped",
			[157607]
		],
		[
			[194952, 194952],
			"mapped",
			[157621]
		],
		[
			[194953, 194953],
			"mapped",
			[144275]
		],
		[
			[194954, 194954],
			"mapped",
			[144284]
		],
		[
			[194955, 194955],
			"mapped",
			[33281]
		],
		[
			[194956, 194956],
			"mapped",
			[33284]
		],
		[
			[194957, 194957],
			"mapped",
			[36766]
		],
		[
			[194958, 194958],
			"mapped",
			[17515]
		],
		[
			[194959, 194959],
			"mapped",
			[33425]
		],
		[
			[194960, 194960],
			"mapped",
			[33419]
		],
		[
			[194961, 194961],
			"mapped",
			[33437]
		],
		[
			[194962, 194962],
			"mapped",
			[21171]
		],
		[
			[194963, 194963],
			"mapped",
			[33457]
		],
		[
			[194964, 194964],
			"mapped",
			[33459]
		],
		[
			[194965, 194965],
			"mapped",
			[33469]
		],
		[
			[194966, 194966],
			"mapped",
			[33510]
		],
		[
			[194967, 194967],
			"mapped",
			[158524]
		],
		[
			[194968, 194968],
			"mapped",
			[33509]
		],
		[
			[194969, 194969],
			"mapped",
			[33565]
		],
		[
			[194970, 194970],
			"mapped",
			[33635]
		],
		[
			[194971, 194971],
			"mapped",
			[33709]
		],
		[
			[194972, 194972],
			"mapped",
			[33571]
		],
		[
			[194973, 194973],
			"mapped",
			[33725]
		],
		[
			[194974, 194974],
			"mapped",
			[33767]
		],
		[
			[194975, 194975],
			"mapped",
			[33879]
		],
		[
			[194976, 194976],
			"mapped",
			[33619]
		],
		[
			[194977, 194977],
			"mapped",
			[33738]
		],
		[
			[194978, 194978],
			"mapped",
			[33740]
		],
		[
			[194979, 194979],
			"mapped",
			[33756]
		],
		[
			[194980, 194980],
			"mapped",
			[158774]
		],
		[
			[194981, 194981],
			"mapped",
			[159083]
		],
		[
			[194982, 194982],
			"mapped",
			[158933]
		],
		[
			[194983, 194983],
			"mapped",
			[17707]
		],
		[
			[194984, 194984],
			"mapped",
			[34033]
		],
		[
			[194985, 194985],
			"mapped",
			[34035]
		],
		[
			[194986, 194986],
			"mapped",
			[34070]
		],
		[
			[194987, 194987],
			"mapped",
			[160714]
		],
		[
			[194988, 194988],
			"mapped",
			[34148]
		],
		[
			[194989, 194989],
			"mapped",
			[159532]
		],
		[
			[194990, 194990],
			"mapped",
			[17757]
		],
		[
			[194991, 194991],
			"mapped",
			[17761]
		],
		[
			[194992, 194992],
			"mapped",
			[159665]
		],
		[
			[194993, 194993],
			"mapped",
			[159954]
		],
		[
			[194994, 194994],
			"mapped",
			[17771]
		],
		[
			[194995, 194995],
			"mapped",
			[34384]
		],
		[
			[194996, 194996],
			"mapped",
			[34396]
		],
		[
			[194997, 194997],
			"mapped",
			[34407]
		],
		[
			[194998, 194998],
			"mapped",
			[34409]
		],
		[
			[194999, 194999],
			"mapped",
			[34473]
		],
		[
			[195e3, 195e3],
			"mapped",
			[34440]
		],
		[
			[195001, 195001],
			"mapped",
			[34574]
		],
		[
			[195002, 195002],
			"mapped",
			[34530]
		],
		[
			[195003, 195003],
			"mapped",
			[34681]
		],
		[
			[195004, 195004],
			"mapped",
			[34600]
		],
		[
			[195005, 195005],
			"mapped",
			[34667]
		],
		[
			[195006, 195006],
			"mapped",
			[34694]
		],
		[[195007, 195007], "disallowed"],
		[
			[195008, 195008],
			"mapped",
			[34785]
		],
		[
			[195009, 195009],
			"mapped",
			[34817]
		],
		[
			[195010, 195010],
			"mapped",
			[17913]
		],
		[
			[195011, 195011],
			"mapped",
			[34912]
		],
		[
			[195012, 195012],
			"mapped",
			[34915]
		],
		[
			[195013, 195013],
			"mapped",
			[161383]
		],
		[
			[195014, 195014],
			"mapped",
			[35031]
		],
		[
			[195015, 195015],
			"mapped",
			[35038]
		],
		[
			[195016, 195016],
			"mapped",
			[17973]
		],
		[
			[195017, 195017],
			"mapped",
			[35066]
		],
		[
			[195018, 195018],
			"mapped",
			[13499]
		],
		[
			[195019, 195019],
			"mapped",
			[161966]
		],
		[
			[195020, 195020],
			"mapped",
			[162150]
		],
		[
			[195021, 195021],
			"mapped",
			[18110]
		],
		[
			[195022, 195022],
			"mapped",
			[18119]
		],
		[
			[195023, 195023],
			"mapped",
			[35488]
		],
		[
			[195024, 195024],
			"mapped",
			[35565]
		],
		[
			[195025, 195025],
			"mapped",
			[35722]
		],
		[
			[195026, 195026],
			"mapped",
			[35925]
		],
		[
			[195027, 195027],
			"mapped",
			[162984]
		],
		[
			[195028, 195028],
			"mapped",
			[36011]
		],
		[
			[195029, 195029],
			"mapped",
			[36033]
		],
		[
			[195030, 195030],
			"mapped",
			[36123]
		],
		[
			[195031, 195031],
			"mapped",
			[36215]
		],
		[
			[195032, 195032],
			"mapped",
			[163631]
		],
		[
			[195033, 195033],
			"mapped",
			[133124]
		],
		[
			[195034, 195034],
			"mapped",
			[36299]
		],
		[
			[195035, 195035],
			"mapped",
			[36284]
		],
		[
			[195036, 195036],
			"mapped",
			[36336]
		],
		[
			[195037, 195037],
			"mapped",
			[133342]
		],
		[
			[195038, 195038],
			"mapped",
			[36564]
		],
		[
			[195039, 195039],
			"mapped",
			[36664]
		],
		[
			[195040, 195040],
			"mapped",
			[165330]
		],
		[
			[195041, 195041],
			"mapped",
			[165357]
		],
		[
			[195042, 195042],
			"mapped",
			[37012]
		],
		[
			[195043, 195043],
			"mapped",
			[37105]
		],
		[
			[195044, 195044],
			"mapped",
			[37137]
		],
		[
			[195045, 195045],
			"mapped",
			[165678]
		],
		[
			[195046, 195046],
			"mapped",
			[37147]
		],
		[
			[195047, 195047],
			"mapped",
			[37432]
		],
		[
			[195048, 195048],
			"mapped",
			[37591]
		],
		[
			[195049, 195049],
			"mapped",
			[37592]
		],
		[
			[195050, 195050],
			"mapped",
			[37500]
		],
		[
			[195051, 195051],
			"mapped",
			[37881]
		],
		[
			[195052, 195052],
			"mapped",
			[37909]
		],
		[
			[195053, 195053],
			"mapped",
			[166906]
		],
		[
			[195054, 195054],
			"mapped",
			[38283]
		],
		[
			[195055, 195055],
			"mapped",
			[18837]
		],
		[
			[195056, 195056],
			"mapped",
			[38327]
		],
		[
			[195057, 195057],
			"mapped",
			[167287]
		],
		[
			[195058, 195058],
			"mapped",
			[18918]
		],
		[
			[195059, 195059],
			"mapped",
			[38595]
		],
		[
			[195060, 195060],
			"mapped",
			[23986]
		],
		[
			[195061, 195061],
			"mapped",
			[38691]
		],
		[
			[195062, 195062],
			"mapped",
			[168261]
		],
		[
			[195063, 195063],
			"mapped",
			[168474]
		],
		[
			[195064, 195064],
			"mapped",
			[19054]
		],
		[
			[195065, 195065],
			"mapped",
			[19062]
		],
		[
			[195066, 195066],
			"mapped",
			[38880]
		],
		[
			[195067, 195067],
			"mapped",
			[168970]
		],
		[
			[195068, 195068],
			"mapped",
			[19122]
		],
		[
			[195069, 195069],
			"mapped",
			[169110]
		],
		[
			[195070, 195071],
			"mapped",
			[38923]
		],
		[
			[195072, 195072],
			"mapped",
			[38953]
		],
		[
			[195073, 195073],
			"mapped",
			[169398]
		],
		[
			[195074, 195074],
			"mapped",
			[39138]
		],
		[
			[195075, 195075],
			"mapped",
			[19251]
		],
		[
			[195076, 195076],
			"mapped",
			[39209]
		],
		[
			[195077, 195077],
			"mapped",
			[39335]
		],
		[
			[195078, 195078],
			"mapped",
			[39362]
		],
		[
			[195079, 195079],
			"mapped",
			[39422]
		],
		[
			[195080, 195080],
			"mapped",
			[19406]
		],
		[
			[195081, 195081],
			"mapped",
			[170800]
		],
		[
			[195082, 195082],
			"mapped",
			[39698]
		],
		[
			[195083, 195083],
			"mapped",
			[4e4]
		],
		[
			[195084, 195084],
			"mapped",
			[40189]
		],
		[
			[195085, 195085],
			"mapped",
			[19662]
		],
		[
			[195086, 195086],
			"mapped",
			[19693]
		],
		[
			[195087, 195087],
			"mapped",
			[40295]
		],
		[
			[195088, 195088],
			"mapped",
			[172238]
		],
		[
			[195089, 195089],
			"mapped",
			[19704]
		],
		[
			[195090, 195090],
			"mapped",
			[172293]
		],
		[
			[195091, 195091],
			"mapped",
			[172558]
		],
		[
			[195092, 195092],
			"mapped",
			[172689]
		],
		[
			[195093, 195093],
			"mapped",
			[40635]
		],
		[
			[195094, 195094],
			"mapped",
			[19798]
		],
		[
			[195095, 195095],
			"mapped",
			[40697]
		],
		[
			[195096, 195096],
			"mapped",
			[40702]
		],
		[
			[195097, 195097],
			"mapped",
			[40709]
		],
		[
			[195098, 195098],
			"mapped",
			[40719]
		],
		[
			[195099, 195099],
			"mapped",
			[40726]
		],
		[
			[195100, 195100],
			"mapped",
			[40763]
		],
		[
			[195101, 195101],
			"mapped",
			[173568]
		],
		[[195102, 196605], "disallowed"],
		[[196606, 196607], "disallowed"],
		[[196608, 262141], "disallowed"],
		[[262142, 262143], "disallowed"],
		[[262144, 327677], "disallowed"],
		[[327678, 327679], "disallowed"],
		[[327680, 393213], "disallowed"],
		[[393214, 393215], "disallowed"],
		[[393216, 458749], "disallowed"],
		[[458750, 458751], "disallowed"],
		[[458752, 524285], "disallowed"],
		[[524286, 524287], "disallowed"],
		[[524288, 589821], "disallowed"],
		[[589822, 589823], "disallowed"],
		[[589824, 655357], "disallowed"],
		[[655358, 655359], "disallowed"],
		[[655360, 720893], "disallowed"],
		[[720894, 720895], "disallowed"],
		[[720896, 786429], "disallowed"],
		[[786430, 786431], "disallowed"],
		[[786432, 851965], "disallowed"],
		[[851966, 851967], "disallowed"],
		[[851968, 917501], "disallowed"],
		[[917502, 917503], "disallowed"],
		[[917504, 917504], "disallowed"],
		[[917505, 917505], "disallowed"],
		[[917506, 917535], "disallowed"],
		[[917536, 917631], "disallowed"],
		[[917632, 917759], "disallowed"],
		[[917760, 917999], "ignored"],
		[[918e3, 983037], "disallowed"],
		[[983038, 983039], "disallowed"],
		[[983040, 1048573], "disallowed"],
		[[1048574, 1048575], "disallowed"],
		[[1048576, 1114109], "disallowed"],
		[[1114110, 1114111], "disallowed"]
	];
} });

//#endregion
//#region node_modules/tr46/index.js
var require_tr46 = __commonJS({ "node_modules/tr46/index.js"(exports, module) {
	var punycode$1 = require("punycode");
	var mappingTable = require_mappingTable();
	var PROCESSING_OPTIONS = {
		TRANSITIONAL: 0,
		NONTRANSITIONAL: 1
	};
	function normalize(str) {
		return str.split("\0").map(function(s$1) {
			return s$1.normalize("NFC");
		}).join("\0");
	}
	function findStatus(val) {
		var start = 0;
		var end = mappingTable.length - 1;
		while (start <= end) {
			var mid = Math.floor((start + end) / 2);
			var target = mappingTable[mid];
			if (target[0][0] <= val && target[0][1] >= val) return target;
			else if (target[0][0] > val) end = mid - 1;
			else start = mid + 1;
		}
		return null;
	}
	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	function countSymbols$1(string) {
		return string.replace(regexAstralSymbols, "_").length;
	}
	function mapChars(domain_name, useSTD3, processing_option) {
		var hasError = false;
		var processed = "";
		var len$1 = countSymbols$1(domain_name);
		for (var i$1 = 0; i$1 < len$1; ++i$1) {
			var codePoint = domain_name.codePointAt(i$1);
			var status = findStatus(codePoint);
			switch (status[1]) {
				case "disallowed":
					hasError = true;
					processed += String.fromCodePoint(codePoint);
					break;
				case "ignored": break;
				case "mapped":
					processed += String.fromCodePoint.apply(String, status[2]);
					break;
				case "deviation":
					if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) processed += String.fromCodePoint.apply(String, status[2]);
					else processed += String.fromCodePoint(codePoint);
					break;
				case "valid":
					processed += String.fromCodePoint(codePoint);
					break;
				case "disallowed_STD3_mapped":
					if (useSTD3) {
						hasError = true;
						processed += String.fromCodePoint(codePoint);
					} else processed += String.fromCodePoint.apply(String, status[2]);
					break;
				case "disallowed_STD3_valid":
					if (useSTD3) hasError = true;
					processed += String.fromCodePoint(codePoint);
					break;
			}
		}
		return {
			string: processed,
			error: hasError
		};
	}
	var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
	function validateLabel(label, processing_option) {
		if (label.substr(0, 4) === "xn--") {
			label = punycode$1.toUnicode(label);
			processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
		}
		var error$1 = false;
		if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) error$1 = true;
		var len$1 = countSymbols$1(label);
		for (var i$1 = 0; i$1 < len$1; ++i$1) {
			var status = findStatus(label.codePointAt(i$1));
			if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
				error$1 = true;
				break;
			}
		}
		return {
			label,
			error: error$1
		};
	}
	function processing(domain_name, useSTD3, processing_option) {
		var result = mapChars(domain_name, useSTD3, processing_option);
		result.string = normalize(result.string);
		var labels = result.string.split(".");
		for (var i$1 = 0; i$1 < labels.length; ++i$1) try {
			var validation = validateLabel(labels[i$1]);
			labels[i$1] = validation.label;
			result.error = result.error || validation.error;
		} catch (e) {
			result.error = true;
		}
		return {
			string: labels.join("."),
			error: result.error
		};
	}
	module.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
		var result = processing(domain_name, useSTD3, processing_option);
		var labels = result.string.split(".");
		labels = labels.map(function(l) {
			try {
				return punycode$1.toASCII(l);
			} catch (e) {
				result.error = true;
				return l;
			}
		});
		if (verifyDnsLength) {
			var total = labels.slice(0, labels.length - 1).join(".").length;
			if (total.length > 253 || total.length === 0) result.error = true;
			for (var i$1 = 0; i$1 < labels.length; ++i$1) if (labels.length > 63 || labels.length === 0) {
				result.error = true;
				break;
			}
		}
		if (result.error) return null;
		return labels.join(".");
	};
	module.exports.toUnicode = function(domain_name, useSTD3) {
		var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
		return {
			domain: result.string,
			error: result.error
		};
	};
	module.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
} });

//#endregion
//#region node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({ "node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
	const punycode = require("punycode");
	const tr46 = require_tr46();
	const specialSchemes = {
		ftp: 21,
		file: null,
		gopher: 70,
		http: 80,
		https: 443,
		ws: 80,
		wss: 443
	};
	const failure = Symbol("failure");
	function countSymbols(str) {
		return punycode.ucs2.decode(str).length;
	}
	function at(input, idx) {
		const c = input[idx];
		return isNaN(c) ? void 0 : String.fromCodePoint(c);
	}
	function isASCIIDigit(c) {
		return c >= 48 && c <= 57;
	}
	function isASCIIAlpha(c) {
		return c >= 65 && c <= 90 || c >= 97 && c <= 122;
	}
	function isASCIIAlphanumeric(c) {
		return isASCIIAlpha(c) || isASCIIDigit(c);
	}
	function isASCIIHex(c) {
		return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
	}
	function isSingleDot(buffer$1) {
		return buffer$1 === "." || buffer$1.toLowerCase() === "%2e";
	}
	function isDoubleDot(buffer$1) {
		buffer$1 = buffer$1.toLowerCase();
		return buffer$1 === ".." || buffer$1 === "%2e." || buffer$1 === ".%2e" || buffer$1 === "%2e%2e";
	}
	function isWindowsDriveLetterCodePoints(cp1, cp2) {
		return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
	}
	function isWindowsDriveLetterString(string) {
		return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
	}
	function isNormalizedWindowsDriveLetterString(string) {
		return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
	}
	function containsForbiddenHostCodePoint(string) {
		return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
	}
	function containsForbiddenHostCodePointExcludingPercent(string) {
		return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
	}
	function isSpecialScheme(scheme) {
		return specialSchemes[scheme] !== void 0;
	}
	function isSpecial(url) {
		return isSpecialScheme(url.scheme);
	}
	function defaultPort(scheme) {
		return specialSchemes[scheme];
	}
	function percentEncode(c) {
		let hex = c.toString(16).toUpperCase();
		if (hex.length === 1) hex = "0" + hex;
		return "%" + hex;
	}
	function utf8PercentEncode(c) {
		const buf = new Buffer(c);
		let str = "";
		for (let i$1 = 0; i$1 < buf.length; ++i$1) str += percentEncode(buf[i$1]);
		return str;
	}
	function utf8PercentDecode(str) {
		const input = new Buffer(str);
		const output = [];
		for (let i$1 = 0; i$1 < input.length; ++i$1) if (input[i$1] !== 37) output.push(input[i$1]);
		else if (input[i$1] === 37 && isASCIIHex(input[i$1 + 1]) && isASCIIHex(input[i$1 + 2])) {
			output.push(parseInt(input.slice(i$1 + 1, i$1 + 3).toString(), 16));
			i$1 += 2;
		} else output.push(input[i$1]);
		return new Buffer(output).toString();
	}
	function isC0ControlPercentEncode(c) {
		return c <= 31 || c > 126;
	}
	const extraPathPercentEncodeSet = new Set([
		32,
		34,
		35,
		60,
		62,
		63,
		96,
		123,
		125
	]);
	function isPathPercentEncode(c) {
		return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
	}
	const extraUserinfoPercentEncodeSet = new Set([
		47,
		58,
		59,
		61,
		64,
		91,
		92,
		93,
		94,
		124
	]);
	function isUserinfoPercentEncode(c) {
		return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
	}
	function percentEncodeChar(c, encodeSetPredicate) {
		const cStr = String.fromCodePoint(c);
		if (encodeSetPredicate(c)) return utf8PercentEncode(cStr);
		return cStr;
	}
	function parseIPv4Number(input) {
		let R = 10;
		if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
			input = input.substring(2);
			R = 16;
		} else if (input.length >= 2 && input.charAt(0) === "0") {
			input = input.substring(1);
			R = 8;
		}
		if (input === "") return 0;
		const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
		if (regex.test(input)) return failure;
		return parseInt(input, R);
	}
	function parseIPv4(input) {
		const parts = input.split(".");
		if (parts[parts.length - 1] === "") {
			if (parts.length > 1) parts.pop();
		}
		if (parts.length > 4) return input;
		const numbers = [];
		for (const part of parts) {
			if (part === "") return input;
			const n = parseIPv4Number(part);
			if (n === failure) return input;
			numbers.push(n);
		}
		for (let i$1 = 0; i$1 < numbers.length - 1; ++i$1) if (numbers[i$1] > 255) return failure;
		if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) return failure;
		let ipv4 = numbers.pop();
		let counter = 0;
		for (const n of numbers) {
			ipv4 += n * Math.pow(256, 3 - counter);
			++counter;
		}
		return ipv4;
	}
	function serializeIPv4(address) {
		let output = "";
		let n = address;
		for (let i$1 = 1; i$1 <= 4; ++i$1) {
			output = String(n % 256) + output;
			if (i$1 !== 4) output = "." + output;
			n = Math.floor(n / 256);
		}
		return output;
	}
	function parseIPv6(input) {
		const address = [
			0,
			0,
			0,
			0,
			0,
			0,
			0,
			0
		];
		let pieceIndex = 0;
		let compress = null;
		let pointer = 0;
		input = punycode.ucs2.decode(input);
		if (input[pointer] === 58) {
			if (input[pointer + 1] !== 58) return failure;
			pointer += 2;
			++pieceIndex;
			compress = pieceIndex;
		}
		while (pointer < input.length) {
			if (pieceIndex === 8) return failure;
			if (input[pointer] === 58) {
				if (compress !== null) return failure;
				++pointer;
				++pieceIndex;
				compress = pieceIndex;
				continue;
			}
			let value = 0;
			let length = 0;
			while (length < 4 && isASCIIHex(input[pointer])) {
				value = value * 16 + parseInt(at(input, pointer), 16);
				++pointer;
				++length;
			}
			if (input[pointer] === 46) {
				if (length === 0) return failure;
				pointer -= length;
				if (pieceIndex > 6) return failure;
				let numbersSeen = 0;
				while (input[pointer] !== void 0) {
					let ipv4Piece = null;
					if (numbersSeen > 0) if (input[pointer] === 46 && numbersSeen < 4) ++pointer;
					else return failure;
					if (!isASCIIDigit(input[pointer])) return failure;
					while (isASCIIDigit(input[pointer])) {
						const number = parseInt(at(input, pointer));
						if (ipv4Piece === null) ipv4Piece = number;
						else if (ipv4Piece === 0) return failure;
						else ipv4Piece = ipv4Piece * 10 + number;
						if (ipv4Piece > 255) return failure;
						++pointer;
					}
					address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
					++numbersSeen;
					if (numbersSeen === 2 || numbersSeen === 4) ++pieceIndex;
				}
				if (numbersSeen !== 4) return failure;
				break;
			} else if (input[pointer] === 58) {
				++pointer;
				if (input[pointer] === void 0) return failure;
			} else if (input[pointer] !== void 0) return failure;
			address[pieceIndex] = value;
			++pieceIndex;
		}
		if (compress !== null) {
			let swaps = pieceIndex - compress;
			pieceIndex = 7;
			while (pieceIndex !== 0 && swaps > 0) {
				const temp = address[compress + swaps - 1];
				address[compress + swaps - 1] = address[pieceIndex];
				address[pieceIndex] = temp;
				--pieceIndex;
				--swaps;
			}
		} else if (compress === null && pieceIndex !== 8) return failure;
		return address;
	}
	function serializeIPv6(address) {
		let output = "";
		const seqResult = findLongestZeroSequence(address);
		const compress = seqResult.idx;
		let ignore0 = false;
		for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
			if (ignore0 && address[pieceIndex] === 0) continue;
			else if (ignore0) ignore0 = false;
			if (compress === pieceIndex) {
				const separator = pieceIndex === 0 ? "::" : ":";
				output += separator;
				ignore0 = true;
				continue;
			}
			output += address[pieceIndex].toString(16);
			if (pieceIndex !== 7) output += ":";
		}
		return output;
	}
	function parseHost(input, isSpecialArg) {
		if (input[0] === "[") {
			if (input[input.length - 1] !== "]") return failure;
			return parseIPv6(input.substring(1, input.length - 1));
		}
		if (!isSpecialArg) return parseOpaqueHost(input);
		const domain = utf8PercentDecode(input);
		const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
		if (asciiDomain === null) return failure;
		if (containsForbiddenHostCodePoint(asciiDomain)) return failure;
		const ipv4Host = parseIPv4(asciiDomain);
		if (typeof ipv4Host === "number" || ipv4Host === failure) return ipv4Host;
		return asciiDomain;
	}
	function parseOpaqueHost(input) {
		if (containsForbiddenHostCodePointExcludingPercent(input)) return failure;
		let output = "";
		const decoded = punycode.ucs2.decode(input);
		for (let i$1 = 0; i$1 < decoded.length; ++i$1) output += percentEncodeChar(decoded[i$1], isC0ControlPercentEncode);
		return output;
	}
	function findLongestZeroSequence(arr) {
		let maxIdx = null;
		let maxLen = 1;
		let currStart = null;
		let currLen = 0;
		for (let i$1 = 0; i$1 < arr.length; ++i$1) if (arr[i$1] !== 0) {
			if (currLen > maxLen) {
				maxIdx = currStart;
				maxLen = currLen;
			}
			currStart = null;
			currLen = 0;
		} else {
			if (currStart === null) currStart = i$1;
			++currLen;
		}
		if (currLen > maxLen) {
			maxIdx = currStart;
			maxLen = currLen;
		}
		return {
			idx: maxIdx,
			len: maxLen
		};
	}
	function serializeHost(host) {
		if (typeof host === "number") return serializeIPv4(host);
		if (host instanceof Array) return "[" + serializeIPv6(host) + "]";
		return host;
	}
	function trimControlChars(url) {
		return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
	}
	function trimTabAndNewline(url) {
		return url.replace(/\u0009|\u000A|\u000D/g, "");
	}
	function shortenPath(url) {
		const path$8 = url.path;
		if (path$8.length === 0) return;
		if (url.scheme === "file" && path$8.length === 1 && isNormalizedWindowsDriveLetter(path$8[0])) return;
		path$8.pop();
	}
	function includesCredentials(url) {
		return url.username !== "" || url.password !== "";
	}
	function cannotHaveAUsernamePasswordPort(url) {
		return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
	}
	function isNormalizedWindowsDriveLetter(string) {
		return /^[A-Za-z]:$/.test(string);
	}
	function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
		this.pointer = 0;
		this.input = input;
		this.base = base || null;
		this.encodingOverride = encodingOverride || "utf-8";
		this.stateOverride = stateOverride;
		this.url = url;
		this.failure = false;
		this.parseError = false;
		if (!this.url) {
			this.url = {
				scheme: "",
				username: "",
				password: "",
				host: null,
				port: null,
				path: [],
				query: null,
				fragment: null,
				cannotBeABaseURL: false
			};
			const res$1 = trimControlChars(this.input);
			if (res$1 !== this.input) this.parseError = true;
			this.input = res$1;
		}
		const res = trimTabAndNewline(this.input);
		if (res !== this.input) this.parseError = true;
		this.input = res;
		this.state = stateOverride || "scheme start";
		this.buffer = "";
		this.atFlag = false;
		this.arrFlag = false;
		this.passwordTokenSeenFlag = false;
		this.input = punycode.ucs2.decode(this.input);
		for (; this.pointer <= this.input.length; ++this.pointer) {
			const c = this.input[this.pointer];
			const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
			const ret = this["parse " + this.state](c, cStr);
			if (!ret) break;
			else if (ret === failure) {
				this.failure = true;
				break;
			}
		}
	}
	URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
		if (isASCIIAlpha(c)) {
			this.buffer += cStr.toLowerCase();
			this.state = "scheme";
		} else if (!this.stateOverride) {
			this.state = "no scheme";
			--this.pointer;
		} else {
			this.parseError = true;
			return failure;
		}
		return true;
	};
	URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
		if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) this.buffer += cStr.toLowerCase();
		else if (c === 58) {
			if (this.stateOverride) {
				if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) return false;
				if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) return false;
				if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") return false;
				if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) return false;
			}
			this.url.scheme = this.buffer;
			this.buffer = "";
			if (this.stateOverride) return false;
			if (this.url.scheme === "file") {
				if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) this.parseError = true;
				this.state = "file";
			} else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) this.state = "special relative or authority";
			else if (isSpecial(this.url)) this.state = "special authority slashes";
			else if (this.input[this.pointer + 1] === 47) {
				this.state = "path or authority";
				++this.pointer;
			} else {
				this.url.cannotBeABaseURL = true;
				this.url.path.push("");
				this.state = "cannot-be-a-base-URL path";
			}
		} else if (!this.stateOverride) {
			this.buffer = "";
			this.state = "no scheme";
			this.pointer = -1;
		} else {
			this.parseError = true;
			return failure;
		}
		return true;
	};
	URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
		if (this.base === null || this.base.cannotBeABaseURL && c !== 35) return failure;
		else if (this.base.cannotBeABaseURL && c === 35) {
			this.url.scheme = this.base.scheme;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
			this.url.fragment = "";
			this.url.cannotBeABaseURL = true;
			this.state = "fragment";
		} else if (this.base.scheme === "file") {
			this.state = "file";
			--this.pointer;
		} else {
			this.state = "relative";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
		if (c === 47 && this.input[this.pointer + 1] === 47) {
			this.state = "special authority ignore slashes";
			++this.pointer;
		} else {
			this.parseError = true;
			this.state = "relative";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
		if (c === 47) this.state = "authority";
		else {
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
		this.url.scheme = this.base.scheme;
		if (isNaN(c)) {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
		} else if (c === 47) this.state = "relative slash";
		else if (c === 63) {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.url.path = this.base.path.slice();
			this.url.query = "";
			this.state = "query";
		} else if (c === 35) {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
			this.url.fragment = "";
			this.state = "fragment";
		} else if (isSpecial(this.url) && c === 92) {
			this.parseError = true;
			this.state = "relative slash";
		} else {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.url.path = this.base.path.slice(0, this.base.path.length - 1);
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
		if (isSpecial(this.url) && (c === 47 || c === 92)) {
			if (c === 92) this.parseError = true;
			this.state = "special authority ignore slashes";
		} else if (c === 47) this.state = "authority";
		else {
			this.url.username = this.base.username;
			this.url.password = this.base.password;
			this.url.host = this.base.host;
			this.url.port = this.base.port;
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
		if (c === 47 && this.input[this.pointer + 1] === 47) {
			this.state = "special authority ignore slashes";
			++this.pointer;
		} else {
			this.parseError = true;
			this.state = "special authority ignore slashes";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
		if (c !== 47 && c !== 92) {
			this.state = "authority";
			--this.pointer;
		} else this.parseError = true;
		return true;
	};
	URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
		if (c === 64) {
			this.parseError = true;
			if (this.atFlag) this.buffer = "%40" + this.buffer;
			this.atFlag = true;
			const len$1 = countSymbols(this.buffer);
			for (let pointer = 0; pointer < len$1; ++pointer) {
				const codePoint = this.buffer.codePointAt(pointer);
				if (codePoint === 58 && !this.passwordTokenSeenFlag) {
					this.passwordTokenSeenFlag = true;
					continue;
				}
				const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
				if (this.passwordTokenSeenFlag) this.url.password += encodedCodePoints;
				else this.url.username += encodedCodePoints;
			}
			this.buffer = "";
		} else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
			if (this.atFlag && this.buffer === "") {
				this.parseError = true;
				return failure;
			}
			this.pointer -= countSymbols(this.buffer) + 1;
			this.buffer = "";
			this.state = "host";
		} else this.buffer += cStr;
		return true;
	};
	URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
		if (this.stateOverride && this.url.scheme === "file") {
			--this.pointer;
			this.state = "file host";
		} else if (c === 58 && !this.arrFlag) {
			if (this.buffer === "") {
				this.parseError = true;
				return failure;
			}
			const host = parseHost(this.buffer, isSpecial(this.url));
			if (host === failure) return failure;
			this.url.host = host;
			this.buffer = "";
			this.state = "port";
			if (this.stateOverride === "hostname") return false;
		} else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
			--this.pointer;
			if (isSpecial(this.url) && this.buffer === "") {
				this.parseError = true;
				return failure;
			} else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
				this.parseError = true;
				return false;
			}
			const host = parseHost(this.buffer, isSpecial(this.url));
			if (host === failure) return failure;
			this.url.host = host;
			this.buffer = "";
			this.state = "path start";
			if (this.stateOverride) return false;
		} else {
			if (c === 91) this.arrFlag = true;
			else if (c === 93) this.arrFlag = false;
			this.buffer += cStr;
		}
		return true;
	};
	URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
		if (isASCIIDigit(c)) this.buffer += cStr;
		else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
			if (this.buffer !== "") {
				const port = parseInt(this.buffer);
				if (port > Math.pow(2, 16) - 1) {
					this.parseError = true;
					return failure;
				}
				this.url.port = port === defaultPort(this.url.scheme) ? null : port;
				this.buffer = "";
			}
			if (this.stateOverride) return false;
			this.state = "path start";
			--this.pointer;
		} else {
			this.parseError = true;
			return failure;
		}
		return true;
	};
	const fileOtherwiseCodePoints = new Set([
		47,
		92,
		63,
		35
	]);
	URLStateMachine.prototype["parse file"] = function parseFile(c) {
		this.url.scheme = "file";
		if (c === 47 || c === 92) {
			if (c === 92) this.parseError = true;
			this.state = "file slash";
		} else if (this.base !== null && this.base.scheme === "file") if (isNaN(c)) {
			this.url.host = this.base.host;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
		} else if (c === 63) {
			this.url.host = this.base.host;
			this.url.path = this.base.path.slice();
			this.url.query = "";
			this.state = "query";
		} else if (c === 35) {
			this.url.host = this.base.host;
			this.url.path = this.base.path.slice();
			this.url.query = this.base.query;
			this.url.fragment = "";
			this.state = "fragment";
		} else {
			if (this.input.length - this.pointer - 1 === 0 || !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
				this.url.host = this.base.host;
				this.url.path = this.base.path.slice();
				shortenPath(this.url);
			} else this.parseError = true;
			this.state = "path";
			--this.pointer;
		}
		else {
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
		if (c === 47 || c === 92) {
			if (c === 92) this.parseError = true;
			this.state = "file host";
		} else {
			if (this.base !== null && this.base.scheme === "file") if (isNormalizedWindowsDriveLetterString(this.base.path[0])) this.url.path.push(this.base.path[0]);
			else this.url.host = this.base.host;
			this.state = "path";
			--this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
		if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
			--this.pointer;
			if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
				this.parseError = true;
				this.state = "path";
			} else if (this.buffer === "") {
				this.url.host = "";
				if (this.stateOverride) return false;
				this.state = "path start";
			} else {
				let host = parseHost(this.buffer, isSpecial(this.url));
				if (host === failure) return failure;
				if (host === "localhost") host = "";
				this.url.host = host;
				if (this.stateOverride) return false;
				this.buffer = "";
				this.state = "path start";
			}
		} else this.buffer += cStr;
		return true;
	};
	URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
		if (isSpecial(this.url)) {
			if (c === 92) this.parseError = true;
			this.state = "path";
			if (c !== 47 && c !== 92) --this.pointer;
		} else if (!this.stateOverride && c === 63) {
			this.url.query = "";
			this.state = "query";
		} else if (!this.stateOverride && c === 35) {
			this.url.fragment = "";
			this.state = "fragment";
		} else if (c !== void 0) {
			this.state = "path";
			if (c !== 47) --this.pointer;
		}
		return true;
	};
	URLStateMachine.prototype["parse path"] = function parsePath(c) {
		if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
			if (isSpecial(this.url) && c === 92) this.parseError = true;
			if (isDoubleDot(this.buffer)) {
				shortenPath(this.url);
				if (c !== 47 && !(isSpecial(this.url) && c === 92)) this.url.path.push("");
			} else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) this.url.path.push("");
			else if (!isSingleDot(this.buffer)) {
				if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
					if (this.url.host !== "" && this.url.host !== null) {
						this.parseError = true;
						this.url.host = "";
					}
					this.buffer = this.buffer[0] + ":";
				}
				this.url.path.push(this.buffer);
			}
			this.buffer = "";
			if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) while (this.url.path.length > 1 && this.url.path[0] === "") {
				this.parseError = true;
				this.url.path.shift();
			}
			if (c === 63) {
				this.url.query = "";
				this.state = "query";
			}
			if (c === 35) {
				this.url.fragment = "";
				this.state = "fragment";
			}
		} else {
			if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
			this.buffer += percentEncodeChar(c, isPathPercentEncode);
		}
		return true;
	};
	URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
		if (c === 63) {
			this.url.query = "";
			this.state = "query";
		} else if (c === 35) {
			this.url.fragment = "";
			this.state = "fragment";
		} else {
			if (!isNaN(c) && c !== 37) this.parseError = true;
			if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
			if (!isNaN(c)) this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
		}
		return true;
	};
	URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
		if (isNaN(c) || !this.stateOverride && c === 35) {
			if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") this.encodingOverride = "utf-8";
			const buffer$1 = new Buffer(this.buffer);
			for (let i$1 = 0; i$1 < buffer$1.length; ++i$1) if (buffer$1[i$1] < 33 || buffer$1[i$1] > 126 || buffer$1[i$1] === 34 || buffer$1[i$1] === 35 || buffer$1[i$1] === 60 || buffer$1[i$1] === 62) this.url.query += percentEncode(buffer$1[i$1]);
			else this.url.query += String.fromCodePoint(buffer$1[i$1]);
			this.buffer = "";
			if (c === 35) {
				this.url.fragment = "";
				this.state = "fragment";
			}
		} else {
			if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
			this.buffer += cStr;
		}
		return true;
	};
	URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
		if (isNaN(c)) {} else if (c === 0) this.parseError = true;
		else {
			if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) this.parseError = true;
			this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
		}
		return true;
	};
	function serializeURL(url, excludeFragment) {
		let output = url.scheme + ":";
		if (url.host !== null) {
			output += "//";
			if (url.username !== "" || url.password !== "") {
				output += url.username;
				if (url.password !== "") output += ":" + url.password;
				output += "@";
			}
			output += serializeHost(url.host);
			if (url.port !== null) output += ":" + url.port;
		} else if (url.host === null && url.scheme === "file") output += "//";
		if (url.cannotBeABaseURL) output += url.path[0];
		else for (const string of url.path) output += "/" + string;
		if (url.query !== null) output += "?" + url.query;
		if (!excludeFragment && url.fragment !== null) output += "#" + url.fragment;
		return output;
	}
	function serializeOrigin(tuple) {
		let result = tuple.scheme + "://";
		result += serializeHost(tuple.host);
		if (tuple.port !== null) result += ":" + tuple.port;
		return result;
	}
	module.exports.serializeURL = serializeURL;
	module.exports.serializeURLOrigin = function(url) {
		switch (url.scheme) {
			case "blob": try {
				return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
			} catch (e) {
				return "null";
			}
			case "ftp":
			case "gopher":
			case "http":
			case "https":
			case "ws":
			case "wss": return serializeOrigin({
				scheme: url.scheme,
				host: url.host,
				port: url.port
			});
			case "file": return "file://";
			default: return "null";
		}
	};
	module.exports.basicURLParse = function(input, options) {
		if (options === void 0) options = {};
		const usm$1 = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
		if (usm$1.failure) return "failure";
		return usm$1.url;
	};
	module.exports.setTheUsername = function(url, username) {
		url.username = "";
		const decoded = punycode.ucs2.decode(username);
		for (let i$1 = 0; i$1 < decoded.length; ++i$1) url.username += percentEncodeChar(decoded[i$1], isUserinfoPercentEncode);
	};
	module.exports.setThePassword = function(url, password) {
		url.password = "";
		const decoded = punycode.ucs2.decode(password);
		for (let i$1 = 0; i$1 < decoded.length; ++i$1) url.password += percentEncodeChar(decoded[i$1], isUserinfoPercentEncode);
	};
	module.exports.serializeHost = serializeHost;
	module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
	module.exports.serializeInteger = function(integer) {
		return String(integer);
	};
	module.exports.parseURL = function(input, options) {
		if (options === void 0) options = {};
		return module.exports.basicURLParse(input, {
			baseURL: options.baseURL,
			encodingOverride: options.encodingOverride
		});
	};
} });

//#endregion
//#region node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({ "node_modules/whatwg-url/lib/URL-impl.js"(exports) {
	const usm = require_url_state_machine();
	exports.implementation = class URLImpl {
		constructor(constructorArgs) {
			const url = constructorArgs[0];
			const base = constructorArgs[1];
			let parsedBase = null;
			if (base !== void 0) {
				parsedBase = usm.basicURLParse(base);
				if (parsedBase === "failure") throw new TypeError("Invalid base URL");
			}
			const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
			if (parsedURL === "failure") throw new TypeError("Invalid URL");
			this._url = parsedURL;
		}
		get href() {
			return usm.serializeURL(this._url);
		}
		set href(v) {
			const parsedURL = usm.basicURLParse(v);
			if (parsedURL === "failure") throw new TypeError("Invalid URL");
			this._url = parsedURL;
		}
		get origin() {
			return usm.serializeURLOrigin(this._url);
		}
		get protocol() {
			return this._url.scheme + ":";
		}
		set protocol(v) {
			usm.basicURLParse(v + ":", {
				url: this._url,
				stateOverride: "scheme start"
			});
		}
		get username() {
			return this._url.username;
		}
		set username(v) {
			if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
			usm.setTheUsername(this._url, v);
		}
		get password() {
			return this._url.password;
		}
		set password(v) {
			if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
			usm.setThePassword(this._url, v);
		}
		get host() {
			const url = this._url;
			if (url.host === null) return "";
			if (url.port === null) return usm.serializeHost(url.host);
			return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
		}
		set host(v) {
			if (this._url.cannotBeABaseURL) return;
			usm.basicURLParse(v, {
				url: this._url,
				stateOverride: "host"
			});
		}
		get hostname() {
			if (this._url.host === null) return "";
			return usm.serializeHost(this._url.host);
		}
		set hostname(v) {
			if (this._url.cannotBeABaseURL) return;
			usm.basicURLParse(v, {
				url: this._url,
				stateOverride: "hostname"
			});
		}
		get port() {
			if (this._url.port === null) return "";
			return usm.serializeInteger(this._url.port);
		}
		set port(v) {
			if (usm.cannotHaveAUsernamePasswordPort(this._url)) return;
			if (v === "") this._url.port = null;
			else usm.basicURLParse(v, {
				url: this._url,
				stateOverride: "port"
			});
		}
		get pathname() {
			if (this._url.cannotBeABaseURL) return this._url.path[0];
			if (this._url.path.length === 0) return "";
			return "/" + this._url.path.join("/");
		}
		set pathname(v) {
			if (this._url.cannotBeABaseURL) return;
			this._url.path = [];
			usm.basicURLParse(v, {
				url: this._url,
				stateOverride: "path start"
			});
		}
		get search() {
			if (this._url.query === null || this._url.query === "") return "";
			return "?" + this._url.query;
		}
		set search(v) {
			const url = this._url;
			if (v === "") {
				url.query = null;
				return;
			}
			const input = v[0] === "?" ? v.substring(1) : v;
			url.query = "";
			usm.basicURLParse(input, {
				url,
				stateOverride: "query"
			});
		}
		get hash() {
			if (this._url.fragment === null || this._url.fragment === "") return "";
			return "#" + this._url.fragment;
		}
		set hash(v) {
			if (v === "") {
				this._url.fragment = null;
				return;
			}
			const input = v[0] === "#" ? v.substring(1) : v;
			this._url.fragment = "";
			usm.basicURLParse(input, {
				url: this._url,
				stateOverride: "fragment"
			});
		}
		toJSON() {
			return this.href;
		}
	};
} });

//#endregion
//#region node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({ "node_modules/whatwg-url/lib/URL.js"(exports, module) {
	const conversions = require_lib$1();
	const utils = require_utils();
	const Impl = require_URL_impl();
	const impl = utils.implSymbol;
	function URL$4(url) {
		if (!this || this[impl] || !(this instanceof URL$4)) throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
		if (arguments.length < 1) throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
		const args = [];
		for (let i$1 = 0; i$1 < arguments.length && i$1 < 2; ++i$1) args[i$1] = arguments[i$1];
		args[0] = conversions["USVString"](args[0]);
		if (args[1] !== void 0) args[1] = conversions["USVString"](args[1]);
		module.exports.setup(this, args);
	}
	URL$4.prototype.toJSON = function toJSON() {
		if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
		const args = [];
		for (let i$1 = 0; i$1 < arguments.length && i$1 < 0; ++i$1) args[i$1] = arguments[i$1];
		return this[impl].toJSON.apply(this[impl], args);
	};
	Object.defineProperty(URL$4.prototype, "href", {
		get() {
			return this[impl].href;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].href = V;
		},
		enumerable: true,
		configurable: true
	});
	URL$4.prototype.toString = function() {
		if (!this || !module.exports.is(this)) throw new TypeError("Illegal invocation");
		return this.href;
	};
	Object.defineProperty(URL$4.prototype, "origin", {
		get() {
			return this[impl].origin;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$4.prototype, "protocol", {
		get() {
			return this[impl].protocol;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].protocol = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$4.prototype, "username", {
		get() {
			return this[impl].username;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].username = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$4.prototype, "password", {
		get() {
			return this[impl].password;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].password = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$4.prototype, "host", {
		get() {
			return this[impl].host;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].host = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$4.prototype, "hostname", {
		get() {
			return this[impl].hostname;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].hostname = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$4.prototype, "port", {
		get() {
			return this[impl].port;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].port = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$4.prototype, "pathname", {
		get() {
			return this[impl].pathname;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].pathname = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$4.prototype, "search", {
		get() {
			return this[impl].search;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].search = V;
		},
		enumerable: true,
		configurable: true
	});
	Object.defineProperty(URL$4.prototype, "hash", {
		get() {
			return this[impl].hash;
		},
		set(V) {
			V = conversions["USVString"](V);
			this[impl].hash = V;
		},
		enumerable: true,
		configurable: true
	});
	module.exports = {
		is(obj) {
			return !!obj && obj[impl] instanceof Impl.implementation;
		},
		create(constructorArgs, privateData) {
			let obj = Object.create(URL$4.prototype);
			this.setup(obj, constructorArgs, privateData);
			return obj;
		},
		setup(obj, constructorArgs, privateData) {
			if (!privateData) privateData = {};
			privateData.wrapper = obj;
			obj[impl] = new Impl.implementation(constructorArgs, privateData);
			obj[impl][utils.wrapperSymbol] = obj;
		},
		interface: URL$4,
		expose: {
			Window: { URL: URL$4 },
			Worker: { URL: URL$4 }
		}
	};
} });

//#endregion
//#region node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({ "node_modules/whatwg-url/lib/public-api.js"(exports) {
	exports.URL = require_URL().interface;
	exports.serializeURL = require_url_state_machine().serializeURL;
	exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
	exports.basicURLParse = require_url_state_machine().basicURLParse;
	exports.setTheUsername = require_url_state_machine().setTheUsername;
	exports.setThePassword = require_url_state_machine().setThePassword;
	exports.serializeHost = require_url_state_machine().serializeHost;
	exports.serializeInteger = require_url_state_machine().serializeInteger;
	exports.parseURL = require_url_state_machine().parseURL;
} });

//#endregion
//#region node_modules/node-fetch/lib/index.js
var require_lib = __commonJS({ "node_modules/node-fetch/lib/index.js"(exports, module) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function _interopDefault(ex) {
		return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
	}
	var Stream$3 = _interopDefault(require("stream"));
	var http$4 = _interopDefault(require("http"));
	var Url = _interopDefault(require("url"));
	var whatwgUrl = _interopDefault(require_public_api());
	var https$2 = _interopDefault(require("https"));
	var zlib$1 = _interopDefault(require("zlib"));
	const Readable$1 = Stream$3.Readable;
	const BUFFER = Symbol("buffer");
	const TYPE = Symbol("type");
	var Blob$1 = class Blob$1 {
		constructor() {
			this[TYPE] = "";
			const blobParts = arguments[0];
			const options = arguments[1];
			const buffers = [];
			let size = 0;
			if (blobParts) {
				const a$1 = blobParts;
				const length = Number(a$1.length);
				for (let i$1 = 0; i$1 < length; i$1++) {
					const element = a$1[i$1];
					let buffer$1;
					if (element instanceof Buffer) buffer$1 = element;
					else if (ArrayBuffer.isView(element)) buffer$1 = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
					else if (element instanceof ArrayBuffer) buffer$1 = Buffer.from(element);
					else if (element instanceof Blob$1) buffer$1 = element[BUFFER];
					else buffer$1 = Buffer.from(typeof element === "string" ? element : String(element));
					size += buffer$1.length;
					buffers.push(buffer$1);
				}
			}
			this[BUFFER] = Buffer.concat(buffers);
			let type = options && options.type !== void 0 && String(options.type).toLowerCase();
			if (type && !/[^\u0020-\u007E]/.test(type)) this[TYPE] = type;
		}
		get size() {
			return this[BUFFER].length;
		}
		get type() {
			return this[TYPE];
		}
		text() {
			return Promise.resolve(this[BUFFER].toString());
		}
		arrayBuffer() {
			const buf = this[BUFFER];
			const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
			return Promise.resolve(ab);
		}
		stream() {
			const readable = new Readable$1();
			readable._read = function() {};
			readable.push(this[BUFFER]);
			readable.push(null);
			return readable;
		}
		toString() {
			return "[object Blob]";
		}
		slice() {
			const size = this.size;
			const start = arguments[0];
			const end = arguments[1];
			let relativeStart, relativeEnd;
			if (start === void 0) relativeStart = 0;
			else if (start < 0) relativeStart = Math.max(size + start, 0);
			else relativeStart = Math.min(start, size);
			if (end === void 0) relativeEnd = size;
			else if (end < 0) relativeEnd = Math.max(size + end, 0);
			else relativeEnd = Math.min(end, size);
			const span = Math.max(relativeEnd - relativeStart, 0);
			const buffer$1 = this[BUFFER];
			const slicedBuffer = buffer$1.slice(relativeStart, relativeStart + span);
			const blob = new Blob$1([], { type: arguments[2] });
			blob[BUFFER] = slicedBuffer;
			return blob;
		}
	};
	Object.defineProperties(Blob$1.prototype, {
		size: { enumerable: true },
		type: { enumerable: true },
		slice: { enumerable: true }
	});
	Object.defineProperty(Blob$1.prototype, Symbol.toStringTag, {
		value: "Blob",
		writable: false,
		enumerable: false,
		configurable: true
	});
	/**
	* fetch-error.js
	*
	* FetchError interface for operational errors
	*/
	/**
	* Create FetchError instance
	*
	* @param   String      message      Error message for human
	* @param   String      type         Error type for machine
	* @param   String      systemError  For Node.js system error
	* @return  FetchError
	*/
	function FetchError(message, type, systemError) {
		Error.call(this, message);
		this.message = message;
		this.type = type;
		if (systemError) this.code = this.errno = systemError.code;
		Error.captureStackTrace(this, this.constructor);
	}
	FetchError.prototype = Object.create(Error.prototype);
	FetchError.prototype.constructor = FetchError;
	FetchError.prototype.name = "FetchError";
	let convert;
	try {
		convert = require("encoding").convert;
	} catch (e) {}
	const INTERNALS = Symbol("Body internals");
	const PassThrough = Stream$3.PassThrough;
	/**
	* Body mixin
	*
	* Ref: https://fetch.spec.whatwg.org/#body
	*
	* @param   Stream  body  Readable stream
	* @param   Object  opts  Response options
	* @return  Void
	*/
	function Body(body) {
		var _this = this;
		var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
		let size = _ref$size === void 0 ? 0 : _ref$size;
		var _ref$timeout = _ref.timeout;
		let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
		if (body == null) body = null;
		else if (isURLSearchParams(body)) body = Buffer.from(body.toString());
		else if (isBlob$3(body));
		else if (Buffer.isBuffer(body));
		else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") body = Buffer.from(body);
		else if (ArrayBuffer.isView(body)) body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
		else if (body instanceof Stream$3);
		else body = Buffer.from(String(body));
		this[INTERNALS] = {
			body,
			disturbed: false,
			error: null
		};
		this.size = size;
		this.timeout = timeout;
		if (body instanceof Stream$3) body.on("error", function(err) {
			const error$1 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
			_this[INTERNALS].error = error$1;
		});
	}
	Body.prototype = {
		get body() {
			return this[INTERNALS].body;
		},
		get bodyUsed() {
			return this[INTERNALS].disturbed;
		},
		arrayBuffer() {
			return consumeBody.call(this).then(function(buf) {
				return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
			});
		},
		blob() {
			let ct = this.headers && this.headers.get("content-type") || "";
			return consumeBody.call(this).then(function(buf) {
				return Object.assign(
					// Prevent copying
					new Blob$1([], { type: ct.toLowerCase() }),
					{ [BUFFER]: buf }
);
			});
		},
		json() {
			var _this2 = this;
			return consumeBody.call(this).then(function(buffer$1) {
				try {
					return JSON.parse(buffer$1.toString());
				} catch (err) {
					return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
				}
			});
		},
		text() {
			return consumeBody.call(this).then(function(buffer$1) {
				return buffer$1.toString();
			});
		},
		buffer() {
			return consumeBody.call(this);
		},
		textConverted() {
			var _this3 = this;
			return consumeBody.call(this).then(function(buffer$1) {
				return convertBody(buffer$1, _this3.headers);
			});
		}
	};
	Object.defineProperties(Body.prototype, {
		body: { enumerable: true },
		bodyUsed: { enumerable: true },
		arrayBuffer: { enumerable: true },
		blob: { enumerable: true },
		json: { enumerable: true },
		text: { enumerable: true }
	});
	Body.mixIn = function(proto) {
		for (const name of Object.getOwnPropertyNames(Body.prototype))
 // istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	};
	/**
	* Consume and convert an entire Body to a Buffer.
	*
	* Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
	*
	* @return  Promise
	*/
	function consumeBody() {
		var _this4 = this;
		if (this[INTERNALS].disturbed) return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
		this[INTERNALS].disturbed = true;
		if (this[INTERNALS].error) return Body.Promise.reject(this[INTERNALS].error);
		let body = this.body;
		if (body === null) return Body.Promise.resolve(Buffer.alloc(0));
		if (isBlob$3(body)) body = body.stream();
		if (Buffer.isBuffer(body)) return Body.Promise.resolve(body);
		// istanbul ignore if: should never happen
		if (!(body instanceof Stream$3)) return Body.Promise.resolve(Buffer.alloc(0));
		let accum = [];
		let accumBytes = 0;
		let abort$1 = false;
		return new Body.Promise(function(resolve, reject) {
			let resTimeout;
			if (_this4.timeout) resTimeout = setTimeout(function() {
				abort$1 = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
			}, _this4.timeout);
			body.on("error", function(err) {
				if (err.name === "AbortError") {
					abort$1 = true;
					reject(err);
				} else reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
			});
			body.on("data", function(chunk) {
				if (abort$1 || chunk === null) return;
				if (_this4.size && accumBytes + chunk.length > _this4.size) {
					abort$1 = true;
					reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
					return;
				}
				accumBytes += chunk.length;
				accum.push(chunk);
			});
			body.on("end", function() {
				if (abort$1) return;
				clearTimeout(resTimeout);
				try {
					resolve(Buffer.concat(accum, accumBytes));
				} catch (err) {
					reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
				}
			});
		});
	}
	/**
	* Detect buffer encoding and convert to target encoding
	* ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
	*
	* @param   Buffer  buffer    Incoming buffer
	* @param   String  encoding  Target encoding
	* @return  String
	*/
	function convertBody(buffer$1, headers) {
		if (typeof convert !== "function") throw new Error("The package `encoding` must be installed to use the textConverted() function");
		const ct = headers.get("content-type");
		let charset = "utf-8";
		let res, str;
		if (ct) res = /charset=([^;]*)/i.exec(ct);
		str = buffer$1.slice(0, 1024).toString();
		if (!res && str) res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
		if (!res && str) {
			res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
			if (!res) {
				res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
				if (res) res.pop();
			}
			if (res) res = /charset=(.*)/i.exec(res.pop());
		}
		if (!res && str) res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
		if (res) {
			charset = res.pop();
			if (charset === "gb2312" || charset === "gbk") charset = "gb18030";
		}
		return convert(buffer$1, "UTF-8", charset).toString();
	}
	/**
	* Detect a URLSearchParams object
	* ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
	*
	* @param   Object  obj     Object to detect by type or brand
	* @return  String
	*/
	function isURLSearchParams(obj) {
		if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") return false;
		return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
	}
	/**
	* Check if `obj` is a W3C `Blob` object (which `File` inherits from)
	* @param  {*} obj
	* @return {boolean}
	*/
	function isBlob$3(obj) {
		return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
	}
	/**
	* Clone body given Res/Req instance
	*
	* @param   Mixed  instance  Response or Request instance
	* @return  Mixed
	*/
	function clone(instance$1) {
		let p1, p2;
		let body = instance$1.body;
		if (instance$1.bodyUsed) throw new Error("cannot clone body after it is used");
		if (body instanceof Stream$3 && typeof body.getBoundary !== "function") {
			p1 = new PassThrough();
			p2 = new PassThrough();
			body.pipe(p1);
			body.pipe(p2);
			instance$1[INTERNALS].body = p1;
			body = p2;
		}
		return body;
	}
	/**
	* Performs the operation "extract a `Content-Type` value from |object|" as
	* specified in the specification:
	* https://fetch.spec.whatwg.org/#concept-bodyinit-extract
	*
	* This function assumes that instance.body is present.
	*
	* @param   Mixed  instance  Any options.body input
	*/
	function extractContentType(body) {
		if (body === null) return null;
		else if (typeof body === "string") return "text/plain;charset=UTF-8";
		else if (isURLSearchParams(body)) return "application/x-www-form-urlencoded;charset=UTF-8";
		else if (isBlob$3(body)) return body.type || null;
		else if (Buffer.isBuffer(body)) return null;
		else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") return null;
		else if (ArrayBuffer.isView(body)) return null;
		else if (typeof body.getBoundary === "function") return `multipart/form-data;boundary=${body.getBoundary()}`;
		else if (body instanceof Stream$3) return null;
		else return "text/plain;charset=UTF-8";
	}
	/**
	* The Fetch Standard treats this as if "total bytes" is a property on the body.
	* For us, we have to explicitly get it with a function.
	*
	* ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
	*
	* @param   Body    instance   Instance of Body
	* @return  Number?            Number of bytes, or null if not possible
	*/
	function getTotalBytes(instance$1) {
		const body = instance$1.body;
		if (body === null) return 0;
		else if (isBlob$3(body)) return body.size;
		else if (Buffer.isBuffer(body)) return body.length;
		else if (body && typeof body.getLengthSync === "function") {
			if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) return body.getLengthSync();
			return null;
		} else return null;
	}
	/**
	* Write a Body to a Node.js WritableStream (e.g. http.Request) object.
	*
	* @param   Body    instance   Instance of Body
	* @return  Void
	*/
	function writeToStream(dest, instance$1) {
		const body = instance$1.body;
		if (body === null) dest.end();
		else if (isBlob$3(body)) body.stream().pipe(dest);
		else if (Buffer.isBuffer(body)) {
			dest.write(body);
			dest.end();
		} else body.pipe(dest);
	}
	Body.Promise = global.Promise;
	/**
	* headers.js
	*
	* Headers class offers convenient helpers
	*/
	const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
	const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
	function validateName(name) {
		name = `${name}`;
		if (invalidTokenRegex.test(name) || name === "") throw new TypeError(`${name} is not a legal HTTP header name`);
	}
	function validateValue(value) {
		value = `${value}`;
		if (invalidHeaderCharRegex.test(value)) throw new TypeError(`${value} is not a legal HTTP header value`);
	}
	/**
	* Find the key in the map object given a header name.
	*
	* Returns undefined if not found.
	*
	* @param   String  name  Header name
	* @return  String|Undefined
	*/
	function find(map, name) {
		name = name.toLowerCase();
		for (const key in map) if (key.toLowerCase() === name) return key;
		return void 0;
	}
	const MAP = Symbol("map");
	var Headers$1 = class Headers$1 {
		/**
		* Headers class
		*
		* @param   Object  headers  Response headers
		* @return  Void
		*/
		constructor() {
			let init$1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
			this[MAP] = Object.create(null);
			if (init$1 instanceof Headers$1) {
				const rawHeaders = init$1.raw();
				const headerNames = Object.keys(rawHeaders);
				for (const headerName of headerNames) for (const value of rawHeaders[headerName]) this.append(headerName, value);
				return;
			}
			if (init$1 == null);
			else if (typeof init$1 === "object") {
				const method = init$1[Symbol.iterator];
				if (method != null) {
					if (typeof method !== "function") throw new TypeError("Header pairs must be iterable");
					const pairs = [];
					for (const pair of init$1) {
						if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") throw new TypeError("Each header pair must be iterable");
						pairs.push(Array.from(pair));
					}
					for (const pair of pairs) {
						if (pair.length !== 2) throw new TypeError("Each header pair must be a name/value tuple");
						this.append(pair[0], pair[1]);
					}
				} else for (const key of Object.keys(init$1)) {
					const value = init$1[key];
					this.append(key, value);
				}
			} else throw new TypeError("Provided initializer must be an object");
		}
		/**
		* Return combined header value given name
		*
		* @param   String  name  Header name
		* @return  Mixed
		*/
		get(name) {
			name = `${name}`;
			validateName(name);
			const key = find(this[MAP], name);
			if (key === void 0) return null;
			return this[MAP][key].join(", ");
		}
		/**
		* Iterate over all headers
		*
		* @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
		* @param   Boolean   thisArg   `this` context for callback function
		* @return  Void
		*/
		forEach(callback) {
			let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
			let pairs = getHeaders(this);
			let i$1 = 0;
			while (i$1 < pairs.length) {
				var _pairs$i = pairs[i$1];
				const name = _pairs$i[0], value = _pairs$i[1];
				callback.call(thisArg, value, name, this);
				pairs = getHeaders(this);
				i$1++;
			}
		}
		/**
		* Overwrite header values given name
		*
		* @param   String  name   Header name
		* @param   String  value  Header value
		* @return  Void
		*/
		set(name, value) {
			name = `${name}`;
			value = `${value}`;
			validateName(name);
			validateValue(value);
			const key = find(this[MAP], name);
			this[MAP][key !== void 0 ? key : name] = [value];
		}
		/**
		* Append a value onto existing header
		*
		* @param   String  name   Header name
		* @param   String  value  Header value
		* @return  Void
		*/
		append(name, value) {
			name = `${name}`;
			value = `${value}`;
			validateName(name);
			validateValue(value);
			const key = find(this[MAP], name);
			if (key !== void 0) this[MAP][key].push(value);
			else this[MAP][name] = [value];
		}
		/**
		* Check for header name existence
		*
		* @param   String   name  Header name
		* @return  Boolean
		*/
		has(name) {
			name = `${name}`;
			validateName(name);
			return find(this[MAP], name) !== void 0;
		}
		/**
		* Delete all header values given name
		*
		* @param   String  name  Header name
		* @return  Void
		*/
		delete(name) {
			name = `${name}`;
			validateName(name);
			const key = find(this[MAP], name);
			if (key !== void 0) delete this[MAP][key];
		}
		/**
		* Return raw headers (non-spec api)
		*
		* @return  Object
		*/
		raw() {
			return this[MAP];
		}
		/**
		* Get an iterator on keys.
		*
		* @return  Iterator
		*/
		keys() {
			return createHeadersIterator(this, "key");
		}
		/**
		* Get an iterator on values.
		*
		* @return  Iterator
		*/
		values() {
			return createHeadersIterator(this, "value");
		}
		/**
		* Get an iterator on entries.
		*
		* This is the default iterator of the Headers object.
		*
		* @return  Iterator
		*/
		[Symbol.iterator]() {
			return createHeadersIterator(this, "key+value");
		}
	};
	Headers$1.prototype.entries = Headers$1.prototype[Symbol.iterator];
	Object.defineProperty(Headers$1.prototype, Symbol.toStringTag, {
		value: "Headers",
		writable: false,
		enumerable: false,
		configurable: true
	});
	Object.defineProperties(Headers$1.prototype, {
		get: { enumerable: true },
		forEach: { enumerable: true },
		set: { enumerable: true },
		append: { enumerable: true },
		has: { enumerable: true },
		delete: { enumerable: true },
		keys: { enumerable: true },
		values: { enumerable: true },
		entries: { enumerable: true }
	});
	function getHeaders(headers) {
		let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
		const keys = Object.keys(headers[MAP]).sort();
		return keys.map(kind === "key" ? function(k) {
			return k.toLowerCase();
		} : kind === "value" ? function(k) {
			return headers[MAP][k].join(", ");
		} : function(k) {
			return [k.toLowerCase(), headers[MAP][k].join(", ")];
		});
	}
	const INTERNAL$1 = Symbol("internal");
	function createHeadersIterator(target, kind) {
		const iterator$1 = Object.create(HeadersIteratorPrototype);
		iterator$1[INTERNAL$1] = {
			target,
			kind,
			index: 0
		};
		return iterator$1;
	}
	const HeadersIteratorPrototype = Object.setPrototypeOf({ next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) throw new TypeError("Value of `this` is not a HeadersIterator");
		var _INTERNAL = this[INTERNAL$1];
		const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
		const values = getHeaders(target, kind);
		const len$1 = values.length;
		if (index >= len$1) return {
			value: void 0,
			done: true
		};
		this[INTERNAL$1].index = index + 1;
		return {
			value: values[index],
			done: false
		};
	} }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
	Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
		value: "HeadersIterator",
		writable: false,
		enumerable: false,
		configurable: true
	});
	/**
	* Export the Headers object in a form that Node.js can consume.
	*
	* @param   Headers  headers
	* @return  Object
	*/
	function exportNodeCompatibleHeaders(headers) {
		const obj = Object.assign({ __proto__: null }, headers[MAP]);
		const hostHeaderKey = find(headers[MAP], "Host");
		if (hostHeaderKey !== void 0) obj[hostHeaderKey] = obj[hostHeaderKey][0];
		return obj;
	}
	/**
	* Create a Headers object from an object of headers, ignoring those that do
	* not conform to HTTP grammar productions.
	*
	* @param   Object  obj  Object of headers
	* @return  Headers
	*/
	function createHeadersLenient(obj) {
		const headers = new Headers$1();
		for (const name of Object.keys(obj)) {
			if (invalidTokenRegex.test(name)) continue;
			if (Array.isArray(obj[name])) for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) continue;
				if (headers[MAP][name] === void 0) headers[MAP][name] = [val];
				else headers[MAP][name].push(val);
			}
			else if (!invalidHeaderCharRegex.test(obj[name])) headers[MAP][name] = [obj[name]];
		}
		return headers;
	}
	const INTERNALS$1 = Symbol("Response internals");
	const STATUS_CODES = http$4.STATUS_CODES;
	/**
	* Response class
	*
	* @param   Stream  body  Readable stream
	* @param   Object  opts  Response options
	* @return  Void
	*/
	var Response$1 = class Response$1 {
		constructor() {
			let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
			let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			Body.call(this, body, opts);
			const status = opts.status || 200;
			const headers = new Headers$1(opts.headers);
			if (body != null && !headers.has("Content-Type")) {
				const contentType = extractContentType(body);
				if (contentType) headers.append("Content-Type", contentType);
			}
			this[INTERNALS$1] = {
				url: opts.url,
				status,
				statusText: opts.statusText || STATUS_CODES[status],
				headers,
				counter: opts.counter
			};
		}
		get url() {
			return this[INTERNALS$1].url || "";
		}
		get status() {
			return this[INTERNALS$1].status;
		}
		/**
		* Convenience property representing if the request ended normally
		*/
		get ok() {
			return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
		}
		get redirected() {
			return this[INTERNALS$1].counter > 0;
		}
		get statusText() {
			return this[INTERNALS$1].statusText;
		}
		get headers() {
			return this[INTERNALS$1].headers;
		}
		/**
		* Clone this response
		*
		* @return  Response
		*/
		clone() {
			return new Response$1(clone(this), {
				url: this.url,
				status: this.status,
				statusText: this.statusText,
				headers: this.headers,
				ok: this.ok,
				redirected: this.redirected
			});
		}
	};
	Body.mixIn(Response$1.prototype);
	Object.defineProperties(Response$1.prototype, {
		url: { enumerable: true },
		status: { enumerable: true },
		ok: { enumerable: true },
		redirected: { enumerable: true },
		statusText: { enumerable: true },
		headers: { enumerable: true },
		clone: { enumerable: true }
	});
	Object.defineProperty(Response$1.prototype, Symbol.toStringTag, {
		value: "Response",
		writable: false,
		enumerable: false,
		configurable: true
	});
	const INTERNALS$2 = Symbol("Request internals");
	const URL$3 = Url.URL || whatwgUrl.URL;
	const parse_url = Url.parse;
	const format_url = Url.format;
	/**
	* Wrapper around `new URL` to handle arbitrary URLs
	*
	* @param  {string} urlStr
	* @return {void}
	*/
	function parseURL(urlStr) {
		if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) urlStr = new URL$3(urlStr).toString();
		return parse_url(urlStr);
	}
	const streamDestructionSupported = "destroy" in Stream$3.Readable.prototype;
	/**
	* Check if a value is an instance of Request.
	*
	* @param   Mixed   input
	* @return  Boolean
	*/
	function isRequest(input) {
		return typeof input === "object" && typeof input[INTERNALS$2] === "object";
	}
	function isAbortSignal(signal) {
		const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
		return !!(proto && proto.constructor.name === "AbortSignal");
	}
	/**
	* Request class
	*
	* @param   Mixed   input  Url or Request instance
	* @param   Object  init   Custom options
	* @return  Void
	*/
	var Request = class Request {
		constructor(input) {
			let init$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			let parsedURL;
			if (!isRequest(input)) {
				if (input && input.href) parsedURL = parseURL(input.href);
				else parsedURL = parseURL(`${input}`);
				input = {};
			} else parsedURL = parseURL(input.url);
			let method = init$1.method || input.method || "GET";
			method = method.toUpperCase();
			if ((init$1.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body");
			let inputBody = init$1.body != null ? init$1.body : isRequest(input) && input.body !== null ? clone(input) : null;
			Body.call(this, inputBody, {
				timeout: init$1.timeout || input.timeout || 0,
				size: init$1.size || input.size || 0
			});
			const headers = new Headers$1(init$1.headers || input.headers || {});
			if (inputBody != null && !headers.has("Content-Type")) {
				const contentType = extractContentType(inputBody);
				if (contentType) headers.append("Content-Type", contentType);
			}
			let signal = isRequest(input) ? input.signal : null;
			if ("signal" in init$1) signal = init$1.signal;
			if (signal != null && !isAbortSignal(signal)) throw new TypeError("Expected signal to be an instanceof AbortSignal");
			this[INTERNALS$2] = {
				method,
				redirect: init$1.redirect || input.redirect || "follow",
				headers,
				parsedURL,
				signal
			};
			this.follow = init$1.follow !== void 0 ? init$1.follow : input.follow !== void 0 ? input.follow : 20;
			this.compress = init$1.compress !== void 0 ? init$1.compress : input.compress !== void 0 ? input.compress : true;
			this.counter = init$1.counter || input.counter || 0;
			this.agent = init$1.agent || input.agent;
		}
		get method() {
			return this[INTERNALS$2].method;
		}
		get url() {
			return format_url(this[INTERNALS$2].parsedURL);
		}
		get headers() {
			return this[INTERNALS$2].headers;
		}
		get redirect() {
			return this[INTERNALS$2].redirect;
		}
		get signal() {
			return this[INTERNALS$2].signal;
		}
		/**
		* Clone this request
		*
		* @return  Request
		*/
		clone() {
			return new Request(this);
		}
	};
	Body.mixIn(Request.prototype);
	Object.defineProperty(Request.prototype, Symbol.toStringTag, {
		value: "Request",
		writable: false,
		enumerable: false,
		configurable: true
	});
	Object.defineProperties(Request.prototype, {
		method: { enumerable: true },
		url: { enumerable: true },
		headers: { enumerable: true },
		redirect: { enumerable: true },
		clone: { enumerable: true },
		signal: { enumerable: true }
	});
	/**
	* Convert a Request to Node.js http request options.
	*
	* @param   Request  A Request instance
	* @return  Object   The options object to be passed to http.request
	*/
	function getNodeRequestOptions(request$3) {
		const parsedURL = request$3[INTERNALS$2].parsedURL;
		const headers = new Headers$1(request$3[INTERNALS$2].headers);
		if (!headers.has("Accept")) headers.set("Accept", "*/*");
		if (!parsedURL.protocol || !parsedURL.hostname) throw new TypeError("Only absolute URLs are supported");
		if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError("Only HTTP(S) protocols are supported");
		if (request$3.signal && request$3.body instanceof Stream$3.Readable && !streamDestructionSupported) throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
		let contentLengthValue = null;
		if (request$3.body == null && /^(POST|PUT)$/i.test(request$3.method)) contentLengthValue = "0";
		if (request$3.body != null) {
			const totalBytes = getTotalBytes(request$3);
			if (typeof totalBytes === "number") contentLengthValue = String(totalBytes);
		}
		if (contentLengthValue) headers.set("Content-Length", contentLengthValue);
		if (!headers.has("User-Agent")) headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
		if (request$3.compress && !headers.has("Accept-Encoding")) headers.set("Accept-Encoding", "gzip,deflate");
		let agent = request$3.agent;
		if (typeof agent === "function") agent = agent(parsedURL);
		return Object.assign({}, parsedURL, {
			method: request$3.method,
			headers: exportNodeCompatibleHeaders(headers),
			agent
		});
	}
	/**
	* abort-error.js
	*
	* AbortError interface for cancelled requests
	*/
	/**
	* Create AbortError instance
	*
	* @param   String      message      Error message for human
	* @return  AbortError
	*/
	function AbortError(message) {
		Error.call(this, message);
		this.type = "aborted";
		this.message = message;
		Error.captureStackTrace(this, this.constructor);
	}
	AbortError.prototype = Object.create(Error.prototype);
	AbortError.prototype.constructor = AbortError;
	AbortError.prototype.name = "AbortError";
	const URL$1$1 = Url.URL || whatwgUrl.URL;
	const PassThrough$1 = Stream$3.PassThrough;
	const isDomainOrSubdomain = function isDomainOrSubdomain$1(destination, original) {
		const orig = new URL$1$1(original).hostname;
		const dest = new URL$1$1(destination).hostname;
		return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
	};
	/**
	* isSameProtocol reports whether the two provided URLs use the same protocol.
	*
	* Both domains must already be in canonical form.
	* @param {string|URL} original
	* @param {string|URL} destination
	*/
	const isSameProtocol = function isSameProtocol$1(destination, original) {
		const orig = new URL$1$1(original).protocol;
		const dest = new URL$1$1(destination).protocol;
		return orig === dest;
	};
	/**
	* Fetch function
	*
	* @param   Mixed    url   Absolute url or Request instance
	* @param   Object   opts  Fetch options
	* @return  Promise
	*/
	function fetch$2(url, opts) {
		if (!fetch$2.Promise) throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
		Body.Promise = fetch$2.Promise;
		return new fetch$2.Promise(function(resolve, reject) {
			const request$3 = new Request(url, opts);
			const options = getNodeRequestOptions(request$3);
			const send = (options.protocol === "https:" ? https$2 : http$4).request;
			const signal = request$3.signal;
			let response = null;
			const abort$1 = function abort$2() {
				let error$1 = new AbortError("The user aborted a request.");
				reject(error$1);
				if (request$3.body && request$3.body instanceof Stream$3.Readable) destroyStream(request$3.body, error$1);
				if (!response || !response.body) return;
				response.body.emit("error", error$1);
			};
			if (signal && signal.aborted) {
				abort$1();
				return;
			}
			const abortAndFinalize = function abortAndFinalize$1() {
				abort$1();
				finalize();
			};
			const req$1 = send(options);
			let reqTimeout;
			if (signal) signal.addEventListener("abort", abortAndFinalize);
			function finalize() {
				req$1.abort();
				if (signal) signal.removeEventListener("abort", abortAndFinalize);
				clearTimeout(reqTimeout);
			}
			if (request$3.timeout) req$1.once("socket", function(socket) {
				reqTimeout = setTimeout(function() {
					reject(new FetchError(`network timeout at: ${request$3.url}`, "request-timeout"));
					finalize();
				}, request$3.timeout);
			});
			req$1.on("error", function(err) {
				reject(new FetchError(`request to ${request$3.url} failed, reason: ${err.message}`, "system", err));
				if (response && response.body) destroyStream(response.body, err);
				finalize();
			});
			fixResponseChunkedTransferBadEnding(req$1, function(err) {
				if (signal && signal.aborted) return;
				if (response && response.body) destroyStream(response.body, err);
			});
			/* c8 ignore next 18 */
			if (parseInt(process.version.substring(1)) < 14) req$1.on("socket", function(s$1) {
				s$1.addListener("close", function(hadError) {
					const hasDataListener = s$1.listenerCount("data") > 0;
					if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
						const err = new Error("Premature close");
						err.code = "ERR_STREAM_PREMATURE_CLOSE";
						response.body.emit("error", err);
					}
				});
			});
			req$1.on("response", function(res) {
				clearTimeout(reqTimeout);
				const headers = createHeadersLenient(res.headers);
				if (fetch$2.isRedirect(res.statusCode)) {
					const location = headers.get("Location");
					let locationURL = null;
					try {
						locationURL = location === null ? null : new URL$1$1(location, request$3.url).toString();
					} catch (err) {
						if (request$3.redirect !== "manual") {
							reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
							finalize();
							return;
						}
					}
					switch (request$3.redirect) {
						case "error":
							reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request$3.url}`, "no-redirect"));
							finalize();
							return;
						case "manual":
							if (locationURL !== null) try {
								headers.set("Location", locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
							break;
						case "follow":
							if (locationURL === null) break;
							if (request$3.counter >= request$3.follow) {
								reject(new FetchError(`maximum redirect reached at: ${request$3.url}`, "max-redirect"));
								finalize();
								return;
							}
							const requestOpts = {
								headers: new Headers$1(request$3.headers),
								follow: request$3.follow,
								counter: request$3.counter + 1,
								agent: request$3.agent,
								compress: request$3.compress,
								method: request$3.method,
								body: request$3.body,
								signal: request$3.signal,
								timeout: request$3.timeout,
								size: request$3.size
							};
							if (!isDomainOrSubdomain(request$3.url, locationURL) || !isSameProtocol(request$3.url, locationURL)) for (const name of [
								"authorization",
								"www-authenticate",
								"cookie",
								"cookie2"
							]) requestOpts.headers.delete(name);
							if (res.statusCode !== 303 && request$3.body && getTotalBytes(request$3) === null) {
								reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
								finalize();
								return;
							}
							if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request$3.method === "POST") {
								requestOpts.method = "GET";
								requestOpts.body = void 0;
								requestOpts.headers.delete("content-length");
							}
							resolve(fetch$2(new Request(locationURL, requestOpts)));
							finalize();
							return;
					}
				}
				res.once("end", function() {
					if (signal) signal.removeEventListener("abort", abortAndFinalize);
				});
				let body = res.pipe(new PassThrough$1());
				const response_options = {
					url: request$3.url,
					status: res.statusCode,
					statusText: res.statusMessage,
					headers,
					size: request$3.size,
					timeout: request$3.timeout,
					counter: request$3.counter
				};
				const codings = headers.get("Content-Encoding");
				if (!request$3.compress || request$3.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
					response = new Response$1(body, response_options);
					resolve(response);
					return;
				}
				const zlibOptions = {
					flush: zlib$1.Z_SYNC_FLUSH,
					finishFlush: zlib$1.Z_SYNC_FLUSH
				};
				if (codings == "gzip" || codings == "x-gzip") {
					body = body.pipe(zlib$1.createGunzip(zlibOptions));
					response = new Response$1(body, response_options);
					resolve(response);
					return;
				}
				if (codings == "deflate" || codings == "x-deflate") {
					const raw = res.pipe(new PassThrough$1());
					raw.once("data", function(chunk) {
						if ((chunk[0] & 15) === 8) body = body.pipe(zlib$1.createInflate());
						else body = body.pipe(zlib$1.createInflateRaw());
						response = new Response$1(body, response_options);
						resolve(response);
					});
					raw.on("end", function() {
						if (!response) {
							response = new Response$1(body, response_options);
							resolve(response);
						}
					});
					return;
				}
				if (codings == "br" && typeof zlib$1.createBrotliDecompress === "function") {
					body = body.pipe(zlib$1.createBrotliDecompress());
					response = new Response$1(body, response_options);
					resolve(response);
					return;
				}
				response = new Response$1(body, response_options);
				resolve(response);
			});
			writeToStream(req$1, request$3);
		});
	}
	function fixResponseChunkedTransferBadEnding(request$3, errorCallback) {
		let socket;
		request$3.on("socket", function(s$1) {
			socket = s$1;
		});
		request$3.on("response", function(response) {
			const headers = response.headers;
			if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) response.once("close", function(hadError) {
				const hasDataListener = socket && socket.listenerCount("data") > 0;
				if (hasDataListener && !hadError) {
					const err = new Error("Premature close");
					err.code = "ERR_STREAM_PREMATURE_CLOSE";
					errorCallback(err);
				}
			});
		});
	}
	function destroyStream(stream$6, err) {
		if (stream$6.destroy) stream$6.destroy(err);
		else {
			stream$6.emit("error", err);
			stream$6.end();
		}
	}
	/**
	* Redirect code matching
	*
	* @param   Number   code  Status code
	* @return  Boolean
	*/
	fetch$2.isRedirect = function(code$1) {
		return code$1 === 301 || code$1 === 302 || code$1 === 303 || code$1 === 307 || code$1 === 308;
	};
	fetch$2.Promise = global.Promise;
	module.exports = exports = fetch$2;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = exports;
	exports.Headers = Headers$1;
	exports.Request = Request;
	exports.Response = Response$1;
	exports.FetchError = FetchError;
	exports.AbortError = AbortError;
} });

//#endregion
//#region node_modules/is-stream/index.js
var require_is_stream = __commonJS({ "node_modules/is-stream/index.js"(exports, module) {
	const isStream = (stream$6) => stream$6 !== null && typeof stream$6 === "object" && typeof stream$6.pipe === "function";
	isStream.writable = (stream$6) => isStream(stream$6) && stream$6.writable !== false && typeof stream$6._write === "function" && typeof stream$6._writableState === "object";
	isStream.readable = (stream$6) => isStream(stream$6) && stream$6.readable !== false && typeof stream$6._read === "function" && typeof stream$6._readableState === "object";
	isStream.duplex = (stream$6) => isStream.writable(stream$6) && isStream.readable(stream$6);
	isStream.transform = (stream$6) => isStream.duplex(stream$6) && typeof stream$6._transform === "function";
	module.exports = isStream;
} });

//#endregion
//#region node_modules/gaxios/package.json
var require_package$2 = __commonJS({ "node_modules/gaxios/package.json"(exports, module) {
	module.exports = {
		"name": "gaxios",
		"version": "6.7.1",
		"description": "A simple common HTTP client specifically for Google APIs and services.",
		"main": "build/src/index.js",
		"types": "build/src/index.d.ts",
		"files": ["build/src"],
		"scripts": {
			"lint": "gts check",
			"test": "c8 mocha build/test",
			"presystem-test": "npm run compile",
			"system-test": "mocha build/system-test --timeout 80000",
			"compile": "tsc -p .",
			"fix": "gts fix",
			"prepare": "npm run compile",
			"pretest": "npm run compile",
			"webpack": "webpack",
			"prebrowser-test": "npm run compile",
			"browser-test": "node build/browser-test/browser-test-runner.js",
			"docs": "compodoc src/",
			"docs-test": "linkinator docs",
			"predocs-test": "npm run docs",
			"samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
			"prelint": "cd samples; npm link ../; npm install",
			"clean": "gts clean",
			"precompile": "gts clean"
		},
		"repository": "googleapis/gaxios",
		"keywords": ["google"],
		"engines": { "node": ">=14" },
		"author": "Google, LLC",
		"license": "Apache-2.0",
		"devDependencies": {
			"@babel/plugin-proposal-private-methods": "^7.18.6",
			"@compodoc/compodoc": "1.1.19",
			"@types/cors": "^2.8.6",
			"@types/express": "^4.16.1",
			"@types/extend": "^3.0.1",
			"@types/mocha": "^9.0.0",
			"@types/multiparty": "0.0.36",
			"@types/mv": "^2.1.0",
			"@types/ncp": "^2.0.1",
			"@types/node": "^20.0.0",
			"@types/node-fetch": "^2.5.7",
			"@types/sinon": "^17.0.0",
			"@types/tmp": "0.2.6",
			"@types/uuid": "^10.0.0",
			"abort-controller": "^3.0.0",
			"assert": "^2.0.0",
			"browserify": "^17.0.0",
			"c8": "^8.0.0",
			"cheerio": "1.0.0-rc.10",
			"cors": "^2.8.5",
			"execa": "^5.0.0",
			"express": "^4.16.4",
			"form-data": "^4.0.0",
			"gts": "^5.0.0",
			"is-docker": "^2.0.0",
			"karma": "^6.0.0",
			"karma-chrome-launcher": "^3.0.0",
			"karma-coverage": "^2.0.0",
			"karma-firefox-launcher": "^2.0.0",
			"karma-mocha": "^2.0.0",
			"karma-remap-coverage": "^0.1.5",
			"karma-sourcemap-loader": "^0.4.0",
			"karma-webpack": "5.0.0",
			"linkinator": "^3.0.0",
			"mocha": "^8.0.0",
			"multiparty": "^4.2.1",
			"mv": "^2.1.1",
			"ncp": "^2.0.0",
			"nock": "^13.0.0",
			"null-loader": "^4.0.0",
			"puppeteer": "^19.0.0",
			"sinon": "^18.0.0",
			"stream-browserify": "^3.0.0",
			"tmp": "0.2.3",
			"ts-loader": "^8.0.0",
			"typescript": "^5.1.6",
			"webpack": "^5.35.0",
			"webpack-cli": "^4.0.0"
		},
		"dependencies": {
			"extend": "^3.0.2",
			"https-proxy-agent": "^7.0.1",
			"is-stream": "^2.0.0",
			"node-fetch": "^2.6.9",
			"uuid": "^9.0.1"
		}
	};
} });

//#endregion
//#region node_modules/gaxios/build/src/util.js
var require_util$1 = __commonJS({ "node_modules/gaxios/build/src/util.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.pkg = void 0;
	exports.pkg = require_package$2();
} });

//#endregion
//#region node_modules/gaxios/build/src/common.js
var require_common$1 = __commonJS({ "node_modules/gaxios/build/src/common.js"(exports) {
	var __importDefault$3 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	var _a$3;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GaxiosError = exports.GAXIOS_ERROR_SYMBOL = void 0;
	exports.defaultErrorRedactor = defaultErrorRedactor;
	const url_1$2 = require("url");
	const util_1$9 = require_util$1();
	const extend_1$1 = __importDefault$3(require_extend());
	/**
	* Support `instanceof` operator for `GaxiosError`s in different versions of this library.
	*
	* @see {@link GaxiosError[Symbol.hasInstance]}
	*/
	exports.GAXIOS_ERROR_SYMBOL = Symbol.for(`${util_1$9.pkg.name}-gaxios-error`);
	var GaxiosError = class GaxiosError extends Error {
		/**
		* Support `instanceof` operator for `GaxiosError` across builds/duplicated files.
		*
		* @see {@link GAXIOS_ERROR_SYMBOL}
		* @see {@link GaxiosError[GAXIOS_ERROR_SYMBOL]}
		*/
		static [(_a$3 = exports.GAXIOS_ERROR_SYMBOL, Symbol.hasInstance)](instance$1) {
			if (instance$1 && typeof instance$1 === "object" && exports.GAXIOS_ERROR_SYMBOL in instance$1 && instance$1[exports.GAXIOS_ERROR_SYMBOL] === util_1$9.pkg.version) return true;
			return Function.prototype[Symbol.hasInstance].call(GaxiosError, instance$1);
		}
		constructor(message, config$1, response, error$1) {
			var _b$1;
			super(message);
			this.config = config$1;
			this.response = response;
			this.error = error$1;
			/**
			* Support `instanceof` operator for `GaxiosError` across builds/duplicated files.
			*
			* @see {@link GAXIOS_ERROR_SYMBOL}
			* @see {@link GaxiosError[Symbol.hasInstance]}
			* @see {@link https://github.com/microsoft/TypeScript/issues/13965#issuecomment-278570200}
			* @see {@link https://stackoverflow.com/questions/46618852/require-and-instanceof}
			* @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/@@hasInstance#reverting_to_default_instanceof_behavior}
			*/
			this[_a$3] = util_1$9.pkg.version;
			this.config = (0, extend_1$1.default)(true, {}, config$1);
			if (this.response) this.response.config = (0, extend_1$1.default)(true, {}, this.response.config);
			if (this.response) {
				try {
					this.response.data = translateData(this.config.responseType, (_b$1 = this.response) === null || _b$1 === void 0 ? void 0 : _b$1.data);
				} catch (_c$1) {}
				this.status = this.response.status;
			}
			if (error$1 && "code" in error$1 && error$1.code) this.code = error$1.code;
			if (config$1.errorRedactor) config$1.errorRedactor({
				config: this.config,
				response: this.response
			});
		}
	};
	exports.GaxiosError = GaxiosError;
	function translateData(responseType, data) {
		switch (responseType) {
			case "stream": return data;
			case "json": return JSON.parse(JSON.stringify(data));
			case "arraybuffer": return JSON.parse(Buffer.from(data).toString("utf8"));
			case "blob": return JSON.parse(data.text());
			default: return data;
		}
	}
	/**
	* An experimental error redactor.
	*
	* @param config Config to potentially redact properties of
	* @param response Config to potentially redact properties of
	*
	* @experimental
	*/
	function defaultErrorRedactor(data) {
		const REDACT = "<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.";
		function redactHeaders(headers) {
			if (!headers) return;
			for (const key of Object.keys(headers)) {
				if (/^authentication$/i.test(key)) headers[key] = REDACT;
				if (/^authorization$/i.test(key)) headers[key] = REDACT;
				if (/secret/i.test(key)) headers[key] = REDACT;
			}
		}
		function redactString(obj, key) {
			if (typeof obj === "object" && obj !== null && typeof obj[key] === "string") {
				const text = obj[key];
				if (/grant_type=/i.test(text) || /assertion=/i.test(text) || /secret/i.test(text)) obj[key] = REDACT;
			}
		}
		function redactObject(obj) {
			if (typeof obj === "object" && obj !== null) {
				if ("grant_type" in obj) obj["grant_type"] = REDACT;
				if ("assertion" in obj) obj["assertion"] = REDACT;
				if ("client_secret" in obj) obj["client_secret"] = REDACT;
			}
		}
		if (data.config) {
			redactHeaders(data.config.headers);
			redactString(data.config, "data");
			redactObject(data.config.data);
			redactString(data.config, "body");
			redactObject(data.config.body);
			try {
				const url = new url_1$2.URL("", data.config.url);
				if (url.searchParams.has("token")) url.searchParams.set("token", REDACT);
				if (url.searchParams.has("client_secret")) url.searchParams.set("client_secret", REDACT);
				data.config.url = url.toString();
			} catch (_b$1) {}
		}
		if (data.response) {
			defaultErrorRedactor({ config: data.response.config });
			redactHeaders(data.response.headers);
			redactString(data.response, "data");
			redactObject(data.response.data);
		}
		return data;
	}
} });

//#endregion
//#region node_modules/gaxios/build/src/retry.js
var require_retry = __commonJS({ "node_modules/gaxios/build/src/retry.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRetryConfig = getRetryConfig;
	async function getRetryConfig(err) {
		let config$1 = getConfig(err);
		if (!err || !err.config || !config$1 && !err.config.retry) return { shouldRetry: false };
		config$1 = config$1 || {};
		config$1.currentRetryAttempt = config$1.currentRetryAttempt || 0;
		config$1.retry = config$1.retry === void 0 || config$1.retry === null ? 3 : config$1.retry;
		config$1.httpMethodsToRetry = config$1.httpMethodsToRetry || [
			"GET",
			"HEAD",
			"PUT",
			"OPTIONS",
			"DELETE"
		];
		config$1.noResponseRetries = config$1.noResponseRetries === void 0 || config$1.noResponseRetries === null ? 2 : config$1.noResponseRetries;
		config$1.retryDelayMultiplier = config$1.retryDelayMultiplier ? config$1.retryDelayMultiplier : 2;
		config$1.timeOfFirstRequest = config$1.timeOfFirstRequest ? config$1.timeOfFirstRequest : Date.now();
		config$1.totalTimeout = config$1.totalTimeout ? config$1.totalTimeout : Number.MAX_SAFE_INTEGER;
		config$1.maxRetryDelay = config$1.maxRetryDelay ? config$1.maxRetryDelay : Number.MAX_SAFE_INTEGER;
		const retryRanges = [
			[100, 199],
			[408, 408],
			[429, 429],
			[500, 599]
		];
		config$1.statusCodesToRetry = config$1.statusCodesToRetry || retryRanges;
		err.config.retryConfig = config$1;
		const shouldRetryFn = config$1.shouldRetry || shouldRetryRequest;
		if (!await shouldRetryFn(err)) return {
			shouldRetry: false,
			config: err.config
		};
		const delay = getNextRetryDelay(config$1);
		err.config.retryConfig.currentRetryAttempt += 1;
		const backoff = config$1.retryBackoff ? config$1.retryBackoff(err, delay) : new Promise((resolve) => {
			setTimeout(resolve, delay);
		});
		if (config$1.onRetryAttempt) config$1.onRetryAttempt(err);
		await backoff;
		return {
			shouldRetry: true,
			config: err.config
		};
	}
	/**
	* Determine based on config if we should retry the request.
	* @param err The GaxiosError passed to the interceptor.
	*/
	function shouldRetryRequest(err) {
		var _a$5;
		const config$1 = getConfig(err);
		if (err.name === "AbortError" || ((_a$5 = err.error) === null || _a$5 === void 0 ? void 0 : _a$5.name) === "AbortError") return false;
		if (!config$1 || config$1.retry === 0) return false;
		if (!err.response && (config$1.currentRetryAttempt || 0) >= config$1.noResponseRetries) return false;
		if (!err.config.method || config$1.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) return false;
		if (err.response && err.response.status) {
			let isInRange = false;
			for (const [min, max] of config$1.statusCodesToRetry) {
				const status = err.response.status;
				if (status >= min && status <= max) {
					isInRange = true;
					break;
				}
			}
			if (!isInRange) return false;
		}
		config$1.currentRetryAttempt = config$1.currentRetryAttempt || 0;
		if (config$1.currentRetryAttempt >= config$1.retry) return false;
		return true;
	}
	/**
	* Acquire the raxConfig object from an GaxiosError if available.
	* @param err The Gaxios error with a config object.
	*/
	function getConfig(err) {
		if (err && err.config && err.config.retryConfig) return err.config.retryConfig;
		return;
	}
	/**
	* Gets the delay to wait before the next retry.
	*
	* @param {RetryConfig} config The current set of retry options
	* @returns {number} the amount of ms to wait before the next retry attempt.
	*/
	function getNextRetryDelay(config$1) {
		var _a$5;
		const retryDelay = config$1.currentRetryAttempt ? 0 : (_a$5 = config$1.retryDelay) !== null && _a$5 !== void 0 ? _a$5 : 100;
		const calculatedDelay = retryDelay + (Math.pow(config$1.retryDelayMultiplier, config$1.currentRetryAttempt) - 1) / 2 * 1e3;
		const maxAllowableDelay = config$1.totalTimeout - (Date.now() - config$1.timeOfFirstRequest);
		return Math.min(calculatedDelay, maxAllowableDelay, config$1.maxRetryDelay);
	}
} });

//#endregion
//#region node_modules/uuid/dist/rng.js
var require_rng = __commonJS({ "node_modules/uuid/dist/rng.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = rng;
	var _crypto$3 = _interopRequireDefault$13(require("crypto"));
	function _interopRequireDefault$13(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	const rnds8Pool = new Uint8Array(256);
	let poolPtr = rnds8Pool.length;
	function rng() {
		if (poolPtr > rnds8Pool.length - 16) {
			_crypto$3.default.randomFillSync(rnds8Pool);
			poolPtr = 0;
		}
		return rnds8Pool.slice(poolPtr, poolPtr += 16);
	}
} });

//#endregion
//#region node_modules/uuid/dist/regex.js
var require_regex = __commonJS({ "node_modules/uuid/dist/regex.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _default$12 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
	exports.default = _default$12;
} });

//#endregion
//#region node_modules/uuid/dist/validate.js
var require_validate = __commonJS({ "node_modules/uuid/dist/validate.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _regex = _interopRequireDefault$12(require_regex());
	function _interopRequireDefault$12(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function validate$2(uuid) {
		return typeof uuid === "string" && _regex.default.test(uuid);
	}
	var _default$11 = validate$2;
	exports.default = _default$11;
} });

//#endregion
//#region node_modules/uuid/dist/stringify.js
var require_stringify$1 = __commonJS({ "node_modules/uuid/dist/stringify.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	exports.unsafeStringify = unsafeStringify;
	var _validate$3 = _interopRequireDefault$11(require_validate());
	function _interopRequireDefault$11(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	/**
	* Convert array of 16 byte values to UUID string format of the form:
	* XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	*/
	const byteToHex = [];
	for (let i$1 = 0; i$1 < 256; ++i$1) byteToHex.push((i$1 + 256).toString(16).slice(1));
	function unsafeStringify(arr, offset = 0) {
		return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
	}
	function stringify(arr, offset = 0) {
		const uuid = unsafeStringify(arr, offset);
		if (!(0, _validate$3.default)(uuid)) throw TypeError("Stringified UUID is invalid");
		return uuid;
	}
	var _default$10 = stringify;
	exports.default = _default$10;
} });

//#endregion
//#region node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({ "node_modules/uuid/dist/v1.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _rng$1 = _interopRequireDefault$10(require_rng());
	var _stringify$3 = require_stringify$1();
	function _interopRequireDefault$10(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	let _nodeId;
	let _clockseq;
	let _lastMSecs = 0;
	let _lastNSecs = 0;
	function v1(options, buf, offset) {
		let i$1 = buf && offset || 0;
		const b = buf || new Array(16);
		options = options || {};
		let node = options.node || _nodeId;
		let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
		if (node == null || clockseq == null) {
			const seedBytes = options.random || (options.rng || _rng$1.default)();
			if (node == null) node = _nodeId = [
				seedBytes[0] | 1,
				seedBytes[1],
				seedBytes[2],
				seedBytes[3],
				seedBytes[4],
				seedBytes[5]
			];
			if (clockseq == null) clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
		}
		let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
		let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
		const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
		if (dt < 0 && options.clockseq === void 0) clockseq = clockseq + 1 & 16383;
		if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) nsecs = 0;
		if (nsecs >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
		_lastMSecs = msecs;
		_lastNSecs = nsecs;
		_clockseq = clockseq;
		msecs += 122192928e5;
		const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
		b[i$1++] = tl >>> 24 & 255;
		b[i$1++] = tl >>> 16 & 255;
		b[i$1++] = tl >>> 8 & 255;
		b[i$1++] = tl & 255;
		const tmh = msecs / 4294967296 * 1e4 & 268435455;
		b[i$1++] = tmh >>> 8 & 255;
		b[i$1++] = tmh & 255;
		b[i$1++] = tmh >>> 24 & 15 | 16;
		b[i$1++] = tmh >>> 16 & 255;
		b[i$1++] = clockseq >>> 8 | 128;
		b[i$1++] = clockseq & 255;
		for (let n = 0; n < 6; ++n) b[i$1 + n] = node[n];
		return buf || (0, _stringify$3.unsafeStringify)(b);
	}
	var _default$9 = v1;
	exports.default = _default$9;
} });

//#endregion
//#region node_modules/uuid/dist/parse.js
var require_parse$1 = __commonJS({ "node_modules/uuid/dist/parse.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _validate$2 = _interopRequireDefault$9(require_validate());
	function _interopRequireDefault$9(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function parse$5(uuid) {
		if (!(0, _validate$2.default)(uuid)) throw TypeError("Invalid UUID");
		let v;
		const arr = new Uint8Array(16);
		arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
		arr[1] = v >>> 16 & 255;
		arr[2] = v >>> 8 & 255;
		arr[3] = v & 255;
		arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
		arr[5] = v & 255;
		arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
		arr[7] = v & 255;
		arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
		arr[9] = v & 255;
		arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
		arr[11] = v / 4294967296 & 255;
		arr[12] = v >>> 24 & 255;
		arr[13] = v >>> 16 & 255;
		arr[14] = v >>> 8 & 255;
		arr[15] = v & 255;
		return arr;
	}
	var _default$8 = parse$5;
	exports.default = _default$8;
} });

//#endregion
//#region node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({ "node_modules/uuid/dist/v35.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.URL = exports.DNS = void 0;
	exports.default = v35;
	var _stringify$2 = require_stringify$1();
	var _parse$1 = _interopRequireDefault$8(require_parse$1());
	function _interopRequireDefault$8(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function stringToBytes(str) {
		str = unescape(encodeURIComponent(str));
		const bytes = [];
		for (let i$1 = 0; i$1 < str.length; ++i$1) bytes.push(str.charCodeAt(i$1));
		return bytes;
	}
	const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
	exports.DNS = DNS;
	const URL$2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
	exports.URL = URL$2;
	function v35(name, version$2, hashfunc) {
		function generateUUID(value, namespace, buf, offset) {
			var _namespace;
			if (typeof value === "string") value = stringToBytes(value);
			if (typeof namespace === "string") namespace = (0, _parse$1.default)(namespace);
			if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
			let bytes = new Uint8Array(16 + value.length);
			bytes.set(namespace);
			bytes.set(value, namespace.length);
			bytes = hashfunc(bytes);
			bytes[6] = bytes[6] & 15 | version$2;
			bytes[8] = bytes[8] & 63 | 128;
			if (buf) {
				offset = offset || 0;
				for (let i$1 = 0; i$1 < 16; ++i$1) buf[offset + i$1] = bytes[i$1];
				return buf;
			}
			return (0, _stringify$2.unsafeStringify)(bytes);
		}
		try {
			generateUUID.name = name;
		} catch (err) {}
		generateUUID.DNS = DNS;
		generateUUID.URL = URL$2;
		return generateUUID;
	}
} });

//#endregion
//#region node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({ "node_modules/uuid/dist/md5.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _crypto$2 = _interopRequireDefault$7(require("crypto"));
	function _interopRequireDefault$7(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function md5(bytes) {
		if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
		else if (typeof bytes === "string") bytes = Buffer.from(bytes, "utf8");
		return _crypto$2.default.createHash("md5").update(bytes).digest();
	}
	var _default$7 = md5;
	exports.default = _default$7;
} });

//#endregion
//#region node_modules/uuid/dist/v3.js
var require_v3 = __commonJS({ "node_modules/uuid/dist/v3.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _v$2 = _interopRequireDefault$6(require_v35());
	var _md = _interopRequireDefault$6(require_md5());
	function _interopRequireDefault$6(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	const v3 = (0, _v$2.default)("v3", 48, _md.default);
	var _default$6 = v3;
	exports.default = _default$6;
} });

//#endregion
//#region node_modules/uuid/dist/native.js
var require_native = __commonJS({ "node_modules/uuid/dist/native.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _crypto$1 = _interopRequireDefault$5(require("crypto"));
	function _interopRequireDefault$5(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	var _default$5 = { randomUUID: _crypto$1.default.randomUUID };
	exports.default = _default$5;
} });

//#endregion
//#region node_modules/uuid/dist/v4.js
var require_v4 = __commonJS({ "node_modules/uuid/dist/v4.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _native = _interopRequireDefault$4(require_native());
	var _rng = _interopRequireDefault$4(require_rng());
	var _stringify$1 = require_stringify$1();
	function _interopRequireDefault$4(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function v4(options, buf, offset) {
		if (_native.default.randomUUID && !buf && !options) return _native.default.randomUUID();
		options = options || {};
		const rnds = options.random || (options.rng || _rng.default)();
		rnds[6] = rnds[6] & 15 | 64;
		rnds[8] = rnds[8] & 63 | 128;
		if (buf) {
			offset = offset || 0;
			for (let i$1 = 0; i$1 < 16; ++i$1) buf[offset + i$1] = rnds[i$1];
			return buf;
		}
		return (0, _stringify$1.unsafeStringify)(rnds);
	}
	var _default$4 = v4;
	exports.default = _default$4;
} });

//#endregion
//#region node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({ "node_modules/uuid/dist/sha1.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _crypto = _interopRequireDefault$3(require("crypto"));
	function _interopRequireDefault$3(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function sha1(bytes) {
		if (Array.isArray(bytes)) bytes = Buffer.from(bytes);
		else if (typeof bytes === "string") bytes = Buffer.from(bytes, "utf8");
		return _crypto.default.createHash("sha1").update(bytes).digest();
	}
	var _default$3 = sha1;
	exports.default = _default$3;
} });

//#endregion
//#region node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({ "node_modules/uuid/dist/v5.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _v$1 = _interopRequireDefault$2(require_v35());
	var _sha = _interopRequireDefault$2(require_sha1());
	function _interopRequireDefault$2(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	const v5 = (0, _v$1.default)("v5", 80, _sha.default);
	var _default$2 = v5;
	exports.default = _default$2;
} });

//#endregion
//#region node_modules/uuid/dist/nil.js
var require_nil = __commonJS({ "node_modules/uuid/dist/nil.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _default$1 = "00000000-0000-0000-0000-000000000000";
	exports.default = _default$1;
} });

//#endregion
//#region node_modules/uuid/dist/version.js
var require_version = __commonJS({ "node_modules/uuid/dist/version.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = void 0;
	var _validate$1 = _interopRequireDefault$1(require_validate());
	function _interopRequireDefault$1(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
	function version$1(uuid) {
		if (!(0, _validate$1.default)(uuid)) throw TypeError("Invalid UUID");
		return parseInt(uuid.slice(14, 15), 16);
	}
	var _default = version$1;
	exports.default = _default;
} });

//#endregion
//#region node_modules/uuid/dist/index.js
var require_dist$2 = __commonJS({ "node_modules/uuid/dist/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	Object.defineProperty(exports, "NIL", {
		enumerable: true,
		get: function() {
			return _nil.default;
		}
	});
	Object.defineProperty(exports, "parse", {
		enumerable: true,
		get: function() {
			return _parse.default;
		}
	});
	Object.defineProperty(exports, "stringify", {
		enumerable: true,
		get: function() {
			return _stringify.default;
		}
	});
	Object.defineProperty(exports, "v1", {
		enumerable: true,
		get: function() {
			return _v.default;
		}
	});
	Object.defineProperty(exports, "v3", {
		enumerable: true,
		get: function() {
			return _v2.default;
		}
	});
	Object.defineProperty(exports, "v4", {
		enumerable: true,
		get: function() {
			return _v3.default;
		}
	});
	Object.defineProperty(exports, "v5", {
		enumerable: true,
		get: function() {
			return _v4.default;
		}
	});
	Object.defineProperty(exports, "validate", {
		enumerable: true,
		get: function() {
			return _validate.default;
		}
	});
	Object.defineProperty(exports, "version", {
		enumerable: true,
		get: function() {
			return _version.default;
		}
	});
	var _v = _interopRequireDefault(require_v1());
	var _v2 = _interopRequireDefault(require_v3());
	var _v3 = _interopRequireDefault(require_v4());
	var _v4 = _interopRequireDefault(require_v5());
	var _nil = _interopRequireDefault(require_nil());
	var _version = _interopRequireDefault(require_version());
	var _validate = _interopRequireDefault(require_validate());
	var _stringify = _interopRequireDefault(require_stringify$1());
	var _parse = _interopRequireDefault(require_parse$1());
	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}
} });

//#endregion
//#region node_modules/gaxios/build/src/interceptor.js
var require_interceptor = __commonJS({ "node_modules/gaxios/build/src/interceptor.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GaxiosInterceptorManager = void 0;
	/**
	* Class to manage collections of GaxiosInterceptors for both requests and responses.
	*/
	var GaxiosInterceptorManager = class extends Set {};
	exports.GaxiosInterceptorManager = GaxiosInterceptorManager;
} });

//#endregion
//#region node_modules/ms/index.js
var require_ms = __commonJS({ "node_modules/ms/index.js"(exports, module) {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse$4(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse$4(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		var type = (match[2] || "ms").toLowerCase();
		switch (type) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return void 0;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return Math.round(ms / d) + "d";
		if (msAbs >= h) return Math.round(ms / h) + "h";
		if (msAbs >= m) return Math.round(ms / m) + "m";
		if (msAbs >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return plural(ms, msAbs, d, "day");
		if (msAbs >= h) return plural(ms, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms, msAbs, s, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
	}
} });

//#endregion
//#region node_modules/debug/src/common.js
var require_common = __commonJS({ "node_modules/debug/src/common.js"(exports, module) {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		createDebug.destroy = destroy$1;
		Object.keys(env).forEach((key) => {
			createDebug[key] = env[key];
		});
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug.names = [];
		createDebug.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;
			for (let i$1 = 0; i$1 < namespace.length; i$1++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i$1);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug$4(...args) {
				if (!debug$4.enabled) return;
				const self$1 = debug$4;
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self$1.diff = ms;
				self$1.prev = prevTime;
				self$1.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format$2) => {
					if (match === "%%") return "%";
					index++;
					const formatter = createDebug.formatters[format$2];
					if (typeof formatter === "function") {
						const val = args[index];
						match = formatter.call(self$1, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug.formatArgs.call(self$1, args);
				const logFn = self$1.log || createDebug.log;
				logFn.apply(self$1, args);
			}
			debug$4.namespace = namespace;
			debug$4.useColors = createDebug.useColors();
			debug$4.color = createDebug.selectColor(namespace);
			debug$4.extend = extend;
			debug$4.destroy = createDebug.destroy;
			Object.defineProperty(debug$4, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) return enableOverride;
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				}
			});
			if (typeof createDebug.init === "function") createDebug.init(debug$4);
			return debug$4;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
			for (const ns of split) if (ns[0] === "-") createDebug.skips.push(ns.slice(1));
			else createDebug.names.push(ns);
		}
		/**
		* Checks if the given string matches a namespace template, honoring
		* asterisks as wildcards.
		*
		* @param {String} search
		* @param {String} template
		* @return {Boolean}
		*/
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) if (template[templateIndex] === "*") {
				starIndex = templateIndex;
				matchIndex = searchIndex;
				templateIndex++;
			} else {
				searchIndex++;
				templateIndex++;
			}
			else if (starIndex !== -1) {
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else return false;
			while (templateIndex < template.length && template[templateIndex] === "*") templateIndex++;
			return templateIndex === template.length;
		}
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [...createDebug.names, ...createDebug.skips.map((namespace) => "-" + namespace)].join(",");
			createDebug.enable("");
			return namespaces;
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) if (matchesTemplate(name, skip)) return false;
			for (const ns of createDebug.names) if (matchesTemplate(name, ns)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy$1() {
			console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
} });

//#endregion
//#region node_modules/debug/src/browser.js
var require_browser = __commonJS({ "node_modules/debug/src/browser.js"(exports, module) {
	/**
	* This is the web browser implementation of `debug()`.
	*/
	exports.formatArgs = formatArgs$1;
	exports.save = save$1;
	exports.load = load$1;
	exports.useColors = useColors$1;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
			}
		};
	})();
	/**
	* Colors.
	*/
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors$1() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		let m$1;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m$1 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m$1[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs$1(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match) => {
			if (match === "%%") return;
			index++;
			if (match === "%c") lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.debug()` when available.
	* No-op when `console.debug` is not a "function".
	* If `console.debug` is not available, falls back
	* to `console.log`.
	*
	* @api public
	*/
	exports.log = console.debug || console.log || (() => {});
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save$1(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error$1) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load$1() {
		let r;
		try {
			r = exports.storage.getItem("debug");
		} catch (error$1) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return localStorage;
		} catch (error$1) {}
	}
	module.exports = require_common()(exports);
	const { formatters: formatters$1 } = module.exports;
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	formatters$1.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error$1) {
			return "[UnexpectedJSONParseError]: " + error$1.message;
		}
	};
} });

//#endregion
//#region node_modules/debug/src/node.js
var require_node$1 = __commonJS({ "node_modules/debug/src/node.js"(exports, module) {
	/**
	* Module dependencies.
	*/
	const tty = require("tty");
	const util$5 = require("util");
	/**
	* This is the Node.js implementation of `debug()`.
	*/
	exports.init = init;
	exports.log = log$2;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.destroy = util$5.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
	/**
	* Colors.
	*/
	exports.colors = [
		6,
		2,
		3,
		4,
		5,
		1
	];
	try {
		const supportsColor = require("supports-color");
		if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	} catch (error$1) {}
	/**
	* Build up the default `inspectOpts` object from the environment variables.
	*
	*   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
	*/
	exports.inspectOpts = Object.keys(process.env).filter((key) => {
		return /^debug_/i.test(key);
	}).reduce((obj, key) => {
		const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});
		let val = process.env[key];
		if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
		else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
		else if (val === "null") val = null;
		else val = Number(val);
		obj[prop] = val;
		return obj;
	}, {});
	/**
	* Is stdout a TTY? Colored output is enabled when `true`.
	*/
	function useColors() {
		return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
	}
	/**
	* Adds ANSI color escape codes if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		const { namespace: name, useColors: useColors$2 } = this;
		if (useColors$2) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name} \u001B[0m`;
			args[0] = prefix + args[0].split("\n").join("\n" + prefix);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else args[0] = getDate() + name + " " + args[0];
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) return "";
		return new Date().toISOString() + " ";
	}
	/**
	* Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
	*/
	function log$2(...args) {
		return process.stderr.write(util$5.formatWithOptions(exports.inspectOpts, ...args) + "\n");
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		if (namespaces) process.env.DEBUG = namespaces;
		else delete process.env.DEBUG;
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		return process.env.DEBUG;
	}
	/**
	* Init logic for `debug` instances.
	*
	* Create a new `inspectOpts` object in case `useColors` is set
	* differently for a particular `debug` instance.
	*/
	function init(debug$4) {
		debug$4.inspectOpts = {};
		const keys = Object.keys(exports.inspectOpts);
		for (let i$1 = 0; i$1 < keys.length; i$1++) debug$4.inspectOpts[keys[i$1]] = exports.inspectOpts[keys[i$1]];
	}
	module.exports = require_common()(exports);
	const { formatters } = module.exports;
	/**
	* Map %o to `util.inspect()`, all on a single line.
	*/
	formatters.o = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$5.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
	};
	/**
	* Map %O to `util.inspect()`, allowing multiple lines if needed.
	*/
	formatters.O = function(v) {
		this.inspectOpts.colors = this.useColors;
		return util$5.inspect(v, this.inspectOpts);
	};
} });

//#endregion
//#region node_modules/debug/src/index.js
var require_src$5 = __commonJS({ "node_modules/debug/src/index.js"(exports, module) {
	/**
	* Detect Electron renderer / nwjs process, which is node, but we should
	* treat as a browser.
	*/
	if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) module.exports = require_browser();
	else module.exports = require_node$1();
} });

//#endregion
//#region node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS({ "node_modules/agent-base/dist/helpers.js"(exports) {
	var __createBinding$7 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$4 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$4 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$7(result, mod, k);
		}
		__setModuleDefault$4(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.req = exports.json = exports.toBuffer = void 0;
	const http$3 = __importStar$4(require("http"));
	const https$1 = __importStar$4(require("https"));
	async function toBuffer$4(stream$6) {
		let length = 0;
		const chunks = [];
		for await (const chunk of stream$6) {
			length += chunk.length;
			chunks.push(chunk);
		}
		return Buffer.concat(chunks, length);
	}
	exports.toBuffer = toBuffer$4;
	async function json(stream$6) {
		const buf = await toBuffer$4(stream$6);
		const str = buf.toString("utf8");
		try {
			return JSON.parse(str);
		} catch (_err) {
			const err = _err;
			err.message += ` (input: ${str})`;
			throw err;
		}
	}
	exports.json = json;
	function req(url, opts = {}) {
		const href = typeof url === "string" ? url : url.href;
		const req$1 = (href.startsWith("https:") ? https$1 : http$3).request(url, opts);
		const promise = new Promise((resolve, reject) => {
			req$1.once("response", resolve).once("error", reject).end();
		});
		req$1.then = promise.then.bind(promise);
		return req$1;
	}
	exports.req = req;
} });

//#endregion
//#region node_modules/agent-base/dist/index.js
var require_dist$1 = __commonJS({ "node_modules/agent-base/dist/index.js"(exports) {
	var __createBinding$6 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$3 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$3 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$6(result, mod, k);
		}
		__setModuleDefault$3(result, mod);
		return result;
	};
	var __exportStar$3 = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p in m$1) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$6(exports$1, m$1, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Agent = void 0;
	const net$2 = __importStar$3(require("net"));
	const http$2 = __importStar$3(require("http"));
	const https_1$1 = require("https");
	__exportStar$3(require_helpers(), exports);
	const INTERNAL = Symbol("AgentBaseInternalState");
	var Agent = class extends http$2.Agent {
		constructor(opts) {
			super(opts);
			this[INTERNAL] = {};
		}
		/**
		* Determine whether this is an `http` or `https` request.
		*/
		isSecureEndpoint(options) {
			if (options) {
				if (typeof options.secureEndpoint === "boolean") return options.secureEndpoint;
				if (typeof options.protocol === "string") return options.protocol === "https:";
			}
			const { stack } = new Error();
			if (typeof stack !== "string") return false;
			return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
		}
		incrementSockets(name) {
			if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) return null;
			if (!this.sockets[name]) this.sockets[name] = [];
			const fakeSocket = new net$2.Socket({ writable: false });
			this.sockets[name].push(fakeSocket);
			this.totalSocketCount++;
			return fakeSocket;
		}
		decrementSockets(name, socket) {
			if (!this.sockets[name] || socket === null) return;
			const sockets = this.sockets[name];
			const index = sockets.indexOf(socket);
			if (index !== -1) {
				sockets.splice(index, 1);
				this.totalSocketCount--;
				if (sockets.length === 0) delete this.sockets[name];
			}
		}
		getName(options) {
			const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
			if (secureEndpoint) return https_1$1.Agent.prototype.getName.call(this, options);
			return super.getName(options);
		}
		createSocket(req$1, options, cb) {
			const connectOpts = {
				...options,
				secureEndpoint: this.isSecureEndpoint(options)
			};
			const name = this.getName(connectOpts);
			const fakeSocket = this.incrementSockets(name);
			Promise.resolve().then(() => this.connect(req$1, connectOpts)).then((socket) => {
				this.decrementSockets(name, fakeSocket);
				if (socket instanceof http$2.Agent) try {
					return socket.addRequest(req$1, connectOpts);
				} catch (err) {
					return cb(err);
				}
				this[INTERNAL].currentSocket = socket;
				super.createSocket(req$1, options, cb);
			}, (err) => {
				this.decrementSockets(name, fakeSocket);
				cb(err);
			});
		}
		createConnection() {
			const socket = this[INTERNAL].currentSocket;
			this[INTERNAL].currentSocket = void 0;
			if (!socket) throw new Error("No socket was returned in the `connect()` function");
			return socket;
		}
		get defaultPort() {
			return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
		}
		set defaultPort(v) {
			if (this[INTERNAL]) this[INTERNAL].defaultPort = v;
		}
		get protocol() {
			return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
		}
		set protocol(v) {
			if (this[INTERNAL]) this[INTERNAL].protocol = v;
		}
	};
	exports.Agent = Agent;
} });

//#endregion
//#region node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({ "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
	var __importDefault$2 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseProxyResponse = void 0;
	const debug_1$1 = __importDefault$2(require_src$5());
	const debug$1 = (0, debug_1$1.default)("https-proxy-agent:parse-proxy-response");
	function parseProxyResponse(socket) {
		return new Promise((resolve, reject) => {
			let buffersLength = 0;
			const buffers = [];
			function read() {
				const b = socket.read();
				if (b) ondata(b);
				else socket.once("readable", read);
			}
			function cleanup() {
				socket.removeListener("end", onend);
				socket.removeListener("error", onerror);
				socket.removeListener("readable", read);
			}
			function onend() {
				cleanup();
				debug$1("onend");
				reject(new Error("Proxy connection ended before receiving CONNECT response"));
			}
			function onerror(err) {
				cleanup();
				debug$1("onerror %o", err);
				reject(err);
			}
			function ondata(b) {
				buffers.push(b);
				buffersLength += b.length;
				const buffered = Buffer.concat(buffers, buffersLength);
				const endOfHeaders = buffered.indexOf("\r\n\r\n");
				if (endOfHeaders === -1) {
					debug$1("have not received end of HTTP headers yet...");
					read();
					return;
				}
				const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
				const firstLine = headerParts.shift();
				if (!firstLine) {
					socket.destroy();
					return reject(new Error("No header received from proxy CONNECT response"));
				}
				const firstLineParts = firstLine.split(" ");
				const statusCode = +firstLineParts[1];
				const statusText = firstLineParts.slice(2).join(" ");
				const headers = {};
				for (const header of headerParts) {
					if (!header) continue;
					const firstColon = header.indexOf(":");
					if (firstColon === -1) {
						socket.destroy();
						return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
					}
					const key = header.slice(0, firstColon).toLowerCase();
					const value = header.slice(firstColon + 1).trimStart();
					const current = headers[key];
					if (typeof current === "string") headers[key] = [current, value];
					else if (Array.isArray(current)) current.push(value);
					else headers[key] = value;
				}
				debug$1("got proxy server response: %o %o", firstLine, headers);
				cleanup();
				resolve({
					connect: {
						statusCode,
						statusText,
						headers
					},
					buffered
				});
			}
			socket.on("error", onerror);
			socket.on("end", onend);
			read();
		});
	}
	exports.parseProxyResponse = parseProxyResponse;
} });

//#endregion
//#region node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS({ "node_modules/https-proxy-agent/dist/index.js"(exports) {
	var __createBinding$5 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$2 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$2 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$5(result, mod, k);
		}
		__setModuleDefault$2(result, mod);
		return result;
	};
	var __importDefault$1 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpsProxyAgent = void 0;
	const net$1 = __importStar$2(require("net"));
	const tls$1 = __importStar$2(require("tls"));
	const assert_1 = __importDefault$1(require("assert"));
	const debug_1 = __importDefault$1(require_src$5());
	const agent_base_1 = require_dist$1();
	const url_1$1 = require("url");
	const parse_proxy_response_1 = require_parse_proxy_response();
	const debug = (0, debug_1.default)("https-proxy-agent");
	const setServernameFromNonIpHost = (options) => {
		if (options.servername === void 0 && options.host && !net$1.isIP(options.host)) return {
			...options,
			servername: options.host
		};
		return options;
	};
	/**
	* The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
	* the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
	*
	* Outgoing HTTP requests are first tunneled through the proxy server using the
	* `CONNECT` HTTP request method to establish a connection to the proxy server,
	* and then the proxy server connects to the destination target and issues the
	* HTTP request from the proxy server.
	*
	* `https:` requests have their socket connection upgraded to TLS once
	* the connection to the proxy server has been established.
	*/
	var HttpsProxyAgent = class extends agent_base_1.Agent {
		constructor(proxy, opts) {
			super(opts);
			this.options = { path: void 0 };
			this.proxy = typeof proxy === "string" ? new url_1$1.URL(proxy) : proxy;
			this.proxyHeaders = opts?.headers ?? {};
			debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
			const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
			const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
			this.connectOpts = {
				ALPNProtocols: ["http/1.1"],
				...opts ? omit(opts, "headers") : null,
				host,
				port
			};
		}
		/**
		* Called when the node-core HTTP client library is creating a
		* new HTTP request.
		*/
		async connect(req$1, opts) {
			const { proxy } = this;
			if (!opts.host) throw new TypeError("No \"host\" provided");
			let socket;
			if (proxy.protocol === "https:") {
				debug("Creating `tls.Socket`: %o", this.connectOpts);
				socket = tls$1.connect(setServernameFromNonIpHost(this.connectOpts));
			} else {
				debug("Creating `net.Socket`: %o", this.connectOpts);
				socket = net$1.connect(this.connectOpts);
			}
			const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
			const host = net$1.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
			let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
			if (proxy.username || proxy.password) {
				const auth$2 = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
				headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth$2).toString("base64")}`;
			}
			headers.Host = `${host}:${opts.port}`;
			if (!headers["Proxy-Connection"]) headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
			for (const name of Object.keys(headers)) payload += `${name}: ${headers[name]}\r\n`;
			const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
			socket.write(`${payload}\r\n`);
			const { connect: connect$2, buffered } = await proxyResponsePromise;
			req$1.emit("proxyConnect", connect$2);
			this.emit("proxyConnect", connect$2, req$1);
			if (connect$2.statusCode === 200) {
				req$1.once("socket", resume$1);
				if (opts.secureEndpoint) {
					debug("Upgrading socket connection to TLS");
					return tls$1.connect({
						...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
						socket
					});
				}
				return socket;
			}
			socket.destroy();
			const fakeSocket = new net$1.Socket({ writable: false });
			fakeSocket.readable = true;
			req$1.once("socket", (s$1) => {
				debug("Replaying proxy buffer for failed request");
				(0, assert_1.default)(s$1.listenerCount("data") > 0);
				s$1.push(buffered);
				s$1.push(null);
			});
			return fakeSocket;
		}
	};
	HttpsProxyAgent.protocols = ["http", "https"];
	exports.HttpsProxyAgent = HttpsProxyAgent;
	function resume$1(socket) {
		socket.resume();
	}
	function omit(obj, ...keys) {
		const ret = {};
		let key;
		for (key in obj) if (!keys.includes(key)) ret[key] = obj[key];
		return ret;
	}
} });

//#endregion
//#region node_modules/gaxios/build/src/gaxios.js
var require_gaxios = __commonJS({ "node_modules/gaxios/build/src/gaxios.js"(exports) {
	var __createBinding$4 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault$1 = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar$1 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$4(result, mod, k);
		}
		__setModuleDefault$1(result, mod);
		return result;
	};
	var __classPrivateFieldGet$6 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
		return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var __classPrivateFieldSet$3 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
		if (kind === "m") throw new TypeError("Private method is not writable");
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
		return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
	};
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	var _Gaxios_instances, _a$2, _Gaxios_urlMayUseProxy, _Gaxios_applyRequestInterceptors, _Gaxios_applyResponseInterceptors, _Gaxios_prepareRequest, _Gaxios_proxyAgent, _Gaxios_getProxyAgent;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Gaxios = void 0;
	const extend_1 = __importDefault(require_extend());
	const https_1 = require("https");
	const node_fetch_1 = __importDefault(require_lib());
	const querystring_1$1 = __importDefault(require("querystring"));
	const is_stream_1 = __importDefault(require_is_stream());
	const url_1 = require("url");
	const common_1$1 = require_common$1();
	const retry_1 = require_retry();
	const stream_1 = require("stream");
	const uuid_1 = require_dist$2();
	const interceptor_1 = require_interceptor();
	const fetch$1 = hasFetch() ? window.fetch : node_fetch_1.default;
	function hasWindow() {
		return typeof window !== "undefined" && !!window;
	}
	function hasFetch() {
		return hasWindow() && !!window.fetch;
	}
	function hasBuffer() {
		return typeof Buffer !== "undefined";
	}
	function hasHeader(options, header) {
		return !!getHeader(options, header);
	}
	function getHeader(options, header) {
		header = header.toLowerCase();
		for (const key of Object.keys((options === null || options === void 0 ? void 0 : options.headers) || {})) if (header === key.toLowerCase()) return options.headers[key];
		return void 0;
	}
	var Gaxios = class {
		/**
		* The Gaxios class is responsible for making HTTP requests.
		* @param defaults The default set of options to be used for this instance.
		*/
		constructor(defaults) {
			_Gaxios_instances.add(this);
			this.agentCache = new Map();
			this.defaults = defaults || {};
			this.interceptors = {
				request: new interceptor_1.GaxiosInterceptorManager(),
				response: new interceptor_1.GaxiosInterceptorManager()
			};
		}
		/**
		* Perform an HTTP request with the given options.
		* @param opts Set of HTTP options that will be used for this HTTP request.
		*/
		async request(opts = {}) {
			opts = await __classPrivateFieldGet$6(this, _Gaxios_instances, "m", _Gaxios_prepareRequest).call(this, opts);
			opts = await __classPrivateFieldGet$6(this, _Gaxios_instances, "m", _Gaxios_applyRequestInterceptors).call(this, opts);
			return __classPrivateFieldGet$6(this, _Gaxios_instances, "m", _Gaxios_applyResponseInterceptors).call(this, this._request(opts));
		}
		async _defaultAdapter(opts) {
			const fetchImpl = opts.fetchImplementation || fetch$1;
			const res = await fetchImpl(opts.url, opts);
			const data = await this.getResponseData(opts, res);
			return this.translateResponse(opts, res, data);
		}
		/**
		* Internal, retryable version of the `request` method.
		* @param opts Set of HTTP options that will be used for this HTTP request.
		*/
		async _request(opts = {}) {
			var _b$1;
			try {
				let translatedResponse;
				if (opts.adapter) translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));
				else translatedResponse = await this._defaultAdapter(opts);
				if (!opts.validateStatus(translatedResponse.status)) {
					if (opts.responseType === "stream") {
						let response = "";
						await new Promise((resolve) => {
							(translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on("data", (chunk) => {
								response += chunk;
							});
							(translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on("end", resolve);
						});
						translatedResponse.data = response;
					}
					throw new common_1$1.GaxiosError(`Request failed with status code ${translatedResponse.status}`, opts, translatedResponse);
				}
				return translatedResponse;
			} catch (e) {
				const err = e instanceof common_1$1.GaxiosError ? e : new common_1$1.GaxiosError(e.message, opts, void 0, e);
				const { shouldRetry, config: config$1 } = await (0, retry_1.getRetryConfig)(err);
				if (shouldRetry && config$1) {
					err.config.retryConfig.currentRetryAttempt = config$1.retryConfig.currentRetryAttempt;
					opts.retryConfig = (_b$1 = err.config) === null || _b$1 === void 0 ? void 0 : _b$1.retryConfig;
					return this._request(opts);
				}
				throw err;
			}
		}
		async getResponseData(opts, res) {
			switch (opts.responseType) {
				case "stream": return res.body;
				case "json": {
					let data = await res.text();
					try {
						data = JSON.parse(data);
					} catch (_b$1) {}
					return data;
				}
				case "arraybuffer": return res.arrayBuffer();
				case "blob": return res.blob();
				case "text": return res.text();
				default: return this.getResponseDataFromContentType(res);
			}
		}
		/**
		* By default, throw for any non-2xx status code
		* @param status status code from the HTTP response
		*/
		validateStatus(status) {
			return status >= 200 && status < 300;
		}
		/**
		* Encode a set of key/value pars into a querystring format (?foo=bar&baz=boo)
		* @param params key value pars to encode
		*/
		paramsSerializer(params) {
			return querystring_1$1.default.stringify(params);
		}
		translateResponse(opts, res, data) {
			const headers = {};
			res.headers.forEach((value, key) => {
				headers[key] = value;
			});
			return {
				config: opts,
				data,
				headers,
				status: res.status,
				statusText: res.statusText,
				request: { responseURL: res.url }
			};
		}
		/**
		* Attempts to parse a response by looking at the Content-Type header.
		* @param {FetchResponse} response the HTTP response.
		* @returns {Promise<any>} a promise that resolves to the response data.
		*/
		async getResponseDataFromContentType(response) {
			let contentType = response.headers.get("Content-Type");
			if (contentType === null) return response.text();
			contentType = contentType.toLowerCase();
			if (contentType.includes("application/json")) {
				let data = await response.text();
				try {
					data = JSON.parse(data);
				} catch (_b$1) {}
				return data;
			} else if (contentType.match(/^text\//)) return response.text();
			else return response.blob();
		}
		/**
		* Creates an async generator that yields the pieces of a multipart/related request body.
		* This implementation follows the spec: https://www.ietf.org/rfc/rfc2387.txt. However, recursive
		* multipart/related requests are not currently supported.
		*
		* @param {GaxioMultipartOptions[]} multipartOptions the pieces to turn into a multipart/related body.
		* @param {string} boundary the boundary string to be placed between each part.
		*/
		async *getMultipartRequest(multipartOptions, boundary) {
			const finale = `--${boundary}--`;
			for (const currentPart of multipartOptions) {
				const partContentType = currentPart.headers["Content-Type"] || "application/octet-stream";
				const preamble = `--${boundary}\r\nContent-Type: ${partContentType}\r\n\r\n`;
				yield preamble;
				if (typeof currentPart.content === "string") yield currentPart.content;
				else yield* currentPart.content;
				yield "\r\n";
			}
			yield finale;
		}
	};
	exports.Gaxios = Gaxios;
	_a$2 = Gaxios, _Gaxios_instances = new WeakSet(), _Gaxios_urlMayUseProxy = function _Gaxios_urlMayUseProxy$1(url, noProxy = []) {
		var _b$1, _c$1;
		const candidate = new url_1.URL(url);
		const noProxyList = [...noProxy];
		const noProxyEnvList = ((_c$1 = (_b$1 = process.env.NO_PROXY) !== null && _b$1 !== void 0 ? _b$1 : process.env.no_proxy) === null || _c$1 === void 0 ? void 0 : _c$1.split(",")) || [];
		for (const rule of noProxyEnvList) noProxyList.push(rule.trim());
		for (const rule of noProxyList) if (rule instanceof RegExp) {
			if (rule.test(candidate.toString())) return false;
		} else if (rule instanceof url_1.URL) {
			if (rule.origin === candidate.origin) return false;
		} else if (rule.startsWith("*.") || rule.startsWith(".")) {
			const cleanedRule = rule.replace(/^\*\./, ".");
			if (candidate.hostname.endsWith(cleanedRule)) return false;
		} else if (rule === candidate.origin || rule === candidate.hostname || rule === candidate.href) return false;
		return true;
	}, _Gaxios_applyRequestInterceptors = async function _Gaxios_applyRequestInterceptors$1(options) {
		let promiseChain = Promise.resolve(options);
		for (const interceptor of this.interceptors.request.values()) if (interceptor) promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
		return promiseChain;
	}, _Gaxios_applyResponseInterceptors = async function _Gaxios_applyResponseInterceptors$1(response) {
		let promiseChain = Promise.resolve(response);
		for (const interceptor of this.interceptors.response.values()) if (interceptor) promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
		return promiseChain;
	}, _Gaxios_prepareRequest = async function _Gaxios_prepareRequest$1(options) {
		var _b$1, _c$1, _d, _e;
		const opts = (0, extend_1.default)(true, {}, this.defaults, options);
		if (!opts.url) throw new Error("URL is required.");
		const baseUrl$1 = opts.baseUrl || opts.baseURL;
		if (baseUrl$1) opts.url = baseUrl$1.toString() + opts.url;
		opts.paramsSerializer = opts.paramsSerializer || this.paramsSerializer;
		if (opts.params && Object.keys(opts.params).length > 0) {
			let additionalQueryParams = opts.paramsSerializer(opts.params);
			if (additionalQueryParams.startsWith("?")) additionalQueryParams = additionalQueryParams.slice(1);
			const prefix = opts.url.toString().includes("?") ? "&" : "?";
			opts.url = opts.url + prefix + additionalQueryParams;
		}
		if (typeof options.maxContentLength === "number") opts.size = options.maxContentLength;
		if (typeof options.maxRedirects === "number") opts.follow = options.maxRedirects;
		opts.headers = opts.headers || {};
		if (opts.multipart === void 0 && opts.data) {
			const isFormData = typeof FormData === "undefined" ? false : (opts === null || opts === void 0 ? void 0 : opts.data) instanceof FormData;
			if (is_stream_1.default.readable(opts.data)) opts.body = opts.data;
			else if (hasBuffer() && Buffer.isBuffer(opts.data)) {
				opts.body = opts.data;
				if (!hasHeader(opts, "Content-Type")) opts.headers["Content-Type"] = "application/json";
			} else if (typeof opts.data === "object") {
				if (!isFormData) if (getHeader(opts, "content-type") === "application/x-www-form-urlencoded") opts.body = opts.paramsSerializer(opts.data);
				else {
					if (!hasHeader(opts, "Content-Type")) opts.headers["Content-Type"] = "application/json";
					opts.body = JSON.stringify(opts.data);
				}
			} else opts.body = opts.data;
		} else if (opts.multipart && opts.multipart.length > 0) {
			const boundary = (0, uuid_1.v4)();
			opts.headers["Content-Type"] = `multipart/related; boundary=${boundary}`;
			const bodyStream = new stream_1.PassThrough();
			opts.body = bodyStream;
			(0, stream_1.pipeline)(this.getMultipartRequest(opts.multipart, boundary), bodyStream, () => {});
		}
		opts.validateStatus = opts.validateStatus || this.validateStatus;
		opts.responseType = opts.responseType || "unknown";
		if (!opts.headers["Accept"] && opts.responseType === "json") opts.headers["Accept"] = "application/json";
		opts.method = opts.method || "GET";
		const proxy = opts.proxy || ((_b$1 = process === null || process === void 0 ? void 0 : process.env) === null || _b$1 === void 0 ? void 0 : _b$1.HTTPS_PROXY) || ((_c$1 = process === null || process === void 0 ? void 0 : process.env) === null || _c$1 === void 0 ? void 0 : _c$1.https_proxy) || ((_d = process === null || process === void 0 ? void 0 : process.env) === null || _d === void 0 ? void 0 : _d.HTTP_PROXY) || ((_e = process === null || process === void 0 ? void 0 : process.env) === null || _e === void 0 ? void 0 : _e.http_proxy);
		const urlMayUseProxy = __classPrivateFieldGet$6(this, _Gaxios_instances, "m", _Gaxios_urlMayUseProxy).call(this, opts.url, opts.noProxy);
		if (opts.agent) {} else if (proxy && urlMayUseProxy) {
			const HttpsProxyAgent$1 = await __classPrivateFieldGet$6(_a$2, _a$2, "m", _Gaxios_getProxyAgent).call(_a$2);
			if (this.agentCache.has(proxy)) opts.agent = this.agentCache.get(proxy);
			else {
				opts.agent = new HttpsProxyAgent$1(proxy, {
					cert: opts.cert,
					key: opts.key
				});
				this.agentCache.set(proxy, opts.agent);
			}
		} else if (opts.cert && opts.key) if (this.agentCache.has(opts.key)) opts.agent = this.agentCache.get(opts.key);
		else {
			opts.agent = new https_1.Agent({
				cert: opts.cert,
				key: opts.key
			});
			this.agentCache.set(opts.key, opts.agent);
		}
		if (typeof opts.errorRedactor !== "function" && opts.errorRedactor !== false) opts.errorRedactor = common_1$1.defaultErrorRedactor;
		return opts;
	}, _Gaxios_getProxyAgent = async function _Gaxios_getProxyAgent$1() {
		__classPrivateFieldSet$3(this, _a$2, __classPrivateFieldGet$6(this, _a$2, "f", _Gaxios_proxyAgent) || (await Promise.resolve().then(() => __importStar$1(require_dist()))).HttpsProxyAgent, "f", _Gaxios_proxyAgent);
		return __classPrivateFieldGet$6(this, _a$2, "f", _Gaxios_proxyAgent);
	};
	/**
	* A cache for the lazily-loaded proxy agent.
	*
	* Should use {@link Gaxios[#getProxyAgent]} to retrieve.
	*/
	_Gaxios_proxyAgent = { value: void 0 };
} });

//#endregion
//#region node_modules/gaxios/build/src/index.js
var require_src$4 = __commonJS({ "node_modules/gaxios/build/src/index.js"(exports) {
	var __createBinding$3 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __exportStar$2 = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p in m$1) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$3(exports$1, m$1, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.instance = exports.Gaxios = exports.GaxiosError = void 0;
	exports.request = request;
	const gaxios_1$9 = require_gaxios();
	Object.defineProperty(exports, "Gaxios", {
		enumerable: true,
		get: function() {
			return gaxios_1$9.Gaxios;
		}
	});
	var common_1 = require_common$1();
	Object.defineProperty(exports, "GaxiosError", {
		enumerable: true,
		get: function() {
			return common_1.GaxiosError;
		}
	});
	__exportStar$2(require_interceptor(), exports);
	/**
	* The default instance used when the `request` method is directly
	* invoked.
	*/
	exports.instance = new gaxios_1$9.Gaxios();
	/**
	* Make an HTTP request using the given options.
	* @param opts Options for the request
	*/
	async function request(opts) {
		return exports.instance.request(opts);
	}
} });

//#endregion
//#region node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({ "node_modules/bignumber.js/bignumber.js"(exports, module) {
	(function(globalObject) {
		"use strict";
		var BigNumber$2, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [
			1,
			10,
			100,
			1e3,
			1e4,
			1e5,
			1e6,
			1e7,
			1e8,
			1e9,
			1e10,
			1e11,
			1e12,
			1e13
		], SQRT_BASE = 1e7, MAX = 1e9;
		function clone$1(configObject) {
			var div, convertBase, parseNumeric, P = BigNumber$3.prototype = {
				constructor: BigNumber$3,
				toString: null,
				valueOf: null
			}, ONE = new BigNumber$3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
				prefix: "",
				groupSize: 3,
				secondaryGroupSize: 0,
				groupSeparator: ",",
				decimalSeparator: ".",
				fractionGroupSize: 0,
				fractionGroupSeparator: "\xA0",
				suffix: ""
			}, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
			function BigNumber$3(v, b) {
				var alphabet, c, caseChanged, e, i$1, isNum, len$1, str, x = this;
				if (!(x instanceof BigNumber$3)) return new BigNumber$3(v, b);
				if (b == null) {
					if (v && v._isBigNumber === true) {
						x.s = v.s;
						if (!v.c || v.e > MAX_EXP) x.c = x.e = null;
						else if (v.e < MIN_EXP) x.c = [x.e = 0];
						else {
							x.e = v.e;
							x.c = v.c.slice();
						}
						return;
					}
					if ((isNum = typeof v == "number") && v * 0 == 0) {
						x.s = 1 / v < 0 ? (v = -v, -1) : 1;
						if (v === ~~v) {
							for (e = 0, i$1 = v; i$1 >= 10; i$1 /= 10, e++);
							if (e > MAX_EXP) x.c = x.e = null;
							else {
								x.e = e;
								x.c = [v];
							}
							return;
						}
						str = String(v);
					} else {
						if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
						x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
					}
					if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
					if ((i$1 = str.search(/e/i)) > 0) {
						if (e < 0) e = i$1;
						e += +str.slice(i$1 + 1);
						str = str.substring(0, i$1);
					} else if (e < 0) e = str.length;
				} else {
					intCheck(b, 2, ALPHABET.length, "Base");
					if (b == 10 && alphabetHasNormalDecimalDigits) {
						x = new BigNumber$3(v);
						return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
					}
					str = String(v);
					if (isNum = typeof v == "number") {
						if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
						x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
						if (BigNumber$3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) throw Error(tooManyDigits + v);
					} else x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
					alphabet = ALPHABET.slice(0, b);
					e = i$1 = 0;
					for (len$1 = str.length; i$1 < len$1; i$1++) if (alphabet.indexOf(c = str.charAt(i$1)) < 0) {
						if (c == ".") {
							if (i$1 > e) {
								e = len$1;
								continue;
							}
						} else if (!caseChanged) {
							if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
								caseChanged = true;
								i$1 = -1;
								e = 0;
								continue;
							}
						}
						return parseNumeric(x, String(v), isNum, b);
					}
					isNum = false;
					str = convertBase(str, b, 10, x.s);
					if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
					else e = str.length;
				}
				for (i$1 = 0; str.charCodeAt(i$1) === 48; i$1++);
				for (len$1 = str.length; str.charCodeAt(--len$1) === 48;);
				if (str = str.slice(i$1, ++len$1)) {
					len$1 -= i$1;
					if (isNum && BigNumber$3.DEBUG && len$1 > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) throw Error(tooManyDigits + x.s * v);
					if ((e = e - i$1 - 1) > MAX_EXP) x.c = x.e = null;
					else if (e < MIN_EXP) x.c = [x.e = 0];
					else {
						x.e = e;
						x.c = [];
						i$1 = (e + 1) % LOG_BASE;
						if (e < 0) i$1 += LOG_BASE;
						if (i$1 < len$1) {
							if (i$1) x.c.push(+str.slice(0, i$1));
							for (len$1 -= LOG_BASE; i$1 < len$1;) x.c.push(+str.slice(i$1, i$1 += LOG_BASE));
							i$1 = LOG_BASE - (str = str.slice(i$1)).length;
						} else i$1 -= len$1;
						for (; i$1--; str += "0");
						x.c.push(+str);
					}
				} else x.c = [x.e = 0];
			}
			BigNumber$3.clone = clone$1;
			BigNumber$3.ROUND_UP = 0;
			BigNumber$3.ROUND_DOWN = 1;
			BigNumber$3.ROUND_CEIL = 2;
			BigNumber$3.ROUND_FLOOR = 3;
			BigNumber$3.ROUND_HALF_UP = 4;
			BigNumber$3.ROUND_HALF_DOWN = 5;
			BigNumber$3.ROUND_HALF_EVEN = 6;
			BigNumber$3.ROUND_HALF_CEIL = 7;
			BigNumber$3.ROUND_HALF_FLOOR = 8;
			BigNumber$3.EUCLID = 9;
			BigNumber$3.config = BigNumber$3.set = function(obj) {
				var p, v;
				if (obj != null) if (typeof obj == "object") {
					if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
						v = obj[p];
						intCheck(v, 0, MAX, p);
						DECIMAL_PLACES = v;
					}
					if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
						v = obj[p];
						intCheck(v, 0, 8, p);
						ROUNDING_MODE = v;
					}
					if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
						v = obj[p];
						if (v && v.pop) {
							intCheck(v[0], -MAX, 0, p);
							intCheck(v[1], 0, MAX, p);
							TO_EXP_NEG = v[0];
							TO_EXP_POS = v[1];
						} else {
							intCheck(v, -MAX, MAX, p);
							TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
						}
					}
					if (obj.hasOwnProperty(p = "RANGE")) {
						v = obj[p];
						if (v && v.pop) {
							intCheck(v[0], -MAX, -1, p);
							intCheck(v[1], 1, MAX, p);
							MIN_EXP = v[0];
							MAX_EXP = v[1];
						} else {
							intCheck(v, -MAX, MAX, p);
							if (v) MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
							else throw Error(bignumberError + p + " cannot be zero: " + v);
						}
					}
					if (obj.hasOwnProperty(p = "CRYPTO")) {
						v = obj[p];
						if (v === !!v) if (v) if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) CRYPTO = v;
						else {
							CRYPTO = !v;
							throw Error(bignumberError + "crypto unavailable");
						}
						else CRYPTO = v;
						else throw Error(bignumberError + p + " not true or false: " + v);
					}
					if (obj.hasOwnProperty(p = "MODULO_MODE")) {
						v = obj[p];
						intCheck(v, 0, 9, p);
						MODULO_MODE = v;
					}
					if (obj.hasOwnProperty(p = "POW_PRECISION")) {
						v = obj[p];
						intCheck(v, 0, MAX, p);
						POW_PRECISION = v;
					}
					if (obj.hasOwnProperty(p = "FORMAT")) {
						v = obj[p];
						if (typeof v == "object") FORMAT = v;
						else throw Error(bignumberError + p + " not an object: " + v);
					}
					if (obj.hasOwnProperty(p = "ALPHABET")) {
						v = obj[p];
						if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
							alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
							ALPHABET = v;
						} else throw Error(bignumberError + p + " invalid: " + v);
					}
				} else throw Error(bignumberError + "Object expected: " + obj);
				return {
					DECIMAL_PLACES,
					ROUNDING_MODE,
					EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
					RANGE: [MIN_EXP, MAX_EXP],
					CRYPTO,
					MODULO_MODE,
					POW_PRECISION,
					FORMAT,
					ALPHABET
				};
			};
			BigNumber$3.isBigNumber = function(v) {
				if (!v || v._isBigNumber !== true) return false;
				if (!BigNumber$3.DEBUG) return true;
				var i$1, n, c = v.c, e = v.e, s$1 = v.s;
				out: if ({}.toString.call(c) == "[object Array]") {
					if ((s$1 === 1 || s$1 === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
						if (c[0] === 0) {
							if (e === 0 && c.length === 1) return true;
							break out;
						}
						i$1 = (e + 1) % LOG_BASE;
						if (i$1 < 1) i$1 += LOG_BASE;
						if (String(c[0]).length == i$1) {
							for (i$1 = 0; i$1 < c.length; i$1++) {
								n = c[i$1];
								if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
							}
							if (n !== 0) return true;
						}
					}
				} else if (c === null && e === null && (s$1 === null || s$1 === 1 || s$1 === -1)) return true;
				throw Error(bignumberError + "Invalid BigNumber: " + v);
			};
			BigNumber$3.maximum = BigNumber$3.max = function() {
				return maxOrMin(arguments, -1);
			};
			BigNumber$3.minimum = BigNumber$3.min = function() {
				return maxOrMin(arguments, 1);
			};
			BigNumber$3.random = function() {
				var pow2_53 = 9007199254740992;
				var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
					return mathfloor(Math.random() * pow2_53);
				} : function() {
					return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
				};
				return function(dp) {
					var a$1, b, e, k, v, i$1 = 0, c = [], rand = new BigNumber$3(ONE);
					if (dp == null) dp = DECIMAL_PLACES;
					else intCheck(dp, 0, MAX);
					k = mathceil(dp / LOG_BASE);
					if (CRYPTO) if (crypto.getRandomValues) {
						a$1 = crypto.getRandomValues(new Uint32Array(k *= 2));
						for (; i$1 < k;) {
							v = a$1[i$1] * 131072 + (a$1[i$1 + 1] >>> 11);
							if (v >= 9e15) {
								b = crypto.getRandomValues(new Uint32Array(2));
								a$1[i$1] = b[0];
								a$1[i$1 + 1] = b[1];
							} else {
								c.push(v % 1e14);
								i$1 += 2;
							}
						}
						i$1 = k / 2;
					} else if (crypto.randomBytes) {
						a$1 = crypto.randomBytes(k *= 7);
						for (; i$1 < k;) {
							v = (a$1[i$1] & 31) * 281474976710656 + a$1[i$1 + 1] * 1099511627776 + a$1[i$1 + 2] * 4294967296 + a$1[i$1 + 3] * 16777216 + (a$1[i$1 + 4] << 16) + (a$1[i$1 + 5] << 8) + a$1[i$1 + 6];
							if (v >= 9e15) crypto.randomBytes(7).copy(a$1, i$1);
							else {
								c.push(v % 1e14);
								i$1 += 7;
							}
						}
						i$1 = k / 7;
					} else {
						CRYPTO = false;
						throw Error(bignumberError + "crypto unavailable");
					}
					if (!CRYPTO) for (; i$1 < k;) {
						v = random53bitInt();
						if (v < 9e15) c[i$1++] = v % 1e14;
					}
					k = c[--i$1];
					dp %= LOG_BASE;
					if (k && dp) {
						v = POWS_TEN[LOG_BASE - dp];
						c[i$1] = mathfloor(k / v) * v;
					}
					for (; c[i$1] === 0; c.pop(), i$1--);
					if (i$1 < 0) c = [e = 0];
					else {
						for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);
						for (i$1 = 1, v = c[0]; v >= 10; v /= 10, i$1++);
						if (i$1 < LOG_BASE) e -= LOG_BASE - i$1;
					}
					rand.e = e;
					rand.c = c;
					return rand;
				};
			}();
			BigNumber$3.sum = function() {
				var i$1 = 1, args = arguments, sum = new BigNumber$3(args[0]);
				for (; i$1 < args.length;) sum = sum.plus(args[i$1++]);
				return sum;
			};
			convertBase = function() {
				var decimal = "0123456789";
				function toBaseOut(str, baseIn, baseOut, alphabet) {
					var j, arr = [0], arrL, i$1 = 0, len$1 = str.length;
					for (; i$1 < len$1;) {
						for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);
						arr[0] += alphabet.indexOf(str.charAt(i$1++));
						for (j = 0; j < arr.length; j++) if (arr[j] > baseOut - 1) {
							if (arr[j + 1] == null) arr[j + 1] = 0;
							arr[j + 1] += arr[j] / baseOut | 0;
							arr[j] %= baseOut;
						}
					}
					return arr.reverse();
				}
				return function(str, baseIn, baseOut, sign$2, callerIsToString) {
					var alphabet, d$1, e, k, r, x, xc, y$1, i$1 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
					if (i$1 >= 0) {
						k = POW_PRECISION;
						POW_PRECISION = 0;
						str = str.replace(".", "");
						y$1 = new BigNumber$3(baseIn);
						x = y$1.pow(str.length - i$1);
						POW_PRECISION = k;
						y$1.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
						y$1.e = y$1.c.length;
					}
					xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
					e = k = xc.length;
					for (; xc[--k] == 0; xc.pop());
					if (!xc[0]) return alphabet.charAt(0);
					if (i$1 < 0) --e;
					else {
						x.c = xc;
						x.e = e;
						x.s = sign$2;
						x = div(x, y$1, dp, rm, baseOut);
						xc = x.c;
						r = x.r;
						e = x.e;
					}
					d$1 = e + dp + 1;
					i$1 = xc[d$1];
					k = baseOut / 2;
					r = r || d$1 < 0 || xc[d$1 + 1] != null;
					r = rm < 4 ? (i$1 != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i$1 > k || i$1 == k && (rm == 4 || r || rm == 6 && xc[d$1 - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
					if (d$1 < 1 || !xc[0]) str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
					else {
						xc.length = d$1;
						if (r) for (--baseOut; ++xc[--d$1] > baseOut;) {
							xc[d$1] = 0;
							if (!d$1) {
								++e;
								xc = [1].concat(xc);
							}
						}
						for (k = xc.length; !xc[--k];);
						for (i$1 = 0, str = ""; i$1 <= k; str += alphabet.charAt(xc[i$1++]));
						str = toFixedPoint(str, e, alphabet.charAt(0));
					}
					return str;
				};
			}();
			div = function() {
				function multiply(x, k, base) {
					var m$1, temp, xlo, xhi, carry = 0, i$1 = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
					for (x = x.slice(); i$1--;) {
						xlo = x[i$1] % SQRT_BASE;
						xhi = x[i$1] / SQRT_BASE | 0;
						m$1 = khi * xlo + xhi * klo;
						temp = klo * xlo + m$1 % SQRT_BASE * SQRT_BASE + carry;
						carry = (temp / base | 0) + (m$1 / SQRT_BASE | 0) + khi * xhi;
						x[i$1] = temp % base;
					}
					if (carry) x = [carry].concat(x);
					return x;
				}
				function compare$1(a$1, b, aL, bL) {
					var i$1, cmp;
					if (aL != bL) cmp = aL > bL ? 1 : -1;
					else for (i$1 = cmp = 0; i$1 < aL; i$1++) if (a$1[i$1] != b[i$1]) {
						cmp = a$1[i$1] > b[i$1] ? 1 : -1;
						break;
					}
					return cmp;
				}
				function subtract(a$1, b, aL, base) {
					var i$1 = 0;
					for (; aL--;) {
						a$1[aL] -= i$1;
						i$1 = a$1[aL] < b[aL] ? 1 : 0;
						a$1[aL] = i$1 * base + a$1[aL] - b[aL];
					}
					for (; !a$1[0] && a$1.length > 1; a$1.splice(0, 1));
				}
				return function(x, y$1, dp, rm, base) {
					var cmp, e, i$1, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s$1 = x.s == y$1.s ? 1 : -1, xc = x.c, yc = y$1.c;
					if (!xc || !xc[0] || !yc || !yc[0]) return new BigNumber$3(
						// Return NaN if either NaN, or both Infinity or 0.
						!x.s || !y$1.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s$1 * 0 : s$1 / 0
);
					q = new BigNumber$3(s$1);
					qc = q.c = [];
					e = x.e - y$1.e;
					s$1 = dp + e + 1;
					if (!base) {
						base = BASE;
						e = bitFloor(x.e / LOG_BASE) - bitFloor(y$1.e / LOG_BASE);
						s$1 = s$1 / LOG_BASE | 0;
					}
					for (i$1 = 0; yc[i$1] == (xc[i$1] || 0); i$1++);
					if (yc[i$1] > (xc[i$1] || 0)) e--;
					if (s$1 < 0) {
						qc.push(1);
						more = true;
					} else {
						xL = xc.length;
						yL = yc.length;
						i$1 = 0;
						s$1 += 2;
						n = mathfloor(base / (yc[0] + 1));
						if (n > 1) {
							yc = multiply(yc, n, base);
							xc = multiply(xc, n, base);
							yL = yc.length;
							xL = xc.length;
						}
						xi = yL;
						rem = xc.slice(0, yL);
						remL = rem.length;
						for (; remL < yL; rem[remL++] = 0);
						yz = yc.slice();
						yz = [0].concat(yz);
						yc0 = yc[0];
						if (yc[1] >= base / 2) yc0++;
						do {
							n = 0;
							cmp = compare$1(yc, rem, yL, remL);
							if (cmp < 0) {
								rem0 = rem[0];
								if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
								n = mathfloor(rem0 / yc0);
								if (n > 1) {
									if (n >= base) n = base - 1;
									prod = multiply(yc, n, base);
									prodL = prod.length;
									remL = rem.length;
									while (compare$1(prod, rem, prodL, remL) == 1) {
										n--;
										subtract(prod, yL < prodL ? yz : yc, prodL, base);
										prodL = prod.length;
										cmp = 1;
									}
								} else {
									if (n == 0) cmp = n = 1;
									prod = yc.slice();
									prodL = prod.length;
								}
								if (prodL < remL) prod = [0].concat(prod);
								subtract(rem, prod, remL, base);
								remL = rem.length;
								if (cmp == -1) while (compare$1(yc, rem, yL, remL) < 1) {
									n++;
									subtract(rem, yL < remL ? yz : yc, remL, base);
									remL = rem.length;
								}
							} else if (cmp === 0) {
								n++;
								rem = [0];
							}
							qc[i$1++] = n;
							if (rem[0]) rem[remL++] = xc[xi] || 0;
							else {
								rem = [xc[xi]];
								remL = 1;
							}
						} while ((xi++ < xL || rem[0] != null) && s$1--);
						more = rem[0] != null;
						if (!qc[0]) qc.splice(0, 1);
					}
					if (base == BASE) {
						for (i$1 = 1, s$1 = qc[0]; s$1 >= 10; s$1 /= 10, i$1++);
						round(q, dp + (q.e = i$1 + e * LOG_BASE - 1) + 1, rm, more);
					} else {
						q.e = e;
						q.r = +more;
					}
					return q;
				};
			}();
			function format$2(n, i$1, rm, id) {
				var c0, e, ne, len$1, str;
				if (rm == null) rm = ROUNDING_MODE;
				else intCheck(rm, 0, 8);
				if (!n.c) return n.toString();
				c0 = n.c[0];
				ne = n.e;
				if (i$1 == null) {
					str = coeffToString(n.c);
					str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
				} else {
					n = round(new BigNumber$3(n), i$1, rm);
					e = n.e;
					str = coeffToString(n.c);
					len$1 = str.length;
					if (id == 1 || id == 2 && (i$1 <= e || e <= TO_EXP_NEG)) {
						for (; len$1 < i$1; str += "0", len$1++);
						str = toExponential(str, e);
					} else {
						i$1 -= ne;
						str = toFixedPoint(str, e, "0");
						if (e + 1 > len$1) {
							if (--i$1 > 0) for (str += "."; i$1--; str += "0");
						} else {
							i$1 += e - len$1;
							if (i$1 > 0) {
								if (e + 1 == len$1) str += ".";
								for (; i$1--; str += "0");
							}
						}
					}
				}
				return n.s < 0 && c0 ? "-" + str : str;
			}
			function maxOrMin(args, n) {
				var k, y$1, i$1 = 1, x = new BigNumber$3(args[0]);
				for (; i$1 < args.length; i$1++) {
					y$1 = new BigNumber$3(args[i$1]);
					if (!y$1.s || (k = compare(x, y$1)) === n || k === 0 && x.s === n) x = y$1;
				}
				return x;
			}
			function normalise(n, c, e) {
				var i$1 = 1, j = c.length;
				for (; !c[--j]; c.pop());
				for (j = c[0]; j >= 10; j /= 10, i$1++);
				if ((e = i$1 + e * LOG_BASE - 1) > MAX_EXP) n.c = n.e = null;
				else if (e < MIN_EXP) n.c = [n.e = 0];
				else {
					n.e = e;
					n.c = c;
				}
				return n;
			}
			parseNumeric = function() {
				var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
				return function(x, str, isNum, b) {
					var base, s$1 = isNum ? str : str.replace(whitespaceOrPlus, "");
					if (isInfinityOrNaN.test(s$1)) x.s = isNaN(s$1) ? null : s$1 < 0 ? -1 : 1;
					else {
						if (!isNum) {
							s$1 = s$1.replace(basePrefix, function(m$1, p1, p2) {
								base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
								return !b || b == base ? p1 : m$1;
							});
							if (b) {
								base = b;
								s$1 = s$1.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
							}
							if (str != s$1) return new BigNumber$3(s$1, base);
						}
						if (BigNumber$3.DEBUG) throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
						x.s = null;
					}
					x.c = x.e = null;
				};
			}();
			function round(x, sd, rm, r) {
				var d$1, i$1, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
				if (xc) {
					out: {
						for (d$1 = 1, k = xc[0]; k >= 10; k /= 10, d$1++);
						i$1 = sd - d$1;
						if (i$1 < 0) {
							i$1 += LOG_BASE;
							j = sd;
							n = xc[ni = 0];
							rd = mathfloor(n / pows10[d$1 - j - 1] % 10);
						} else {
							ni = mathceil((i$1 + 1) / LOG_BASE);
							if (ni >= xc.length) if (r) {
								for (; xc.length <= ni; xc.push(0));
								n = rd = 0;
								d$1 = 1;
								i$1 %= LOG_BASE;
								j = i$1 - LOG_BASE + 1;
							} else break out;
							else {
								n = k = xc[ni];
								for (d$1 = 1; k >= 10; k /= 10, d$1++);
								i$1 %= LOG_BASE;
								j = i$1 - LOG_BASE + d$1;
								rd = j < 0 ? 0 : mathfloor(n / pows10[d$1 - j - 1] % 10);
							}
						}
						r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d$1 - j - 1]);
						r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i$1 > 0 ? j > 0 ? n / pows10[d$1 - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
						if (sd < 1 || !xc[0]) {
							xc.length = 0;
							if (r) {
								sd -= x.e + 1;
								xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
								x.e = -sd || 0;
							} else xc[0] = x.e = 0;
							return x;
						}
						if (i$1 == 0) {
							xc.length = ni;
							k = 1;
							ni--;
						} else {
							xc.length = ni + 1;
							k = pows10[LOG_BASE - i$1];
							xc[ni] = j > 0 ? mathfloor(n / pows10[d$1 - j] % pows10[j]) * k : 0;
						}
						if (r) for (;;) if (ni == 0) {
							for (i$1 = 1, j = xc[0]; j >= 10; j /= 10, i$1++);
							j = xc[0] += k;
							for (k = 1; j >= 10; j /= 10, k++);
							if (i$1 != k) {
								x.e++;
								if (xc[0] == BASE) xc[0] = 1;
							}
							break;
						} else {
							xc[ni] += k;
							if (xc[ni] != BASE) break;
							xc[ni--] = 0;
							k = 1;
						}
						for (i$1 = xc.length; xc[--i$1] === 0; xc.pop());
					}
					if (x.e > MAX_EXP) x.c = x.e = null;
					else if (x.e < MIN_EXP) x.c = [x.e = 0];
				}
				return x;
			}
			function valueOf(n) {
				var str, e = n.e;
				if (e === null) return n.toString();
				str = coeffToString(n.c);
				str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
				return n.s < 0 ? "-" + str : str;
			}
			P.absoluteValue = P.abs = function() {
				var x = new BigNumber$3(this);
				if (x.s < 0) x.s = 1;
				return x;
			};
			P.comparedTo = function(y$1, b) {
				return compare(this, new BigNumber$3(y$1, b));
			};
			P.decimalPlaces = P.dp = function(dp, rm) {
				var c, n, v, x = this;
				if (dp != null) {
					intCheck(dp, 0, MAX);
					if (rm == null) rm = ROUNDING_MODE;
					else intCheck(rm, 0, 8);
					return round(new BigNumber$3(x), dp + x.e + 1, rm);
				}
				if (!(c = x.c)) return null;
				n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
				if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
				if (n < 0) n = 0;
				return n;
			};
			P.dividedBy = P.div = function(y$1, b) {
				return div(this, new BigNumber$3(y$1, b), DECIMAL_PLACES, ROUNDING_MODE);
			};
			P.dividedToIntegerBy = P.idiv = function(y$1, b) {
				return div(this, new BigNumber$3(y$1, b), 0, 1);
			};
			P.exponentiatedBy = P.pow = function(n, m$1) {
				var half, isModExp, i$1, k, more, nIsBig, nIsNeg, nIsOdd, y$1, x = this;
				n = new BigNumber$3(n);
				if (n.c && !n.isInteger()) throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
				if (m$1 != null) m$1 = new BigNumber$3(m$1);
				nIsBig = n.e > 14;
				if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
					y$1 = new BigNumber$3(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
					return m$1 ? y$1.mod(m$1) : y$1;
				}
				nIsNeg = n.s < 0;
				if (m$1) {
					if (m$1.c ? !m$1.c[0] : !m$1.s) return new BigNumber$3(NaN);
					isModExp = !nIsNeg && x.isInteger() && m$1.isInteger();
					if (isModExp) x = x.mod(m$1);
				} else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
					k = x.s < 0 && isOdd(n) ? -0 : 0;
					if (x.e > -1) k = 1 / k;
					return new BigNumber$3(nIsNeg ? 1 / k : k);
				} else if (POW_PRECISION) k = mathceil(POW_PRECISION / LOG_BASE + 2);
				if (nIsBig) {
					half = new BigNumber$3(.5);
					if (nIsNeg) n.s = 1;
					nIsOdd = isOdd(n);
				} else {
					i$1 = Math.abs(+valueOf(n));
					nIsOdd = i$1 % 2;
				}
				y$1 = new BigNumber$3(ONE);
				for (;;) {
					if (nIsOdd) {
						y$1 = y$1.times(x);
						if (!y$1.c) break;
						if (k) {
							if (y$1.c.length > k) y$1.c.length = k;
						} else if (isModExp) y$1 = y$1.mod(m$1);
					}
					if (i$1) {
						i$1 = mathfloor(i$1 / 2);
						if (i$1 === 0) break;
						nIsOdd = i$1 % 2;
					} else {
						n = n.times(half);
						round(n, n.e + 1, 1);
						if (n.e > 14) nIsOdd = isOdd(n);
						else {
							i$1 = +valueOf(n);
							if (i$1 === 0) break;
							nIsOdd = i$1 % 2;
						}
					}
					x = x.times(x);
					if (k) {
						if (x.c && x.c.length > k) x.c.length = k;
					} else if (isModExp) x = x.mod(m$1);
				}
				if (isModExp) return y$1;
				if (nIsNeg) y$1 = ONE.div(y$1);
				return m$1 ? y$1.mod(m$1) : k ? round(y$1, POW_PRECISION, ROUNDING_MODE, more) : y$1;
			};
			P.integerValue = function(rm) {
				var n = new BigNumber$3(this);
				if (rm == null) rm = ROUNDING_MODE;
				else intCheck(rm, 0, 8);
				return round(n, n.e + 1, rm);
			};
			P.isEqualTo = P.eq = function(y$1, b) {
				return compare(this, new BigNumber$3(y$1, b)) === 0;
			};
			P.isFinite = function() {
				return !!this.c;
			};
			P.isGreaterThan = P.gt = function(y$1, b) {
				return compare(this, new BigNumber$3(y$1, b)) > 0;
			};
			P.isGreaterThanOrEqualTo = P.gte = function(y$1, b) {
				return (b = compare(this, new BigNumber$3(y$1, b))) === 1 || b === 0;
			};
			P.isInteger = function() {
				return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
			};
			P.isLessThan = P.lt = function(y$1, b) {
				return compare(this, new BigNumber$3(y$1, b)) < 0;
			};
			P.isLessThanOrEqualTo = P.lte = function(y$1, b) {
				return (b = compare(this, new BigNumber$3(y$1, b))) === -1 || b === 0;
			};
			P.isNaN = function() {
				return !this.s;
			};
			P.isNegative = function() {
				return this.s < 0;
			};
			P.isPositive = function() {
				return this.s > 0;
			};
			P.isZero = function() {
				return !!this.c && this.c[0] == 0;
			};
			P.minus = function(y$1, b) {
				var i$1, j, t, xLTy, x = this, a$1 = x.s;
				y$1 = new BigNumber$3(y$1, b);
				b = y$1.s;
				if (!a$1 || !b) return new BigNumber$3(NaN);
				if (a$1 != b) {
					y$1.s = -b;
					return x.plus(y$1);
				}
				var xe = x.e / LOG_BASE, ye = y$1.e / LOG_BASE, xc = x.c, yc = y$1.c;
				if (!xe || !ye) {
					if (!xc || !yc) return xc ? (y$1.s = -b, y$1) : new BigNumber$3(yc ? x : NaN);
					if (!xc[0] || !yc[0]) return yc[0] ? (y$1.s = -b, y$1) : new BigNumber$3(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
				}
				xe = bitFloor(xe);
				ye = bitFloor(ye);
				xc = xc.slice();
				if (a$1 = xe - ye) {
					if (xLTy = a$1 < 0) {
						a$1 = -a$1;
						t = xc;
					} else {
						ye = xe;
						t = yc;
					}
					t.reverse();
					for (b = a$1; b--; t.push(0));
					t.reverse();
				} else {
					j = (xLTy = (a$1 = xc.length) < (b = yc.length)) ? a$1 : b;
					for (a$1 = b = 0; b < j; b++) if (xc[b] != yc[b]) {
						xLTy = xc[b] < yc[b];
						break;
					}
				}
				if (xLTy) {
					t = xc;
					xc = yc;
					yc = t;
					y$1.s = -y$1.s;
				}
				b = (j = yc.length) - (i$1 = xc.length);
				if (b > 0) for (; b--; xc[i$1++] = 0);
				b = BASE - 1;
				for (; j > a$1;) {
					if (xc[--j] < yc[j]) {
						for (i$1 = j; i$1 && !xc[--i$1]; xc[i$1] = b);
						--xc[i$1];
						xc[j] += BASE;
					}
					xc[j] -= yc[j];
				}
				for (; xc[0] == 0; xc.splice(0, 1), --ye);
				if (!xc[0]) {
					y$1.s = ROUNDING_MODE == 3 ? -1 : 1;
					y$1.c = [y$1.e = 0];
					return y$1;
				}
				return normalise(y$1, xc, ye);
			};
			P.modulo = P.mod = function(y$1, b) {
				var q, s$1, x = this;
				y$1 = new BigNumber$3(y$1, b);
				if (!x.c || !y$1.s || y$1.c && !y$1.c[0]) return new BigNumber$3(NaN);
				else if (!y$1.c || x.c && !x.c[0]) return new BigNumber$3(x);
				if (MODULO_MODE == 9) {
					s$1 = y$1.s;
					y$1.s = 1;
					q = div(x, y$1, 0, 3);
					y$1.s = s$1;
					q.s *= s$1;
				} else q = div(x, y$1, 0, MODULO_MODE);
				y$1 = x.minus(q.times(y$1));
				if (!y$1.c[0] && MODULO_MODE == 1) y$1.s = x.s;
				return y$1;
			};
			P.multipliedBy = P.times = function(y$1, b) {
				var c, e, i$1, j, k, m$1, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y$1 = new BigNumber$3(y$1, b)).c;
				if (!xc || !yc || !xc[0] || !yc[0]) {
					if (!x.s || !y$1.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) y$1.c = y$1.e = y$1.s = null;
					else {
						y$1.s *= x.s;
						if (!xc || !yc) y$1.c = y$1.e = null;
						else {
							y$1.c = [0];
							y$1.e = 0;
						}
					}
					return y$1;
				}
				e = bitFloor(x.e / LOG_BASE) + bitFloor(y$1.e / LOG_BASE);
				y$1.s *= x.s;
				xcL = xc.length;
				ycL = yc.length;
				if (xcL < ycL) {
					zc = xc;
					xc = yc;
					yc = zc;
					i$1 = xcL;
					xcL = ycL;
					ycL = i$1;
				}
				for (i$1 = xcL + ycL, zc = []; i$1--; zc.push(0));
				base = BASE;
				sqrtBase = SQRT_BASE;
				for (i$1 = ycL; --i$1 >= 0;) {
					c = 0;
					ylo = yc[i$1] % sqrtBase;
					yhi = yc[i$1] / sqrtBase | 0;
					for (k = xcL, j = i$1 + k; j > i$1;) {
						xlo = xc[--k] % sqrtBase;
						xhi = xc[k] / sqrtBase | 0;
						m$1 = yhi * xlo + xhi * ylo;
						xlo = ylo * xlo + m$1 % sqrtBase * sqrtBase + zc[j] + c;
						c = (xlo / base | 0) + (m$1 / sqrtBase | 0) + yhi * xhi;
						zc[j--] = xlo % base;
					}
					zc[j] = c;
				}
				if (c) ++e;
				else zc.splice(0, 1);
				return normalise(y$1, zc, e);
			};
			P.negated = function() {
				var x = new BigNumber$3(this);
				x.s = -x.s || null;
				return x;
			};
			P.plus = function(y$1, b) {
				var t, x = this, a$1 = x.s;
				y$1 = new BigNumber$3(y$1, b);
				b = y$1.s;
				if (!a$1 || !b) return new BigNumber$3(NaN);
				if (a$1 != b) {
					y$1.s = -b;
					return x.minus(y$1);
				}
				var xe = x.e / LOG_BASE, ye = y$1.e / LOG_BASE, xc = x.c, yc = y$1.c;
				if (!xe || !ye) {
					if (!xc || !yc) return new BigNumber$3(a$1 / 0);
					if (!xc[0] || !yc[0]) return yc[0] ? y$1 : new BigNumber$3(xc[0] ? x : a$1 * 0);
				}
				xe = bitFloor(xe);
				ye = bitFloor(ye);
				xc = xc.slice();
				if (a$1 = xe - ye) {
					if (a$1 > 0) {
						ye = xe;
						t = yc;
					} else {
						a$1 = -a$1;
						t = xc;
					}
					t.reverse();
					for (; a$1--; t.push(0));
					t.reverse();
				}
				a$1 = xc.length;
				b = yc.length;
				if (a$1 - b < 0) {
					t = yc;
					yc = xc;
					xc = t;
					b = a$1;
				}
				for (a$1 = 0; b;) {
					a$1 = (xc[--b] = xc[b] + yc[b] + a$1) / BASE | 0;
					xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
				}
				if (a$1) {
					xc = [a$1].concat(xc);
					++ye;
				}
				return normalise(y$1, xc, ye);
			};
			P.precision = P.sd = function(sd, rm) {
				var c, n, v, x = this;
				if (sd != null && sd !== !!sd) {
					intCheck(sd, 1, MAX);
					if (rm == null) rm = ROUNDING_MODE;
					else intCheck(rm, 0, 8);
					return round(new BigNumber$3(x), sd, rm);
				}
				if (!(c = x.c)) return null;
				v = c.length - 1;
				n = v * LOG_BASE + 1;
				if (v = c[v]) {
					for (; v % 10 == 0; v /= 10, n--);
					for (v = c[0]; v >= 10; v /= 10, n++);
				}
				if (sd && x.e + 1 > n) n = x.e + 1;
				return n;
			};
			P.shiftedBy = function(k) {
				intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
				return this.times("1e" + k);
			};
			P.squareRoot = P.sqrt = function() {
				var m$1, n, r, rep, t, x = this, c = x.c, s$1 = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber$3("0.5");
				if (s$1 !== 1 || !c || !c[0]) return new BigNumber$3(!s$1 || s$1 < 0 && (!c || c[0]) ? NaN : c ? x : Infinity);
				s$1 = Math.sqrt(+valueOf(x));
				if (s$1 == 0 || s$1 == Infinity) {
					n = coeffToString(c);
					if ((n.length + e) % 2 == 0) n += "0";
					s$1 = Math.sqrt(+n);
					e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
					if (s$1 == Infinity) n = "5e" + e;
					else {
						n = s$1.toExponential();
						n = n.slice(0, n.indexOf("e") + 1) + e;
					}
					r = new BigNumber$3(n);
				} else r = new BigNumber$3(s$1 + "");
				if (r.c[0]) {
					e = r.e;
					s$1 = e + dp;
					if (s$1 < 3) s$1 = 0;
					for (;;) {
						t = r;
						r = half.times(t.plus(div(x, t, dp, 1)));
						if (coeffToString(t.c).slice(0, s$1) === (n = coeffToString(r.c)).slice(0, s$1)) {
							if (r.e < e) --s$1;
							n = n.slice(s$1 - 3, s$1 + 1);
							if (n == "9999" || !rep && n == "4999") {
								if (!rep) {
									round(t, t.e + DECIMAL_PLACES + 2, 0);
									if (t.times(t).eq(x)) {
										r = t;
										break;
									}
								}
								dp += 4;
								s$1 += 4;
								rep = 1;
							} else {
								if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
									round(r, r.e + DECIMAL_PLACES + 2, 1);
									m$1 = !r.times(r).eq(x);
								}
								break;
							}
						}
					}
				}
				return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m$1);
			};
			P.toExponential = function(dp, rm) {
				if (dp != null) {
					intCheck(dp, 0, MAX);
					dp++;
				}
				return format$2(this, dp, rm, 1);
			};
			P.toFixed = function(dp, rm) {
				if (dp != null) {
					intCheck(dp, 0, MAX);
					dp = dp + this.e + 1;
				}
				return format$2(this, dp, rm);
			};
			P.toFormat = function(dp, rm, format$3) {
				var str, x = this;
				if (format$3 == null) if (dp != null && rm && typeof rm == "object") {
					format$3 = rm;
					rm = null;
				} else if (dp && typeof dp == "object") {
					format$3 = dp;
					dp = rm = null;
				} else format$3 = FORMAT;
				else if (typeof format$3 != "object") throw Error(bignumberError + "Argument not an object: " + format$3);
				str = x.toFixed(dp, rm);
				if (x.c) {
					var i$1, arr = str.split("."), g1 = +format$3.groupSize, g2 = +format$3.secondaryGroupSize, groupSeparator = format$3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len$1 = intDigits.length;
					if (g2) {
						i$1 = g1;
						g1 = g2;
						g2 = i$1;
						len$1 -= i$1;
					}
					if (g1 > 0 && len$1 > 0) {
						i$1 = len$1 % g1 || g1;
						intPart = intDigits.substr(0, i$1);
						for (; i$1 < len$1; i$1 += g1) intPart += groupSeparator + intDigits.substr(i$1, g1);
						if (g2 > 0) intPart += groupSeparator + intDigits.slice(i$1);
						if (isNeg) intPart = "-" + intPart;
					}
					str = fractionPart ? intPart + (format$3.decimalSeparator || "") + ((g2 = +format$3.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format$3.fractionGroupSeparator || "")) : fractionPart) : intPart;
				}
				return (format$3.prefix || "") + str + (format$3.suffix || "");
			};
			P.toFraction = function(md) {
				var d$1, d0, d1, d2, e, exp, n, n0, n1, q, r, s$1, x = this, xc = x.c;
				if (md != null) {
					n = new BigNumber$3(md);
					if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
				}
				if (!xc) return new BigNumber$3(x);
				d$1 = new BigNumber$3(ONE);
				n1 = d0 = new BigNumber$3(ONE);
				d1 = n0 = new BigNumber$3(ONE);
				s$1 = coeffToString(xc);
				e = d$1.e = s$1.length - x.e - 1;
				d$1.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
				md = !md || n.comparedTo(d$1) > 0 ? e > 0 ? d$1 : n1 : n;
				exp = MAX_EXP;
				MAX_EXP = Infinity;
				n = new BigNumber$3(s$1);
				n0.c[0] = 0;
				for (;;) {
					q = div(n, d$1, 0, 1);
					d2 = d0.plus(q.times(d1));
					if (d2.comparedTo(md) == 1) break;
					d0 = d1;
					d1 = d2;
					n1 = n0.plus(q.times(d2 = n1));
					n0 = d2;
					d$1 = n.minus(q.times(d2 = d$1));
					n = d2;
				}
				d2 = div(md.minus(d0), d1, 0, 1);
				n0 = n0.plus(d2.times(n1));
				d0 = d0.plus(d2.times(d1));
				n0.s = n1.s = x.s;
				e = e * 2;
				r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
				MAX_EXP = exp;
				return r;
			};
			P.toNumber = function() {
				return +valueOf(this);
			};
			P.toPrecision = function(sd, rm) {
				if (sd != null) intCheck(sd, 1, MAX);
				return format$2(this, sd, rm, 2);
			};
			P.toString = function(b) {
				var str, n = this, s$1 = n.s, e = n.e;
				if (e === null) if (s$1) {
					str = "Infinity";
					if (s$1 < 0) str = "-" + str;
				} else str = "NaN";
				else {
					if (b == null) str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
					else if (b === 10 && alphabetHasNormalDecimalDigits) {
						n = round(new BigNumber$3(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
						str = toFixedPoint(coeffToString(n.c), n.e, "0");
					} else {
						intCheck(b, 2, ALPHABET.length, "Base");
						str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s$1, true);
					}
					if (s$1 < 0 && n.c[0]) str = "-" + str;
				}
				return str;
			};
			P.valueOf = P.toJSON = function() {
				return valueOf(this);
			};
			P._isBigNumber = true;
			if (configObject != null) BigNumber$3.set(configObject);
			return BigNumber$3;
		}
		function bitFloor(n) {
			var i$1 = n | 0;
			return n > 0 || n === i$1 ? i$1 : i$1 - 1;
		}
		function coeffToString(a$1) {
			var s$1, z, i$1 = 1, j = a$1.length, r = a$1[0] + "";
			for (; i$1 < j;) {
				s$1 = a$1[i$1++] + "";
				z = LOG_BASE - s$1.length;
				for (; z--; s$1 = "0" + s$1);
				r += s$1;
			}
			for (j = r.length; r.charCodeAt(--j) === 48;);
			return r.slice(0, j + 1 || 1);
		}
		function compare(x, y$1) {
			var a$1, b, xc = x.c, yc = y$1.c, i$1 = x.s, j = y$1.s, k = x.e, l = y$1.e;
			if (!i$1 || !j) return null;
			a$1 = xc && !xc[0];
			b = yc && !yc[0];
			if (a$1 || b) return a$1 ? b ? 0 : -j : i$1;
			if (i$1 != j) return i$1;
			a$1 = i$1 < 0;
			b = k == l;
			if (!xc || !yc) return b ? 0 : !xc ^ a$1 ? 1 : -1;
			if (!b) return k > l ^ a$1 ? 1 : -1;
			j = (k = xc.length) < (l = yc.length) ? k : l;
			for (i$1 = 0; i$1 < j; i$1++) if (xc[i$1] != yc[i$1]) return xc[i$1] > yc[i$1] ^ a$1 ? 1 : -1;
			return k == l ? 0 : k > l ^ a$1 ? 1 : -1;
		}
		function intCheck(n, min, max, name) {
			if (n < min || n > max || n !== mathfloor(n)) throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
		}
		function isOdd(n) {
			var k = n.c.length - 1;
			return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
		}
		function toExponential(str, e) {
			return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
		}
		function toFixedPoint(str, e, z) {
			var len$1, zs;
			if (e < 0) {
				for (zs = z + "."; ++e; zs += z);
				str = zs + str;
			} else {
				len$1 = str.length;
				if (++e > len$1) {
					for (zs = z, e -= len$1; --e; zs += z);
					str += zs;
				} else if (e < len$1) str = str.slice(0, e) + "." + str.slice(e);
			}
			return str;
		}
		BigNumber$2 = clone$1();
		BigNumber$2["default"] = BigNumber$2.BigNumber = BigNumber$2;
		if (typeof define == "function" && define.amd) define(function() {
			return BigNumber$2;
		});
		else if (typeof module != "undefined" && module.exports) module.exports = BigNumber$2;
		else {
			if (!globalObject) globalObject = typeof self != "undefined" && self ? self : window;
			globalObject.BigNumber = BigNumber$2;
		}
	})(exports);
} });

//#endregion
//#region node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({ "node_modules/json-bigint/lib/stringify.js"(exports, module) {
	var BigNumber$1 = require_bignumber();
	var JSON$1 = module.exports;
	(function() {
		"use strict";
		function f(n) {
			return n < 10 ? "0" + n : n;
		}
		var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
			"\b": "\\b",
			"	": "\\t",
			"\n": "\\n",
			"\f": "\\f",
			"\r": "\\r",
			"\"": "\\\"",
			"\\": "\\\\"
		}, rep;
		function quote(string) {
			escapable.lastIndex = 0;
			return escapable.test(string) ? "\"" + string.replace(escapable, function(a$1) {
				var c = meta[a$1];
				return typeof c === "string" ? c : "\\u" + ("0000" + a$1.charCodeAt(0).toString(16)).slice(-4);
			}) + "\"" : "\"" + string + "\"";
		}
		function str(key, holder) {
			var i$1, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber$1 || BigNumber$1.isBigNumber(value));
			if (value && typeof value === "object" && typeof value.toJSON === "function") value = value.toJSON(key);
			if (typeof rep === "function") value = rep.call(holder, key, value);
			switch (typeof value) {
				case "string": if (isBigNumber) return value;
				else return quote(value);
				case "number": return isFinite(value) ? String(value) : "null";
				case "boolean":
				case "null":
				case "bigint": return String(value);
				case "object":
					if (!value) return "null";
					gap += indent;
					partial = [];
					if (Object.prototype.toString.apply(value) === "[object Array]") {
						length = value.length;
						for (i$1 = 0; i$1 < length; i$1 += 1) partial[i$1] = str(i$1, value) || "null";
						v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
						gap = mind;
						return v;
					}
					if (rep && typeof rep === "object") {
						length = rep.length;
						for (i$1 = 0; i$1 < length; i$1 += 1) if (typeof rep[i$1] === "string") {
							k = rep[i$1];
							v = str(k, value);
							if (v) partial.push(quote(k) + (gap ? ": " : ":") + v);
						}
					} else Object.keys(value).forEach(function(k$1) {
						var v$1 = str(k$1, value);
						if (v$1) partial.push(quote(k$1) + (gap ? ": " : ":") + v$1);
					});
					v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
					gap = mind;
					return v;
			}
		}
		if (typeof JSON$1.stringify !== "function") JSON$1.stringify = function(value, replacer, space) {
			var i$1;
			gap = "";
			indent = "";
			if (typeof space === "number") for (i$1 = 0; i$1 < space; i$1 += 1) indent += " ";
			else if (typeof space === "string") indent = space;
			rep = replacer;
			if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) throw new Error("JSON.stringify");
			return str("", { "": value });
		};
	})();
} });

//#endregion
//#region node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({ "node_modules/json-bigint/lib/parse.js"(exports, module) {
	var BigNumber = null;
	const suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
	const suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
	var json_parse$1 = function(options) {
		"use strict";
		var _options = {
			strict: false,
			storeAsString: false,
			alwaysParseAsBig: false,
			useNativeBigInt: false,
			protoAction: "error",
			constructorAction: "error"
		};
		if (options !== void 0 && options !== null) {
			if (options.strict === true) _options.strict = true;
			if (options.storeAsString === true) _options.storeAsString = true;
			_options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
			_options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
			if (typeof options.constructorAction !== "undefined") if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") _options.constructorAction = options.constructorAction;
			else throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`);
			if (typeof options.protoAction !== "undefined") if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") _options.protoAction = options.protoAction;
			else throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`);
		}
		var at$1, ch, escapee = {
			"\"": "\"",
			"\\": "\\",
			"/": "/",
			b: "\b",
			f: "\f",
			n: "\n",
			r: "\r",
			t: "	"
		}, text, error$1 = function(m$1) {
			throw {
				name: "SyntaxError",
				message: m$1,
				at: at$1,
				text
			};
		}, next = function(c) {
			if (c && c !== ch) error$1("Expected '" + c + "' instead of '" + ch + "'");
			ch = text.charAt(at$1);
			at$1 += 1;
			return ch;
		}, number = function() {
			var number$1, string$1 = "";
			if (ch === "-") {
				string$1 = "-";
				next("-");
			}
			while (ch >= "0" && ch <= "9") {
				string$1 += ch;
				next();
			}
			if (ch === ".") {
				string$1 += ".";
				while (next() && ch >= "0" && ch <= "9") string$1 += ch;
			}
			if (ch === "e" || ch === "E") {
				string$1 += ch;
				next();
				if (ch === "-" || ch === "+") {
					string$1 += ch;
					next();
				}
				while (ch >= "0" && ch <= "9") {
					string$1 += ch;
					next();
				}
			}
			number$1 = +string$1;
			if (!isFinite(number$1)) error$1("Bad number");
			else {
				if (BigNumber == null) BigNumber = require_bignumber();
				if (string$1.length > 15) return _options.storeAsString ? string$1 : _options.useNativeBigInt ? BigInt(string$1) : new BigNumber(string$1);
				else return !_options.alwaysParseAsBig ? number$1 : _options.useNativeBigInt ? BigInt(number$1) : new BigNumber(number$1);
			}
		}, string = function() {
			var hex, i$1, string$1 = "", uffff;
			if (ch === "\"") {
				var startAt = at$1;
				while (next()) {
					if (ch === "\"") {
						if (at$1 - 1 > startAt) string$1 += text.substring(startAt, at$1 - 1);
						next();
						return string$1;
					}
					if (ch === "\\") {
						if (at$1 - 1 > startAt) string$1 += text.substring(startAt, at$1 - 1);
						next();
						if (ch === "u") {
							uffff = 0;
							for (i$1 = 0; i$1 < 4; i$1 += 1) {
								hex = parseInt(next(), 16);
								if (!isFinite(hex)) break;
								uffff = uffff * 16 + hex;
							}
							string$1 += String.fromCharCode(uffff);
						} else if (typeof escapee[ch] === "string") string$1 += escapee[ch];
						else break;
						startAt = at$1;
					}
				}
			}
			error$1("Bad string");
		}, white = function() {
			while (ch && ch <= " ") next();
		}, word = function() {
			switch (ch) {
				case "t":
					next("t");
					next("r");
					next("u");
					next("e");
					return true;
				case "f":
					next("f");
					next("a");
					next("l");
					next("s");
					next("e");
					return false;
				case "n":
					next("n");
					next("u");
					next("l");
					next("l");
					return null;
			}
			error$1("Unexpected '" + ch + "'");
		}, value, array = function() {
			var array$1 = [];
			if (ch === "[") {
				next("[");
				white();
				if (ch === "]") {
					next("]");
					return array$1;
				}
				while (ch) {
					array$1.push(value());
					white();
					if (ch === "]") {
						next("]");
						return array$1;
					}
					next(",");
					white();
				}
			}
			error$1("Bad array");
		}, object = function() {
			var key, object$1 = Object.create(null);
			if (ch === "{") {
				next("{");
				white();
				if (ch === "}") {
					next("}");
					return object$1;
				}
				while (ch) {
					key = string();
					white();
					next(":");
					if (_options.strict === true && Object.hasOwnProperty.call(object$1, key)) error$1("Duplicate key \"" + key + "\"");
					if (suspectProtoRx.test(key) === true) if (_options.protoAction === "error") error$1("Object contains forbidden prototype property");
					else if (_options.protoAction === "ignore") value();
					else object$1[key] = value();
					else if (suspectConstructorRx.test(key) === true) if (_options.constructorAction === "error") error$1("Object contains forbidden constructor property");
					else if (_options.constructorAction === "ignore") value();
					else object$1[key] = value();
					else object$1[key] = value();
					white();
					if (ch === "}") {
						next("}");
						return object$1;
					}
					next(",");
					white();
				}
			}
			error$1("Bad object");
		};
		value = function() {
			white();
			switch (ch) {
				case "{": return object();
				case "[": return array();
				case "\"": return string();
				case "-": return number();
				default: return ch >= "0" && ch <= "9" ? number() : word();
			}
		};
		return function(source, reviver) {
			var result;
			text = source + "";
			at$1 = 0;
			ch = " ";
			result = value();
			white();
			if (ch) error$1("Syntax error");
			return typeof reviver === "function" ? function walk(holder, key) {
				var k, v, value$1 = holder[key];
				if (value$1 && typeof value$1 === "object") Object.keys(value$1).forEach(function(k$1) {
					v = walk(value$1, k$1);
					if (v !== void 0) value$1[k$1] = v;
					else delete value$1[k$1];
				});
				return reviver.call(holder, key, value$1);
			}({ "": result }, "") : result;
		};
	};
	module.exports = json_parse$1;
} });

//#endregion
//#region node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({ "node_modules/json-bigint/index.js"(exports, module) {
	var json_stringify = require_stringify().stringify;
	var json_parse = require_parse();
	module.exports = function(options) {
		return {
			parse: json_parse(options),
			stringify: json_stringify
		};
	};
	module.exports.parse = json_parse();
	module.exports.stringify = json_stringify;
} });

//#endregion
//#region node_modules/gcp-metadata/build/src/gcp-residency.js
var require_gcp_residency = __commonJS({ "node_modules/gcp-metadata/build/src/gcp-residency.js"(exports) {
	/**
	* Copyright 2022 Google LLC
	*
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*      http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GCE_LINUX_BIOS_PATHS = void 0;
	exports.isGoogleCloudServerless = isGoogleCloudServerless;
	exports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;
	exports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;
	exports.isGoogleComputeEngine = isGoogleComputeEngine;
	exports.detectGCPResidency = detectGCPResidency;
	const fs_1 = require("fs");
	const os_1 = require("os");
	/**
	* Known paths unique to Google Compute Engine Linux instances
	*/
	exports.GCE_LINUX_BIOS_PATHS = {
		BIOS_DATE: "/sys/class/dmi/id/bios_date",
		BIOS_VENDOR: "/sys/class/dmi/id/bios_vendor"
	};
	const GCE_MAC_ADDRESS_REGEX = /^42:01/;
	/**
	* Determines if the process is running on a Google Cloud Serverless environment (Cloud Run or Cloud Functions instance).
	*
	* Uses the:
	* - {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.
	* - {@link https://cloud.google.com/functions/docs/env-var Cloud Functions environment variables}.
	*
	* @returns {boolean} `true` if the process is running on GCP serverless, `false` otherwise.
	*/
	function isGoogleCloudServerless() {
		/**
		* `CLOUD_RUN_JOB` is used for Cloud Run Jobs
		* - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.
		*
		* `FUNCTION_NAME` is used in older Cloud Functions environments:
		* - See {@link https://cloud.google.com/functions/docs/env-var Python 3.7 and Go 1.11}.
		*
		* `K_SERVICE` is used in Cloud Run and newer Cloud Functions environments:
		* - See {@link https://cloud.google.com/run/docs/container-contract#env-vars Cloud Run environment variables}.
		* - See {@link https://cloud.google.com/functions/docs/env-var Cloud Functions newer runtimes}.
		*/
		const isGFEnvironment = process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE;
		return !!isGFEnvironment;
	}
	/**
	* Determines if the process is running on a Linux Google Compute Engine instance.
	*
	* @returns {boolean} `true` if the process is running on Linux GCE, `false` otherwise.
	*/
	function isGoogleComputeEngineLinux() {
		if ((0, os_1.platform)() !== "linux") return false;
		try {
			(0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);
			const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, "utf8");
			return /Google/.test(biosVendor);
		} catch (_a$5) {
			return false;
		}
	}
	/**
	* Determines if the process is running on a Google Compute Engine instance with a known
	* MAC address.
	*
	* @returns {boolean} `true` if the process is running on GCE (as determined by MAC address), `false` otherwise.
	*/
	function isGoogleComputeEngineMACAddress() {
		const interfaces = (0, os_1.networkInterfaces)();
		for (const item of Object.values(interfaces)) {
			if (!item) continue;
			for (const { mac } of item) if (GCE_MAC_ADDRESS_REGEX.test(mac)) return true;
		}
		return false;
	}
	/**
	* Determines if the process is running on a Google Compute Engine instance.
	*
	* @returns {boolean} `true` if the process is running on GCE, `false` otherwise.
	*/
	function isGoogleComputeEngine() {
		return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();
	}
	/**
	* Determines if the process is running on Google Cloud Platform.
	*
	* @returns {boolean} `true` if the process is running on GCP, `false` otherwise.
	*/
	function detectGCPResidency() {
		return isGoogleCloudServerless() || isGoogleComputeEngine();
	}
} });

//#endregion
//#region node_modules/google-logging-utils/build/src/colours.js
var require_colours = __commonJS({ "node_modules/google-logging-utils/build/src/colours.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Colours = void 0;
	/**
	* Handles figuring out if we can use ANSI colours and handing out the escape codes.
	*
	* This is for package-internal use only, and may change at any time.
	*
	* @private
	* @internal
	*/
	var Colours = class Colours {
		/**
		* @param stream The stream (e.g. process.stderr)
		* @returns true if the stream should have colourization enabled
		*/
		static isEnabled(stream$6) {
			return stream$6.isTTY && (typeof stream$6.getColorDepth === "function" ? stream$6.getColorDepth() > 2 : true);
		}
		static refresh() {
			Colours.enabled = Colours.isEnabled(process.stderr);
			if (!this.enabled) {
				Colours.reset = "";
				Colours.bright = "";
				Colours.dim = "";
				Colours.red = "";
				Colours.green = "";
				Colours.yellow = "";
				Colours.blue = "";
				Colours.magenta = "";
				Colours.cyan = "";
				Colours.white = "";
				Colours.grey = "";
			} else {
				Colours.reset = "\x1B[0m";
				Colours.bright = "\x1B[1m";
				Colours.dim = "\x1B[2m";
				Colours.red = "\x1B[31m";
				Colours.green = "\x1B[32m";
				Colours.yellow = "\x1B[33m";
				Colours.blue = "\x1B[34m";
				Colours.magenta = "\x1B[35m";
				Colours.cyan = "\x1B[36m";
				Colours.white = "\x1B[37m";
				Colours.grey = "\x1B[90m";
			}
		}
	};
	exports.Colours = Colours;
	Colours.enabled = false;
	Colours.reset = "";
	Colours.bright = "";
	Colours.dim = "";
	Colours.red = "";
	Colours.green = "";
	Colours.yellow = "";
	Colours.blue = "";
	Colours.magenta = "";
	Colours.cyan = "";
	Colours.white = "";
	Colours.grey = "";
	Colours.refresh();
} });

//#endregion
//#region node_modules/google-logging-utils/build/src/logging-utils.js
var require_logging_utils = __commonJS({ "node_modules/google-logging-utils/build/src/logging-utils.js"(exports) {
	var __createBinding$2 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
		Object.defineProperty(o, "default", {
			enumerable: true,
			value: v
		});
	} : function(o, v) {
		o["default"] = v;
	});
	var __importStar = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
		}
		__setModuleDefault(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.env = exports.DebugLogBackendBase = exports.placeholder = exports.AdhocDebugLogger = exports.LogSeverity = void 0;
	exports.getNodeBackend = getNodeBackend;
	exports.getDebugBackend = getDebugBackend;
	exports.getStructuredBackend = getStructuredBackend;
	exports.setBackend = setBackend;
	exports.log = log$1;
	const node_events_1 = require("node:events");
	const process$1 = __importStar(require("node:process"));
	const util$4 = __importStar(require("node:util"));
	const colours_1 = require_colours();
	/**
	* This module defines an ad-hoc debug logger for Google Cloud Platform
	* client libraries in Node. An ad-hoc debug logger is a tool which lets
	* users use an external, unified interface (in this case, environment
	* variables) to determine what logging they want to see at runtime. This
	* isn't necessarily fed into the console, but is meant to be under the
	* control of the user. The kind of logging that will be produced by this
	* is more like "call retry happened", not "event you'd want to record
	* in Cloud Logger".
	*
	* More for Googlers implementing libraries with it:
	* go/cloud-client-logging-design
	*/
	/**
	* Possible log levels. These are a subset of Cloud Observability levels.
	* https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#LogSeverity
	*/
	var LogSeverity;
	(function(LogSeverity$1) {
		LogSeverity$1["DEFAULT"] = "DEFAULT";
		LogSeverity$1["DEBUG"] = "DEBUG";
		LogSeverity$1["INFO"] = "INFO";
		LogSeverity$1["WARNING"] = "WARNING";
		LogSeverity$1["ERROR"] = "ERROR";
	})(LogSeverity || (exports.LogSeverity = LogSeverity = {}));
	/**
	* Our logger instance. This actually contains the meat of dealing
	* with log lines, including EventEmitter. This contains the function
	* that will be passed back to users of the package.
	*/
	var AdhocDebugLogger = class extends node_events_1.EventEmitter {
		/**
		* @param upstream The backend will pass a function that will be
		*   called whenever our logger function is invoked.
		*/
		constructor(namespace, upstream) {
			super();
			this.namespace = namespace;
			this.upstream = upstream;
			this.func = Object.assign(this.invoke.bind(this), {
				instance: this,
				on: (event, listener) => this.on(event, listener)
			});
			this.func.debug = (...args) => this.invokeSeverity(LogSeverity.DEBUG, ...args);
			this.func.info = (...args) => this.invokeSeverity(LogSeverity.INFO, ...args);
			this.func.warn = (...args) => this.invokeSeverity(LogSeverity.WARNING, ...args);
			this.func.error = (...args) => this.invokeSeverity(LogSeverity.ERROR, ...args);
			this.func.sublog = (namespace$1) => log$1(namespace$1, this.func);
		}
		invoke(fields, ...args) {
			if (this.upstream) this.upstream(fields, ...args);
			this.emit("log", fields, args);
		}
		invokeSeverity(severity, ...args) {
			this.invoke({ severity }, ...args);
		}
	};
	exports.AdhocDebugLogger = AdhocDebugLogger;
	/**
	* This can be used in place of a real logger while waiting for Promises or disabling logging.
	*/
	exports.placeholder = new AdhocDebugLogger("", () => {}).func;
	/**
	* The base class for debug logging backends. It's possible to use this, but the
	* same non-guarantees above still apply (unstable interface, etc).
	*
	* @private
	* @internal
	*/
	var DebugLogBackendBase = class {
		constructor() {
			var _a$5;
			this.cached = new Map();
			this.filters = [];
			this.filtersSet = false;
			let nodeFlag = (_a$5 = process$1.env[exports.env.nodeEnables]) !== null && _a$5 !== void 0 ? _a$5 : "*";
			if (nodeFlag === "all") nodeFlag = "*";
			this.filters = nodeFlag.split(",");
		}
		log(namespace, fields, ...args) {
			try {
				if (!this.filtersSet) {
					this.setFilters();
					this.filtersSet = true;
				}
				let logger$1 = this.cached.get(namespace);
				if (!logger$1) {
					logger$1 = this.makeLogger(namespace);
					this.cached.set(namespace, logger$1);
				}
				logger$1(fields, ...args);
			} catch (e) {
				console.error(e);
			}
		}
	};
	exports.DebugLogBackendBase = DebugLogBackendBase;
	var NodeBackend = class extends DebugLogBackendBase {
		constructor() {
			super(...arguments);
			this.enabledRegexp = /.*/g;
		}
		isEnabled(namespace) {
			return this.enabledRegexp.test(namespace);
		}
		makeLogger(namespace) {
			if (!this.enabledRegexp.test(namespace)) return () => {};
			return (fields, ...args) => {
				var _a$5;
				const nscolour = `${colours_1.Colours.green}${namespace}${colours_1.Colours.reset}`;
				const pid = `${colours_1.Colours.yellow}${process$1.pid}${colours_1.Colours.reset}`;
				let level;
				switch (fields.severity) {
					case LogSeverity.ERROR:
						level = `${colours_1.Colours.red}${fields.severity}${colours_1.Colours.reset}`;
						break;
					case LogSeverity.INFO:
						level = `${colours_1.Colours.magenta}${fields.severity}${colours_1.Colours.reset}`;
						break;
					case LogSeverity.WARNING:
						level = `${colours_1.Colours.yellow}${fields.severity}${colours_1.Colours.reset}`;
						break;
					default:
						level = (_a$5 = fields.severity) !== null && _a$5 !== void 0 ? _a$5 : LogSeverity.DEFAULT;
						break;
				}
				const msg = util$4.formatWithOptions({ colors: colours_1.Colours.enabled }, ...args);
				const filteredFields = Object.assign({}, fields);
				delete filteredFields.severity;
				const fieldsJson = Object.getOwnPropertyNames(filteredFields).length ? JSON.stringify(filteredFields) : "";
				const fieldsColour = fieldsJson ? `${colours_1.Colours.grey}${fieldsJson}${colours_1.Colours.reset}` : "";
				console.error("%s [%s|%s] %s%s", pid, nscolour, level, msg, fieldsJson ? ` ${fieldsColour}` : "");
			};
		}
		setFilters() {
			const totalFilters = this.filters.join(",");
			const regexp = totalFilters.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^");
			this.enabledRegexp = new RegExp(`^${regexp}$`, "i");
		}
	};
	/**
	* @returns A backend based on Node util.debuglog; this is the default.
	*/
	function getNodeBackend() {
		return new NodeBackend();
	}
	var DebugBackend = class extends DebugLogBackendBase {
		constructor(pkg$2) {
			super();
			this.debugPkg = pkg$2;
		}
		makeLogger(namespace) {
			const debugLogger = this.debugPkg(namespace);
			return (fields, ...args) => {
				debugLogger(args[0], ...args.slice(1));
			};
		}
		setFilters() {
			var _a$5;
			const existingFilters = (_a$5 = process$1.env["NODE_DEBUG"]) !== null && _a$5 !== void 0 ? _a$5 : "";
			process$1.env["NODE_DEBUG"] = `${existingFilters}${existingFilters ? "," : ""}${this.filters.join(",")}`;
		}
	};
	/**
	* Creates a "debug" package backend. The user must call require('debug') and pass
	* the resulting object to this function.
	*
	* ```
	*  setBackend(getDebugBackend(require('debug')))
	* ```
	*
	* https://www.npmjs.com/package/debug
	*
	* Note: Google does not explicitly endorse or recommend this package; it's just
	* being provided as an option.
	*
	* @returns A backend based on the npm "debug" package.
	*/
	function getDebugBackend(debugPkg) {
		return new DebugBackend(debugPkg);
	}
	/**
	* This pretty much works like the Node logger, but it outputs structured
	* logging JSON matching Google Cloud's ingestion specs. Rather than handling
	* its own output, it wraps another backend. The passed backend must be a subclass
	* of `DebugLogBackendBase` (any of the backends exposed by this package will work).
	*/
	var StructuredBackend = class extends DebugLogBackendBase {
		constructor(upstream) {
			var _a$5;
			super();
			this.upstream = (_a$5 = upstream) !== null && _a$5 !== void 0 ? _a$5 : new NodeBackend();
		}
		makeLogger(namespace) {
			const debugLogger = this.upstream.makeLogger(namespace);
			return (fields, ...args) => {
				var _a$5;
				const severity = (_a$5 = fields.severity) !== null && _a$5 !== void 0 ? _a$5 : LogSeverity.INFO;
				const json$1 = Object.assign({
					severity,
					message: util$4.format(...args)
				}, fields);
				const jsonString = JSON.stringify(json$1);
				debugLogger(fields, jsonString);
			};
		}
		setFilters() {
			this.upstream.setFilters();
		}
	};
	/**
	* Creates a "structured logging" backend. This pretty much works like the
	* Node logger, but it outputs structured logging JSON matching Google
	* Cloud's ingestion specs instead of plain text.
	*
	* ```
	*  setBackend(getStructuredBackend())
	* ```
	*
	* @param upstream If you want to use something besides the Node backend to
	*   write the actual log lines into, pass that here.
	* @returns A backend based on Google Cloud structured logging.
	*/
	function getStructuredBackend(upstream) {
		return new StructuredBackend(upstream);
	}
	/**
	* The environment variables that we standardized on, for all ad-hoc logging.
	*/
	exports.env = { nodeEnables: "GOOGLE_SDK_NODE_LOGGING" };
	const loggerCache = new Map();
	let cachedBackend = void 0;
	/**
	* Set the backend to use for our log output.
	* - A backend object
	* - null to disable logging
	* - undefined for "nothing yet", defaults to the Node backend
	*
	* @param backend Results from one of the get*Backend() functions.
	*/
	function setBackend(backend) {
		cachedBackend = backend;
		loggerCache.clear();
	}
	/**
	* Creates a logging function. Multiple calls to this with the same namespace
	* will produce the same logger, with the same event emitter hooks.
	*
	* Namespaces can be a simple string ("system" name), or a qualified string
	* (system:subsystem), which can be used for filtering, or for "system:*".
	*
	* @param namespace The namespace, a descriptive text string.
	* @returns A function you can call that works similar to console.log().
	*/
	function log$1(namespace, parent) {
		const enablesFlag = process$1.env[exports.env.nodeEnables];
		if (!enablesFlag) return exports.placeholder;
		if (!namespace) return exports.placeholder;
		if (parent) namespace = `${parent.instance.namespace}:${namespace}`;
		const existing = loggerCache.get(namespace);
		if (existing) return existing.func;
		if (cachedBackend === null) return exports.placeholder;
		else if (cachedBackend === void 0) cachedBackend = getNodeBackend();
		const logger$1 = (() => {
			let previousBackend = void 0;
			const newLogger = new AdhocDebugLogger(namespace, (fields, ...args) => {
				if (previousBackend !== cachedBackend) {
					if (cachedBackend === null) return;
					else if (cachedBackend === void 0) cachedBackend = getNodeBackend();
					previousBackend = cachedBackend;
				}
				cachedBackend === null || cachedBackend === void 0 || cachedBackend.log(namespace, fields, ...args);
			});
			return newLogger;
		})();
		loggerCache.set(namespace, logger$1);
		return logger$1.func;
	}
} });

//#endregion
//#region node_modules/google-logging-utils/build/src/index.js
var require_src$3 = __commonJS({ "node_modules/google-logging-utils/build/src/index.js"(exports) {
	var __createBinding$1 = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __exportStar$1 = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p in m$1) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding$1(exports$1, m$1, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar$1(require_logging_utils(), exports);
} });

//#endregion
//#region node_modules/gcp-metadata/build/src/index.js
var require_src$2 = __commonJS({ "node_modules/gcp-metadata/build/src/index.js"(exports) {
	/**
	* Copyright 2018 Google LLC
	*
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*      http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
	*/
	var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		var desc = Object.getOwnPropertyDescriptor(m$1, k);
		if (!desc || ("get" in desc ? !m$1.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$1[k];
			}
		};
		Object.defineProperty(o, k2, desc);
	} : function(o, m$1, k, k2) {
		if (k2 === void 0) k2 = k;
		o[k2] = m$1[k];
	});
	var __exportStar = exports && exports.__exportStar || function(m$1, exports$1) {
		for (var p in m$1) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m$1, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.gcpResidencyCache = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;
	exports.instance = instance;
	exports.project = project;
	exports.universe = universe;
	exports.bulk = bulk;
	exports.isAvailable = isAvailable;
	exports.resetIsAvailableCache = resetIsAvailableCache;
	exports.getGCPResidency = getGCPResidency;
	exports.setGCPResidency = setGCPResidency;
	exports.requestTimeout = requestTimeout;
	const gaxios_1$8 = require_src$4();
	const jsonBigint = require_json_bigint();
	const gcp_residency_1 = require_gcp_residency();
	const logger = require_src$3();
	exports.BASE_PATH = "/computeMetadata/v1";
	exports.HOST_ADDRESS = "http://169.254.169.254";
	exports.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.";
	exports.HEADER_NAME = "Metadata-Flavor";
	exports.HEADER_VALUE = "Google";
	exports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });
	const log = logger.log("gcp metadata");
	/**
	* Metadata server detection override options.
	*
	* Available via `process.env.METADATA_SERVER_DETECTION`.
	*/
	exports.METADATA_SERVER_DETECTION = Object.freeze({
		"assume-present": "don't try to ping the metadata server, but assume it's present",
		none: "don't try to ping the metadata server, but don't try to use it either",
		"bios-only": "treat the result of a BIOS probe as canonical (don't fall back to pinging)",
		"ping-only": "skip the BIOS probe, and go straight to pinging"
	});
	/**
	* Returns the base URL while taking into account the GCE_METADATA_HOST
	* environment variable if it exists.
	*
	* @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.
	*/
	function getBaseUrl(baseUrl$1) {
		if (!baseUrl$1) baseUrl$1 = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;
		if (!/^https?:\/\//.test(baseUrl$1)) baseUrl$1 = `http://${baseUrl$1}`;
		return new URL(exports.BASE_PATH, baseUrl$1).href;
	}
	function validate$1(options) {
		Object.keys(options).forEach((key) => {
			switch (key) {
				case "params":
				case "property":
				case "headers": break;
				case "qs": throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
				default: throw new Error(`'${key}' is not a valid configuration option.`);
			}
		});
	}
	async function metadataAccessor(type, options = {}, noResponseRetries = 3, fastFail = false) {
		let metadataKey = "";
		let params = {};
		let headers = {};
		if (typeof type === "object") {
			const metadataAccessor$1 = type;
			metadataKey = metadataAccessor$1.metadataKey;
			params = metadataAccessor$1.params || params;
			headers = metadataAccessor$1.headers || headers;
			noResponseRetries = metadataAccessor$1.noResponseRetries || noResponseRetries;
			fastFail = metadataAccessor$1.fastFail || fastFail;
		} else metadataKey = type;
		if (typeof options === "string") metadataKey += `/${options}`;
		else {
			validate$1(options);
			if (options.property) metadataKey += `/${options.property}`;
			headers = options.headers || headers;
			params = options.params || params;
		}
		const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1$8.request;
		const req$1 = {
			url: `${getBaseUrl()}/${metadataKey}`,
			headers: {
				...exports.HEADERS,
				...headers
			},
			retryConfig: { noResponseRetries },
			params,
			responseType: "text",
			timeout: requestTimeout()
		};
		log.info("instance request %j", req$1);
		const res = await requestMethod(req$1);
		log.info("instance metadata is %s", res.data);
		if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header. Expected '${exports.HEADER_VALUE}', got ${res.headers[exports.HEADER_NAME.toLowerCase()] ? `'${res.headers[exports.HEADER_NAME.toLowerCase()]}'` : "no header"}`);
		if (typeof res.data === "string") try {
			return jsonBigint.parse(res.data);
		} catch (_a$5) {}
		return res.data;
	}
	async function fastFailMetadataRequest(options) {
		var _a$5;
		const secondaryOptions = {
			...options,
			url: (_a$5 = options.url) === null || _a$5 === void 0 ? void 0 : _a$5.toString().replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))
		};
		let responded = false;
		const r1 = (0, gaxios_1$8.request)(options).then((res) => {
			responded = true;
			return res;
		}).catch((err) => {
			if (responded) return r2;
			else {
				responded = true;
				throw err;
			}
		});
		const r2 = (0, gaxios_1$8.request)(secondaryOptions).then((res) => {
			responded = true;
			return res;
		}).catch((err) => {
			if (responded) return r1;
			else {
				responded = true;
				throw err;
			}
		});
		return Promise.race([r1, r2]);
	}
	/**
	* Obtain metadata for the current GCE instance.
	*
	* @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}
	*
	* @example
	* ```
	* const serviceAccount: {} = await instance('service-accounts/');
	* const serviceAccountEmail: string = await instance('service-accounts/default/email');
	* ```
	*/
	function instance(options) {
		return metadataAccessor("instance", options);
	}
	/**
	* Obtain metadata for the current GCP project.
	*
	* @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}
	*
	* @example
	* ```
	* const projectId: string = await project('project-id');
	* const numericProjectId: number = await project('numeric-project-id');
	* ```
	*/
	function project(options) {
		return metadataAccessor("project", options);
	}
	/**
	* Obtain metadata for the current universe.
	*
	* @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}
	*
	* @example
	* ```
	* const universeDomain: string = await universe('universe-domain');
	* ```
	*/
	function universe(options) {
		return metadataAccessor("universe", options);
	}
	/**
	* Retrieve metadata items in parallel.
	*
	* @see {@link https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys}
	*
	* @example
	* ```
	* const data = await bulk([
	*   {
	*     metadataKey: 'instance',
	*   },
	*   {
	*     metadataKey: 'project/project-id',
	*   },
	* ] as const);
	*
	* // data.instance;
	* // data['project/project-id'];
	* ```
	*
	* @param properties The metadata properties to retrieve
	* @returns The metadata in `metadatakey:value` format
	*/
	async function bulk(properties) {
		const r = {};
		await Promise.all(properties.map((item) => {
			return (async () => {
				const res = await metadataAccessor(item);
				const key = item.metadataKey;
				r[key] = res;
			})();
		}));
		return r;
	}
	function detectGCPAvailableRetries() {
		return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
	}
	let cachedIsAvailableResponse;
	/**
	* Determine if the metadata server is currently available.
	*/
	async function isAvailable() {
		if (process.env.METADATA_SERVER_DETECTION) {
			const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();
			if (!(value in exports.METADATA_SERVER_DETECTION)) throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${value}\`, but it should be \`${Object.keys(exports.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);
			switch (value) {
				case "assume-present": return true;
				case "none": return false;
				case "bios-only": return getGCPResidency();
				case "ping-only":
			}
		}
		try {
			if (cachedIsAvailableResponse === void 0) cachedIsAvailableResponse = metadataAccessor(
				"instance",
				void 0,
				detectGCPAvailableRetries(),
				// If the default HOST_ADDRESS has been overridden, we should not
				// make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in
				// a non-GCP environment):
				!(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST)
);
			await cachedIsAvailableResponse;
			return true;
		} catch (e) {
			const err = e;
			if (process.env.DEBUG_AUTH) console.info(err);
			if (err.type === "request-timeout") return false;
			if (err.response && err.response.status === 404) return false;
			else {
				if (!(err.response && err.response.status === 404) && (!err.code || ![
					"EHOSTDOWN",
					"EHOSTUNREACH",
					"ENETUNREACH",
					"ENOENT",
					"ENOTFOUND",
					"ECONNREFUSED"
				].includes(err.code))) {
					let code$1 = "UNKNOWN";
					if (err.code) code$1 = err.code;
					process.emitWarning(`received unexpected error = ${err.message} code = ${code$1}`, "MetadataLookupWarning");
				}
				return false;
			}
		}
	}
	/**
	* reset the memoized isAvailable() lookup.
	*/
	function resetIsAvailableCache() {
		cachedIsAvailableResponse = void 0;
	}
	/**
	* A cache for the detected GCP Residency.
	*/
	exports.gcpResidencyCache = null;
	/**
	* Detects GCP Residency.
	* Caches results to reduce costs for subsequent calls.
	*
	* @see setGCPResidency for setting
	*/
	function getGCPResidency() {
		if (exports.gcpResidencyCache === null) setGCPResidency();
		return exports.gcpResidencyCache;
	}
	/**
	* Sets the detected GCP Residency.
	* Useful for forcing metadata server detection behavior.
	*
	* Set `null` to autodetect the environment (default behavior).
	* @see getGCPResidency for getting
	*/
	function setGCPResidency(value = null) {
		exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();
	}
	/**
	* Obtain the timeout for requests to the metadata server.
	*
	* In certain environments and conditions requests can take longer than
	* the default timeout to complete. This function will determine the
	* appropriate timeout based on the environment.
	*
	* @returns {number} a request timeout duration in milliseconds.
	*/
	function requestTimeout() {
		return getGCPResidency() ? 0 : 3e3;
	}
	__exportStar(require_gcp_residency(), exports);
} });

//#endregion
//#region node_modules/base64-js/index.js
var require_base64_js = __commonJS({ "node_modules/base64-js/index.js"(exports) {
	exports.byteLength = byteLength;
	exports.toByteArray = toByteArray;
	exports.fromByteArray = fromByteArray;
	var lookup = [];
	var revLookup = [];
	var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
	var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	for (var i = 0, len = code.length; i < len; ++i) {
		lookup[i] = code[i];
		revLookup[code.charCodeAt(i)] = i;
	}
	revLookup["-".charCodeAt(0)] = 62;
	revLookup["_".charCodeAt(0)] = 63;
	function getLens(b64) {
		var len$1 = b64.length;
		if (len$1 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
		var validLen = b64.indexOf("=");
		if (validLen === -1) validLen = len$1;
		var placeHoldersLen = validLen === len$1 ? 0 : 4 - validLen % 4;
		return [validLen, placeHoldersLen];
	}
	function byteLength(b64) {
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function _byteLength(b64, validLen, placeHoldersLen) {
		return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
	}
	function toByteArray(b64) {
		var tmp;
		var lens = getLens(b64);
		var validLen = lens[0];
		var placeHoldersLen = lens[1];
		var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		var curByte = 0;
		var len$1 = placeHoldersLen > 0 ? validLen - 4 : validLen;
		var i$1;
		for (i$1 = 0; i$1 < len$1; i$1 += 4) {
			tmp = revLookup[b64.charCodeAt(i$1)] << 18 | revLookup[b64.charCodeAt(i$1 + 1)] << 12 | revLookup[b64.charCodeAt(i$1 + 2)] << 6 | revLookup[b64.charCodeAt(i$1 + 3)];
			arr[curByte++] = tmp >> 16 & 255;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 2) {
			tmp = revLookup[b64.charCodeAt(i$1)] << 2 | revLookup[b64.charCodeAt(i$1 + 1)] >> 4;
			arr[curByte++] = tmp & 255;
		}
		if (placeHoldersLen === 1) {
			tmp = revLookup[b64.charCodeAt(i$1)] << 10 | revLookup[b64.charCodeAt(i$1 + 1)] << 4 | revLookup[b64.charCodeAt(i$1 + 2)] >> 2;
			arr[curByte++] = tmp >> 8 & 255;
			arr[curByte++] = tmp & 255;
		}
		return arr;
	}
	function tripletToBase64(num) {
		return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
	}
	function encodeChunk(uint8, start, end) {
		var tmp;
		var output = [];
		for (var i$1 = start; i$1 < end; i$1 += 3) {
			tmp = (uint8[i$1] << 16 & 16711680) + (uint8[i$1 + 1] << 8 & 65280) + (uint8[i$1 + 2] & 255);
			output.push(tripletToBase64(tmp));
		}
		return output.join("");
	}
	function fromByteArray(uint8) {
		var tmp;
		var len$1 = uint8.length;
		var extraBytes = len$1 % 3;
		var parts = [];
		var maxChunkLength = 16383;
		for (var i$1 = 0, len2 = len$1 - extraBytes; i$1 < len2; i$1 += maxChunkLength) parts.push(encodeChunk(uint8, i$1, i$1 + maxChunkLength > len2 ? len2 : i$1 + maxChunkLength));
		if (extraBytes === 1) {
			tmp = uint8[len$1 - 1];
			parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
		} else if (extraBytes === 2) {
			tmp = (uint8[len$1 - 2] << 8) + uint8[len$1 - 1];
			parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
		}
		return parts.join("");
	}
} });

//#endregion
//#region node_modules/google-auth-library/build/src/crypto/browser/crypto.js
var require_crypto$2 = __commonJS({ "node_modules/google-auth-library/build/src/crypto/browser/crypto.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BrowserCrypto = void 0;
	const base64js = require_base64_js();
	const crypto_1$5 = require_crypto();
	var BrowserCrypto = class BrowserCrypto {
		constructor() {
			if (typeof window === "undefined" || window.crypto === void 0 || window.crypto.subtle === void 0) throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
		}
		async sha256DigestBase64(str) {
			const inputBuffer = new TextEncoder().encode(str);
			const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
			return base64js.fromByteArray(new Uint8Array(outputBuffer));
		}
		randomBytesBase64(count) {
			const array = new Uint8Array(count);
			window.crypto.getRandomValues(array);
			return base64js.fromByteArray(array);
		}
		static padBase64(base64) {
			while (base64.length % 4 !== 0) base64 += "=";
			return base64;
		}
		async verify(pubkey, data, signature) {
			const algo = {
				name: "RSASSA-PKCS1-v1_5",
				hash: { name: "SHA-256" }
			};
			const dataArray = new TextEncoder().encode(data);
			const signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));
			const cryptoKey = await window.crypto.subtle.importKey("jwk", pubkey, algo, true, ["verify"]);
			const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);
			return result;
		}
		async sign(privateKey, data) {
			const algo = {
				name: "RSASSA-PKCS1-v1_5",
				hash: { name: "SHA-256" }
			};
			const dataArray = new TextEncoder().encode(data);
			const cryptoKey = await window.crypto.subtle.importKey("jwk", privateKey, algo, true, ["sign"]);
			const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);
			return base64js.fromByteArray(new Uint8Array(result));
		}
		decodeBase64StringUtf8(base64) {
			const uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64));
			const result = new TextDecoder().decode(uint8array);
			return result;
		}
		encodeBase64StringUtf8(text) {
			const uint8array = new TextEncoder().encode(text);
			const result = base64js.fromByteArray(uint8array);
			return result;
		}
		/**
		* Computes the SHA-256 hash of the provided string.
		* @param str The plain text string to hash.
		* @return A promise that resolves with the SHA-256 hash of the provided
		*   string in hexadecimal encoding.
		*/
		async sha256DigestHex(str) {
			const inputBuffer = new TextEncoder().encode(str);
			const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
			return (0, crypto_1$5.fromArrayBufferToHex)(outputBuffer);
		}
		/**
		* Computes the HMAC hash of a message using the provided crypto key and the
		* SHA-256 algorithm.
		* @param key The secret crypto key in utf-8 or ArrayBuffer format.
		* @param msg The plain text message.
		* @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
		*   format.
		*/
		async signWithHmacSha256(key, msg) {
			const rawKey = typeof key === "string" ? key : String.fromCharCode(...new Uint16Array(key));
			const enc = new TextEncoder();
			const cryptoKey = await window.crypto.subtle.importKey("raw", enc.encode(rawKey), {
				name: "HMAC",
				hash: { name: "SHA-256" }
			}, false, ["sign"]);
			return window.crypto.subtle.sign("HMAC", cryptoKey, enc.encode(msg));
		}
	};
	exports.BrowserCrypto = BrowserCrypto;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/crypto/node/crypto.js
var require_crypto$1 = __commonJS({ "node_modules/google-auth-library/build/src/crypto/node/crypto.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.NodeCrypto = void 0;
	const crypto$3 = require("crypto");
	var NodeCrypto = class {
		async sha256DigestBase64(str) {
			return crypto$3.createHash("sha256").update(str).digest("base64");
		}
		randomBytesBase64(count) {
			return crypto$3.randomBytes(count).toString("base64");
		}
		async verify(pubkey, data, signature) {
			const verifier = crypto$3.createVerify("RSA-SHA256");
			verifier.update(data);
			verifier.end();
			return verifier.verify(pubkey, signature, "base64");
		}
		async sign(privateKey, data) {
			const signer = crypto$3.createSign("RSA-SHA256");
			signer.update(data);
			signer.end();
			return signer.sign(privateKey, "base64");
		}
		decodeBase64StringUtf8(base64) {
			return Buffer.from(base64, "base64").toString("utf-8");
		}
		encodeBase64StringUtf8(text) {
			return Buffer.from(text, "utf-8").toString("base64");
		}
		/**
		* Computes the SHA-256 hash of the provided string.
		* @param str The plain text string to hash.
		* @return A promise that resolves with the SHA-256 hash of the provided
		*   string in hexadecimal encoding.
		*/
		async sha256DigestHex(str) {
			return crypto$3.createHash("sha256").update(str).digest("hex");
		}
		/**
		* Computes the HMAC hash of a message using the provided crypto key and the
		* SHA-256 algorithm.
		* @param key The secret crypto key in utf-8 or ArrayBuffer format.
		* @param msg The plain text message.
		* @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
		*   format.
		*/
		async signWithHmacSha256(key, msg) {
			const cryptoKey = typeof key === "string" ? key : toBuffer$3(key);
			return toArrayBuffer$2(crypto$3.createHmac("sha256", cryptoKey).update(msg).digest());
		}
	};
	exports.NodeCrypto = NodeCrypto;
	/**
	* Converts a Node.js Buffer to an ArrayBuffer.
	* https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer
	* @param buffer The Buffer input to covert.
	* @return The ArrayBuffer representation of the input.
	*/
	function toArrayBuffer$2(buffer$1) {
		return buffer$1.buffer.slice(buffer$1.byteOffset, buffer$1.byteOffset + buffer$1.byteLength);
	}
	/**
	* Converts an ArrayBuffer to a Node.js Buffer.
	* @param arrayBuffer The ArrayBuffer input to covert.
	* @return The Buffer representation of the input.
	*/
	function toBuffer$3(arrayBuffer) {
		return Buffer.from(arrayBuffer);
	}
} });

//#endregion
//#region node_modules/google-auth-library/build/src/crypto/crypto.js
var require_crypto = __commonJS({ "node_modules/google-auth-library/build/src/crypto/crypto.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createCrypto = createCrypto;
	exports.hasBrowserCrypto = hasBrowserCrypto;
	exports.fromArrayBufferToHex = fromArrayBufferToHex;
	const crypto_1$4 = require_crypto$2();
	const crypto_2 = require_crypto$1();
	function createCrypto() {
		if (hasBrowserCrypto()) return new crypto_1$4.BrowserCrypto();
		return new crypto_2.NodeCrypto();
	}
	function hasBrowserCrypto() {
		return typeof window !== "undefined" && typeof window.crypto !== "undefined" && typeof window.crypto.subtle !== "undefined";
	}
	/**
	* Converts an ArrayBuffer to a hexadecimal string.
	* @param arrayBuffer The ArrayBuffer to convert to hexadecimal string.
	* @return The hexadecimal encoding of the ArrayBuffer.
	*/
	function fromArrayBufferToHex(arrayBuffer) {
		const byteArray = Array.from(new Uint8Array(arrayBuffer));
		return byteArray.map((byte) => {
			return byte.toString(16).padStart(2, "0");
		}).join("");
	}
} });

//#endregion
//#region node_modules/google-auth-library/build/src/options.js
var require_options = __commonJS({ "node_modules/google-auth-library/build/src/options.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.validate = validate;
	function validate(options) {
		const vpairs = [
			{
				invalid: "uri",
				expected: "url"
			},
			{
				invalid: "json",
				expected: "data"
			},
			{
				invalid: "qs",
				expected: "params"
			}
		];
		for (const pair of vpairs) if (options[pair.invalid]) {
			const e = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;
			throw new Error(e);
		}
	}
} });

//#endregion
//#region node_modules/google-auth-library/package.json
var require_package$1 = __commonJS({ "node_modules/google-auth-library/package.json"(exports, module) {
	module.exports = {
		"name": "google-auth-library",
		"version": "9.15.1",
		"author": "Google Inc.",
		"description": "Google APIs Authentication Client Library for Node.js",
		"engines": { "node": ">=14" },
		"main": "./build/src/index.js",
		"types": "./build/src/index.d.ts",
		"repository": "googleapis/google-auth-library-nodejs.git",
		"keywords": [
			"google",
			"api",
			"google apis",
			"client",
			"client library"
		],
		"dependencies": {
			"base64-js": "^1.3.0",
			"ecdsa-sig-formatter": "^1.0.11",
			"gaxios": "^6.1.1",
			"gcp-metadata": "^6.1.0",
			"gtoken": "^7.0.0",
			"jws": "^4.0.0"
		},
		"devDependencies": {
			"@types/base64-js": "^1.2.5",
			"@types/chai": "^4.1.7",
			"@types/jws": "^3.1.0",
			"@types/mocha": "^9.0.0",
			"@types/mv": "^2.1.0",
			"@types/ncp": "^2.0.1",
			"@types/node": "^20.4.2",
			"@types/sinon": "^17.0.0",
			"assert-rejects": "^1.0.0",
			"c8": "^8.0.0",
			"chai": "^4.2.0",
			"cheerio": "1.0.0-rc.12",
			"codecov": "^3.0.2",
			"engine.io": "6.6.2",
			"gts": "^5.0.0",
			"is-docker": "^2.0.0",
			"jsdoc": "^4.0.0",
			"jsdoc-fresh": "^3.0.0",
			"jsdoc-region-tag": "^3.0.0",
			"karma": "^6.0.0",
			"karma-chrome-launcher": "^3.0.0",
			"karma-coverage": "^2.0.0",
			"karma-firefox-launcher": "^2.0.0",
			"karma-mocha": "^2.0.0",
			"karma-sourcemap-loader": "^0.4.0",
			"karma-webpack": "5.0.0",
			"keypair": "^1.0.4",
			"linkinator": "^4.0.0",
			"mocha": "^9.2.2",
			"mv": "^2.1.1",
			"ncp": "^2.0.0",
			"nock": "^13.0.0",
			"null-loader": "^4.0.0",
			"pdfmake": "0.2.12",
			"puppeteer": "^21.0.0",
			"sinon": "^18.0.0",
			"ts-loader": "^8.0.0",
			"typescript": "^5.1.6",
			"webpack": "^5.21.2",
			"webpack-cli": "^4.0.0"
		},
		"files": ["build/src", "!build/src/**/*.map"],
		"scripts": {
			"test": "c8 mocha build/test",
			"clean": "gts clean",
			"prepare": "npm run compile",
			"lint": "gts check",
			"compile": "tsc -p .",
			"fix": "gts fix",
			"pretest": "npm run compile -- --sourceMap",
			"docs": "jsdoc -c .jsdoc.json",
			"samples-setup": "cd samples/ && npm link ../ && npm run setup && cd ../",
			"samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
			"system-test": "mocha build/system-test --timeout 60000",
			"presystem-test": "npm run compile -- --sourceMap",
			"webpack": "webpack",
			"browser-test": "karma start",
			"docs-test": "linkinator docs",
			"predocs-test": "npm run docs",
			"prelint": "cd samples; npm link ../; npm install",
			"precompile": "gts clean"
		},
		"license": "Apache-2.0"
	};
} });

//#endregion
//#region node_modules/google-auth-library/build/src/transporters.js
var require_transporters = __commonJS({ "node_modules/google-auth-library/build/src/transporters.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DefaultTransporter = void 0;
	const gaxios_1$7 = require_src$4();
	const options_1 = require_options();
	const pkg$1 = require_package$1();
	const PRODUCT_NAME = "google-api-nodejs-client";
	var DefaultTransporter = class DefaultTransporter {
		constructor() {
			/**
			* A configurable, replacable `Gaxios` instance.
			*/
			this.instance = new gaxios_1$7.Gaxios();
		}
		/**
		* Configures request options before making a request.
		* @param opts GaxiosOptions options.
		* @return Configured options.
		*/
		configure(opts = {}) {
			opts.headers = opts.headers || {};
			if (typeof window === "undefined") {
				const uaValue = opts.headers["User-Agent"];
				if (!uaValue) opts.headers["User-Agent"] = DefaultTransporter.USER_AGENT;
				else if (!uaValue.includes(`${PRODUCT_NAME}/`)) opts.headers["User-Agent"] = `${uaValue} ${DefaultTransporter.USER_AGENT}`;
				if (!opts.headers["x-goog-api-client"]) {
					const nodeVersion = process.version.replace(/^v/, "");
					opts.headers["x-goog-api-client"] = `gl-node/${nodeVersion}`;
				}
			}
			return opts;
		}
		/**
		* Makes a request using Gaxios with given options.
		* @param opts GaxiosOptions options.
		* @param callback optional callback that contains GaxiosResponse object.
		* @return GaxiosPromise, assuming no callback is passed.
		*/
		request(opts) {
			opts = this.configure(opts);
			(0, options_1.validate)(opts);
			return this.instance.request(opts).catch((e) => {
				throw this.processError(e);
			});
		}
		get defaults() {
			return this.instance.defaults;
		}
		set defaults(opts) {
			this.instance.defaults = opts;
		}
		/**
		* Changes the error to include details from the body.
		*/
		processError(e) {
			const res = e.response;
			const err = e;
			const body = res ? res.data : null;
			if (res && body && body.error && res.status !== 200) if (typeof body.error === "string") {
				err.message = body.error;
				err.status = res.status;
			} else if (Array.isArray(body.error.errors)) {
				err.message = body.error.errors.map((err2) => err2.message).join("\n");
				err.code = body.error.code;
				err.errors = body.error.errors;
			} else {
				err.message = body.error.message;
				err.code = body.error.code;
			}
			else if (res && res.status >= 400) {
				err.message = body;
				err.status = res.status;
			}
			return err;
		}
	};
	exports.DefaultTransporter = DefaultTransporter;
	/**
	* Default user agent.
	*/
	DefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg$1.version}`;
} });

//#endregion
//#region node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({ "node_modules/safe-buffer/index.js"(exports, module) {
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	var buffer = require("buffer");
	var Buffer$8 = buffer.Buffer;
	function copyProps(src, dst) {
		for (var key in src) dst[key] = src[key];
	}
	if (Buffer$8.from && Buffer$8.alloc && Buffer$8.allocUnsafe && Buffer$8.allocUnsafeSlow) module.exports = buffer;
	else {
		copyProps(buffer, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer$8(arg, encodingOrOffset, length);
	}
	SafeBuffer.prototype = Object.create(Buffer$8.prototype);
	copyProps(Buffer$8, SafeBuffer);
	SafeBuffer.from = function(arg, encodingOrOffset, length) {
		if (typeof arg === "number") throw new TypeError("Argument must not be a number");
		return Buffer$8(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function(size, fill$2, encoding) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		var buf = Buffer$8(size);
		if (fill$2 !== void 0) if (typeof encoding === "string") buf.fill(fill$2, encoding);
		else buf.fill(fill$2);
		else buf.fill(0);
		return buf;
	};
	SafeBuffer.allocUnsafe = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return Buffer$8(size);
	};
	SafeBuffer.allocUnsafeSlow = function(size) {
		if (typeof size !== "number") throw new TypeError("Argument must be a number");
		return buffer.SlowBuffer(size);
	};
} });

//#endregion
//#region node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({ "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module) {
	function getParamSize(keySize) {
		var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
		return result;
	}
	var paramBytesForAlg = {
		ES256: getParamSize(256),
		ES384: getParamSize(384),
		ES512: getParamSize(521)
	};
	function getParamBytesForAlg$1(alg) {
		var paramBytes = paramBytesForAlg[alg];
		if (paramBytes) return paramBytes;
		throw new Error("Unknown algorithm \"" + alg + "\"");
	}
	module.exports = getParamBytesForAlg$1;
} });

//#endregion
//#region node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({ "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module) {
	var Buffer$7 = require_safe_buffer().Buffer;
	var getParamBytesForAlg = require_param_bytes_for_alg();
	var MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
	function base64Url(base64) {
		return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function signatureAsBuffer(signature) {
		if (Buffer$7.isBuffer(signature)) return signature;
		else if ("string" === typeof signature) return Buffer$7.from(signature, "base64");
		throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
	}
	function derToJose(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);
		var maxEncodedParamLength = paramBytes + 1;
		var inputLength = signature.length;
		var offset = 0;
		if (signature[offset++] !== ENCODED_TAG_SEQ) throw new Error("Could not find expected \"seq\"");
		var seqLength = signature[offset++];
		if (seqLength === (MAX_OCTET | 1)) seqLength = signature[offset++];
		if (inputLength - offset < seqLength) throw new Error("\"seq\" specified length of \"" + seqLength + "\", only \"" + (inputLength - offset) + "\" remaining");
		if (signature[offset++] !== ENCODED_TAG_INT) throw new Error("Could not find expected \"int\" for \"r\"");
		var rLength = signature[offset++];
		if (inputLength - offset - 2 < rLength) throw new Error("\"r\" specified length of \"" + rLength + "\", only \"" + (inputLength - offset - 2) + "\" available");
		if (maxEncodedParamLength < rLength) throw new Error("\"r\" specified length of \"" + rLength + "\", max of \"" + maxEncodedParamLength + "\" is acceptable");
		var rOffset = offset;
		offset += rLength;
		if (signature[offset++] !== ENCODED_TAG_INT) throw new Error("Could not find expected \"int\" for \"s\"");
		var sLength = signature[offset++];
		if (inputLength - offset !== sLength) throw new Error("\"s\" specified length of \"" + sLength + "\", expected \"" + (inputLength - offset) + "\"");
		if (maxEncodedParamLength < sLength) throw new Error("\"s\" specified length of \"" + sLength + "\", max of \"" + maxEncodedParamLength + "\" is acceptable");
		var sOffset = offset;
		offset += sLength;
		if (offset !== inputLength) throw new Error("Expected to consume entire buffer, but \"" + (inputLength - offset) + "\" bytes remain");
		var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
		var dst = Buffer$7.allocUnsafe(rPadding + rLength + sPadding + sLength);
		for (offset = 0; offset < rPadding; ++offset) dst[offset] = 0;
		signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
		offset = paramBytes;
		for (var o = offset; offset < o + sPadding; ++offset) dst[offset] = 0;
		signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
		dst = dst.toString("base64");
		dst = base64Url(dst);
		return dst;
	}
	function countPadding(buf, start, stop) {
		var padding = 0;
		while (start + padding < stop && buf[start + padding] === 0) ++padding;
		var needsSign = buf[start + padding] >= MAX_OCTET;
		if (needsSign) --padding;
		return padding;
	}
	function joseToDer(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);
		var signatureBytes = signature.length;
		if (signatureBytes !== paramBytes * 2) throw new TypeError("\"" + alg + "\" signatures must be \"" + paramBytes * 2 + "\" bytes, saw \"" + signatureBytes + "\"");
		var rPadding = countPadding(signature, 0, paramBytes);
		var sPadding = countPadding(signature, paramBytes, signature.length);
		var rLength = paramBytes - rPadding;
		var sLength = paramBytes - sPadding;
		var rsBytes = 2 + rLength + 1 + 1 + sLength;
		var shortLength = rsBytes < MAX_OCTET;
		var dst = Buffer$7.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
		var offset = 0;
		dst[offset++] = ENCODED_TAG_SEQ;
		if (shortLength) dst[offset++] = rsBytes;
		else {
			dst[offset++] = MAX_OCTET | 1;
			dst[offset++] = rsBytes & 255;
		}
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = rLength;
		if (rPadding < 0) {
			dst[offset++] = 0;
			offset += signature.copy(dst, offset, 0, paramBytes);
		} else offset += signature.copy(dst, offset, rPadding, paramBytes);
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = sLength;
		if (sPadding < 0) {
			dst[offset++] = 0;
			signature.copy(dst, offset, paramBytes);
		} else signature.copy(dst, offset, paramBytes + sPadding);
		return dst;
	}
	module.exports = {
		derToJose,
		joseToDer
	};
} });

//#endregion
//#region node_modules/google-auth-library/build/src/util.js
var require_util = __commonJS({ "node_modules/google-auth-library/build/src/util.js"(exports) {
	var __classPrivateFieldGet$5 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
		return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var _LRUCache_instances, _LRUCache_cache, _LRUCache_moveToEnd, _LRUCache_evict;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LRUCache = void 0;
	exports.snakeToCamel = snakeToCamel;
	exports.originalOrCamelOptions = originalOrCamelOptions;
	/**
	* Returns the camel case of a provided string.
	*
	* @remarks
	*
	* Match any `_` and not `_` pair, then return the uppercase of the not `_`
	* character.
	*
	* @internal
	*
	* @param str the string to convert
	* @returns the camelCase'd string
	*/
	function snakeToCamel(str) {
		return str.replace(/([_][^_])/g, (match) => match.slice(1).toUpperCase());
	}
	/**
	* Get the value of `obj[key]` or `obj[camelCaseKey]`, with a preference
	* for original, non-camelCase key.
	*
	* @param obj object to lookup a value in
	* @returns a `get` function for getting `obj[key || snakeKey]`, if available
	*/
	function originalOrCamelOptions(obj) {
		/**
		*
		* @param key an index of object, preferably snake_case
		* @returns the value `obj[key || snakeKey]`, if available
		*/
		function get(key) {
			var _a$5;
			const o = obj || {};
			return (_a$5 = o[key]) !== null && _a$5 !== void 0 ? _a$5 : o[snakeToCamel(key)];
		}
		return { get };
	}
	/**
	* A simple LRU cache utility.
	* Not meant for external usage.
	*
	* @experimental
	* @internal
	*/
	var LRUCache = class {
		constructor(options) {
			_LRUCache_instances.add(this);
			/**
			* Maps are in order. Thus, the older item is the first item.
			*
			* {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}
			*/
			_LRUCache_cache.set(this, new Map());
			this.capacity = options.capacity;
			this.maxAge = options.maxAge;
		}
		/**
		* Add an item to the cache.
		*
		* @param key the key to upsert
		* @param value the value of the key
		*/
		set(key, value) {
			__classPrivateFieldGet$5(this, _LRUCache_instances, "m", _LRUCache_moveToEnd).call(this, key, value);
			__classPrivateFieldGet$5(this, _LRUCache_instances, "m", _LRUCache_evict).call(this);
		}
		/**
		* Get an item from the cache.
		*
		* @param key the key to retrieve
		*/
		get(key) {
			const item = __classPrivateFieldGet$5(this, _LRUCache_cache, "f").get(key);
			if (!item) return;
			__classPrivateFieldGet$5(this, _LRUCache_instances, "m", _LRUCache_moveToEnd).call(this, key, item.value);
			__classPrivateFieldGet$5(this, _LRUCache_instances, "m", _LRUCache_evict).call(this);
			return item.value;
		}
	};
	exports.LRUCache = LRUCache;
	_LRUCache_cache = new WeakMap(), _LRUCache_instances = new WeakSet(), _LRUCache_moveToEnd = function _LRUCache_moveToEnd$1(key, value) {
		__classPrivateFieldGet$5(this, _LRUCache_cache, "f").delete(key);
		__classPrivateFieldGet$5(this, _LRUCache_cache, "f").set(key, {
			value,
			lastAccessed: Date.now()
		});
	}, _LRUCache_evict = function _LRUCache_evict$1() {
		const cutoffDate = this.maxAge ? Date.now() - this.maxAge : 0;
		/**
		* Because we know Maps are in order, this item is both the
		* last item in the list (capacity) and oldest (maxAge).
		*/
		let oldestItem = __classPrivateFieldGet$5(this, _LRUCache_cache, "f").entries().next();
		while (!oldestItem.done && (__classPrivateFieldGet$5(this, _LRUCache_cache, "f").size > this.capacity || oldestItem.value[1].lastAccessed < cutoffDate)) {
			__classPrivateFieldGet$5(this, _LRUCache_cache, "f").delete(oldestItem.value[0]);
			oldestItem = __classPrivateFieldGet$5(this, _LRUCache_cache, "f").entries().next();
		}
	};
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/authclient.js
var require_authclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/authclient.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AuthClient = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = exports.DEFAULT_UNIVERSE = void 0;
	const events_1 = require("events");
	const gaxios_1$6 = require_src$4();
	const transporters_1$3 = require_transporters();
	const util_1$8 = require_util();
	/**
	* The default cloud universe
	*
	* @see {@link AuthJSONOptions.universe_domain}
	*/
	exports.DEFAULT_UNIVERSE = "googleapis.com";
	/**
	* The default {@link AuthClientOptions.eagerRefreshThresholdMillis}
	*/
	exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1e3;
	var AuthClient = class extends events_1.EventEmitter {
		constructor(opts = {}) {
			var _a$5, _b$1, _c$1, _d, _e;
			super();
			this.credentials = {};
			this.eagerRefreshThresholdMillis = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS;
			this.forceRefreshOnFailure = false;
			this.universeDomain = exports.DEFAULT_UNIVERSE;
			const options = (0, util_1$8.originalOrCamelOptions)(opts);
			this.apiKey = opts.apiKey;
			this.projectId = (_a$5 = options.get("project_id")) !== null && _a$5 !== void 0 ? _a$5 : null;
			this.quotaProjectId = options.get("quota_project_id");
			this.credentials = (_b$1 = options.get("credentials")) !== null && _b$1 !== void 0 ? _b$1 : {};
			this.universeDomain = (_c$1 = options.get("universe_domain")) !== null && _c$1 !== void 0 ? _c$1 : exports.DEFAULT_UNIVERSE;
			this.transporter = (_d = opts.transporter) !== null && _d !== void 0 ? _d : new transporters_1$3.DefaultTransporter();
			if (opts.transporterOptions) this.transporter.defaults = opts.transporterOptions;
			if (opts.eagerRefreshThresholdMillis) this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis;
			this.forceRefreshOnFailure = (_e = opts.forceRefreshOnFailure) !== null && _e !== void 0 ? _e : false;
		}
		/**
		* Return the {@link Gaxios `Gaxios`} instance from the {@link AuthClient.transporter}.
		*
		* @expiremental
		*/
		get gaxios() {
			if (this.transporter instanceof gaxios_1$6.Gaxios) return this.transporter;
			else if (this.transporter instanceof transporters_1$3.DefaultTransporter) return this.transporter.instance;
			else if ("instance" in this.transporter && this.transporter.instance instanceof gaxios_1$6.Gaxios) return this.transporter.instance;
			return null;
		}
		/**
		* Sets the auth credentials.
		*/
		setCredentials(credentials) {
			this.credentials = credentials;
		}
		/**
		* Append additional headers, e.g., x-goog-user-project, shared across the
		* classes inheriting AuthClient. This method should be used by any method
		* that overrides getRequestMetadataAsync(), which is a shared helper for
		* setting request information in both gRPC and HTTP API calls.
		*
		* @param headers object to append additional headers to.
		*/
		addSharedMetadataHeaders(headers) {
			if (!headers["x-goog-user-project"] && this.quotaProjectId) headers["x-goog-user-project"] = this.quotaProjectId;
			return headers;
		}
		/**
		* Retry config for Auth-related requests.
		*
		* @remarks
		*
		* This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
		* config as some downstream APIs would prefer if customers explicitly enable retries,
		* such as GCS.
		*/
		static get RETRY_CONFIG() {
			return {
				retry: true,
				retryConfig: { httpMethodsToRetry: [
					"GET",
					"PUT",
					"POST",
					"HEAD",
					"OPTIONS",
					"DELETE"
				] }
			};
		}
	};
	exports.AuthClient = AuthClient;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/loginticket.js
var require_loginticket = __commonJS({ "node_modules/google-auth-library/build/src/auth/loginticket.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.LoginTicket = void 0;
	var LoginTicket = class {
		/**
		* Create a simple class to extract user ID from an ID Token
		*
		* @param {string} env Envelope of the jwt
		* @param {TokenPayload} pay Payload of the jwt
		* @constructor
		*/
		constructor(env, pay) {
			this.envelope = env;
			this.payload = pay;
		}
		getEnvelope() {
			return this.envelope;
		}
		getPayload() {
			return this.payload;
		}
		/**
		* Create a simple class to extract user ID from an ID Token
		*
		* @return The user ID
		*/
		getUserId() {
			const payload = this.getPayload();
			if (payload && payload.sub) return payload.sub;
			return null;
		}
		/**
		* Returns attributes from the login ticket.  This can contain
		* various information about the user session.
		*
		* @return The envelope and payload
		*/
		getAttributes() {
			return {
				envelope: this.getEnvelope(),
				payload: this.getPayload()
			};
		}
	};
	exports.LoginTicket = LoginTicket;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/oauth2client.js
var require_oauth2client = __commonJS({ "node_modules/google-auth-library/build/src/auth/oauth2client.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OAuth2Client = exports.ClientAuthentication = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;
	const gaxios_1$5 = require_src$4();
	const querystring$2 = require("querystring");
	const stream$3 = require("stream");
	const formatEcdsa$1 = require_ecdsa_sig_formatter();
	const crypto_1$3 = require_crypto();
	const authclient_1$7 = require_authclient();
	const loginticket_1$1 = require_loginticket();
	var CodeChallengeMethod;
	(function(CodeChallengeMethod$1) {
		CodeChallengeMethod$1["Plain"] = "plain";
		CodeChallengeMethod$1["S256"] = "S256";
	})(CodeChallengeMethod || (exports.CodeChallengeMethod = CodeChallengeMethod = {}));
	var CertificateFormat;
	(function(CertificateFormat$1) {
		CertificateFormat$1["PEM"] = "PEM";
		CertificateFormat$1["JWK"] = "JWK";
	})(CertificateFormat || (exports.CertificateFormat = CertificateFormat = {}));
	/**
	* The client authentication type. Supported values are basic, post, and none.
	* https://datatracker.ietf.org/doc/html/rfc7591#section-2
	*/
	var ClientAuthentication;
	(function(ClientAuthentication$1) {
		ClientAuthentication$1["ClientSecretPost"] = "ClientSecretPost";
		ClientAuthentication$1["ClientSecretBasic"] = "ClientSecretBasic";
		ClientAuthentication$1["None"] = "None";
	})(ClientAuthentication || (exports.ClientAuthentication = ClientAuthentication = {}));
	var OAuth2Client = class OAuth2Client extends authclient_1$7.AuthClient {
		constructor(optionsOrClientId, clientSecret, redirectUri) {
			const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : {
				clientId: optionsOrClientId,
				clientSecret,
				redirectUri
			};
			super(opts);
			this.certificateCache = {};
			this.certificateExpiry = null;
			this.certificateCacheFormat = CertificateFormat.PEM;
			this.refreshTokenPromises = new Map();
			this._clientId = opts.clientId;
			this._clientSecret = opts.clientSecret;
			this.redirectUri = opts.redirectUri;
			this.endpoints = {
				tokenInfoUrl: "https://oauth2.googleapis.com/tokeninfo",
				oauth2AuthBaseUrl: "https://accounts.google.com/o/oauth2/v2/auth",
				oauth2TokenUrl: "https://oauth2.googleapis.com/token",
				oauth2RevokeUrl: "https://oauth2.googleapis.com/revoke",
				oauth2FederatedSignonPemCertsUrl: "https://www.googleapis.com/oauth2/v1/certs",
				oauth2FederatedSignonJwkCertsUrl: "https://www.googleapis.com/oauth2/v3/certs",
				oauth2IapPublicKeyUrl: "https://www.gstatic.com/iap/verify/public_key",
				...opts.endpoints
			};
			this.clientAuthentication = opts.clientAuthentication || ClientAuthentication.ClientSecretPost;
			this.issuers = opts.issuers || [
				"accounts.google.com",
				"https://accounts.google.com",
				this.universeDomain
			];
		}
		/**
		* Generates URL for consent page landing.
		* @param opts Options.
		* @return URL to consent page.
		*/
		generateAuthUrl(opts = {}) {
			if (opts.code_challenge_method && !opts.code_challenge) throw new Error("If a code_challenge_method is provided, code_challenge must be included.");
			opts.response_type = opts.response_type || "code";
			opts.client_id = opts.client_id || this._clientId;
			opts.redirect_uri = opts.redirect_uri || this.redirectUri;
			if (Array.isArray(opts.scope)) opts.scope = opts.scope.join(" ");
			const rootUrl = this.endpoints.oauth2AuthBaseUrl.toString();
			return rootUrl + "?" + querystring$2.stringify(opts);
		}
		generateCodeVerifier() {
			throw new Error("generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.");
		}
		/**
		* Convenience method to automatically generate a code_verifier, and its
		* resulting SHA256. If used, this must be paired with a S256
		* code_challenge_method.
		*
		* For a full example see:
		* https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js
		*/
		async generateCodeVerifierAsync() {
			const crypto$8 = (0, crypto_1$3.createCrypto)();
			const randomString = crypto$8.randomBytesBase64(96);
			const codeVerifier = randomString.replace(/\+/g, "~").replace(/=/g, "_").replace(/\//g, "-");
			const unencodedCodeChallenge = await crypto$8.sha256DigestBase64(codeVerifier);
			const codeChallenge = unencodedCodeChallenge.split("=")[0].replace(/\+/g, "-").replace(/\//g, "_");
			return {
				codeVerifier,
				codeChallenge
			};
		}
		getToken(codeOrOptions, callback) {
			const options = typeof codeOrOptions === "string" ? { code: codeOrOptions } : codeOrOptions;
			if (callback) this.getTokenAsync(options).then((r) => callback(null, r.tokens, r.res), (e) => callback(e, null, e.response));
			else return this.getTokenAsync(options);
		}
		async getTokenAsync(options) {
			const url = this.endpoints.oauth2TokenUrl.toString();
			const headers = { "Content-Type": "application/x-www-form-urlencoded" };
			const values = {
				client_id: options.client_id || this._clientId,
				code_verifier: options.codeVerifier,
				code: options.code,
				grant_type: "authorization_code",
				redirect_uri: options.redirect_uri || this.redirectUri
			};
			if (this.clientAuthentication === ClientAuthentication.ClientSecretBasic) {
				const basic = Buffer.from(`${this._clientId}:${this._clientSecret}`);
				headers["Authorization"] = `Basic ${basic.toString("base64")}`;
			}
			if (this.clientAuthentication === ClientAuthentication.ClientSecretPost) values.client_secret = this._clientSecret;
			const res = await this.transporter.request({
				...OAuth2Client.RETRY_CONFIG,
				method: "POST",
				url,
				data: querystring$2.stringify(values),
				headers
			});
			const tokens = res.data;
			if (res.data && res.data.expires_in) {
				tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1e3;
				delete tokens.expires_in;
			}
			this.emit("tokens", tokens);
			return {
				tokens,
				res
			};
		}
		/**
		* Refreshes the access token.
		* @param refresh_token Existing refresh token.
		* @private
		*/
		async refreshToken(refreshToken) {
			if (!refreshToken) return this.refreshTokenNoCache(refreshToken);
			if (this.refreshTokenPromises.has(refreshToken)) return this.refreshTokenPromises.get(refreshToken);
			const p = this.refreshTokenNoCache(refreshToken).then((r) => {
				this.refreshTokenPromises.delete(refreshToken);
				return r;
			}, (e) => {
				this.refreshTokenPromises.delete(refreshToken);
				throw e;
			});
			this.refreshTokenPromises.set(refreshToken, p);
			return p;
		}
		async refreshTokenNoCache(refreshToken) {
			var _a$5;
			if (!refreshToken) throw new Error("No refresh token is set.");
			const url = this.endpoints.oauth2TokenUrl.toString();
			const data = {
				refresh_token: refreshToken,
				client_id: this._clientId,
				client_secret: this._clientSecret,
				grant_type: "refresh_token"
			};
			let res;
			try {
				res = await this.transporter.request({
					...OAuth2Client.RETRY_CONFIG,
					method: "POST",
					url,
					data: querystring$2.stringify(data),
					headers: { "Content-Type": "application/x-www-form-urlencoded" }
				});
			} catch (e) {
				if (e instanceof gaxios_1$5.GaxiosError && e.message === "invalid_grant" && ((_a$5 = e.response) === null || _a$5 === void 0 ? void 0 : _a$5.data) && /ReAuth/i.test(e.response.data.error_description)) e.message = JSON.stringify(e.response.data);
				throw e;
			}
			const tokens = res.data;
			if (res.data && res.data.expires_in) {
				tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1e3;
				delete tokens.expires_in;
			}
			this.emit("tokens", tokens);
			return {
				tokens,
				res
			};
		}
		refreshAccessToken(callback) {
			if (callback) this.refreshAccessTokenAsync().then((r) => callback(null, r.credentials, r.res), callback);
			else return this.refreshAccessTokenAsync();
		}
		async refreshAccessTokenAsync() {
			const r = await this.refreshToken(this.credentials.refresh_token);
			const tokens = r.tokens;
			tokens.refresh_token = this.credentials.refresh_token;
			this.credentials = tokens;
			return {
				credentials: this.credentials,
				res: r.res
			};
		}
		getAccessToken(callback) {
			if (callback) this.getAccessTokenAsync().then((r) => callback(null, r.token, r.res), callback);
			else return this.getAccessTokenAsync();
		}
		async getAccessTokenAsync() {
			const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();
			if (shouldRefresh) {
				if (!this.credentials.refresh_token) if (this.refreshHandler) {
					const refreshedAccessToken = await this.processAndValidateRefreshHandler();
					if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {
						this.setCredentials(refreshedAccessToken);
						return { token: this.credentials.access_token };
					}
				} else throw new Error("No refresh token or refresh handler callback is set.");
				const r = await this.refreshAccessTokenAsync();
				if (!r.credentials || r.credentials && !r.credentials.access_token) throw new Error("Could not refresh access token.");
				return {
					token: r.credentials.access_token,
					res: r.res
				};
			} else return { token: this.credentials.access_token };
		}
		/**
		* The main authentication interface.  It takes an optional url which when
		* present is the endpoint being accessed, and returns a Promise which
		* resolves with authorization header fields.
		*
		* In OAuth2Client, the result has the form:
		* { Authorization: 'Bearer <access_token_value>' }
		* @param url The optional url being authorized
		*/
		async getRequestHeaders(url) {
			const headers = (await this.getRequestMetadataAsync(url)).headers;
			return headers;
		}
		async getRequestMetadataAsync(url) {
			const thisCreds = this.credentials;
			if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) throw new Error("No access, refresh token, API key or refresh handler callback is set.");
			if (thisCreds.access_token && !this.isTokenExpiring()) {
				thisCreds.token_type = thisCreds.token_type || "Bearer";
				const headers$1 = { Authorization: thisCreds.token_type + " " + thisCreds.access_token };
				return { headers: this.addSharedMetadataHeaders(headers$1) };
			}
			if (this.refreshHandler) {
				const refreshedAccessToken = await this.processAndValidateRefreshHandler();
				if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {
					this.setCredentials(refreshedAccessToken);
					const headers$1 = { Authorization: "Bearer " + this.credentials.access_token };
					return { headers: this.addSharedMetadataHeaders(headers$1) };
				}
			}
			if (this.apiKey) return { headers: { "X-Goog-Api-Key": this.apiKey } };
			let r = null;
			let tokens = null;
			try {
				r = await this.refreshToken(thisCreds.refresh_token);
				tokens = r.tokens;
			} catch (err) {
				const e = err;
				if (e.response && (e.response.status === 403 || e.response.status === 404)) e.message = `Could not refresh access token: ${e.message}`;
				throw e;
			}
			const credentials = this.credentials;
			credentials.token_type = credentials.token_type || "Bearer";
			tokens.refresh_token = credentials.refresh_token;
			this.credentials = tokens;
			const headers = { Authorization: credentials.token_type + " " + tokens.access_token };
			return {
				headers: this.addSharedMetadataHeaders(headers),
				res: r.res
			};
		}
		/**
		* Generates an URL to revoke the given token.
		* @param token The existing token to be revoked.
		*
		* @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}
		*/
		static getRevokeTokenUrl(token) {
			return new OAuth2Client().getRevokeTokenURL(token).toString();
		}
		/**
		* Generates a URL to revoke the given token.
		*
		* @param token The existing token to be revoked.
		*/
		getRevokeTokenURL(token) {
			const url = new URL(this.endpoints.oauth2RevokeUrl);
			url.searchParams.append("token", token);
			return url;
		}
		revokeToken(token, callback) {
			const opts = {
				...OAuth2Client.RETRY_CONFIG,
				url: this.getRevokeTokenURL(token).toString(),
				method: "POST"
			};
			if (callback) this.transporter.request(opts).then((r) => callback(null, r), callback);
			else return this.transporter.request(opts);
		}
		revokeCredentials(callback) {
			if (callback) this.revokeCredentialsAsync().then((res) => callback(null, res), callback);
			else return this.revokeCredentialsAsync();
		}
		async revokeCredentialsAsync() {
			const token = this.credentials.access_token;
			this.credentials = {};
			if (token) return this.revokeToken(token);
			else throw new Error("No access token to revoke.");
		}
		request(opts, callback) {
			if (callback) this.requestAsync(opts).then((r) => callback(null, r), (e) => {
				return callback(e, e.response);
			});
			else return this.requestAsync(opts);
		}
		async requestAsync(opts, reAuthRetried = false) {
			let r2;
			try {
				const r = await this.getRequestMetadataAsync(opts.url);
				opts.headers = opts.headers || {};
				if (r.headers && r.headers["x-goog-user-project"]) opts.headers["x-goog-user-project"] = r.headers["x-goog-user-project"];
				if (r.headers && r.headers.Authorization) opts.headers.Authorization = r.headers.Authorization;
				if (this.apiKey) opts.headers["X-Goog-Api-Key"] = this.apiKey;
				r2 = await this.transporter.request(opts);
			} catch (e) {
				const res = e.response;
				if (res) {
					const statusCode = res.status;
					const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);
					const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;
					const isReadableStream = res.config.data instanceof stream$3.Readable;
					const isAuthErr = statusCode === 401 || statusCode === 403;
					if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefresh) {
						await this.refreshAccessTokenAsync();
						return this.requestAsync(opts, true);
					} else if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {
						const refreshedAccessToken = await this.processAndValidateRefreshHandler();
						if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) this.setCredentials(refreshedAccessToken);
						return this.requestAsync(opts, true);
					}
				}
				throw e;
			}
			return r2;
		}
		verifyIdToken(options, callback) {
			if (callback && typeof callback !== "function") throw new Error("This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.");
			if (callback) this.verifyIdTokenAsync(options).then((r) => callback(null, r), callback);
			else return this.verifyIdTokenAsync(options);
		}
		async verifyIdTokenAsync(options) {
			if (!options.idToken) throw new Error("The verifyIdToken method requires an ID Token");
			const response = await this.getFederatedSignonCertsAsync();
			const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);
			return login;
		}
		/**
		* Obtains information about the provisioned access token.  Especially useful
		* if you want to check the scopes that were provisioned to a given token.
		*
		* @param accessToken Required.  The Access Token for which you want to get
		* user info.
		*/
		async getTokenInfo(accessToken) {
			const { data } = await this.transporter.request({
				...OAuth2Client.RETRY_CONFIG,
				method: "POST",
				headers: {
					"Content-Type": "application/x-www-form-urlencoded",
					Authorization: `Bearer ${accessToken}`
				},
				url: this.endpoints.tokenInfoUrl.toString()
			});
			const info$1 = Object.assign({
				expiry_date: new Date().getTime() + data.expires_in * 1e3,
				scopes: data.scope.split(" ")
			}, data);
			delete info$1.expires_in;
			delete info$1.scope;
			return info$1;
		}
		getFederatedSignonCerts(callback) {
			if (callback) this.getFederatedSignonCertsAsync().then((r) => callback(null, r.certs, r.res), callback);
			else return this.getFederatedSignonCertsAsync();
		}
		async getFederatedSignonCertsAsync() {
			const nowTime = new Date().getTime();
			const format$2 = (0, crypto_1$3.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;
			if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format$2) return {
				certs: this.certificateCache,
				format: format$2
			};
			let res;
			let url;
			switch (format$2) {
				case CertificateFormat.PEM:
					url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();
					break;
				case CertificateFormat.JWK:
					url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();
					break;
				default: throw new Error(`Unsupported certificate format ${format$2}`);
			}
			try {
				res = await this.transporter.request({
					...OAuth2Client.RETRY_CONFIG,
					url
				});
			} catch (e) {
				if (e instanceof Error) e.message = `Failed to retrieve verification certificates: ${e.message}`;
				throw e;
			}
			const cacheControl = res ? res.headers["cache-control"] : void 0;
			let cacheAge = -1;
			if (cacheControl) {
				const pattern = new RegExp("max-age=([0-9]*)");
				const regexResult = pattern.exec(cacheControl);
				if (regexResult && regexResult.length === 2) cacheAge = Number(regexResult[1]) * 1e3;
			}
			let certificates = {};
			switch (format$2) {
				case CertificateFormat.PEM:
					certificates = res.data;
					break;
				case CertificateFormat.JWK:
					for (const key of res.data.keys) certificates[key.kid] = key;
					break;
				default: throw new Error(`Unsupported certificate format ${format$2}`);
			}
			const now = new Date();
			this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
			this.certificateCache = certificates;
			this.certificateCacheFormat = format$2;
			return {
				certs: certificates,
				format: format$2,
				res
			};
		}
		getIapPublicKeys(callback) {
			if (callback) this.getIapPublicKeysAsync().then((r) => callback(null, r.pubkeys, r.res), callback);
			else return this.getIapPublicKeysAsync();
		}
		async getIapPublicKeysAsync() {
			let res;
			const url = this.endpoints.oauth2IapPublicKeyUrl.toString();
			try {
				res = await this.transporter.request({
					...OAuth2Client.RETRY_CONFIG,
					url
				});
			} catch (e) {
				if (e instanceof Error) e.message = `Failed to retrieve verification certificates: ${e.message}`;
				throw e;
			}
			return {
				pubkeys: res.data,
				res
			};
		}
		verifySignedJwtWithCerts() {
			throw new Error("verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.");
		}
		/**
		* Verify the id token is signed with the correct certificate
		* and is from the correct audience.
		* @param jwt The jwt to verify (The ID Token in this case).
		* @param certs The array of certs to test the jwt against.
		* @param requiredAudience The audience to test the jwt against.
		* @param issuers The allowed issuers of the jwt (Optional).
		* @param maxExpiry The max expiry the certificate can be (Optional).
		* @return Returns a promise resolving to LoginTicket on verification.
		*/
		async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {
			const crypto$8 = (0, crypto_1$3.createCrypto)();
			if (!maxExpiry) maxExpiry = OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;
			const segments = jwt.split(".");
			if (segments.length !== 3) throw new Error("Wrong number of segments in token: " + jwt);
			const signed = segments[0] + "." + segments[1];
			let signature = segments[2];
			let envelope;
			let payload;
			try {
				envelope = JSON.parse(crypto$8.decodeBase64StringUtf8(segments[0]));
			} catch (err) {
				if (err instanceof Error) err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;
				throw err;
			}
			if (!envelope) throw new Error("Can't parse token envelope: " + segments[0]);
			try {
				payload = JSON.parse(crypto$8.decodeBase64StringUtf8(segments[1]));
			} catch (err) {
				if (err instanceof Error) err.message = `Can't parse token payload '${segments[0]}`;
				throw err;
			}
			if (!payload) throw new Error("Can't parse token payload: " + segments[1]);
			if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) throw new Error("No pem found for envelope: " + JSON.stringify(envelope));
			const cert = certs[envelope.kid];
			if (envelope.alg === "ES256") signature = formatEcdsa$1.joseToDer(signature, "ES256").toString("base64");
			const verified = await crypto$8.verify(cert, signed, signature);
			if (!verified) throw new Error("Invalid token signature: " + jwt);
			if (!payload.iat) throw new Error("No issue time in token: " + JSON.stringify(payload));
			if (!payload.exp) throw new Error("No expiration time in token: " + JSON.stringify(payload));
			const iat = Number(payload.iat);
			if (isNaN(iat)) throw new Error("iat field using invalid format");
			const exp = Number(payload.exp);
			if (isNaN(exp)) throw new Error("exp field using invalid format");
			const now = new Date().getTime() / 1e3;
			if (exp >= now + maxExpiry) throw new Error("Expiration time too far in future: " + JSON.stringify(payload));
			const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;
			const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;
			if (now < earliest) throw new Error("Token used too early, " + now + " < " + earliest + ": " + JSON.stringify(payload));
			if (now > latest) throw new Error("Token used too late, " + now + " > " + latest + ": " + JSON.stringify(payload));
			if (issuers && issuers.indexOf(payload.iss) < 0) throw new Error("Invalid issuer, expected one of [" + issuers + "], but got " + payload.iss);
			if (typeof requiredAudience !== "undefined" && requiredAudience !== null) {
				const aud = payload.aud;
				let audVerified = false;
				if (requiredAudience.constructor === Array) audVerified = requiredAudience.indexOf(aud) > -1;
				else audVerified = aud === requiredAudience;
				if (!audVerified) throw new Error("Wrong recipient, payload audience != requiredAudience");
			}
			return new loginticket_1$1.LoginTicket(envelope, payload);
		}
		/**
		* Returns a promise that resolves with AccessTokenResponse type if
		* refreshHandler is defined.
		* If not, nothing is returned.
		*/
		async processAndValidateRefreshHandler() {
			if (this.refreshHandler) {
				const accessTokenResponse = await this.refreshHandler();
				if (!accessTokenResponse.access_token) throw new Error("No access token is returned by the refreshHandler callback.");
				return accessTokenResponse;
			}
			return;
		}
		/**
		* Returns true if a token is expired or will expire within
		* eagerRefreshThresholdMillismilliseconds.
		* If there is no expiry time, assumes the token is not expired or expiring.
		*/
		isTokenExpiring() {
			const expiryDate = this.credentials.expiry_date;
			return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;
		}
	};
	exports.OAuth2Client = OAuth2Client;
	/**
	* @deprecated use instance's {@link OAuth2Client.endpoints}
	*/
	OAuth2Client.GOOGLE_TOKEN_INFO_URL = "https://oauth2.googleapis.com/tokeninfo";
	/**
	* Clock skew - five minutes in seconds
	*/
	OAuth2Client.CLOCK_SKEW_SECS_ = 300;
	/**
	* The default max Token Lifetime is one day in seconds
	*/
	OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/computeclient.js
var require_computeclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/computeclient.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Compute = void 0;
	const gaxios_1$4 = require_src$4();
	const gcpMetadata$2 = require_src$2();
	const oauth2client_1$5 = require_oauth2client();
	var Compute = class extends oauth2client_1$5.OAuth2Client {
		/**
		* Google Compute Engine service account credentials.
		*
		* Retrieve access token from the metadata server.
		* See: https://cloud.google.com/compute/docs/access/authenticate-workloads#applications
		*/
		constructor(options = {}) {
			super(options);
			this.credentials = {
				expiry_date: 1,
				refresh_token: "compute-placeholder"
			};
			this.serviceAccountEmail = options.serviceAccountEmail || "default";
			this.scopes = Array.isArray(options.scopes) ? options.scopes : options.scopes ? [options.scopes] : [];
		}
		/**
		* Refreshes the access token.
		* @param refreshToken Unused parameter
		*/
		async refreshTokenNoCache(refreshToken) {
			const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;
			let data;
			try {
				const instanceOptions = { property: tokenPath };
				if (this.scopes.length > 0) instanceOptions.params = { scopes: this.scopes.join(",") };
				data = await gcpMetadata$2.instance(instanceOptions);
			} catch (e) {
				if (e instanceof gaxios_1$4.GaxiosError) {
					e.message = `Could not refresh access token: ${e.message}`;
					this.wrapError(e);
				}
				throw e;
			}
			const tokens = data;
			if (data && data.expires_in) {
				tokens.expiry_date = new Date().getTime() + data.expires_in * 1e3;
				delete tokens.expires_in;
			}
			this.emit("tokens", tokens);
			return {
				tokens,
				res: null
			};
		}
		/**
		* Fetches an ID token.
		* @param targetAudience the audience for the fetched ID token.
		*/
		async fetchIdToken(targetAudience) {
			const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity?format=full&audience=${targetAudience}`;
			let idToken;
			try {
				const instanceOptions = { property: idTokenPath };
				idToken = await gcpMetadata$2.instance(instanceOptions);
			} catch (e) {
				if (e instanceof Error) e.message = `Could not fetch ID token: ${e.message}`;
				throw e;
			}
			return idToken;
		}
		wrapError(e) {
			const res = e.response;
			if (res && res.status) {
				e.status = res.status;
				if (res.status === 403) e.message = "A Forbidden error was returned while attempting to retrieve an access token for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have the correct permission scopes specified: " + e.message;
				else if (res.status === 404) e.message = "A Not Found error was returned while attempting to retrieve an accesstoken for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have any permission scopes specified: " + e.message;
			}
		}
	};
	exports.Compute = Compute;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/idtokenclient.js
var require_idtokenclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/idtokenclient.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IdTokenClient = void 0;
	const oauth2client_1$4 = require_oauth2client();
	var IdTokenClient = class extends oauth2client_1$4.OAuth2Client {
		/**
		* Google ID Token client
		*
		* Retrieve ID token from the metadata server.
		* See: https://cloud.google.com/docs/authentication/get-id-token#metadata-server
		*/
		constructor(options) {
			super(options);
			this.targetAudience = options.targetAudience;
			this.idTokenProvider = options.idTokenProvider;
		}
		async getRequestMetadataAsync(url) {
			if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {
				const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);
				this.credentials = {
					id_token: idToken,
					expiry_date: this.getIdTokenExpiryDate(idToken)
				};
			}
			const headers = { Authorization: "Bearer " + this.credentials.id_token };
			return { headers };
		}
		getIdTokenExpiryDate(idToken) {
			const payloadB64 = idToken.split(".")[1];
			if (payloadB64) {
				const payload = JSON.parse(Buffer.from(payloadB64, "base64").toString("ascii"));
				return payload.exp * 1e3;
			}
		}
	};
	exports.IdTokenClient = IdTokenClient;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/envDetect.js
var require_envDetect = __commonJS({ "node_modules/google-auth-library/build/src/auth/envDetect.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GCPEnv = void 0;
	exports.clear = clear;
	exports.getEnv = getEnv$1;
	const gcpMetadata$1 = require_src$2();
	var GCPEnv;
	(function(GCPEnv$1) {
		GCPEnv$1["APP_ENGINE"] = "APP_ENGINE";
		GCPEnv$1["KUBERNETES_ENGINE"] = "KUBERNETES_ENGINE";
		GCPEnv$1["CLOUD_FUNCTIONS"] = "CLOUD_FUNCTIONS";
		GCPEnv$1["COMPUTE_ENGINE"] = "COMPUTE_ENGINE";
		GCPEnv$1["CLOUD_RUN"] = "CLOUD_RUN";
		GCPEnv$1["NONE"] = "NONE";
	})(GCPEnv || (exports.GCPEnv = GCPEnv = {}));
	let envPromise;
	function clear() {
		envPromise = void 0;
	}
	async function getEnv$1() {
		if (envPromise) return envPromise;
		envPromise = getEnvMemoized();
		return envPromise;
	}
	async function getEnvMemoized() {
		let env = GCPEnv.NONE;
		if (isAppEngine()) env = GCPEnv.APP_ENGINE;
		else if (isCloudFunction()) env = GCPEnv.CLOUD_FUNCTIONS;
		else if (await isComputeEngine()) if (await isKubernetesEngine()) env = GCPEnv.KUBERNETES_ENGINE;
		else if (isCloudRun()) env = GCPEnv.CLOUD_RUN;
		else env = GCPEnv.COMPUTE_ENGINE;
		else env = GCPEnv.NONE;
		return env;
	}
	function isAppEngine() {
		return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
	}
	function isCloudFunction() {
		return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);
	}
	/**
	* This check only verifies that the environment is running knative.
	* This must be run *after* checking for Kubernetes, otherwise it will
	* return a false positive.
	*/
	function isCloudRun() {
		return !!process.env.K_CONFIGURATION;
	}
	async function isKubernetesEngine() {
		try {
			await gcpMetadata$1.instance("attributes/cluster-name");
			return true;
		} catch (e) {
			return false;
		}
	}
	async function isComputeEngine() {
		return gcpMetadata$1.isAvailable();
	}
} });

//#endregion
//#region node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({ "node_modules/jws/lib/data-stream.js"(exports, module) {
	var Buffer$6 = require_safe_buffer().Buffer;
	var Stream$2 = require("stream");
	var util$3 = require("util");
	function DataStream$2(data) {
		this.buffer = null;
		this.writable = true;
		this.readable = true;
		if (!data) {
			this.buffer = Buffer$6.alloc(0);
			return this;
		}
		if (typeof data.pipe === "function") {
			this.buffer = Buffer$6.alloc(0);
			data.pipe(this);
			return this;
		}
		if (data.length || typeof data === "object") {
			this.buffer = data;
			this.writable = false;
			process.nextTick(function() {
				this.emit("end", data);
				this.readable = false;
				this.emit("close");
			}.bind(this));
			return this;
		}
		throw new TypeError("Unexpected data type (" + typeof data + ")");
	}
	util$3.inherits(DataStream$2, Stream$2);
	DataStream$2.prototype.write = function write$1(data) {
		this.buffer = Buffer$6.concat([this.buffer, Buffer$6.from(data)]);
		this.emit("data", data);
	};
	DataStream$2.prototype.end = function end(data) {
		if (data) this.write(data);
		this.emit("end", data);
		this.emit("close");
		this.writable = false;
		this.readable = false;
	};
	module.exports = DataStream$2;
} });

//#endregion
//#region node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({ "node_modules/buffer-equal-constant-time/index.js"(exports, module) {
	var Buffer$5 = require("buffer").Buffer;
	var SlowBuffer = require("buffer").SlowBuffer;
	module.exports = bufferEq;
	function bufferEq(a$1, b) {
		if (!Buffer$5.isBuffer(a$1) || !Buffer$5.isBuffer(b)) return false;
		if (a$1.length !== b.length) return false;
		var c = 0;
		for (var i$1 = 0; i$1 < a$1.length; i$1++) c |= a$1[i$1] ^ b[i$1];
		return c === 0;
	}
	bufferEq.install = function() {
		Buffer$5.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
			return bufferEq(this, that);
		};
	};
	var origBufEqual = Buffer$5.prototype.equal;
	var origSlowBufEqual = SlowBuffer.prototype.equal;
	bufferEq.restore = function() {
		Buffer$5.prototype.equal = origBufEqual;
		SlowBuffer.prototype.equal = origSlowBufEqual;
	};
} });

//#endregion
//#region node_modules/jwa/index.js
var require_jwa = __commonJS({ "node_modules/jwa/index.js"(exports, module) {
	var bufferEqual = require_buffer_equal_constant_time();
	var Buffer$4 = require_safe_buffer().Buffer;
	var crypto$2 = require("crypto");
	var formatEcdsa = require_ecdsa_sig_formatter();
	var util$2 = require("util");
	var MSG_INVALID_ALGORITHM = "\"%s\" is not a valid algorithm.\n  Supported algorithms are:\n  \"HS256\", \"HS384\", \"HS512\", \"RS256\", \"RS384\", \"RS512\", \"PS256\", \"PS384\", \"PS512\", \"ES256\", \"ES384\", \"ES512\" and \"none\".";
	var MSG_INVALID_SECRET = "secret must be a string or buffer";
	var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
	var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
	var supportsKeyObjects = typeof crypto$2.createPublicKey === "function";
	if (supportsKeyObjects) {
		MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
		MSG_INVALID_SECRET += "or a KeyObject";
	}
	function checkIsPublicKey(key) {
		if (Buffer$4.isBuffer(key)) return;
		if (typeof key === "string") return;
		if (!supportsKeyObjects) throw typeError(MSG_INVALID_VERIFIER_KEY);
		if (typeof key !== "object") throw typeError(MSG_INVALID_VERIFIER_KEY);
		if (typeof key.type !== "string") throw typeError(MSG_INVALID_VERIFIER_KEY);
		if (typeof key.asymmetricKeyType !== "string") throw typeError(MSG_INVALID_VERIFIER_KEY);
		if (typeof key.export !== "function") throw typeError(MSG_INVALID_VERIFIER_KEY);
	}
	function checkIsPrivateKey(key) {
		if (Buffer$4.isBuffer(key)) return;
		if (typeof key === "string") return;
		if (typeof key === "object") return;
		throw typeError(MSG_INVALID_SIGNER_KEY);
	}
	function checkIsSecretKey(key) {
		if (Buffer$4.isBuffer(key)) return;
		if (typeof key === "string") return key;
		if (!supportsKeyObjects) throw typeError(MSG_INVALID_SECRET);
		if (typeof key !== "object") throw typeError(MSG_INVALID_SECRET);
		if (key.type !== "secret") throw typeError(MSG_INVALID_SECRET);
		if (typeof key.export !== "function") throw typeError(MSG_INVALID_SECRET);
	}
	function fromBase64(base64) {
		return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function toBase64(base64url$1) {
		base64url$1 = base64url$1.toString();
		var padding = 4 - base64url$1.length % 4;
		if (padding !== 4) for (var i$1 = 0; i$1 < padding; ++i$1) base64url$1 += "=";
		return base64url$1.replace(/\-/g, "+").replace(/_/g, "/");
	}
	function typeError(template) {
		var args = [].slice.call(arguments, 1);
		var errMsg = util$2.format.bind(util$2, template).apply(null, args);
		return new TypeError(errMsg);
	}
	function bufferOrString(obj) {
		return Buffer$4.isBuffer(obj) || typeof obj === "string";
	}
	function normalizeInput(thing) {
		if (!bufferOrString(thing)) thing = JSON.stringify(thing);
		return thing;
	}
	function createHmacSigner(bits) {
		return function sign$2(thing, secret) {
			checkIsSecretKey(secret);
			thing = normalizeInput(thing);
			var hmac = crypto$2.createHmac("sha" + bits, secret);
			var sig = (hmac.update(thing), hmac.digest("base64"));
			return fromBase64(sig);
		};
	}
	function createHmacVerifier(bits) {
		return function verify(thing, signature, secret) {
			var computedSig = createHmacSigner(bits)(thing, secret);
			return bufferEqual(Buffer$4.from(signature), Buffer$4.from(computedSig));
		};
	}
	function createKeySigner(bits) {
		return function sign$2(thing, privateKey) {
			checkIsPrivateKey(privateKey);
			thing = normalizeInput(thing);
			var signer = crypto$2.createSign("RSA-SHA" + bits);
			var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
			return fromBase64(sig);
		};
	}
	function createKeyVerifier(bits) {
		return function verify(thing, signature, publicKey) {
			checkIsPublicKey(publicKey);
			thing = normalizeInput(thing);
			signature = toBase64(signature);
			var verifier = crypto$2.createVerify("RSA-SHA" + bits);
			verifier.update(thing);
			return verifier.verify(publicKey, signature, "base64");
		};
	}
	function createPSSKeySigner(bits) {
		return function sign$2(thing, privateKey) {
			checkIsPrivateKey(privateKey);
			thing = normalizeInput(thing);
			var signer = crypto$2.createSign("RSA-SHA" + bits);
			var sig = (signer.update(thing), signer.sign({
				key: privateKey,
				padding: crypto$2.constants.RSA_PKCS1_PSS_PADDING,
				saltLength: crypto$2.constants.RSA_PSS_SALTLEN_DIGEST
			}, "base64"));
			return fromBase64(sig);
		};
	}
	function createPSSKeyVerifier(bits) {
		return function verify(thing, signature, publicKey) {
			checkIsPublicKey(publicKey);
			thing = normalizeInput(thing);
			signature = toBase64(signature);
			var verifier = crypto$2.createVerify("RSA-SHA" + bits);
			verifier.update(thing);
			return verifier.verify({
				key: publicKey,
				padding: crypto$2.constants.RSA_PKCS1_PSS_PADDING,
				saltLength: crypto$2.constants.RSA_PSS_SALTLEN_DIGEST
			}, signature, "base64");
		};
	}
	function createECDSASigner(bits) {
		var inner = createKeySigner(bits);
		return function sign$2() {
			var signature = inner.apply(null, arguments);
			signature = formatEcdsa.derToJose(signature, "ES" + bits);
			return signature;
		};
	}
	function createECDSAVerifer(bits) {
		var inner = createKeyVerifier(bits);
		return function verify(thing, signature, publicKey) {
			signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
			var result = inner(thing, signature, publicKey);
			return result;
		};
	}
	function createNoneSigner() {
		return function sign$2() {
			return "";
		};
	}
	function createNoneVerifier() {
		return function verify(thing, signature) {
			return signature === "";
		};
	}
	module.exports = function jwa$2(algorithm) {
		var signerFactories = {
			hs: createHmacSigner,
			rs: createKeySigner,
			ps: createPSSKeySigner,
			es: createECDSASigner,
			none: createNoneSigner
		};
		var verifierFactories = {
			hs: createHmacVerifier,
			rs: createKeyVerifier,
			ps: createPSSKeyVerifier,
			es: createECDSAVerifer,
			none: createNoneVerifier
		};
		var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
		if (!match) throw typeError(MSG_INVALID_ALGORITHM, algorithm);
		var algo = (match[1] || match[3]).toLowerCase();
		var bits = match[2];
		return {
			sign: signerFactories[algo](bits),
			verify: verifierFactories[algo](bits)
		};
	};
} });

//#endregion
//#region node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({ "node_modules/jws/lib/tostring.js"(exports, module) {
	var Buffer$3 = require("buffer").Buffer;
	module.exports = function toString$2(obj) {
		if (typeof obj === "string") return obj;
		if (typeof obj === "number" || Buffer$3.isBuffer(obj)) return obj.toString();
		return JSON.stringify(obj);
	};
} });

//#endregion
//#region node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({ "node_modules/jws/lib/sign-stream.js"(exports, module) {
	var Buffer$2 = require_safe_buffer().Buffer;
	var DataStream$1 = require_data_stream();
	var jwa$1 = require_jwa();
	var Stream$1 = require("stream");
	var toString$1 = require_tostring();
	var util$1 = require("util");
	function base64url(string, encoding) {
		return Buffer$2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function jwsSecuredInput(header, payload, encoding) {
		encoding = encoding || "utf8";
		var encodedHeader = base64url(toString$1(header), "binary");
		var encodedPayload = base64url(toString$1(payload), encoding);
		return util$1.format("%s.%s", encodedHeader, encodedPayload);
	}
	function jwsSign(opts) {
		var header = opts.header;
		var payload = opts.payload;
		var secretOrKey = opts.secret || opts.privateKey;
		var encoding = opts.encoding;
		var algo = jwa$1(header.alg);
		var securedInput = jwsSecuredInput(header, payload, encoding);
		var signature = algo.sign(securedInput, secretOrKey);
		return util$1.format("%s.%s", securedInput, signature);
	}
	function SignStream$1(opts) {
		var secret = opts.secret || opts.privateKey || opts.key;
		var secretStream = new DataStream$1(secret);
		this.readable = true;
		this.header = opts.header;
		this.encoding = opts.encoding;
		this.secret = this.privateKey = this.key = secretStream;
		this.payload = new DataStream$1(opts.payload);
		this.secret.once("close", function() {
			if (!this.payload.writable && this.readable) this.sign();
		}.bind(this));
		this.payload.once("close", function() {
			if (!this.secret.writable && this.readable) this.sign();
		}.bind(this));
	}
	util$1.inherits(SignStream$1, Stream$1);
	SignStream$1.prototype.sign = function sign$2() {
		try {
			var signature = jwsSign({
				header: this.header,
				payload: this.payload.buffer,
				secret: this.secret.buffer,
				encoding: this.encoding
			});
			this.emit("done", signature);
			this.emit("data", signature);
			this.emit("end");
			this.readable = false;
			return signature;
		} catch (e) {
			this.readable = false;
			this.emit("error", e);
			this.emit("close");
		}
	};
	SignStream$1.sign = jwsSign;
	module.exports = SignStream$1;
} });

//#endregion
//#region node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({ "node_modules/jws/lib/verify-stream.js"(exports, module) {
	var Buffer$1 = require_safe_buffer().Buffer;
	var DataStream = require_data_stream();
	var jwa = require_jwa();
	var Stream = require("stream");
	var toString = require_tostring();
	var util = require("util");
	var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
	function isObject(thing) {
		return Object.prototype.toString.call(thing) === "[object Object]";
	}
	function safeJsonParse(thing) {
		if (isObject(thing)) return thing;
		try {
			return JSON.parse(thing);
		} catch (e) {
			return void 0;
		}
	}
	function headerFromJWS(jwsSig) {
		var encodedHeader = jwsSig.split(".", 1)[0];
		return safeJsonParse(Buffer$1.from(encodedHeader, "base64").toString("binary"));
	}
	function securedInputFromJWS(jwsSig) {
		return jwsSig.split(".", 2).join(".");
	}
	function signatureFromJWS(jwsSig) {
		return jwsSig.split(".")[2];
	}
	function payloadFromJWS(jwsSig, encoding) {
		encoding = encoding || "utf8";
		var payload = jwsSig.split(".")[1];
		return Buffer$1.from(payload, "base64").toString(encoding);
	}
	function isValidJws(string) {
		return JWS_REGEX.test(string) && !!headerFromJWS(string);
	}
	function jwsVerify(jwsSig, algorithm, secretOrKey) {
		if (!algorithm) {
			var err = new Error("Missing algorithm parameter for jws.verify");
			err.code = "MISSING_ALGORITHM";
			throw err;
		}
		jwsSig = toString(jwsSig);
		var signature = signatureFromJWS(jwsSig);
		var securedInput = securedInputFromJWS(jwsSig);
		var algo = jwa(algorithm);
		return algo.verify(securedInput, signature, secretOrKey);
	}
	function jwsDecode(jwsSig, opts) {
		opts = opts || {};
		jwsSig = toString(jwsSig);
		if (!isValidJws(jwsSig)) return null;
		var header = headerFromJWS(jwsSig);
		if (!header) return null;
		var payload = payloadFromJWS(jwsSig);
		if (header.typ === "JWT" || opts.json) payload = JSON.parse(payload, opts.encoding);
		return {
			header,
			payload,
			signature: signatureFromJWS(jwsSig)
		};
	}
	function VerifyStream$1(opts) {
		opts = opts || {};
		var secretOrKey = opts.secret || opts.publicKey || opts.key;
		var secretStream = new DataStream(secretOrKey);
		this.readable = true;
		this.algorithm = opts.algorithm;
		this.encoding = opts.encoding;
		this.secret = this.publicKey = this.key = secretStream;
		this.signature = new DataStream(opts.signature);
		this.secret.once("close", function() {
			if (!this.signature.writable && this.readable) this.verify();
		}.bind(this));
		this.signature.once("close", function() {
			if (!this.secret.writable && this.readable) this.verify();
		}.bind(this));
	}
	util.inherits(VerifyStream$1, Stream);
	VerifyStream$1.prototype.verify = function verify() {
		try {
			var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
			var obj = jwsDecode(this.signature.buffer, this.encoding);
			this.emit("done", valid, obj);
			this.emit("data", valid);
			this.emit("end");
			this.readable = false;
			return valid;
		} catch (e) {
			this.readable = false;
			this.emit("error", e);
			this.emit("close");
		}
	};
	VerifyStream$1.decode = jwsDecode;
	VerifyStream$1.isValid = isValidJws;
	VerifyStream$1.verify = jwsVerify;
	module.exports = VerifyStream$1;
} });

//#endregion
//#region node_modules/jws/index.js
var require_jws = __commonJS({ "node_modules/jws/index.js"(exports) {
	var SignStream = require_sign_stream();
	var VerifyStream = require_verify_stream();
	var ALGORITHMS = [
		"HS256",
		"HS384",
		"HS512",
		"RS256",
		"RS384",
		"RS512",
		"PS256",
		"PS384",
		"PS512",
		"ES256",
		"ES384",
		"ES512"
	];
	exports.ALGORITHMS = ALGORITHMS;
	exports.sign = SignStream.sign;
	exports.verify = VerifyStream.verify;
	exports.decode = VerifyStream.decode;
	exports.isValid = VerifyStream.isValid;
	exports.createSign = function createSign(opts) {
		return new SignStream(opts);
	};
	exports.createVerify = function createVerify(opts) {
		return new VerifyStream(opts);
	};
} });

//#endregion
//#region node_modules/gtoken/build/src/index.js
var require_src$1 = __commonJS({ "node_modules/gtoken/build/src/index.js"(exports) {
	/**
	* Copyright 2018 Google LLC
	*
	* Distributed under MIT license.
	* See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
	*/
	var __classPrivateFieldGet$4 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
		return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var __classPrivateFieldSet$2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
		if (kind === "m") throw new TypeError("Private method is not writable");
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
		return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
	};
	var _GoogleToken_instances, _GoogleToken_inFlightRequest, _GoogleToken_getTokenAsync, _GoogleToken_getTokenAsyncInner, _GoogleToken_ensureEmail, _GoogleToken_revokeTokenAsync, _GoogleToken_configure, _GoogleToken_requestToken;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GoogleToken = void 0;
	const fs$6 = require("fs");
	const gaxios_1$3 = require_src$4();
	const jws$1 = require_jws();
	const path$2 = require("path");
	const util_1$7 = require("util");
	const readFile$1 = fs$6.readFile ? (0, util_1$7.promisify)(fs$6.readFile) : async () => {
		throw new ErrorWithCode("use key rather than keyFile.", "MISSING_CREDENTIALS");
	};
	const GOOGLE_TOKEN_URL = "https://www.googleapis.com/oauth2/v4/token";
	const GOOGLE_REVOKE_TOKEN_URL = "https://accounts.google.com/o/oauth2/revoke?token=";
	var ErrorWithCode = class extends Error {
		constructor(message, code$1) {
			super(message);
			this.code = code$1;
		}
	};
	var GoogleToken = class {
		get accessToken() {
			return this.rawToken ? this.rawToken.access_token : void 0;
		}
		get idToken() {
			return this.rawToken ? this.rawToken.id_token : void 0;
		}
		get tokenType() {
			return this.rawToken ? this.rawToken.token_type : void 0;
		}
		get refreshToken() {
			return this.rawToken ? this.rawToken.refresh_token : void 0;
		}
		/**
		* Create a GoogleToken.
		*
		* @param options  Configuration object.
		*/
		constructor(options) {
			_GoogleToken_instances.add(this);
			this.transporter = { request: (opts) => (0, gaxios_1$3.request)(opts) };
			_GoogleToken_inFlightRequest.set(this, void 0);
			__classPrivateFieldGet$4(this, _GoogleToken_instances, "m", _GoogleToken_configure).call(this, options);
		}
		/**
		* Returns whether the token has expired.
		*
		* @return true if the token has expired, false otherwise.
		*/
		hasExpired() {
			const now = new Date().getTime();
			if (this.rawToken && this.expiresAt) return now >= this.expiresAt;
			else return true;
		}
		/**
		* Returns whether the token will expire within eagerRefreshThresholdMillis
		*
		* @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.
		*/
		isTokenExpiring() {
			var _a$5;
			const now = new Date().getTime();
			const eagerRefreshThresholdMillis = (_a$5 = this.eagerRefreshThresholdMillis) !== null && _a$5 !== void 0 ? _a$5 : 0;
			if (this.rawToken && this.expiresAt) return this.expiresAt <= now + eagerRefreshThresholdMillis;
			else return true;
		}
		getToken(callback, opts = {}) {
			if (typeof callback === "object") {
				opts = callback;
				callback = void 0;
			}
			opts = Object.assign({ forceRefresh: false }, opts);
			if (callback) {
				const cb = callback;
				__classPrivateFieldGet$4(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsync).call(this, opts).then((t) => cb(null, t), callback);
				return;
			}
			return __classPrivateFieldGet$4(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsync).call(this, opts);
		}
		/**
		* Given a keyFile, extract the key and client email if available
		* @param keyFile Path to a json, pem, or p12 file that contains the key.
		* @returns an object with privateKey and clientEmail properties
		*/
		async getCredentials(keyFile) {
			const ext = path$2.extname(keyFile);
			switch (ext) {
				case ".json": {
					const key = await readFile$1(keyFile, "utf8");
					const body = JSON.parse(key);
					const privateKey = body.private_key;
					const clientEmail = body.client_email;
					if (!privateKey || !clientEmail) throw new ErrorWithCode("private_key and client_email are required.", "MISSING_CREDENTIALS");
					return {
						privateKey,
						clientEmail
					};
				}
				case ".der":
				case ".crt":
				case ".pem": {
					const privateKey = await readFile$1(keyFile, "utf8");
					return { privateKey };
				}
				case ".p12":
				case ".pfx": throw new ErrorWithCode("*.p12 certificates are not supported after v6.1.2. Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.", "UNKNOWN_CERTIFICATE_TYPE");
				default: throw new ErrorWithCode("Unknown certificate type. Type is determined based on file extension. Current supported extensions are *.json, and *.pem.", "UNKNOWN_CERTIFICATE_TYPE");
			}
		}
		revokeToken(callback) {
			if (callback) {
				__classPrivateFieldGet$4(this, _GoogleToken_instances, "m", _GoogleToken_revokeTokenAsync).call(this).then(() => callback(), callback);
				return;
			}
			return __classPrivateFieldGet$4(this, _GoogleToken_instances, "m", _GoogleToken_revokeTokenAsync).call(this);
		}
	};
	exports.GoogleToken = GoogleToken;
	_GoogleToken_inFlightRequest = new WeakMap(), _GoogleToken_instances = new WeakSet(), _GoogleToken_getTokenAsync = async function _GoogleToken_getTokenAsync$1(opts) {
		if (__classPrivateFieldGet$4(this, _GoogleToken_inFlightRequest, "f") && !opts.forceRefresh) return __classPrivateFieldGet$4(this, _GoogleToken_inFlightRequest, "f");
		try {
			return await __classPrivateFieldSet$2(this, _GoogleToken_inFlightRequest, __classPrivateFieldGet$4(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsyncInner).call(this, opts), "f");
		} finally {
			__classPrivateFieldSet$2(this, _GoogleToken_inFlightRequest, void 0, "f");
		}
	}, _GoogleToken_getTokenAsyncInner = async function _GoogleToken_getTokenAsyncInner$1(opts) {
		if (this.isTokenExpiring() === false && opts.forceRefresh === false) return Promise.resolve(this.rawToken);
		if (!this.key && !this.keyFile) throw new Error("No key or keyFile set.");
		if (!this.key && this.keyFile) {
			const creds = await this.getCredentials(this.keyFile);
			this.key = creds.privateKey;
			this.iss = creds.clientEmail || this.iss;
			if (!creds.clientEmail) __classPrivateFieldGet$4(this, _GoogleToken_instances, "m", _GoogleToken_ensureEmail).call(this);
		}
		return __classPrivateFieldGet$4(this, _GoogleToken_instances, "m", _GoogleToken_requestToken).call(this);
	}, _GoogleToken_ensureEmail = function _GoogleToken_ensureEmail$1() {
		if (!this.iss) throw new ErrorWithCode("email is required.", "MISSING_CREDENTIALS");
	}, _GoogleToken_revokeTokenAsync = async function _GoogleToken_revokeTokenAsync$1() {
		if (!this.accessToken) throw new Error("No token to revoke.");
		const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;
		await this.transporter.request({
			url,
			retry: true
		});
		__classPrivateFieldGet$4(this, _GoogleToken_instances, "m", _GoogleToken_configure).call(this, {
			email: this.iss,
			sub: this.sub,
			key: this.key,
			keyFile: this.keyFile,
			scope: this.scope,
			additionalClaims: this.additionalClaims
		});
	}, _GoogleToken_configure = function _GoogleToken_configure$1(options = {}) {
		this.keyFile = options.keyFile;
		this.key = options.key;
		this.rawToken = void 0;
		this.iss = options.email || options.iss;
		this.sub = options.sub;
		this.additionalClaims = options.additionalClaims;
		if (typeof options.scope === "object") this.scope = options.scope.join(" ");
		else this.scope = options.scope;
		this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
		if (options.transporter) this.transporter = options.transporter;
	}, _GoogleToken_requestToken = async function _GoogleToken_requestToken$1() {
		var _a$5, _b$1;
		const iat = Math.floor(new Date().getTime() / 1e3);
		const additionalClaims = this.additionalClaims || {};
		const payload = Object.assign({
			iss: this.iss,
			scope: this.scope,
			aud: GOOGLE_TOKEN_URL,
			exp: iat + 3600,
			iat,
			sub: this.sub
		}, additionalClaims);
		const signedJWT = jws$1.sign({
			header: { alg: "RS256" },
			payload,
			secret: this.key
		});
		try {
			const r = await this.transporter.request({
				method: "POST",
				url: GOOGLE_TOKEN_URL,
				data: {
					grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
					assertion: signedJWT
				},
				headers: { "Content-Type": "application/x-www-form-urlencoded" },
				responseType: "json",
				retryConfig: { httpMethodsToRetry: ["POST"] }
			});
			this.rawToken = r.data;
			this.expiresAt = r.data.expires_in === null || r.data.expires_in === void 0 ? void 0 : (iat + r.data.expires_in) * 1e3;
			return this.rawToken;
		} catch (e) {
			this.rawToken = void 0;
			this.tokenExpires = void 0;
			const body = e.response && ((_a$5 = e.response) === null || _a$5 === void 0 ? void 0 : _a$5.data) ? (_b$1 = e.response) === null || _b$1 === void 0 ? void 0 : _b$1.data : {};
			if (body.error) {
				const desc = body.error_description ? `: ${body.error_description}` : "";
				e.message = `${body.error}${desc}`;
			}
			throw e;
		}
	};
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/jwtaccess.js
var require_jwtaccess = __commonJS({ "node_modules/google-auth-library/build/src/auth/jwtaccess.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JWTAccess = void 0;
	const jws = require_jws();
	const util_1$6 = require_util();
	const DEFAULT_HEADER = {
		alg: "RS256",
		typ: "JWT"
	};
	var JWTAccess = class JWTAccess {
		/**
		* JWTAccess service account credentials.
		*
		* Create a new access token by using the credential to create a new JWT token
		* that's recognized as the access token.
		*
		* @param email the service account email address.
		* @param key the private key that will be used to sign the token.
		* @param keyId the ID of the private key used to sign the token.
		*/
		constructor(email, key, keyId, eagerRefreshThresholdMillis) {
			this.cache = new util_1$6.LRUCache({
				capacity: 500,
				maxAge: 60 * 60 * 1e3
			});
			this.email = email;
			this.key = key;
			this.keyId = keyId;
			this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1e3;
		}
		/**
		* Ensures that we're caching a key appropriately, giving precedence to scopes vs. url
		*
		* @param url The URI being authorized.
		* @param scopes The scope or scopes being authorized
		* @returns A string that returns the cached key.
		*/
		getCachedKey(url, scopes) {
			let cacheKey = url;
			if (scopes && Array.isArray(scopes) && scopes.length) cacheKey = url ? `${url}_${scopes.join("_")}` : `${scopes.join("_")}`;
			else if (typeof scopes === "string") cacheKey = url ? `${url}_${scopes}` : scopes;
			if (!cacheKey) throw Error("Scopes or url must be provided");
			return cacheKey;
		}
		/**
		* Get a non-expired access token, after refreshing if necessary.
		*
		* @param url The URI being authorized.
		* @param additionalClaims An object with a set of additional claims to
		* include in the payload.
		* @returns An object that includes the authorization header.
		*/
		getRequestHeaders(url, additionalClaims, scopes) {
			const key = this.getCachedKey(url, scopes);
			const cachedToken = this.cache.get(key);
			const now = Date.now();
			if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) return cachedToken.headers;
			const iat = Math.floor(Date.now() / 1e3);
			const exp = JWTAccess.getExpirationTime(iat);
			let defaultClaims;
			if (Array.isArray(scopes)) scopes = scopes.join(" ");
			if (scopes) defaultClaims = {
				iss: this.email,
				sub: this.email,
				scope: scopes,
				exp,
				iat
			};
			else defaultClaims = {
				iss: this.email,
				sub: this.email,
				aud: url,
				exp,
				iat
			};
			if (additionalClaims) {
				for (const claim in defaultClaims) if (additionalClaims[claim]) throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
			}
			const header = this.keyId ? {
				...DEFAULT_HEADER,
				kid: this.keyId
			} : DEFAULT_HEADER;
			const payload = Object.assign(defaultClaims, additionalClaims);
			const signedJWT = jws.sign({
				header,
				payload,
				secret: this.key
			});
			const headers = { Authorization: `Bearer ${signedJWT}` };
			this.cache.set(key, {
				expiration: exp * 1e3,
				headers
			});
			return headers;
		}
		/**
		* Returns an expiration time for the JWT token.
		*
		* @param iat The issued at time for the JWT.
		* @returns An expiration time for the JWT.
		*/
		static getExpirationTime(iat) {
			const exp = iat + 3600;
			return exp;
		}
		/**
		* Create a JWTAccess credentials instance using the given input options.
		* @param json The input object.
		*/
		fromJSON(json$1) {
			if (!json$1) throw new Error("Must pass in a JSON object containing the service account auth settings.");
			if (!json$1.client_email) throw new Error("The incoming JSON object does not contain a client_email field");
			if (!json$1.private_key) throw new Error("The incoming JSON object does not contain a private_key field");
			this.email = json$1.client_email;
			this.key = json$1.private_key;
			this.keyId = json$1.private_key_id;
			this.projectId = json$1.project_id;
		}
		fromStream(inputStream, callback) {
			if (callback) this.fromStreamAsync(inputStream).then(() => callback(), callback);
			else return this.fromStreamAsync(inputStream);
		}
		fromStreamAsync(inputStream) {
			return new Promise((resolve, reject) => {
				if (!inputStream) reject(new Error("Must pass in a stream containing the service account auth settings."));
				let s$1 = "";
				inputStream.setEncoding("utf8").on("data", (chunk) => s$1 += chunk).on("error", reject).on("end", () => {
					try {
						const data = JSON.parse(s$1);
						this.fromJSON(data);
						resolve();
					} catch (err) {
						reject(err);
					}
				});
			});
		}
	};
	exports.JWTAccess = JWTAccess;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/jwtclient.js
var require_jwtclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/jwtclient.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JWT = void 0;
	const gtoken_1 = require_src$1();
	const jwtaccess_1$1 = require_jwtaccess();
	const oauth2client_1$3 = require_oauth2client();
	const authclient_1$6 = require_authclient();
	var JWT = class JWT extends oauth2client_1$3.OAuth2Client {
		constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {
			const opts = optionsOrEmail && typeof optionsOrEmail === "object" ? optionsOrEmail : {
				email: optionsOrEmail,
				keyFile,
				key,
				keyId,
				scopes,
				subject
			};
			super(opts);
			this.email = opts.email;
			this.keyFile = opts.keyFile;
			this.key = opts.key;
			this.keyId = opts.keyId;
			this.scopes = opts.scopes;
			this.subject = opts.subject;
			this.additionalClaims = opts.additionalClaims;
			this.credentials = {
				refresh_token: "jwt-placeholder",
				expiry_date: 1
			};
		}
		/**
		* Creates a copy of the credential with the specified scopes.
		* @param scopes List of requested scopes or a single scope.
		* @return The cloned instance.
		*/
		createScoped(scopes) {
			const jwt = new JWT(this);
			jwt.scopes = scopes;
			return jwt;
		}
		/**
		* Obtains the metadata to be sent with the request.
		*
		* @param url the URI being authorized.
		*/
		async getRequestMetadataAsync(url) {
			url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;
			const useSelfSignedJWT = !this.hasUserScopes() && url || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== authclient_1$6.DEFAULT_UNIVERSE;
			if (this.subject && this.universeDomain !== authclient_1$6.DEFAULT_UNIVERSE) throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${authclient_1$6.DEFAULT_UNIVERSE}`);
			if (!this.apiKey && useSelfSignedJWT) if (this.additionalClaims && this.additionalClaims.target_audience) {
				const { tokens } = await this.refreshToken();
				return { headers: this.addSharedMetadataHeaders({ Authorization: `Bearer ${tokens.id_token}` }) };
			} else {
				if (!this.access) this.access = new jwtaccess_1$1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);
				let scopes;
				if (this.hasUserScopes()) scopes = this.scopes;
				else if (!url) scopes = this.defaultScopes;
				const useScopes = this.useJWTAccessWithScope || this.universeDomain !== authclient_1$6.DEFAULT_UNIVERSE;
				const headers = await this.access.getRequestHeaders(
					url !== null && url !== void 0 ? url : void 0,
					this.additionalClaims,
					// Scopes take precedent over audience for signing,
					// so we only provide them if `useJWTAccessWithScope` is on or
					// if we are in a non-default universe
					useScopes ? scopes : void 0
);
				return { headers: this.addSharedMetadataHeaders(headers) };
			}
			else if (this.hasAnyScopes() || this.apiKey) return super.getRequestMetadataAsync(url);
			else return { headers: {} };
		}
		/**
		* Fetches an ID token.
		* @param targetAudience the audience for the fetched ID token.
		*/
		async fetchIdToken(targetAudience) {
			const gtoken = new gtoken_1.GoogleToken({
				iss: this.email,
				sub: this.subject,
				scope: this.scopes || this.defaultScopes,
				keyFile: this.keyFile,
				key: this.key,
				additionalClaims: { target_audience: targetAudience },
				transporter: this.transporter
			});
			await gtoken.getToken({ forceRefresh: true });
			if (!gtoken.idToken) throw new Error("Unknown error: Failed to fetch ID token");
			return gtoken.idToken;
		}
		/**
		* Determine if there are currently scopes available.
		*/
		hasUserScopes() {
			if (!this.scopes) return false;
			return this.scopes.length > 0;
		}
		/**
		* Are there any default or user scopes defined.
		*/
		hasAnyScopes() {
			if (this.scopes && this.scopes.length > 0) return true;
			if (this.defaultScopes && this.defaultScopes.length > 0) return true;
			return false;
		}
		authorize(callback) {
			if (callback) this.authorizeAsync().then((r) => callback(null, r), callback);
			else return this.authorizeAsync();
		}
		async authorizeAsync() {
			const result = await this.refreshToken();
			if (!result) throw new Error("No result returned");
			this.credentials = result.tokens;
			this.credentials.refresh_token = "jwt-placeholder";
			this.key = this.gtoken.key;
			this.email = this.gtoken.iss;
			return result.tokens;
		}
		/**
		* Refreshes the access token.
		* @param refreshToken ignored
		* @private
		*/
		async refreshTokenNoCache(refreshToken) {
			const gtoken = this.createGToken();
			const token = await gtoken.getToken({ forceRefresh: this.isTokenExpiring() });
			const tokens = {
				access_token: token.access_token,
				token_type: "Bearer",
				expiry_date: gtoken.expiresAt,
				id_token: gtoken.idToken
			};
			this.emit("tokens", tokens);
			return {
				res: null,
				tokens
			};
		}
		/**
		* Create a gToken if it doesn't already exist.
		*/
		createGToken() {
			if (!this.gtoken) this.gtoken = new gtoken_1.GoogleToken({
				iss: this.email,
				sub: this.subject,
				scope: this.scopes || this.defaultScopes,
				keyFile: this.keyFile,
				key: this.key,
				additionalClaims: this.additionalClaims,
				transporter: this.transporter
			});
			return this.gtoken;
		}
		/**
		* Create a JWT credentials instance using the given input options.
		* @param json The input object.
		*
		* @remarks
		*
		* **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
		*/
		fromJSON(json$1) {
			if (!json$1) throw new Error("Must pass in a JSON object containing the service account auth settings.");
			if (!json$1.client_email) throw new Error("The incoming JSON object does not contain a client_email field");
			if (!json$1.private_key) throw new Error("The incoming JSON object does not contain a private_key field");
			this.email = json$1.client_email;
			this.key = json$1.private_key;
			this.keyId = json$1.private_key_id;
			this.projectId = json$1.project_id;
			this.quotaProjectId = json$1.quota_project_id;
			this.universeDomain = json$1.universe_domain || this.universeDomain;
		}
		fromStream(inputStream, callback) {
			if (callback) this.fromStreamAsync(inputStream).then(() => callback(), callback);
			else return this.fromStreamAsync(inputStream);
		}
		fromStreamAsync(inputStream) {
			return new Promise((resolve, reject) => {
				if (!inputStream) throw new Error("Must pass in a stream containing the service account auth settings.");
				let s$1 = "";
				inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s$1 += chunk).on("end", () => {
					try {
						const data = JSON.parse(s$1);
						this.fromJSON(data);
						resolve();
					} catch (e) {
						reject(e);
					}
				});
			});
		}
		/**
		* Creates a JWT credentials instance using an API Key for authentication.
		* @param apiKey The API Key in string form.
		*/
		fromAPIKey(apiKey) {
			if (typeof apiKey !== "string") throw new Error("Must provide an API Key string.");
			this.apiKey = apiKey;
		}
		/**
		* Using the key or keyFile on the JWT client, obtain an object that contains
		* the key and the client email.
		*/
		async getCredentials() {
			if (this.key) return {
				private_key: this.key,
				client_email: this.email
			};
			else if (this.keyFile) {
				const gtoken = this.createGToken();
				const creds = await gtoken.getCredentials(this.keyFile);
				return {
					private_key: creds.privateKey,
					client_email: creds.clientEmail
				};
			}
			throw new Error("A key or a keyFile must be provided to getCredentials.");
		}
	};
	exports.JWT = JWT;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/refreshclient.js
var require_refreshclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/refreshclient.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = void 0;
	const oauth2client_1$2 = require_oauth2client();
	const querystring_1 = require("querystring");
	exports.USER_REFRESH_ACCOUNT_TYPE = "authorized_user";
	var UserRefreshClient = class UserRefreshClient extends oauth2client_1$2.OAuth2Client {
		constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure) {
			const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : {
				clientId: optionsOrClientId,
				clientSecret,
				refreshToken,
				eagerRefreshThresholdMillis,
				forceRefreshOnFailure
			};
			super(opts);
			this._refreshToken = opts.refreshToken;
			this.credentials.refresh_token = opts.refreshToken;
		}
		/**
		* Refreshes the access token.
		* @param refreshToken An ignored refreshToken..
		* @param callback Optional callback.
		*/
		async refreshTokenNoCache(refreshToken) {
			return super.refreshTokenNoCache(this._refreshToken);
		}
		async fetchIdToken(targetAudience) {
			const res = await this.transporter.request({
				...UserRefreshClient.RETRY_CONFIG,
				url: this.endpoints.oauth2TokenUrl,
				headers: { "Content-Type": "application/x-www-form-urlencoded" },
				method: "POST",
				data: (0, querystring_1.stringify)({
					client_id: this._clientId,
					client_secret: this._clientSecret,
					grant_type: "refresh_token",
					refresh_token: this._refreshToken,
					target_audience: targetAudience
				})
			});
			return res.data.id_token;
		}
		/**
		* Create a UserRefreshClient credentials instance using the given input
		* options.
		* @param json The input object.
		*/
		fromJSON(json$1) {
			if (!json$1) throw new Error("Must pass in a JSON object containing the user refresh token");
			if (json$1.type !== "authorized_user") throw new Error("The incoming JSON object does not have the \"authorized_user\" type");
			if (!json$1.client_id) throw new Error("The incoming JSON object does not contain a client_id field");
			if (!json$1.client_secret) throw new Error("The incoming JSON object does not contain a client_secret field");
			if (!json$1.refresh_token) throw new Error("The incoming JSON object does not contain a refresh_token field");
			this._clientId = json$1.client_id;
			this._clientSecret = json$1.client_secret;
			this._refreshToken = json$1.refresh_token;
			this.credentials.refresh_token = json$1.refresh_token;
			this.quotaProjectId = json$1.quota_project_id;
			this.universeDomain = json$1.universe_domain || this.universeDomain;
		}
		fromStream(inputStream, callback) {
			if (callback) this.fromStreamAsync(inputStream).then(() => callback(), callback);
			else return this.fromStreamAsync(inputStream);
		}
		async fromStreamAsync(inputStream) {
			return new Promise((resolve, reject) => {
				if (!inputStream) return reject(new Error("Must pass in a stream containing the user refresh token."));
				let s$1 = "";
				inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s$1 += chunk).on("end", () => {
					try {
						const data = JSON.parse(s$1);
						this.fromJSON(data);
						return resolve();
					} catch (err) {
						return reject(err);
					}
				});
			});
		}
		/**
		* Create a UserRefreshClient credentials instance using the given input
		* options.
		* @param json The input object.
		*/
		static fromJSON(json$1) {
			const client = new UserRefreshClient();
			client.fromJSON(json$1);
			return client;
		}
	};
	exports.UserRefreshClient = UserRefreshClient;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/impersonated.js
var require_impersonated = __commonJS({ "node_modules/google-auth-library/build/src/auth/impersonated.js"(exports) {
	/**
	* Copyright 2021 Google LLC
	*
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*      http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;
	const oauth2client_1$1 = require_oauth2client();
	const gaxios_1$2 = require_src$4();
	const util_1$5 = require_util();
	exports.IMPERSONATED_ACCOUNT_TYPE = "impersonated_service_account";
	var Impersonated = class Impersonated extends oauth2client_1$1.OAuth2Client {
		/**
		* Impersonated service account credentials.
		*
		* Create a new access token by impersonating another service account.
		*
		* Impersonated Credentials allowing credentials issued to a user or
		* service account to impersonate another. The source project using
		* Impersonated Credentials must enable the "IAMCredentials" API.
		* Also, the target service account must grant the orginating principal
		* the "Service Account Token Creator" IAM role.
		*
		* @param {object} options - The configuration object.
		* @param {object} [options.sourceClient] the source credential used as to
		* acquire the impersonated credentials.
		* @param {string} [options.targetPrincipal] the service account to
		* impersonate.
		* @param {string[]} [options.delegates] the chained list of delegates
		* required to grant the final access_token. If set, the sequence of
		* identities must have "Service Account Token Creator" capability granted to
		* the preceding identity. For example, if set to [serviceAccountB,
		* serviceAccountC], the sourceCredential must have the Token Creator role on
		* serviceAccountB. serviceAccountB must have the Token Creator on
		* serviceAccountC. Finally, C must have Token Creator on target_principal.
		* If left unset, sourceCredential must have that role on targetPrincipal.
		* @param {string[]} [options.targetScopes] scopes to request during the
		* authorization grant.
		* @param {number} [options.lifetime] number of seconds the delegated
		* credential should be valid for up to 3600 seconds by default, or 43,200
		* seconds by extending the token's lifetime, see:
		* https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth
		* @param {string} [options.endpoint] api endpoint override.
		*/
		constructor(options = {}) {
			var _a$5, _b$1, _c$1, _d, _e, _f;
			super(options);
			this.credentials = {
				expiry_date: 1,
				refresh_token: "impersonated-placeholder"
			};
			this.sourceClient = (_a$5 = options.sourceClient) !== null && _a$5 !== void 0 ? _a$5 : new oauth2client_1$1.OAuth2Client();
			this.targetPrincipal = (_b$1 = options.targetPrincipal) !== null && _b$1 !== void 0 ? _b$1 : "";
			this.delegates = (_c$1 = options.delegates) !== null && _c$1 !== void 0 ? _c$1 : [];
			this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];
			this.lifetime = (_e = options.lifetime) !== null && _e !== void 0 ? _e : 3600;
			const usingExplicitUniverseDomain = !!(0, util_1$5.originalOrCamelOptions)(options).get("universe_domain");
			if (!usingExplicitUniverseDomain) this.universeDomain = this.sourceClient.universeDomain;
			else if (this.sourceClient.universeDomain !== this.universeDomain) throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);
			this.endpoint = (_f = options.endpoint) !== null && _f !== void 0 ? _f : `https://iamcredentials.${this.universeDomain}`;
		}
		/**
		* Signs some bytes.
		*
		* {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}
		* @param blobToSign String to sign.
		*
		* @returns A {@link SignBlobResponse} denoting the keyID and signedBlob in base64 string
		*/
		async sign(blobToSign) {
			await this.sourceClient.getAccessToken();
			const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
			const u = `${this.endpoint}/v1/${name}:signBlob`;
			const body = {
				delegates: this.delegates,
				payload: Buffer.from(blobToSign).toString("base64")
			};
			const res = await this.sourceClient.request({
				...Impersonated.RETRY_CONFIG,
				url: u,
				data: body,
				method: "POST"
			});
			return res.data;
		}
		/** The service account email to be impersonated. */
		getTargetPrincipal() {
			return this.targetPrincipal;
		}
		/**
		* Refreshes the access token.
		*/
		async refreshToken() {
			var _a$5, _b$1, _c$1, _d, _e, _f;
			try {
				await this.sourceClient.getAccessToken();
				const name = "projects/-/serviceAccounts/" + this.targetPrincipal;
				const u = `${this.endpoint}/v1/${name}:generateAccessToken`;
				const body = {
					delegates: this.delegates,
					scope: this.targetScopes,
					lifetime: this.lifetime + "s"
				};
				const res = await this.sourceClient.request({
					...Impersonated.RETRY_CONFIG,
					url: u,
					data: body,
					method: "POST"
				});
				const tokenResponse = res.data;
				this.credentials.access_token = tokenResponse.accessToken;
				this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);
				return {
					tokens: this.credentials,
					res
				};
			} catch (error$1) {
				if (!(error$1 instanceof Error)) throw error$1;
				let status = 0;
				let message = "";
				if (error$1 instanceof gaxios_1$2.GaxiosError) {
					status = (_c$1 = (_b$1 = (_a$5 = error$1 === null || error$1 === void 0 ? void 0 : error$1.response) === null || _a$5 === void 0 ? void 0 : _a$5.data) === null || _b$1 === void 0 ? void 0 : _b$1.error) === null || _c$1 === void 0 ? void 0 : _c$1.status;
					message = (_f = (_e = (_d = error$1 === null || error$1 === void 0 ? void 0 : error$1.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message;
				}
				if (status && message) {
					error$1.message = `${status}: unable to impersonate: ${message}`;
					throw error$1;
				} else {
					error$1.message = `unable to impersonate: ${error$1}`;
					throw error$1;
				}
			}
		}
		/**
		* Generates an OpenID Connect ID token for a service account.
		*
		* {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}
		*
		* @param targetAudience the audience for the fetched ID token.
		* @param options the for the request
		* @return an OpenID Connect ID token
		*/
		async fetchIdToken(targetAudience, options) {
			var _a$5, _b$1;
			await this.sourceClient.getAccessToken();
			const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
			const u = `${this.endpoint}/v1/${name}:generateIdToken`;
			const body = {
				delegates: this.delegates,
				audience: targetAudience,
				includeEmail: (_a$5 = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a$5 !== void 0 ? _a$5 : true,
				useEmailAzp: (_b$1 = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _b$1 !== void 0 ? _b$1 : true
			};
			const res = await this.sourceClient.request({
				...Impersonated.RETRY_CONFIG,
				url: u,
				data: body,
				method: "POST"
			});
			return res.data.token;
		}
	};
	exports.Impersonated = Impersonated;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/oauth2common.js
var require_oauth2common = __commonJS({ "node_modules/google-auth-library/build/src/auth/oauth2common.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OAuthClientAuthHandler = void 0;
	exports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;
	const querystring$1 = require("querystring");
	const crypto_1$2 = require_crypto();
	/** List of HTTP methods that accept request bodies. */
	const METHODS_SUPPORTING_REQUEST_BODY = [
		"PUT",
		"POST",
		"PATCH"
	];
	/**
	* Abstract class for handling client authentication in OAuth-based
	* operations.
	* When request-body client authentication is used, only application/json and
	* application/x-www-form-urlencoded content types for HTTP methods that support
	* request bodies are supported.
	*/
	var OAuthClientAuthHandler = class {
		/**
		* Instantiates an OAuth client authentication handler.
		* @param clientAuthentication The client auth credentials.
		*/
		constructor(clientAuthentication) {
			this.clientAuthentication = clientAuthentication;
			this.crypto = (0, crypto_1$2.createCrypto)();
		}
		/**
		* Applies client authentication on the OAuth request's headers or POST
		* body but does not process the request.
		* @param opts The GaxiosOptions whose headers or data are to be modified
		*   depending on the client authentication mechanism to be used.
		* @param bearerToken The optional bearer token to use for authentication.
		*   When this is used, no client authentication credentials are needed.
		*/
		applyClientAuthenticationOptions(opts, bearerToken) {
			this.injectAuthenticatedHeaders(opts, bearerToken);
			if (!bearerToken) this.injectAuthenticatedRequestBody(opts);
		}
		/**
		* Applies client authentication on the request's header if either
		* basic authentication or bearer token authentication is selected.
		*
		* @param opts The GaxiosOptions whose headers or data are to be modified
		*   depending on the client authentication mechanism to be used.
		* @param bearerToken The optional bearer token to use for authentication.
		*   When this is used, no client authentication credentials are needed.
		*/
		injectAuthenticatedHeaders(opts, bearerToken) {
			var _a$5;
			if (bearerToken) {
				opts.headers = opts.headers || {};
				Object.assign(opts.headers, { Authorization: `Bearer ${bearerToken}}` });
			} else if (((_a$5 = this.clientAuthentication) === null || _a$5 === void 0 ? void 0 : _a$5.confidentialClientType) === "basic") {
				opts.headers = opts.headers || {};
				const clientId = this.clientAuthentication.clientId;
				const clientSecret = this.clientAuthentication.clientSecret || "";
				const base64EncodedCreds = this.crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);
				Object.assign(opts.headers, { Authorization: `Basic ${base64EncodedCreds}` });
			}
		}
		/**
		* Applies client authentication on the request's body if request-body
		* client authentication is selected.
		*
		* @param opts The GaxiosOptions whose headers or data are to be modified
		*   depending on the client authentication mechanism to be used.
		*/
		injectAuthenticatedRequestBody(opts) {
			var _a$5;
			if (((_a$5 = this.clientAuthentication) === null || _a$5 === void 0 ? void 0 : _a$5.confidentialClientType) === "request-body") {
				const method = (opts.method || "GET").toUpperCase();
				if (METHODS_SUPPORTING_REQUEST_BODY.indexOf(method) !== -1) {
					let contentType;
					const headers = opts.headers || {};
					for (const key in headers) if (key.toLowerCase() === "content-type" && headers[key]) {
						contentType = headers[key].toLowerCase();
						break;
					}
					if (contentType === "application/x-www-form-urlencoded") {
						opts.data = opts.data || "";
						const data = querystring$1.parse(opts.data);
						Object.assign(data, {
							client_id: this.clientAuthentication.clientId,
							client_secret: this.clientAuthentication.clientSecret || ""
						});
						opts.data = querystring$1.stringify(data);
					} else if (contentType === "application/json") {
						opts.data = opts.data || {};
						Object.assign(opts.data, {
							client_id: this.clientAuthentication.clientId,
							client_secret: this.clientAuthentication.clientSecret || ""
						});
					} else throw new Error(`${contentType} content-types are not supported with ${this.clientAuthentication.confidentialClientType} client authentication`);
				} else throw new Error(`${method} HTTP method does not support ${this.clientAuthentication.confidentialClientType} client authentication`);
			}
		}
		/**
		* Retry config for Auth-related requests.
		*
		* @remarks
		*
		* This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
		* config as some downstream APIs would prefer if customers explicitly enable retries,
		* such as GCS.
		*/
		static get RETRY_CONFIG() {
			return {
				retry: true,
				retryConfig: { httpMethodsToRetry: [
					"GET",
					"PUT",
					"POST",
					"HEAD",
					"OPTIONS",
					"DELETE"
				] }
			};
		}
	};
	exports.OAuthClientAuthHandler = OAuthClientAuthHandler;
	/**
	* Converts an OAuth error response to a native JavaScript Error.
	* @param resp The OAuth error response to convert to a native Error object.
	* @param err The optional original error. If provided, the error properties
	*   will be copied to the new error.
	* @return The converted native Error object.
	*/
	function getErrorFromOAuthErrorResponse(resp, err) {
		const errorCode = resp.error;
		const errorDescription = resp.error_description;
		const errorUri = resp.error_uri;
		let message = `Error code ${errorCode}`;
		if (typeof errorDescription !== "undefined") message += `: ${errorDescription}`;
		if (typeof errorUri !== "undefined") message += ` - ${errorUri}`;
		const newError = new Error(message);
		if (err) {
			const keys = Object.keys(err);
			if (err.stack) keys.push("stack");
			keys.forEach((key) => {
				if (key !== "message") Object.defineProperty(newError, key, {
					value: err[key],
					writable: false,
					enumerable: true
				});
			});
		}
		return newError;
	}
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/stscredentials.js
var require_stscredentials = __commonJS({ "node_modules/google-auth-library/build/src/auth/stscredentials.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.StsCredentials = void 0;
	const gaxios_1$1 = require_src$4();
	const querystring = require("querystring");
	const transporters_1$2 = require_transporters();
	const oauth2common_1$1 = require_oauth2common();
	/**
	* Implements the OAuth 2.0 token exchange based on
	* https://tools.ietf.org/html/rfc8693
	*/
	var StsCredentials = class StsCredentials extends oauth2common_1$1.OAuthClientAuthHandler {
		/**
		* Initializes an STS credentials instance.
		* @param tokenExchangeEndpoint The token exchange endpoint.
		* @param clientAuthentication The client authentication credentials if
		*   available.
		*/
		constructor(tokenExchangeEndpoint, clientAuthentication) {
			super(clientAuthentication);
			this.tokenExchangeEndpoint = tokenExchangeEndpoint;
			this.transporter = new transporters_1$2.DefaultTransporter();
		}
		/**
		* Exchanges the provided token for another type of token based on the
		* rfc8693 spec.
		* @param stsCredentialsOptions The token exchange options used to populate
		*   the token exchange request.
		* @param additionalHeaders Optional additional headers to pass along the
		*   request.
		* @param options Optional additional GCP-specific non-spec defined options
		*   to send with the request.
		*   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`
		* @return A promise that resolves with the token exchange response containing
		*   the requested token and its expiration time.
		*/
		async exchangeToken(stsCredentialsOptions, additionalHeaders, options) {
			var _a$5, _b$1, _c$1;
			const values = {
				grant_type: stsCredentialsOptions.grantType,
				resource: stsCredentialsOptions.resource,
				audience: stsCredentialsOptions.audience,
				scope: (_a$5 = stsCredentialsOptions.scope) === null || _a$5 === void 0 ? void 0 : _a$5.join(" "),
				requested_token_type: stsCredentialsOptions.requestedTokenType,
				subject_token: stsCredentialsOptions.subjectToken,
				subject_token_type: stsCredentialsOptions.subjectTokenType,
				actor_token: (_b$1 = stsCredentialsOptions.actingParty) === null || _b$1 === void 0 ? void 0 : _b$1.actorToken,
				actor_token_type: (_c$1 = stsCredentialsOptions.actingParty) === null || _c$1 === void 0 ? void 0 : _c$1.actorTokenType,
				options: options && JSON.stringify(options)
			};
			Object.keys(values).forEach((key) => {
				if (typeof values[key] === "undefined") delete values[key];
			});
			const headers = { "Content-Type": "application/x-www-form-urlencoded" };
			Object.assign(headers, additionalHeaders || {});
			const opts = {
				...StsCredentials.RETRY_CONFIG,
				url: this.tokenExchangeEndpoint.toString(),
				method: "POST",
				headers,
				data: querystring.stringify(values),
				responseType: "json"
			};
			this.applyClientAuthenticationOptions(opts);
			try {
				const response = await this.transporter.request(opts);
				const stsSuccessfulResponse = response.data;
				stsSuccessfulResponse.res = response;
				return stsSuccessfulResponse;
			} catch (error$1) {
				if (error$1 instanceof gaxios_1$1.GaxiosError && error$1.response) throw (0, oauth2common_1$1.getErrorFromOAuthErrorResponse)(
					error$1.response.data,
					// Preserve other fields from the original error.
					error$1
);
				throw error$1;
			}
		}
	};
	exports.StsCredentials = StsCredentials;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/baseexternalclient.js
var require_baseexternalclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/baseexternalclient.js"(exports) {
	var __classPrivateFieldGet$3 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
		return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var __classPrivateFieldSet$1 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
		if (kind === "m") throw new TypeError("Private method is not writable");
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
		return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
	};
	var _BaseExternalAccountClient_instances, _BaseExternalAccountClient_pendingAccessToken, _BaseExternalAccountClient_internalRefreshAccessTokenAsync;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.BaseExternalAccountClient = exports.DEFAULT_UNIVERSE = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;
	const stream$2 = require("stream");
	const authclient_1$5 = require_authclient();
	const sts$1 = require_stscredentials();
	const util_1$4 = require_util();
	/**
	* The required token exchange grant_type: rfc8693#section-2.1
	*/
	const STS_GRANT_TYPE$1 = "urn:ietf:params:oauth:grant-type:token-exchange";
	/**
	* The requested token exchange requested_token_type: rfc8693#section-2.1
	*/
	const STS_REQUEST_TOKEN_TYPE$1 = "urn:ietf:params:oauth:token-type:access_token";
	/** The default OAuth scope to request when none is provided. */
	const DEFAULT_OAUTH_SCOPE = "https://www.googleapis.com/auth/cloud-platform";
	/** Default impersonated token lifespan in seconds.*/
	const DEFAULT_TOKEN_LIFESPAN = 3600;
	/**
	* Offset to take into account network delays and server clock skews.
	*/
	exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
	/**
	* The credentials JSON file type for external account clients.
	* There are 3 types of JSON configs:
	* 1. authorized_user => Google end user credential
	* 2. service_account => Google service account credential
	* 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)
	*/
	exports.EXTERNAL_ACCOUNT_TYPE = "external_account";
	/**
	* Cloud resource manager URL used to retrieve project information.
	*
	* @deprecated use {@link BaseExternalAccountClient.cloudResourceManagerURL} instead
	**/
	exports.CLOUD_RESOURCE_MANAGER = "https://cloudresourcemanager.googleapis.com/v1/projects/";
	/** The workforce audience pattern. */
	const WORKFORCE_AUDIENCE_PATTERN = "//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+";
	const DEFAULT_TOKEN_URL$1 = "https://sts.{universeDomain}/v1/token";
	const pkg = require_package$1();
	/**
	* For backwards compatibility.
	*/
	var authclient_2 = require_authclient();
	Object.defineProperty(exports, "DEFAULT_UNIVERSE", {
		enumerable: true,
		get: function() {
			return authclient_2.DEFAULT_UNIVERSE;
		}
	});
	/**
	* Base external account client. This is used to instantiate AuthClients for
	* exchanging external account credentials for GCP access token and authorizing
	* requests to GCP APIs.
	* The base class implements common logic for exchanging various type of
	* external credentials for GCP access token. The logic of determining and
	* retrieving the external credential based on the environment and
	* credential_source will be left for the subclasses.
	*/
	var BaseExternalAccountClient = class BaseExternalAccountClient extends authclient_1$5.AuthClient {
		/**
		* Instantiate a BaseExternalAccountClient instance using the provided JSON
		* object loaded from an external account credentials file.
		* @param options The external account options object typically loaded
		*   from the external account JSON credential file. The camelCased options
		*   are aliases for the snake_cased options.
		* @param additionalOptions **DEPRECATED, all options are available in the
		*   `options` parameter.** Optional additional behavior customization options.
		*   These currently customize expiration threshold time and whether to retry
		*   on 401/403 API request errors.
		*/
		constructor(options, additionalOptions) {
			var _a$5;
			super({
				...options,
				...additionalOptions
			});
			_BaseExternalAccountClient_instances.add(this);
			/**
			* A pending access token request. Used for concurrent calls.
			*/
			_BaseExternalAccountClient_pendingAccessToken.set(this, null);
			const opts = (0, util_1$4.originalOrCamelOptions)(options);
			const type = opts.get("type");
			if (type && type !== exports.EXTERNAL_ACCOUNT_TYPE) throw new Error(`Expected "${exports.EXTERNAL_ACCOUNT_TYPE}" type but received "${options.type}"`);
			const clientId = opts.get("client_id");
			const clientSecret = opts.get("client_secret");
			const tokenUrl = (_a$5 = opts.get("token_url")) !== null && _a$5 !== void 0 ? _a$5 : DEFAULT_TOKEN_URL$1.replace("{universeDomain}", this.universeDomain);
			const subjectTokenType = opts.get("subject_token_type");
			const workforcePoolUserProject = opts.get("workforce_pool_user_project");
			const serviceAccountImpersonationUrl = opts.get("service_account_impersonation_url");
			const serviceAccountImpersonation = opts.get("service_account_impersonation");
			const serviceAccountImpersonationLifetime = (0, util_1$4.originalOrCamelOptions)(serviceAccountImpersonation).get("token_lifetime_seconds");
			this.cloudResourceManagerURL = new URL(opts.get("cloud_resource_manager_url") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);
			if (clientId) this.clientAuth = {
				confidentialClientType: "basic",
				clientId,
				clientSecret
			};
			this.stsCredential = new sts$1.StsCredentials(tokenUrl, this.clientAuth);
			this.scopes = opts.get("scopes") || [DEFAULT_OAUTH_SCOPE];
			this.cachedAccessToken = null;
			this.audience = opts.get("audience");
			this.subjectTokenType = subjectTokenType;
			this.workforcePoolUserProject = workforcePoolUserProject;
			const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);
			if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) throw new Error("workforcePoolUserProject should not be set for non-workforce pool credentials.");
			this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;
			this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;
			if (this.serviceAccountImpersonationLifetime) this.configLifetimeRequested = true;
			else {
				this.configLifetimeRequested = false;
				this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;
			}
			this.projectNumber = this.getProjectNumber(this.audience);
			this.supplierContext = {
				audience: this.audience,
				subjectTokenType: this.subjectTokenType,
				transporter: this.transporter
			};
		}
		/** The service account email to be impersonated, if available. */
		getServiceAccountEmail() {
			var _a$5;
			if (this.serviceAccountImpersonationUrl) {
				if (this.serviceAccountImpersonationUrl.length > 256)
 /**
				* Prevents DOS attacks.
				* @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/84}
				**/
				throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);
				const re = /serviceAccounts\/(?<email>[^:]+):generateAccessToken$/;
				const result = re.exec(this.serviceAccountImpersonationUrl);
				return ((_a$5 = result === null || result === void 0 ? void 0 : result.groups) === null || _a$5 === void 0 ? void 0 : _a$5.email) || null;
			}
			return null;
		}
		/**
		* Provides a mechanism to inject GCP access tokens directly.
		* When the provided credential expires, a new credential, using the
		* external account options, is retrieved.
		* @param credentials The Credentials object to set on the current client.
		*/
		setCredentials(credentials) {
			super.setCredentials(credentials);
			this.cachedAccessToken = credentials;
		}
		/**
		* @return A promise that resolves with the current GCP access token
		*   response. If the current credential is expired, a new one is retrieved.
		*/
		async getAccessToken() {
			if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) await this.refreshAccessTokenAsync();
			return {
				token: this.cachedAccessToken.access_token,
				res: this.cachedAccessToken.res
			};
		}
		/**
		* The main authentication interface. It takes an optional url which when
		* present is the endpoint being accessed, and returns a Promise which
		* resolves with authorization header fields.
		*
		* The result has the form:
		* { Authorization: 'Bearer <access_token_value>' }
		*/
		async getRequestHeaders() {
			const accessTokenResponse = await this.getAccessToken();
			const headers = { Authorization: `Bearer ${accessTokenResponse.token}` };
			return this.addSharedMetadataHeaders(headers);
		}
		request(opts, callback) {
			if (callback) this.requestAsync(opts).then((r) => callback(null, r), (e) => {
				return callback(e, e.response);
			});
			else return this.requestAsync(opts);
		}
		/**
		* @return A promise that resolves with the project ID corresponding to the
		*   current workload identity pool or current workforce pool if
		*   determinable. For workforce pool credential, it returns the project ID
		*   corresponding to the workforcePoolUserProject.
		*   This is introduced to match the current pattern of using the Auth
		*   library:
		*   const projectId = await auth.getProjectId();
		*   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;
		*   const res = await client.request({ url });
		*   The resource may not have permission
		*   (resourcemanager.projects.get) to call this API or the required
		*   scopes may not be selected:
		*   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes
		*/
		async getProjectId() {
			const projectNumber = this.projectNumber || this.workforcePoolUserProject;
			if (this.projectId) return this.projectId;
			else if (projectNumber) {
				const headers = await this.getRequestHeaders();
				const response = await this.transporter.request({
					...BaseExternalAccountClient.RETRY_CONFIG,
					headers,
					url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`,
					responseType: "json"
				});
				this.projectId = response.data.projectId;
				return this.projectId;
			}
			return null;
		}
		/**
		* Authenticates the provided HTTP request, processes it and resolves with the
		* returned response.
		* @param opts The HTTP request options.
		* @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
		* @return A promise that resolves with the successful response.
		*/
		async requestAsync(opts, reAuthRetried = false) {
			let response;
			try {
				const requestHeaders = await this.getRequestHeaders();
				opts.headers = opts.headers || {};
				if (requestHeaders && requestHeaders["x-goog-user-project"]) opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
				if (requestHeaders && requestHeaders.Authorization) opts.headers.Authorization = requestHeaders.Authorization;
				response = await this.transporter.request(opts);
			} catch (e) {
				const res = e.response;
				if (res) {
					const statusCode = res.status;
					const isReadableStream = res.config.data instanceof stream$2.Readable;
					const isAuthErr = statusCode === 401 || statusCode === 403;
					if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
						await this.refreshAccessTokenAsync();
						return await this.requestAsync(opts, true);
					}
				}
				throw e;
			}
			return response;
		}
		/**
		* Forces token refresh, even if unexpired tokens are currently cached.
		* External credentials are exchanged for GCP access tokens via the token
		* exchange endpoint and other settings provided in the client options
		* object.
		* If the service_account_impersonation_url is provided, an additional
		* step to exchange the external account GCP access token for a service
		* account impersonated token is performed.
		* @return A promise that resolves with the fresh GCP access tokens.
		*/
		async refreshAccessTokenAsync() {
			__classPrivateFieldSet$1(this, _BaseExternalAccountClient_pendingAccessToken, __classPrivateFieldGet$3(this, _BaseExternalAccountClient_pendingAccessToken, "f") || __classPrivateFieldGet$3(this, _BaseExternalAccountClient_instances, "m", _BaseExternalAccountClient_internalRefreshAccessTokenAsync).call(this), "f");
			try {
				return await __classPrivateFieldGet$3(this, _BaseExternalAccountClient_pendingAccessToken, "f");
			} finally {
				__classPrivateFieldSet$1(this, _BaseExternalAccountClient_pendingAccessToken, null, "f");
			}
		}
		/**
		* Returns the workload identity pool project number if it is determinable
		* from the audience resource name.
		* @param audience The STS audience used to determine the project number.
		* @return The project number associated with the workload identity pool, if
		*   this can be determined from the STS audience field. Otherwise, null is
		*   returned.
		*/
		getProjectNumber(audience) {
			const match = audience.match(/\/projects\/([^/]+)/);
			if (!match) return null;
			return match[1];
		}
		/**
		* Exchanges an external account GCP access token for a service
		* account impersonated access token using iamcredentials
		* GenerateAccessToken API.
		* @param token The access token to exchange for a service account access
		*   token.
		* @return A promise that resolves with the service account impersonated
		*   credentials response.
		*/
		async getImpersonatedAccessToken(token) {
			const opts = {
				...BaseExternalAccountClient.RETRY_CONFIG,
				url: this.serviceAccountImpersonationUrl,
				method: "POST",
				headers: {
					"Content-Type": "application/json",
					Authorization: `Bearer ${token}`
				},
				data: {
					scope: this.getScopesArray(),
					lifetime: this.serviceAccountImpersonationLifetime + "s"
				},
				responseType: "json"
			};
			const response = await this.transporter.request(opts);
			const successResponse = response.data;
			return {
				access_token: successResponse.accessToken,
				expiry_date: new Date(successResponse.expireTime).getTime(),
				res: response
			};
		}
		/**
		* Returns whether the provided credentials are expired or not.
		* If there is no expiry time, assumes the token is not expired or expiring.
		* @param accessToken The credentials to check for expiration.
		* @return Whether the credentials are expired or not.
		*/
		isExpired(accessToken) {
			const now = new Date().getTime();
			return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
		}
		/**
		* @return The list of scopes for the requested GCP access token.
		*/
		getScopesArray() {
			if (typeof this.scopes === "string") return [this.scopes];
			return this.scopes || [DEFAULT_OAUTH_SCOPE];
		}
		getMetricsHeaderValue() {
			const nodeVersion = process.version.replace(/^v/, "");
			const saImpersonation = this.serviceAccountImpersonationUrl !== void 0;
			const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : "unknown";
			return `gl-node/${nodeVersion} auth/${pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;
		}
	};
	exports.BaseExternalAccountClient = BaseExternalAccountClient;
	_BaseExternalAccountClient_pendingAccessToken = new WeakMap(), _BaseExternalAccountClient_instances = new WeakSet(), _BaseExternalAccountClient_internalRefreshAccessTokenAsync = async function _BaseExternalAccountClient_internalRefreshAccessTokenAsync$1() {
		const subjectToken = await this.retrieveSubjectToken();
		const stsCredentialsOptions = {
			grantType: STS_GRANT_TYPE$1,
			audience: this.audience,
			requestedTokenType: STS_REQUEST_TOKEN_TYPE$1,
			subjectToken,
			subjectTokenType: this.subjectTokenType,
			scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()
		};
		const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? { userProject: this.workforcePoolUserProject } : void 0;
		const additionalHeaders = { "x-goog-api-client": this.getMetricsHeaderValue() };
		const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);
		if (this.serviceAccountImpersonationUrl) this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);
		else if (stsResponse.expires_in) this.cachedAccessToken = {
			access_token: stsResponse.access_token,
			expiry_date: new Date().getTime() + stsResponse.expires_in * 1e3,
			res: stsResponse.res
		};
		else this.cachedAccessToken = {
			access_token: stsResponse.access_token,
			res: stsResponse.res
		};
		this.credentials = {};
		Object.assign(this.credentials, this.cachedAccessToken);
		delete this.credentials.res;
		this.emit("tokens", {
			refresh_token: null,
			expiry_date: this.cachedAccessToken.expiry_date,
			access_token: this.cachedAccessToken.access_token,
			token_type: "Bearer",
			id_token: null
		});
		return this.cachedAccessToken;
	};
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js
var require_filesubjecttokensupplier = __commonJS({ "node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js"(exports) {
	var _a$1, _b, _c;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FileSubjectTokenSupplier = void 0;
	const util_1$3 = require("util");
	const fs$5 = require("fs");
	const readFile = (0, util_1$3.promisify)((_a$1 = fs$5.readFile) !== null && _a$1 !== void 0 ? _a$1 : () => {});
	const realpath = (0, util_1$3.promisify)((_b = fs$5.realpath) !== null && _b !== void 0 ? _b : () => {});
	const lstat = (0, util_1$3.promisify)((_c = fs$5.lstat) !== null && _c !== void 0 ? _c : () => {});
	/**
	* Internal subject token supplier implementation used when a file location
	* is configured in the credential configuration used to build an {@link IdentityPoolClient}
	*/
	var FileSubjectTokenSupplier = class {
		/**
		* Instantiates a new file based subject token supplier.
		* @param opts The file subject token supplier options to build the supplier
		*   with.
		*/
		constructor(opts) {
			this.filePath = opts.filePath;
			this.formatType = opts.formatType;
			this.subjectTokenFieldName = opts.subjectTokenFieldName;
		}
		/**
		* Returns the subject token stored at the file specified in the constructor.
		* @param context {@link ExternalAccountSupplierContext} from the calling
		*   {@link IdentityPoolClient}, contains the requested audience and subject
		*   token type for the external account identity. Not used.
		*/
		async getSubjectToken(context) {
			let parsedFilePath = this.filePath;
			try {
				parsedFilePath = await realpath(parsedFilePath);
				if (!(await lstat(parsedFilePath)).isFile()) throw new Error();
			} catch (err) {
				if (err instanceof Error) err.message = `The file at ${parsedFilePath} does not exist, or it is not a file. ${err.message}`;
				throw err;
			}
			let subjectToken;
			const rawText = await readFile(parsedFilePath, { encoding: "utf8" });
			if (this.formatType === "text") subjectToken = rawText;
			else if (this.formatType === "json" && this.subjectTokenFieldName) {
				const json$1 = JSON.parse(rawText);
				subjectToken = json$1[this.subjectTokenFieldName];
			}
			if (!subjectToken) throw new Error("Unable to parse the subject_token from the credential_source file");
			return subjectToken;
		}
	};
	exports.FileSubjectTokenSupplier = FileSubjectTokenSupplier;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js
var require_urlsubjecttokensupplier = __commonJS({ "node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.UrlSubjectTokenSupplier = void 0;
	/**
	* Internal subject token supplier implementation used when a URL
	* is configured in the credential configuration used to build an {@link IdentityPoolClient}
	*/
	var UrlSubjectTokenSupplier = class {
		/**
		* Instantiates a URL subject token supplier.
		* @param opts The URL subject token supplier options to build the supplier with.
		*/
		constructor(opts) {
			this.url = opts.url;
			this.formatType = opts.formatType;
			this.subjectTokenFieldName = opts.subjectTokenFieldName;
			this.headers = opts.headers;
			this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
		}
		/**
		* Sends a GET request to the URL provided in the constructor and resolves
		* with the returned external subject token.
		* @param context {@link ExternalAccountSupplierContext} from the calling
		*   {@link IdentityPoolClient}, contains the requested audience and subject
		*   token type for the external account identity. Not used.
		*/
		async getSubjectToken(context) {
			const opts = {
				...this.additionalGaxiosOptions,
				url: this.url,
				method: "GET",
				headers: this.headers,
				responseType: this.formatType
			};
			let subjectToken;
			if (this.formatType === "text") {
				const response = await context.transporter.request(opts);
				subjectToken = response.data;
			} else if (this.formatType === "json" && this.subjectTokenFieldName) {
				const response = await context.transporter.request(opts);
				subjectToken = response.data[this.subjectTokenFieldName];
			}
			if (!subjectToken) throw new Error("Unable to parse the subject_token from the credential_source URL");
			return subjectToken;
		}
	};
	exports.UrlSubjectTokenSupplier = UrlSubjectTokenSupplier;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/identitypoolclient.js
var require_identitypoolclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/identitypoolclient.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IdentityPoolClient = void 0;
	const baseexternalclient_1$6 = require_baseexternalclient();
	const util_1$2 = require_util();
	const filesubjecttokensupplier_1 = require_filesubjecttokensupplier();
	const urlsubjecttokensupplier_1 = require_urlsubjecttokensupplier();
	/**
	* Defines the Url-sourced and file-sourced external account clients mainly
	* used for K8s and Azure workloads.
	*/
	var IdentityPoolClient = class IdentityPoolClient extends baseexternalclient_1$6.BaseExternalAccountClient {
		/**
		* Instantiate an IdentityPoolClient instance using the provided JSON
		* object loaded from an external account credentials file.
		* An error is thrown if the credential is not a valid file-sourced or
		* url-sourced credential or a workforce pool user project is provided
		* with a non workforce audience.
		* @param options The external account options object typically loaded
		*   from the external account JSON credential file. The camelCased options
		*   are aliases for the snake_cased options.
		* @param additionalOptions **DEPRECATED, all options are available in the
		*   `options` parameter.** Optional additional behavior customization options.
		*   These currently customize expiration threshold time and whether to retry
		*   on 401/403 API request errors.
		*/
		constructor(options, additionalOptions) {
			super(options, additionalOptions);
			const opts = (0, util_1$2.originalOrCamelOptions)(options);
			const credentialSource = opts.get("credential_source");
			const subjectTokenSupplier = opts.get("subject_token_supplier");
			if (!credentialSource && !subjectTokenSupplier) throw new Error("A credential source or subject token supplier must be specified.");
			if (credentialSource && subjectTokenSupplier) throw new Error("Only one of credential source or subject token supplier can be specified.");
			if (subjectTokenSupplier) {
				this.subjectTokenSupplier = subjectTokenSupplier;
				this.credentialSourceType = "programmatic";
			} else {
				const credentialSourceOpts = (0, util_1$2.originalOrCamelOptions)(credentialSource);
				const formatOpts = (0, util_1$2.originalOrCamelOptions)(credentialSourceOpts.get("format"));
				const formatType = formatOpts.get("type") || "text";
				const formatSubjectTokenFieldName = formatOpts.get("subject_token_field_name");
				if (formatType !== "json" && formatType !== "text") throw new Error(`Invalid credential_source format "${formatType}"`);
				if (formatType === "json" && !formatSubjectTokenFieldName) throw new Error("Missing subject_token_field_name for JSON credential_source format");
				const file = credentialSourceOpts.get("file");
				const url = credentialSourceOpts.get("url");
				const headers = credentialSourceOpts.get("headers");
				if (file && url) throw new Error("No valid Identity Pool \"credential_source\" provided, must be either file or url.");
				else if (file && !url) {
					this.credentialSourceType = "file";
					this.subjectTokenSupplier = new filesubjecttokensupplier_1.FileSubjectTokenSupplier({
						filePath: file,
						formatType,
						subjectTokenFieldName: formatSubjectTokenFieldName
					});
				} else if (!file && url) {
					this.credentialSourceType = "url";
					this.subjectTokenSupplier = new urlsubjecttokensupplier_1.UrlSubjectTokenSupplier({
						url,
						formatType,
						subjectTokenFieldName: formatSubjectTokenFieldName,
						headers,
						additionalGaxiosOptions: IdentityPoolClient.RETRY_CONFIG
					});
				} else throw new Error("No valid Identity Pool \"credential_source\" provided, must be either file or url.");
			}
		}
		/**
		* Triggered when a external subject token is needed to be exchanged for a GCP
		* access token via GCP STS endpoint. Gets a subject token by calling
		* the configured {@link SubjectTokenSupplier}
		* @return A promise that resolves with the external subject token.
		*/
		async retrieveSubjectToken() {
			return this.subjectTokenSupplier.getSubjectToken(this.supplierContext);
		}
	};
	exports.IdentityPoolClient = IdentityPoolClient;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/awsrequestsigner.js
var require_awsrequestsigner = __commonJS({ "node_modules/google-auth-library/build/src/auth/awsrequestsigner.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AwsRequestSigner = void 0;
	const crypto_1$1 = require_crypto();
	/** AWS Signature Version 4 signing algorithm identifier.  */
	const AWS_ALGORITHM = "AWS4-HMAC-SHA256";
	/**
	* The termination string for the AWS credential scope value as defined in
	* https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html
	*/
	const AWS_REQUEST_TYPE = "aws4_request";
	/**
	* Implements an AWS API request signer based on the AWS Signature Version 4
	* signing process.
	* https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html
	*/
	var AwsRequestSigner = class {
		/**
		* Instantiates an AWS API request signer used to send authenticated signed
		* requests to AWS APIs based on the AWS Signature Version 4 signing process.
		* This also provides a mechanism to generate the signed request without
		* sending it.
		* @param getCredentials A mechanism to retrieve AWS security credentials
		*   when needed.
		* @param region The AWS region to use.
		*/
		constructor(getCredentials, region) {
			this.getCredentials = getCredentials;
			this.region = region;
			this.crypto = (0, crypto_1$1.createCrypto)();
		}
		/**
		* Generates the signed request for the provided HTTP request for calling
		* an AWS API. This follows the steps described at:
		* https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
		* @param amzOptions The AWS request options that need to be signed.
		* @return A promise that resolves with the GaxiosOptions containing the
		*   signed HTTP request parameters.
		*/
		async getRequestOptions(amzOptions) {
			if (!amzOptions.url) throw new Error("\"url\" is required in \"amzOptions\"");
			const requestPayloadData = typeof amzOptions.data === "object" ? JSON.stringify(amzOptions.data) : amzOptions.data;
			const url = amzOptions.url;
			const method = amzOptions.method || "GET";
			const requestPayload = amzOptions.body || requestPayloadData;
			const additionalAmzHeaders = amzOptions.headers;
			const awsSecurityCredentials = await this.getCredentials();
			const uri = new URL(url);
			const headerMap = await generateAuthenticationHeaderMap({
				crypto: this.crypto,
				host: uri.host,
				canonicalUri: uri.pathname,
				canonicalQuerystring: uri.search.substr(1),
				method,
				region: this.region,
				securityCredentials: awsSecurityCredentials,
				requestPayload,
				additionalAmzHeaders
			});
			const headers = Object.assign(
				// Add x-amz-date if available.
				headerMap.amzDate ? { "x-amz-date": headerMap.amzDate } : {},
				{
					Authorization: headerMap.authorizationHeader,
					host: uri.host
				},
				additionalAmzHeaders || {}
);
			if (awsSecurityCredentials.token) Object.assign(headers, { "x-amz-security-token": awsSecurityCredentials.token });
			const awsSignedReq = {
				url,
				method,
				headers
			};
			if (typeof requestPayload !== "undefined") awsSignedReq.body = requestPayload;
			return awsSignedReq;
		}
	};
	exports.AwsRequestSigner = AwsRequestSigner;
	/**
	* Creates the HMAC-SHA256 hash of the provided message using the
	* provided key.
	*
	* @param crypto The crypto instance used to facilitate cryptographic
	*   operations.
	* @param key The HMAC-SHA256 key to use.
	* @param msg The message to hash.
	* @return The computed hash bytes.
	*/
	async function sign(crypto$8, key, msg) {
		return await crypto$8.signWithHmacSha256(key, msg);
	}
	/**
	* Calculates the signing key used to calculate the signature for
	* AWS Signature Version 4 based on:
	* https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html
	*
	* @param crypto The crypto instance used to facilitate cryptographic
	*   operations.
	* @param key The AWS secret access key.
	* @param dateStamp The '%Y%m%d' date format.
	* @param region The AWS region.
	* @param serviceName The AWS service name, eg. sts.
	* @return The signing key bytes.
	*/
	async function getSigningKey(crypto$8, key, dateStamp, region, serviceName) {
		const kDate = await sign(crypto$8, `AWS4${key}`, dateStamp);
		const kRegion = await sign(crypto$8, kDate, region);
		const kService = await sign(crypto$8, kRegion, serviceName);
		const kSigning = await sign(crypto$8, kService, "aws4_request");
		return kSigning;
	}
	/**
	* Generates the authentication header map needed for generating the AWS
	* Signature Version 4 signed request.
	*
	* @param option The options needed to compute the authentication header map.
	* @return The AWS authentication header map which constitutes of the following
	*   components: amz-date, authorization header and canonical query string.
	*/
	async function generateAuthenticationHeaderMap(options) {
		const additionalAmzHeaders = options.additionalAmzHeaders || {};
		const requestPayload = options.requestPayload || "";
		const serviceName = options.host.split(".")[0];
		const now = new Date();
		const amzDate = now.toISOString().replace(/[-:]/g, "").replace(/\.[0-9]+/, "");
		const dateStamp = now.toISOString().replace(/[-]/g, "").replace(/T.*/, "");
		const reformattedAdditionalAmzHeaders = {};
		Object.keys(additionalAmzHeaders).forEach((key) => {
			reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];
		});
		if (options.securityCredentials.token) reformattedAdditionalAmzHeaders["x-amz-security-token"] = options.securityCredentials.token;
		const amzHeaders = Object.assign(
			{ host: options.host },
			// Previously the date was not fixed with x-amz- and could be provided manually.
			// https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req
			reformattedAdditionalAmzHeaders.date ? {} : { "x-amz-date": amzDate },
			reformattedAdditionalAmzHeaders
);
		let canonicalHeaders = "";
		const signedHeadersList = Object.keys(amzHeaders).sort();
		signedHeadersList.forEach((key) => {
			canonicalHeaders += `${key}:${amzHeaders[key]}\n`;
		});
		const signedHeaders = signedHeadersList.join(";");
		const payloadHash = await options.crypto.sha256DigestHex(requestPayload);
		const canonicalRequest = `${options.method}\n${options.canonicalUri}\n${options.canonicalQuerystring}\n${canonicalHeaders}\n${signedHeaders}\n${payloadHash}`;
		const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;
		const stringToSign = `${AWS_ALGORITHM}\n${amzDate}\n${credentialScope}\n` + await options.crypto.sha256DigestHex(canonicalRequest);
		const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);
		const signature = await sign(options.crypto, signingKey, stringToSign);
		const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${(0, crypto_1$1.fromArrayBufferToHex)(signature)}`;
		return {
			amzDate: reformattedAdditionalAmzHeaders.date ? void 0 : amzDate,
			authorizationHeader,
			canonicalQuerystring: options.canonicalQuerystring
		};
	}
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js
var require_defaultawssecuritycredentialssupplier = __commonJS({ "node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js"(exports) {
	var __classPrivateFieldGet$2 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
		return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var _DefaultAwsSecurityCredentialsSupplier_instances, _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken, _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName, _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials, _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get, _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DefaultAwsSecurityCredentialsSupplier = void 0;
	/**
	* Internal AWS security credentials supplier implementation used by {@link AwsClient}
	* when a credential source is provided instead of a user defined supplier.
	* The logic is summarized as:
	* 1. If imdsv2_session_token_url is provided in the credential source, then
	*    fetch the aws session token and include it in the headers of the
	*    metadata requests. This is a requirement for IDMSv2 but optional
	*    for IDMSv1.
	* 2. Retrieve AWS region from availability-zone.
	* 3a. Check AWS credentials in environment variables. If not found, get
	*     from security-credentials endpoint.
	* 3b. Get AWS credentials from security-credentials endpoint. In order
	*     to retrieve this, the AWS role needs to be determined by calling
	*     security-credentials endpoint without any argument. Then the
	*     credentials can be retrieved via: security-credentials/role_name
	* 4. Generate the signed request to AWS STS GetCallerIdentity action.
	* 5. Inject x-goog-cloud-target-resource into header and serialize the
	*    signed request. This will be the subject-token to pass to GCP STS.
	*/
	var DefaultAwsSecurityCredentialsSupplier = class {
		/**
		* Instantiates a new DefaultAwsSecurityCredentialsSupplier using information
		* from the credential_source stored in the ADC file.
		* @param opts The default aws security credentials supplier options object to
		*   build the supplier with.
		*/
		constructor(opts) {
			_DefaultAwsSecurityCredentialsSupplier_instances.add(this);
			this.regionUrl = opts.regionUrl;
			this.securityCredentialsUrl = opts.securityCredentialsUrl;
			this.imdsV2SessionTokenUrl = opts.imdsV2SessionTokenUrl;
			this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
		}
		/**
		* Returns the active AWS region. This first checks to see if the region
		* is available as an environment variable. If it is not, then the supplier
		* will call the region URL.
		* @param context {@link ExternalAccountSupplierContext} from the calling
		*   {@link AwsClient}, contains the requested audience and subject token type
		*   for the external account identity.
		* @return A promise that resolves with the AWS region string.
		*/
		async getAwsRegion(context) {
			if (__classPrivateFieldGet$2(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get)) return __classPrivateFieldGet$2(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get);
			const metadataHeaders = {};
			if (!__classPrivateFieldGet$2(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get) && this.imdsV2SessionTokenUrl) metadataHeaders["x-aws-ec2-metadata-token"] = await __classPrivateFieldGet$2(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context.transporter);
			if (!this.regionUrl) throw new Error("Unable to determine AWS region due to missing \"options.credential_source.region_url\"");
			const opts = {
				...this.additionalGaxiosOptions,
				url: this.regionUrl,
				method: "GET",
				responseType: "text",
				headers: metadataHeaders
			};
			const response = await context.transporter.request(opts);
			return response.data.substr(0, response.data.length - 1);
		}
		/**
		* Returns AWS security credentials. This first checks to see if the credentials
		* is available as environment variables. If it is not, then the supplier
		* will call the security credentials URL.
		* @param context {@link ExternalAccountSupplierContext} from the calling
		*   {@link AwsClient}, contains the requested audience and subject token type
		*   for the external account identity.
		* @return A promise that resolves with the AWS security credentials.
		*/
		async getAwsSecurityCredentials(context) {
			if (__classPrivateFieldGet$2(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get)) return __classPrivateFieldGet$2(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get);
			const metadataHeaders = {};
			if (this.imdsV2SessionTokenUrl) metadataHeaders["x-aws-ec2-metadata-token"] = await __classPrivateFieldGet$2(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context.transporter);
			const roleName = await __classPrivateFieldGet$2(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName).call(this, metadataHeaders, context.transporter);
			const awsCreds = await __classPrivateFieldGet$2(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials).call(this, roleName, metadataHeaders, context.transporter);
			return {
				accessKeyId: awsCreds.AccessKeyId,
				secretAccessKey: awsCreds.SecretAccessKey,
				token: awsCreds.Token
			};
		}
	};
	exports.DefaultAwsSecurityCredentialsSupplier = DefaultAwsSecurityCredentialsSupplier;
	_DefaultAwsSecurityCredentialsSupplier_instances = new WeakSet(), _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken = async function _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken$1(transporter) {
		const opts = {
			...this.additionalGaxiosOptions,
			url: this.imdsV2SessionTokenUrl,
			method: "PUT",
			responseType: "text",
			headers: { "x-aws-ec2-metadata-token-ttl-seconds": "300" }
		};
		const response = await transporter.request(opts);
		return response.data;
	}, _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName = async function _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName$1(headers, transporter) {
		if (!this.securityCredentialsUrl) throw new Error("Unable to determine AWS role name due to missing \"options.credential_source.url\"");
		const opts = {
			...this.additionalGaxiosOptions,
			url: this.securityCredentialsUrl,
			method: "GET",
			responseType: "text",
			headers
		};
		const response = await transporter.request(opts);
		return response.data;
	}, _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials = async function _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials$1(roleName, headers, transporter) {
		const response = await transporter.request({
			...this.additionalGaxiosOptions,
			url: `${this.securityCredentialsUrl}/${roleName}`,
			responseType: "json",
			headers
		});
		return response.data;
	}, _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get = function _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get$1() {
		return process.env["AWS_REGION"] || process.env["AWS_DEFAULT_REGION"] || null;
	}, _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get = function _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get$1() {
		if (process.env["AWS_ACCESS_KEY_ID"] && process.env["AWS_SECRET_ACCESS_KEY"]) return {
			accessKeyId: process.env["AWS_ACCESS_KEY_ID"],
			secretAccessKey: process.env["AWS_SECRET_ACCESS_KEY"],
			token: process.env["AWS_SESSION_TOKEN"]
		};
		return null;
	};
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/awsclient.js
var require_awsclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/awsclient.js"(exports) {
	var __classPrivateFieldGet$1 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
		return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var _a, _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.AwsClient = void 0;
	const awsrequestsigner_1$1 = require_awsrequestsigner();
	const baseexternalclient_1$5 = require_baseexternalclient();
	const defaultawssecuritycredentialssupplier_1 = require_defaultawssecuritycredentialssupplier();
	const util_1$1 = require_util();
	/**
	* AWS external account client. This is used for AWS workloads, where
	* AWS STS GetCallerIdentity serialized signed requests are exchanged for
	* GCP access token.
	*/
	var AwsClient = class extends baseexternalclient_1$5.BaseExternalAccountClient {
		/**
		* Instantiates an AwsClient instance using the provided JSON
		* object loaded from an external account credentials file.
		* An error is thrown if the credential is not a valid AWS credential.
		* @param options The external account options object typically loaded
		*   from the external account JSON credential file.
		* @param additionalOptions **DEPRECATED, all options are available in the
		*   `options` parameter.** Optional additional behavior customization options.
		*   These currently customize expiration threshold time and whether to retry
		*   on 401/403 API request errors.
		*/
		constructor(options, additionalOptions) {
			super(options, additionalOptions);
			const opts = (0, util_1$1.originalOrCamelOptions)(options);
			const credentialSource = opts.get("credential_source");
			const awsSecurityCredentialsSupplier = opts.get("aws_security_credentials_supplier");
			if (!credentialSource && !awsSecurityCredentialsSupplier) throw new Error("A credential source or AWS security credentials supplier must be specified.");
			if (credentialSource && awsSecurityCredentialsSupplier) throw new Error("Only one of credential source or AWS security credentials supplier can be specified.");
			if (awsSecurityCredentialsSupplier) {
				this.awsSecurityCredentialsSupplier = awsSecurityCredentialsSupplier;
				this.regionalCredVerificationUrl = __classPrivateFieldGet$1(_a, _a, "f", _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL);
				this.credentialSourceType = "programmatic";
			} else {
				const credentialSourceOpts = (0, util_1$1.originalOrCamelOptions)(credentialSource);
				this.environmentId = credentialSourceOpts.get("environment_id");
				const regionUrl = credentialSourceOpts.get("region_url");
				const securityCredentialsUrl = credentialSourceOpts.get("url");
				const imdsV2SessionTokenUrl = credentialSourceOpts.get("imdsv2_session_token_url");
				this.awsSecurityCredentialsSupplier = new defaultawssecuritycredentialssupplier_1.DefaultAwsSecurityCredentialsSupplier({
					regionUrl,
					securityCredentialsUrl,
					imdsV2SessionTokenUrl
				});
				this.regionalCredVerificationUrl = credentialSourceOpts.get("regional_cred_verification_url");
				this.credentialSourceType = "aws";
				this.validateEnvironmentId();
			}
			this.awsRequestSigner = null;
			this.region = "";
		}
		validateEnvironmentId() {
			var _b$1;
			const match = (_b$1 = this.environmentId) === null || _b$1 === void 0 ? void 0 : _b$1.match(/^(aws)(\d+)$/);
			if (!match || !this.regionalCredVerificationUrl) throw new Error("No valid AWS \"credential_source\" provided");
			else if (parseInt(match[2], 10) !== 1) throw new Error(`aws version "${match[2]}" is not supported in the current build.`);
		}
		/**
		* Triggered when an external subject token is needed to be exchanged for a
		* GCP access token via GCP STS endpoint. This will call the
		* {@link AwsSecurityCredentialsSupplier} to retrieve an AWS region and AWS
		* Security Credentials, then use them to create a signed AWS STS request that
		* can be exchanged for a GCP access token.
		* @return A promise that resolves with the external subject token.
		*/
		async retrieveSubjectToken() {
			if (!this.awsRequestSigner) {
				this.region = await this.awsSecurityCredentialsSupplier.getAwsRegion(this.supplierContext);
				this.awsRequestSigner = new awsrequestsigner_1$1.AwsRequestSigner(async () => {
					return this.awsSecurityCredentialsSupplier.getAwsSecurityCredentials(this.supplierContext);
				}, this.region);
			}
			const options = await this.awsRequestSigner.getRequestOptions({
				..._a.RETRY_CONFIG,
				url: this.regionalCredVerificationUrl.replace("{region}", this.region),
				method: "POST"
			});
			const reformattedHeader = [];
			const extendedHeaders = Object.assign({ "x-goog-cloud-target-resource": this.audience }, options.headers);
			for (const key in extendedHeaders) reformattedHeader.push({
				key,
				value: extendedHeaders[key]
			});
			return encodeURIComponent(JSON.stringify({
				url: options.url,
				method: options.method,
				headers: reformattedHeader
			}));
		}
	};
	exports.AwsClient = AwsClient;
	_a = AwsClient;
	_AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL = { value: "https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15" };
	/**
	* @deprecated AWS client no validates the EC2 metadata address.
	**/
	AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = "169.254.169.254";
	/**
	* @deprecated AWS client no validates the EC2 metadata address.
	**/
	AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = "fd00:ec2::254";
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/executable-response.js
var require_executable_response = __commonJS({ "node_modules/google-auth-library/build/src/auth/executable-response.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = void 0;
	const SAML_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:saml2";
	const OIDC_SUBJECT_TOKEN_TYPE1 = "urn:ietf:params:oauth:token-type:id_token";
	const OIDC_SUBJECT_TOKEN_TYPE2 = "urn:ietf:params:oauth:token-type:jwt";
	/**
	* Defines the response of a 3rd party executable run by the pluggable auth client.
	*/
	var ExecutableResponse = class {
		/**
		* Instantiates an ExecutableResponse instance using the provided JSON object
		* from the output of the executable.
		* @param responseJson Response from a 3rd party executable, loaded from a
		* run of the executable or a cached output file.
		*/
		constructor(responseJson) {
			if (!responseJson.version) throw new InvalidVersionFieldError("Executable response must contain a 'version' field.");
			if (responseJson.success === void 0) throw new InvalidSuccessFieldError("Executable response must contain a 'success' field.");
			this.version = responseJson.version;
			this.success = responseJson.success;
			if (this.success) {
				this.expirationTime = responseJson.expiration_time;
				this.tokenType = responseJson.token_type;
				if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) throw new InvalidTokenTypeFieldError(`Executable response must contain a 'token_type' field when successful and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);
				if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {
					if (!responseJson.saml_response) throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);
					this.subjectToken = responseJson.saml_response;
				} else {
					if (!responseJson.id_token) throw new InvalidSubjectTokenError(`Executable response must contain a 'id_token' field when token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);
					this.subjectToken = responseJson.id_token;
				}
			} else {
				if (!responseJson.code) throw new InvalidCodeFieldError("Executable response must contain a 'code' field when unsuccessful.");
				if (!responseJson.message) throw new InvalidMessageFieldError("Executable response must contain a 'message' field when unsuccessful.");
				this.errorCode = responseJson.code;
				this.errorMessage = responseJson.message;
			}
		}
		/**
		* @return A boolean representing if the response has a valid token. Returns
		* true when the response was successful and the token is not expired.
		*/
		isValid() {
			return !this.isExpired() && this.success;
		}
		/**
		* @return A boolean representing if the response is expired. Returns true if the
		* provided timeout has passed.
		*/
		isExpired() {
			return this.expirationTime !== void 0 && this.expirationTime < Math.round(Date.now() / 1e3);
		}
	};
	exports.ExecutableResponse = ExecutableResponse;
	/**
	* An error thrown by the ExecutableResponse class.
	*/
	var ExecutableResponseError = class extends Error {
		constructor(message) {
			super(message);
			Object.setPrototypeOf(this, new.target.prototype);
		}
	};
	exports.ExecutableResponseError = ExecutableResponseError;
	/**
	* An error thrown when the 'version' field in an executable response is missing or invalid.
	*/
	var InvalidVersionFieldError = class extends ExecutableResponseError {};
	exports.InvalidVersionFieldError = InvalidVersionFieldError;
	/**
	* An error thrown when the 'success' field in an executable response is missing or invalid.
	*/
	var InvalidSuccessFieldError = class extends ExecutableResponseError {};
	exports.InvalidSuccessFieldError = InvalidSuccessFieldError;
	/**
	* An error thrown when the 'expiration_time' field in an executable response is missing or invalid.
	*/
	var InvalidExpirationTimeFieldError = class extends ExecutableResponseError {};
	exports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;
	/**
	* An error thrown when the 'token_type' field in an executable response is missing or invalid.
	*/
	var InvalidTokenTypeFieldError = class extends ExecutableResponseError {};
	exports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;
	/**
	* An error thrown when the 'code' field in an executable response is missing or invalid.
	*/
	var InvalidCodeFieldError = class extends ExecutableResponseError {};
	exports.InvalidCodeFieldError = InvalidCodeFieldError;
	/**
	* An error thrown when the 'message' field in an executable response is missing or invalid.
	*/
	var InvalidMessageFieldError = class extends ExecutableResponseError {};
	exports.InvalidMessageFieldError = InvalidMessageFieldError;
	/**
	* An error thrown when the subject token in an executable response is missing or invalid.
	*/
	var InvalidSubjectTokenError = class extends ExecutableResponseError {};
	exports.InvalidSubjectTokenError = InvalidSubjectTokenError;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js
var require_pluggable_auth_handler = __commonJS({ "node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PluggableAuthHandler = void 0;
	const pluggable_auth_client_1$2 = require_pluggable_auth_client();
	const executable_response_1$1 = require_executable_response();
	const childProcess = require("child_process");
	const fs$4 = require("fs");
	/**
	* A handler used to retrieve 3rd party token responses from user defined
	* executables and cached file output for the PluggableAuthClient class.
	*/
	var PluggableAuthHandler = class PluggableAuthHandler {
		/**
		* Instantiates a PluggableAuthHandler instance using the provided
		* PluggableAuthHandlerOptions object.
		*/
		constructor(options) {
			if (!options.command) throw new Error("No command provided.");
			this.commandComponents = PluggableAuthHandler.parseCommand(options.command);
			this.timeoutMillis = options.timeoutMillis;
			if (!this.timeoutMillis) throw new Error("No timeoutMillis provided.");
			this.outputFile = options.outputFile;
		}
		/**
		* Calls user provided executable to get a 3rd party subject token and
		* returns the response.
		* @param envMap a Map of additional Environment Variables required for
		*   the executable.
		* @return A promise that resolves with the executable response.
		*/
		retrieveResponseFromExecutable(envMap) {
			return new Promise((resolve, reject) => {
				const child$1 = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), { env: {
					...process.env,
					...Object.fromEntries(envMap)
				} });
				let output = "";
				child$1.stdout.on("data", (data) => {
					output += data;
				});
				child$1.stderr.on("data", (err) => {
					output += err;
				});
				const timeout = setTimeout(() => {
					child$1.removeAllListeners();
					child$1.kill();
					return reject(new Error("The executable failed to finish within the timeout specified."));
				}, this.timeoutMillis);
				child$1.on("close", (code$1) => {
					clearTimeout(timeout);
					if (code$1 === 0) try {
						const responseJson = JSON.parse(output);
						const response = new executable_response_1$1.ExecutableResponse(responseJson);
						return resolve(response);
					} catch (error$1) {
						if (error$1 instanceof executable_response_1$1.ExecutableResponseError) return reject(error$1);
						return reject(new executable_response_1$1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));
					}
					else return reject(new pluggable_auth_client_1$2.ExecutableError(output, code$1.toString()));
				});
			});
		}
		/**
		* Checks user provided output file for response from previous run of
		* executable and return the response if it exists, is formatted correctly, and is not expired.
		*/
		async retrieveCachedResponse() {
			if (!this.outputFile || this.outputFile.length === 0) return void 0;
			let filePath;
			try {
				filePath = await fs$4.promises.realpath(this.outputFile);
			} catch (_a$5) {
				return void 0;
			}
			if (!(await fs$4.promises.lstat(filePath)).isFile()) return void 0;
			const responseString = await fs$4.promises.readFile(filePath, { encoding: "utf8" });
			if (responseString === "") return void 0;
			try {
				const responseJson = JSON.parse(responseString);
				const response = new executable_response_1$1.ExecutableResponse(responseJson);
				if (response.isValid()) return new executable_response_1$1.ExecutableResponse(responseJson);
				return void 0;
			} catch (error$1) {
				if (error$1 instanceof executable_response_1$1.ExecutableResponseError) throw error$1;
				throw new executable_response_1$1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);
			}
		}
		/**
		* Parses given command string into component array, splitting on spaces unless
		* spaces are between quotation marks.
		*/
		static parseCommand(command) {
			const components = command.match(/(?:[^\s"]+|"[^"]*")+/g);
			if (!components) throw new Error(`Provided command: "${command}" could not be parsed.`);
			for (let i$1 = 0; i$1 < components.length; i$1++) if (components[i$1][0] === "\"" && components[i$1].slice(-1) === "\"") components[i$1] = components[i$1].slice(1, -1);
			return components;
		}
	};
	exports.PluggableAuthHandler = PluggableAuthHandler;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js
var require_pluggable_auth_client = __commonJS({ "node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PluggableAuthClient = exports.ExecutableError = void 0;
	const baseexternalclient_1$4 = require_baseexternalclient();
	const executable_response_1 = require_executable_response();
	const pluggable_auth_handler_1 = require_pluggable_auth_handler();
	/**
	* Error thrown from the executable run by PluggableAuthClient.
	*/
	var ExecutableError = class extends Error {
		constructor(message, code$1) {
			super(`The executable failed with exit code: ${code$1} and error message: ${message}.`);
			this.code = code$1;
			Object.setPrototypeOf(this, new.target.prototype);
		}
	};
	exports.ExecutableError = ExecutableError;
	/**
	* The default executable timeout when none is provided, in milliseconds.
	*/
	const DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1e3;
	/**
	* The minimum allowed executable timeout in milliseconds.
	*/
	const MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1e3;
	/**
	* The maximum allowed executable timeout in milliseconds.
	*/
	const MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1e3;
	/**
	* The environment variable to check to see if executable can be run.
	* Value must be set to '1' for the executable to run.
	*/
	const GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = "GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES";
	/**
	* The maximum currently supported executable version.
	*/
	const MAXIMUM_EXECUTABLE_VERSION = 1;
	/**
	* PluggableAuthClient enables the exchange of workload identity pool external credentials for
	* Google access tokens by retrieving 3rd party tokens through a user supplied executable. These
	* scripts/executables are completely independent of the Google Cloud Auth libraries. These
	* credentials plug into ADC and will call the specified executable to retrieve the 3rd party token
	* to be exchanged for a Google access token.
	*
	* <p>To use these credentials, the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment variable
	* must be set to '1'. This is for security reasons.
	*
	* <p>Both OIDC and SAML are supported. The executable must adhere to a specific response format
	* defined below.
	*
	* <p>The executable must print out the 3rd party token to STDOUT in JSON format. When an
	* output_file is specified in the credential configuration, the executable must also handle writing the
	* JSON response to this file.
	*
	* <pre>
	* OIDC response sample:
	* {
	*   "version": 1,
	*   "success": true,
	*   "token_type": "urn:ietf:params:oauth:token-type:id_token",
	*   "id_token": "HEADER.PAYLOAD.SIGNATURE",
	*   "expiration_time": 1620433341
	* }
	*
	* SAML2 response sample:
	* {
	*   "version": 1,
	*   "success": true,
	*   "token_type": "urn:ietf:params:oauth:token-type:saml2",
	*   "saml_response": "...",
	*   "expiration_time": 1620433341
	* }
	*
	* Error response sample:
	* {
	*   "version": 1,
	*   "success": false,
	*   "code": "401",
	*   "message": "Error message."
	* }
	* </pre>
	*
	* <p>The "expiration_time" field in the JSON response is only required for successful
	* responses when an output file was specified in the credential configuration
	*
	* <p>The auth libraries will populate certain environment variables that will be accessible by the
	* executable, such as: GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE, GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE,
	* GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE, GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL, and
	* GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE.
	*
	* <p>Please see this repositories README for a complete executable request/response specification.
	*/
	var PluggableAuthClient = class extends baseexternalclient_1$4.BaseExternalAccountClient {
		/**
		* Instantiates a PluggableAuthClient instance using the provided JSON
		* object loaded from an external account credentials file.
		* An error is thrown if the credential is not a valid pluggable auth credential.
		* @param options The external account options object typically loaded from
		*   the external account JSON credential file.
		* @param additionalOptions **DEPRECATED, all options are available in the
		*   `options` parameter.** Optional additional behavior customization options.
		*   These currently customize expiration threshold time and whether to retry
		*   on 401/403 API request errors.
		*/
		constructor(options, additionalOptions) {
			super(options, additionalOptions);
			if (!options.credential_source.executable) throw new Error("No valid Pluggable Auth \"credential_source\" provided.");
			this.command = options.credential_source.executable.command;
			if (!this.command) throw new Error("No valid Pluggable Auth \"credential_source\" provided.");
			if (options.credential_source.executable.timeout_millis === void 0) this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;
			else {
				this.timeoutMillis = options.credential_source.executable.timeout_millis;
				if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS || this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);
			}
			this.outputFile = options.credential_source.executable.output_file;
			this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({
				command: this.command,
				timeoutMillis: this.timeoutMillis,
				outputFile: this.outputFile
			});
			this.credentialSourceType = "executable";
		}
		/**
		* Triggered when an external subject token is needed to be exchanged for a
		* GCP access token via GCP STS endpoint.
		* This uses the `options.credential_source` object to figure out how
		* to retrieve the token using the current environment. In this case,
		* this calls a user provided executable which returns the subject token.
		* The logic is summarized as:
		* 1. Validated that the executable is allowed to run. The
		*    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to
		*    1 for security reasons.
		* 2. If an output file is specified by the user, check the file location
		*    for a response. If the file exists and contains a valid response,
		*    return the subject token from the file.
		* 3. Call the provided executable and return response.
		* @return A promise that resolves with the external subject token.
		*/
		async retrieveSubjectToken() {
			if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== "1") throw new Error("Pluggable Auth executables need to be explicitly allowed to run by setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment Variable to 1.");
			let executableResponse = void 0;
			if (this.outputFile) executableResponse = await this.handler.retrieveCachedResponse();
			if (!executableResponse) {
				const envMap = new Map();
				envMap.set("GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE", this.audience);
				envMap.set("GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE", this.subjectTokenType);
				envMap.set("GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE", "0");
				if (this.outputFile) envMap.set("GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE", this.outputFile);
				const serviceAccountEmail = this.getServiceAccountEmail();
				if (serviceAccountEmail) envMap.set("GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL", serviceAccountEmail);
				executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);
			}
			if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);
			if (!executableResponse.success) throw new ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);
			if (this.outputFile) {
				if (!executableResponse.expirationTime) throw new executable_response_1.InvalidExpirationTimeFieldError("The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.");
			}
			if (executableResponse.isExpired()) throw new Error("Executable response is expired.");
			return executableResponse.subjectToken;
		}
	};
	exports.PluggableAuthClient = PluggableAuthClient;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/externalclient.js
var require_externalclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/externalclient.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ExternalAccountClient = void 0;
	const baseexternalclient_1$3 = require_baseexternalclient();
	const identitypoolclient_1$1 = require_identitypoolclient();
	const awsclient_1$1 = require_awsclient();
	const pluggable_auth_client_1$1 = require_pluggable_auth_client();
	/**
	* Dummy class with no constructor. Developers are expected to use fromJSON.
	*/
	var ExternalAccountClient = class {
		constructor() {
			throw new Error("ExternalAccountClients should be initialized via: ExternalAccountClient.fromJSON(), directly via explicit constructors, eg. new AwsClient(options), new IdentityPoolClient(options), newPluggableAuthClientOptions, or via new GoogleAuth(options).getClient()");
		}
		/**
		* This static method will instantiate the
		* corresponding type of external account credential depending on the
		* underlying credential source.
		* @param options The external account options object typically loaded
		*   from the external account JSON credential file.
		* @param additionalOptions **DEPRECATED, all options are available in the
		*   `options` parameter.** Optional additional behavior customization options.
		*   These currently customize expiration threshold time and whether to retry
		*   on 401/403 API request errors.
		* @return A BaseExternalAccountClient instance or null if the options
		*   provided do not correspond to an external account credential.
		*/
		static fromJSON(options, additionalOptions) {
			var _a$5, _b$1;
			if (options && options.type === baseexternalclient_1$3.EXTERNAL_ACCOUNT_TYPE) if ((_a$5 = options.credential_source) === null || _a$5 === void 0 ? void 0 : _a$5.environment_id) return new awsclient_1$1.AwsClient(options, additionalOptions);
			else if ((_b$1 = options.credential_source) === null || _b$1 === void 0 ? void 0 : _b$1.executable) return new pluggable_auth_client_1$1.PluggableAuthClient(options, additionalOptions);
			else return new identitypoolclient_1$1.IdentityPoolClient(options, additionalOptions);
			else return null;
		}
	};
	exports.ExternalAccountClient = ExternalAccountClient;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js
var require_externalAccountAuthorizedUserClient = __commonJS({ "node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;
	const authclient_1$4 = require_authclient();
	const oauth2common_1 = require_oauth2common();
	const gaxios_1 = require_src$4();
	const stream$1 = require("stream");
	const baseexternalclient_1$2 = require_baseexternalclient();
	/**
	* The credentials JSON file type for external account authorized user clients.
	*/
	exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = "external_account_authorized_user";
	const DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/oauthtoken";
	/**
	* Handler for token refresh requests sent to the token_url endpoint for external
	* authorized user credentials.
	*/
	var ExternalAccountAuthorizedUserHandler = class ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {
		/**
		* Initializes an ExternalAccountAuthorizedUserHandler instance.
		* @param url The URL of the token refresh endpoint.
		* @param transporter The transporter to use for the refresh request.
		* @param clientAuthentication The client authentication credentials to use
		*   for the refresh request.
		*/
		constructor(url, transporter, clientAuthentication) {
			super(clientAuthentication);
			this.url = url;
			this.transporter = transporter;
		}
		/**
		* Requests a new access token from the token_url endpoint using the provided
		*   refresh token.
		* @param refreshToken The refresh token to use to generate a new access token.
		* @param additionalHeaders Optional additional headers to pass along the
		*   request.
		* @return A promise that resolves with the token refresh response containing
		*   the requested access token and its expiration time.
		*/
		async refreshToken(refreshToken, additionalHeaders) {
			const values = new URLSearchParams({
				grant_type: "refresh_token",
				refresh_token: refreshToken
			});
			const headers = {
				"Content-Type": "application/x-www-form-urlencoded",
				...additionalHeaders
			};
			const opts = {
				...ExternalAccountAuthorizedUserHandler.RETRY_CONFIG,
				url: this.url,
				method: "POST",
				headers,
				data: values.toString(),
				responseType: "json"
			};
			this.applyClientAuthenticationOptions(opts);
			try {
				const response = await this.transporter.request(opts);
				const tokenRefreshResponse = response.data;
				tokenRefreshResponse.res = response;
				return tokenRefreshResponse;
			} catch (error$1) {
				if (error$1 instanceof gaxios_1.GaxiosError && error$1.response) throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(
					error$1.response.data,
					// Preserve other fields from the original error.
					error$1
);
				throw error$1;
			}
		}
	};
	/**
	* External Account Authorized User Client. This is used for OAuth2 credentials
	* sourced using external identities through Workforce Identity Federation.
	* Obtaining the initial access and refresh token can be done through the
	* Google Cloud CLI.
	*/
	var ExternalAccountAuthorizedUserClient = class extends authclient_1$4.AuthClient {
		/**
		* Instantiates an ExternalAccountAuthorizedUserClient instances using the
		* provided JSON object loaded from a credentials files.
		* An error is throws if the credential is not valid.
		* @param options The external account authorized user option object typically
		*   from the external accoutn authorized user JSON credential file.
		* @param additionalOptions **DEPRECATED, all options are available in the
		*   `options` parameter.** Optional additional behavior customization options.
		*   These currently customize expiration threshold time and whether to retry
		*   on 401/403 API request errors.
		*/
		constructor(options, additionalOptions) {
			var _a$5;
			super({
				...options,
				...additionalOptions
			});
			if (options.universe_domain) this.universeDomain = options.universe_domain;
			this.refreshToken = options.refresh_token;
			const clientAuth = {
				confidentialClientType: "basic",
				clientId: options.client_id,
				clientSecret: options.client_secret
			};
			this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler((_a$5 = options.token_url) !== null && _a$5 !== void 0 ? _a$5 : DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain), this.transporter, clientAuth);
			this.cachedAccessToken = null;
			this.quotaProjectId = options.quota_project_id;
			if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== "number") this.eagerRefreshThresholdMillis = baseexternalclient_1$2.EXPIRATION_TIME_OFFSET;
			else this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;
			this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);
		}
		async getAccessToken() {
			if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) await this.refreshAccessTokenAsync();
			return {
				token: this.cachedAccessToken.access_token,
				res: this.cachedAccessToken.res
			};
		}
		async getRequestHeaders() {
			const accessTokenResponse = await this.getAccessToken();
			const headers = { Authorization: `Bearer ${accessTokenResponse.token}` };
			return this.addSharedMetadataHeaders(headers);
		}
		request(opts, callback) {
			if (callback) this.requestAsync(opts).then((r) => callback(null, r), (e) => {
				return callback(e, e.response);
			});
			else return this.requestAsync(opts);
		}
		/**
		* Authenticates the provided HTTP request, processes it and resolves with the
		* returned response.
		* @param opts The HTTP request options.
		* @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
		* @return A promise that resolves with the successful response.
		*/
		async requestAsync(opts, reAuthRetried = false) {
			let response;
			try {
				const requestHeaders = await this.getRequestHeaders();
				opts.headers = opts.headers || {};
				if (requestHeaders && requestHeaders["x-goog-user-project"]) opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
				if (requestHeaders && requestHeaders.Authorization) opts.headers.Authorization = requestHeaders.Authorization;
				response = await this.transporter.request(opts);
			} catch (e) {
				const res = e.response;
				if (res) {
					const statusCode = res.status;
					const isReadableStream = res.config.data instanceof stream$1.Readable;
					const isAuthErr = statusCode === 401 || statusCode === 403;
					if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
						await this.refreshAccessTokenAsync();
						return await this.requestAsync(opts, true);
					}
				}
				throw e;
			}
			return response;
		}
		/**
		* Forces token refresh, even if unexpired tokens are currently cached.
		* @return A promise that resolves with the refreshed credential.
		*/
		async refreshAccessTokenAsync() {
			const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);
			this.cachedAccessToken = {
				access_token: refreshResponse.access_token,
				expiry_date: new Date().getTime() + refreshResponse.expires_in * 1e3,
				res: refreshResponse.res
			};
			if (refreshResponse.refresh_token !== void 0) this.refreshToken = refreshResponse.refresh_token;
			return this.cachedAccessToken;
		}
		/**
		* Returns whether the provided credentials are expired or not.
		* If there is no expiry time, assumes the token is not expired or expiring.
		* @param credentials The credentials to check for expiration.
		* @return Whether the credentials are expired or not.
		*/
		isExpired(credentials) {
			const now = new Date().getTime();
			return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;
		}
	};
	exports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/googleauth.js
var require_googleauth = __commonJS({ "node_modules/google-auth-library/build/src/auth/googleauth.js"(exports) {
	var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
		return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
	};
	var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
		if (kind === "m") throw new TypeError("Private method is not writable");
		if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
		if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
		return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
	};
	var _GoogleAuth_instances, _GoogleAuth_pendingAuthClient, _GoogleAuth_prepareAndCacheClient, _GoogleAuth_determineClient;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GoogleAuth = exports.GoogleAuthExceptionMessages = exports.CLOUD_SDK_CLIENT_ID = void 0;
	const child_process_1 = require("child_process");
	const fs$3 = require("fs");
	const gcpMetadata = require_src$2();
	const os$1 = require("os");
	const path$1 = require("path");
	const crypto_1 = require_crypto();
	const transporters_1$1 = require_transporters();
	const computeclient_1$1 = require_computeclient();
	const idtokenclient_1$1 = require_idtokenclient();
	const envDetect_1$1 = require_envDetect();
	const jwtclient_1$1 = require_jwtclient();
	const refreshclient_1$1 = require_refreshclient();
	const impersonated_1$1 = require_impersonated();
	const externalclient_1$1 = require_externalclient();
	const baseexternalclient_1$1 = require_baseexternalclient();
	const authclient_1$3 = require_authclient();
	const externalAccountAuthorizedUserClient_1 = require_externalAccountAuthorizedUserClient();
	const util_1 = require_util();
	exports.CLOUD_SDK_CLIENT_ID = "764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com";
	exports.GoogleAuthExceptionMessages = {
		API_KEY_WITH_CREDENTIALS: "API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.",
		NO_PROJECT_ID_FOUND: "Unable to detect a Project Id in the current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
		NO_CREDENTIALS_FOUND: "Unable to find credentials in current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
		NO_ADC_FOUND: "Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.",
		NO_UNIVERSE_DOMAIN_FOUND: "Unable to detect a Universe Domain in the current environment.\nTo learn more about Universe Domain retrieval, visit: \nhttps://cloud.google.com/compute/docs/metadata/predefined-metadata-keys"
	};
	var GoogleAuth = class {
		get isGCE() {
			return this.checkIsGCE;
		}
		/**
		* Configuration is resolved in the following order of precedence:
		* - {@link GoogleAuthOptions.credentials `credentials`}
		* - {@link GoogleAuthOptions.keyFilename `keyFilename`}
		* - {@link GoogleAuthOptions.keyFile `keyFile`}
		*
		* {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the
		* {@link AuthClient `AuthClient`s}.
		*
		* @param opts
		*/
		constructor(opts = {}) {
			_GoogleAuth_instances.add(this);
			/**
			* Caches a value indicating whether the auth layer is running on Google
			* Compute Engine.
			* @private
			*/
			this.checkIsGCE = void 0;
			this.jsonContent = null;
			this.cachedCredential = null;
			/**
			* A pending {@link AuthClient}. Used for concurrent {@link GoogleAuth.getClient} calls.
			*/
			_GoogleAuth_pendingAuthClient.set(this, null);
			this.clientOptions = {};
			this._cachedProjectId = opts.projectId || null;
			this.cachedCredential = opts.authClient || null;
			this.keyFilename = opts.keyFilename || opts.keyFile;
			this.scopes = opts.scopes;
			this.clientOptions = opts.clientOptions || {};
			this.jsonContent = opts.credentials || null;
			this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;
			if (this.apiKey && (this.jsonContent || this.clientOptions.credentials)) throw new RangeError(exports.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);
			if (opts.universeDomain) this.clientOptions.universeDomain = opts.universeDomain;
		}
		setGapicJWTValues(client) {
			client.defaultServicePath = this.defaultServicePath;
			client.useJWTAccessWithScope = this.useJWTAccessWithScope;
			client.defaultScopes = this.defaultScopes;
		}
		getProjectId(callback) {
			if (callback) this.getProjectIdAsync().then((r) => callback(null, r), callback);
			else return this.getProjectIdAsync();
		}
		/**
		* A temporary method for internal `getProjectId` usages where `null` is
		* acceptable. In a future major release, `getProjectId` should return `null`
		* (as the `Promise<string | null>` base signature describes) and this private
		* method should be removed.
		*
		* @returns Promise that resolves with project id (or `null`)
		*/
		async getProjectIdOptional() {
			try {
				return await this.getProjectId();
			} catch (e) {
				if (e instanceof Error && e.message === exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) return null;
				else throw e;
			}
		}
		/**
		* A private method for finding and caching a projectId.
		*
		* Supports environments in order of precedence:
		* - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable
		* - GOOGLE_APPLICATION_CREDENTIALS JSON file
		* - Cloud SDK: `gcloud config config-helper --format json`
		* - GCE project ID from metadata server
		*
		* @returns projectId
		*/
		async findAndCacheProjectId() {
			let projectId = null;
			projectId || (projectId = await this.getProductionProjectId());
			projectId || (projectId = await this.getFileProjectId());
			projectId || (projectId = await this.getDefaultServiceProjectId());
			projectId || (projectId = await this.getGCEProjectId());
			projectId || (projectId = await this.getExternalAccountClientProjectId());
			if (projectId) {
				this._cachedProjectId = projectId;
				return projectId;
			} else throw new Error(exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);
		}
		async getProjectIdAsync() {
			if (this._cachedProjectId) return this._cachedProjectId;
			if (!this._findProjectIdPromise) this._findProjectIdPromise = this.findAndCacheProjectId();
			return this._findProjectIdPromise;
		}
		/**
		* Retrieves a universe domain from the metadata server via
		* {@link gcpMetadata.universe}.
		*
		* @returns a universe domain
		*/
		async getUniverseDomainFromMetadataServer() {
			var _a$5;
			let universeDomain;
			try {
				universeDomain = await gcpMetadata.universe("universe-domain");
				universeDomain || (universeDomain = authclient_1$3.DEFAULT_UNIVERSE);
			} catch (e) {
				if (e && ((_a$5 = e === null || e === void 0 ? void 0 : e.response) === null || _a$5 === void 0 ? void 0 : _a$5.status) === 404) universeDomain = authclient_1$3.DEFAULT_UNIVERSE;
				else throw e;
			}
			return universeDomain;
		}
		/**
		* Retrieves, caches, and returns the universe domain in the following order
		* of precedence:
		* - The universe domain in {@link GoogleAuth.clientOptions}
		* - An existing or ADC {@link AuthClient}'s universe domain
		* - {@link gcpMetadata.universe}, if {@link Compute} client
		*
		* @returns The universe domain
		*/
		async getUniverseDomain() {
			let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get("universe_domain");
			try {
				universeDomain !== null && universeDomain !== void 0 || (universeDomain = (await this.getClient()).universeDomain);
			} catch (_a$5) {
				universeDomain !== null && universeDomain !== void 0 || (universeDomain = authclient_1$3.DEFAULT_UNIVERSE);
			}
			return universeDomain;
		}
		/**
		* @returns Any scopes (user-specified or default scopes specified by the
		*   client library) that need to be set on the current Auth client.
		*/
		getAnyScopes() {
			return this.scopes || this.defaultScopes;
		}
		getApplicationDefault(optionsOrCallback = {}, callback) {
			let options;
			if (typeof optionsOrCallback === "function") callback = optionsOrCallback;
			else options = optionsOrCallback;
			if (callback) this.getApplicationDefaultAsync(options).then((r) => callback(null, r.credential, r.projectId), callback);
			else return this.getApplicationDefaultAsync(options);
		}
		async getApplicationDefaultAsync(options = {}) {
			if (this.cachedCredential) return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, this.cachedCredential, null);
			let credential;
			credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);
			if (credential) {
				if (credential instanceof jwtclient_1$1.JWT) credential.scopes = this.scopes;
				else if (credential instanceof baseexternalclient_1$1.BaseExternalAccountClient) credential.scopes = this.getAnyScopes();
				return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, credential);
			}
			credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);
			if (credential) {
				if (credential instanceof jwtclient_1$1.JWT) credential.scopes = this.scopes;
				else if (credential instanceof baseexternalclient_1$1.BaseExternalAccountClient) credential.scopes = this.getAnyScopes();
				return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, credential);
			}
			if (await this._checkIsGCE()) {
				options.scopes = this.getAnyScopes();
				return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, new computeclient_1$1.Compute(options));
			}
			throw new Error(exports.GoogleAuthExceptionMessages.NO_ADC_FOUND);
		}
		/**
		* Determines whether the auth layer is running on Google Compute Engine.
		* Checks for GCP Residency, then fallback to checking if metadata server
		* is available.
		*
		* @returns A promise that resolves with the boolean.
		* @api private
		*/
		async _checkIsGCE() {
			if (this.checkIsGCE === void 0) this.checkIsGCE = gcpMetadata.getGCPResidency() || await gcpMetadata.isAvailable();
			return this.checkIsGCE;
		}
		/**
		* Attempts to load default credentials from the environment variable path..
		* @returns Promise that resolves with the OAuth2Client or null.
		* @api private
		*/
		async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {
			const credentialsPath = process.env["GOOGLE_APPLICATION_CREDENTIALS"] || process.env["google_application_credentials"];
			if (!credentialsPath || credentialsPath.length === 0) return null;
			try {
				return this._getApplicationCredentialsFromFilePath(credentialsPath, options);
			} catch (e) {
				if (e instanceof Error) e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;
				throw e;
			}
		}
		/**
		* Attempts to load default credentials from a well-known file location
		* @return Promise that resolves with the OAuth2Client or null.
		* @api private
		*/
		async _tryGetApplicationCredentialsFromWellKnownFile(options) {
			let location = null;
			if (this._isWindows()) location = process.env["APPDATA"];
			else {
				const home = process.env["HOME"];
				if (home) location = path$1.join(home, ".config");
			}
			if (location) {
				location = path$1.join(location, "gcloud", "application_default_credentials.json");
				if (!fs$3.existsSync(location)) location = null;
			}
			if (!location) return null;
			const client = await this._getApplicationCredentialsFromFilePath(location, options);
			return client;
		}
		/**
		* Attempts to load default credentials from a file at the given path..
		* @param filePath The path to the file to read.
		* @returns Promise that resolves with the OAuth2Client
		* @api private
		*/
		async _getApplicationCredentialsFromFilePath(filePath, options = {}) {
			if (!filePath || filePath.length === 0) throw new Error("The file path is invalid.");
			try {
				filePath = fs$3.realpathSync(filePath);
				if (!fs$3.lstatSync(filePath).isFile()) throw new Error();
			} catch (err) {
				if (err instanceof Error) err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;
				throw err;
			}
			const readStream = fs$3.createReadStream(filePath);
			return this.fromStream(readStream, options);
		}
		/**
		* Create a credentials instance using a given impersonated input options.
		* @param json The impersonated input object.
		* @returns JWT or UserRefresh Client with data
		*/
		fromImpersonatedJSON(json$1) {
			var _a$5, _b$1, _c$1, _d;
			if (!json$1) throw new Error("Must pass in a JSON object containing an  impersonated refresh token");
			if (json$1.type !== impersonated_1$1.IMPERSONATED_ACCOUNT_TYPE) throw new Error(`The incoming JSON object does not have the "${impersonated_1$1.IMPERSONATED_ACCOUNT_TYPE}" type`);
			if (!json$1.source_credentials) throw new Error("The incoming JSON object does not contain a source_credentials field");
			if (!json$1.service_account_impersonation_url) throw new Error("The incoming JSON object does not contain a service_account_impersonation_url field");
			const sourceClient = this.fromJSON(json$1.source_credentials);
			if (((_a$5 = json$1.service_account_impersonation_url) === null || _a$5 === void 0 ? void 0 : _a$5.length) > 256)
 /**
			* Prevents DOS attacks.
			* @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/85}
			**/
			throw new RangeError(`Target principal is too long: ${json$1.service_account_impersonation_url}`);
			const targetPrincipal = (_c$1 = (_b$1 = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(json$1.service_account_impersonation_url)) === null || _b$1 === void 0 ? void 0 : _b$1.groups) === null || _c$1 === void 0 ? void 0 : _c$1.target;
			if (!targetPrincipal) throw new RangeError(`Cannot extract target principal from ${json$1.service_account_impersonation_url}`);
			const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== void 0 ? _d : [];
			return new impersonated_1$1.Impersonated({
				...json$1,
				sourceClient,
				targetPrincipal,
				targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes]
			});
		}
		/**
		* Create a credentials instance using the given input options.
		* This client is not cached.
		*
		* **Important**: If you accept a credential configuration (credential JSON/File/Stream) from an external source for authentication to Google Cloud, you must validate it before providing it to any Google API or library. Providing an unvalidated credential configuration to Google APIs can compromise the security of your systems and data. For more information, refer to {@link https://cloud.google.com/docs/authentication/external/externally-sourced-credentials Validate credential configurations from external sources}.
		*
		* @param json The input object.
		* @param options The JWT or UserRefresh options for the client
		* @returns JWT or UserRefresh Client with data
		*/
		fromJSON(json$1, options = {}) {
			let client;
			const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get("universe_domain");
			if (json$1.type === refreshclient_1$1.USER_REFRESH_ACCOUNT_TYPE) {
				client = new refreshclient_1$1.UserRefreshClient(options);
				client.fromJSON(json$1);
			} else if (json$1.type === impersonated_1$1.IMPERSONATED_ACCOUNT_TYPE) client = this.fromImpersonatedJSON(json$1);
			else if (json$1.type === baseexternalclient_1$1.EXTERNAL_ACCOUNT_TYPE) {
				client = externalclient_1$1.ExternalAccountClient.fromJSON(json$1, options);
				client.scopes = this.getAnyScopes();
			} else if (json$1.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json$1, options);
			else {
				options.scopes = this.scopes;
				client = new jwtclient_1$1.JWT(options);
				this.setGapicJWTValues(client);
				client.fromJSON(json$1);
			}
			if (preferredUniverseDomain) client.universeDomain = preferredUniverseDomain;
			return client;
		}
		/**
		* Return a JWT or UserRefreshClient from JavaScript object, caching both the
		* object used to instantiate and the client.
		* @param json The input object.
		* @param options The JWT or UserRefresh options for the client
		* @returns JWT or UserRefresh Client with data
		*/
		_cacheClientFromJSON(json$1, options) {
			const client = this.fromJSON(json$1, options);
			this.jsonContent = json$1;
			this.cachedCredential = client;
			return client;
		}
		fromStream(inputStream, optionsOrCallback = {}, callback) {
			let options = {};
			if (typeof optionsOrCallback === "function") callback = optionsOrCallback;
			else options = optionsOrCallback;
			if (callback) this.fromStreamAsync(inputStream, options).then((r) => callback(null, r), callback);
			else return this.fromStreamAsync(inputStream, options);
		}
		fromStreamAsync(inputStream, options) {
			return new Promise((resolve, reject) => {
				if (!inputStream) throw new Error("Must pass in a stream containing the Google auth settings.");
				const chunks = [];
				inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => chunks.push(chunk)).on("end", () => {
					try {
						try {
							const data = JSON.parse(chunks.join(""));
							const r = this._cacheClientFromJSON(data, options);
							return resolve(r);
						} catch (err) {
							if (!this.keyFilename) throw err;
							const client = new jwtclient_1$1.JWT({
								...this.clientOptions,
								keyFile: this.keyFilename
							});
							this.cachedCredential = client;
							this.setGapicJWTValues(client);
							return resolve(client);
						}
					} catch (err) {
						return reject(err);
					}
				});
			});
		}
		/**
		* Create a credentials instance using the given API key string.
		* The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.
		*
		* @param apiKey The API key string
		* @param options An optional options object.
		* @returns A JWT loaded from the key
		*/
		fromAPIKey(apiKey, options = {}) {
			return new jwtclient_1$1.JWT({
				...options,
				apiKey
			});
		}
		/**
		* Determines whether the current operating system is Windows.
		* @api private
		*/
		_isWindows() {
			const sys = os$1.platform();
			if (sys && sys.length >= 3) {
				if (sys.substring(0, 3).toLowerCase() === "win") return true;
			}
			return false;
		}
		/**
		* Run the Google Cloud SDK command that prints the default project ID
		*/
		async getDefaultServiceProjectId() {
			return new Promise((resolve) => {
				(0, child_process_1.exec)("gcloud config config-helper --format json", (err, stdout) => {
					if (!err && stdout) try {
						const projectId = JSON.parse(stdout).configuration.properties.core.project;
						resolve(projectId);
						return;
					} catch (e) {}
					resolve(null);
				});
			});
		}
		/**
		* Loads the project id from environment variables.
		* @api private
		*/
		getProductionProjectId() {
			return process.env["GCLOUD_PROJECT"] || process.env["GOOGLE_CLOUD_PROJECT"] || process.env["gcloud_project"] || process.env["google_cloud_project"];
		}
		/**
		* Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.
		* @api private
		*/
		async getFileProjectId() {
			if (this.cachedCredential) return this.cachedCredential.projectId;
			if (this.keyFilename) {
				const creds = await this.getClient();
				if (creds && creds.projectId) return creds.projectId;
			}
			const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();
			if (r) return r.projectId;
			else return null;
		}
		/**
		* Gets the project ID from external account client if available.
		*/
		async getExternalAccountClientProjectId() {
			if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1$1.EXTERNAL_ACCOUNT_TYPE) return null;
			const creds = await this.getClient();
			return await creds.getProjectId();
		}
		/**
		* Gets the Compute Engine project ID if it can be inferred.
		*/
		async getGCEProjectId() {
			try {
				const r = await gcpMetadata.project("project-id");
				return r;
			} catch (e) {
				return null;
			}
		}
		getCredentials(callback) {
			if (callback) this.getCredentialsAsync().then((r) => callback(null, r), callback);
			else return this.getCredentialsAsync();
		}
		async getCredentialsAsync() {
			const client = await this.getClient();
			if (client instanceof impersonated_1$1.Impersonated) return { client_email: client.getTargetPrincipal() };
			if (client instanceof baseexternalclient_1$1.BaseExternalAccountClient) {
				const serviceAccountEmail = client.getServiceAccountEmail();
				if (serviceAccountEmail) return {
					client_email: serviceAccountEmail,
					universe_domain: client.universeDomain
				};
			}
			if (this.jsonContent) return {
				client_email: this.jsonContent.client_email,
				private_key: this.jsonContent.private_key,
				universe_domain: this.jsonContent.universe_domain
			};
			if (await this._checkIsGCE()) {
				const [client_email, universe_domain] = await Promise.all([gcpMetadata.instance("service-accounts/default/email"), this.getUniverseDomain()]);
				return {
					client_email,
					universe_domain
				};
			}
			throw new Error(exports.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);
		}
		/**
		* Automatically obtain an {@link AuthClient `AuthClient`} based on the
		* provided configuration. If no options were passed, use Application
		* Default Credentials.
		*/
		async getClient() {
			if (this.cachedCredential) return this.cachedCredential;
			__classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, "f") || __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_determineClient).call(this), "f");
			try {
				return await __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, "f");
			} finally {
				__classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, null, "f");
			}
		}
		/**
		* Creates a client which will fetch an ID token for authorization.
		* @param targetAudience the audience for the fetched ID token.
		* @returns IdTokenClient for making HTTP calls authenticated with ID tokens.
		*/
		async getIdTokenClient(targetAudience) {
			const client = await this.getClient();
			if (!("fetchIdToken" in client)) throw new Error("Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.");
			return new idtokenclient_1$1.IdTokenClient({
				targetAudience,
				idTokenProvider: client
			});
		}
		/**
		* Automatically obtain application default credentials, and return
		* an access token for making requests.
		*/
		async getAccessToken() {
			const client = await this.getClient();
			return (await client.getAccessToken()).token;
		}
		/**
		* Obtain the HTTP headers that will provide authorization for a given
		* request.
		*/
		async getRequestHeaders(url) {
			const client = await this.getClient();
			return client.getRequestHeaders(url);
		}
		/**
		* Obtain credentials for a request, then attach the appropriate headers to
		* the request options.
		* @param opts Axios or Request options on which to attach the headers
		*/
		async authorizeRequest(opts) {
			opts = opts || {};
			const url = opts.url || opts.uri;
			const client = await this.getClient();
			const headers = await client.getRequestHeaders(url);
			opts.headers = Object.assign(opts.headers || {}, headers);
			return opts;
		}
		/**
		* Automatically obtain application default credentials, and make an
		* HTTP request using the given options.
		* @param opts Axios request options for the HTTP request.
		*/
		async request(opts) {
			const client = await this.getClient();
			return client.request(opts);
		}
		/**
		* Determine the compute environment in which the code is running.
		*/
		getEnv() {
			return (0, envDetect_1$1.getEnv)();
		}
		/**
		* Sign the given data with the current private key, or go out
		* to the IAM API to sign it.
		* @param data The data to be signed.
		* @param endpoint A custom endpoint to use.
		*
		* @example
		* ```
		* sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');
		* ```
		*/
		async sign(data, endpoint$1) {
			const client = await this.getClient();
			const universe$1 = await this.getUniverseDomain();
			endpoint$1 = endpoint$1 || `https://iamcredentials.${universe$1}/v1/projects/-/serviceAccounts/`;
			if (client instanceof impersonated_1$1.Impersonated) {
				const signed = await client.sign(data);
				return signed.signedBlob;
			}
			const crypto$8 = (0, crypto_1.createCrypto)();
			if (client instanceof jwtclient_1$1.JWT && client.key) {
				const sign$2 = await crypto$8.sign(client.key, data);
				return sign$2;
			}
			const creds = await this.getCredentials();
			if (!creds.client_email) throw new Error("Cannot sign data without `client_email`.");
			return this.signBlob(crypto$8, creds.client_email, data, endpoint$1);
		}
		async signBlob(crypto$8, emailOrUniqueId, data, endpoint$1) {
			const url = new URL(endpoint$1 + `${emailOrUniqueId}:signBlob`);
			const res = await this.request({
				method: "POST",
				url: url.href,
				data: { payload: crypto$8.encodeBase64StringUtf8(data) },
				retry: true,
				retryConfig: { httpMethodsToRetry: ["POST"] }
			});
			return res.data.signedBlob;
		}
	};
	exports.GoogleAuth = GoogleAuth;
	_GoogleAuth_pendingAuthClient = new WeakMap(), _GoogleAuth_instances = new WeakSet(), _GoogleAuth_prepareAndCacheClient = async function _GoogleAuth_prepareAndCacheClient$1(credential, quotaProjectIdOverride = process.env["GOOGLE_CLOUD_QUOTA_PROJECT"] || null) {
		const projectId = await this.getProjectIdOptional();
		if (quotaProjectIdOverride) credential.quotaProjectId = quotaProjectIdOverride;
		this.cachedCredential = credential;
		return {
			credential,
			projectId
		};
	}, _GoogleAuth_determineClient = async function _GoogleAuth_determineClient$1() {
		if (this.jsonContent) return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
		else if (this.keyFilename) {
			const filePath = path$1.resolve(this.keyFilename);
			const stream$6 = fs$3.createReadStream(filePath);
			return await this.fromStreamAsync(stream$6, this.clientOptions);
		} else if (this.apiKey) {
			const client = await this.fromAPIKey(this.apiKey, this.clientOptions);
			client.scopes = this.scopes;
			const { credential } = await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, client);
			return credential;
		} else {
			const { credential } = await this.getApplicationDefaultAsync(this.clientOptions);
			return credential;
		}
	};
	/**
	* Export DefaultTransporter as a static property of the class.
	*/
	GoogleAuth.DefaultTransporter = transporters_1$1.DefaultTransporter;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/iam.js
var require_iam = __commonJS({ "node_modules/google-auth-library/build/src/auth/iam.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.IAMAuth = void 0;
	var IAMAuth = class {
		/**
		* IAM credentials.
		*
		* @param selector the iam authority selector
		* @param token the token
		* @constructor
		*/
		constructor(selector, token) {
			this.selector = selector;
			this.token = token;
			this.selector = selector;
			this.token = token;
		}
		/**
		* Acquire the HTTP headers required to make an authenticated request.
		*/
		getRequestHeaders() {
			return {
				"x-goog-iam-authority-selector": this.selector,
				"x-goog-iam-authorization-token": this.token
			};
		}
	};
	exports.IAMAuth = IAMAuth;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/downscopedclient.js
var require_downscopedclient = __commonJS({ "node_modules/google-auth-library/build/src/auth/downscopedclient.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;
	const stream = require("stream");
	const authclient_1$2 = require_authclient();
	const sts = require_stscredentials();
	/**
	* The required token exchange grant_type: rfc8693#section-2.1
	*/
	const STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
	/**
	* The requested token exchange requested_token_type: rfc8693#section-2.1
	*/
	const STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
	/**
	* The requested token exchange subject_token_type: rfc8693#section-2.1
	*/
	const STS_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
	/**
	* The maximum number of access boundary rules a Credential Access Boundary
	* can contain.
	*/
	exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;
	/**
	* Offset to take into account network delays and server clock skews.
	*/
	exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
	/**
	* Defines a set of Google credentials that are downscoped from an existing set
	* of Google OAuth2 credentials. This is useful to restrict the Identity and
	* Access Management (IAM) permissions that a short-lived credential can use.
	* The common pattern of usage is to have a token broker with elevated access
	* generate these downscoped credentials from higher access source credentials
	* and pass the downscoped short-lived access tokens to a token consumer via
	* some secure authenticated channel for limited access to Google Cloud Storage
	* resources.
	*/
	var DownscopedClient = class extends authclient_1$2.AuthClient {
		/**
		* Instantiates a downscoped client object using the provided source
		* AuthClient and credential access boundary rules.
		* To downscope permissions of a source AuthClient, a Credential Access
		* Boundary that specifies which resources the new credential can access, as
		* well as an upper bound on the permissions that are available on each
		* resource, has to be defined. A downscoped client can then be instantiated
		* using the source AuthClient and the Credential Access Boundary.
		* @param authClient The source AuthClient to be downscoped based on the
		*   provided Credential Access Boundary rules.
		* @param credentialAccessBoundary The Credential Access Boundary which
		*   contains a list of access boundary rules. Each rule contains information
		*   on the resource that the rule applies to, the upper bound of the
		*   permissions that are available on that resource and an optional
		*   condition to further restrict permissions.
		* @param additionalOptions **DEPRECATED, set this in the provided `authClient`.**
		*   Optional additional behavior customization options.
		* @param quotaProjectId **DEPRECATED, set this in the provided `authClient`.**
		*   Optional quota project id for setting up in the x-goog-user-project header.
		*/
		constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {
			super({
				...additionalOptions,
				quotaProjectId
			});
			this.authClient = authClient;
			this.credentialAccessBoundary = credentialAccessBoundary;
			if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) throw new Error("At least one access boundary rule needs to be defined.");
			else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) throw new Error(`The provided access boundary has more than ${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);
			for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules) if (rule.availablePermissions.length === 0) throw new Error("At least one permission should be defined in access boundary rules.");
			this.stsCredential = new sts.StsCredentials(`https://sts.${this.universeDomain}/v1/token`);
			this.cachedDownscopedAccessToken = null;
		}
		/**
		* Provides a mechanism to inject Downscoped access tokens directly.
		* The expiry_date field is required to facilitate determination of the token
		* expiration which would make it easier for the token consumer to handle.
		* @param credentials The Credentials object to set on the current client.
		*/
		setCredentials(credentials) {
			if (!credentials.expiry_date) throw new Error("The access token expiry_date field is missing in the provided credentials.");
			super.setCredentials(credentials);
			this.cachedDownscopedAccessToken = credentials;
		}
		async getAccessToken() {
			if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) await this.refreshAccessTokenAsync();
			return {
				token: this.cachedDownscopedAccessToken.access_token,
				expirationTime: this.cachedDownscopedAccessToken.expiry_date,
				res: this.cachedDownscopedAccessToken.res
			};
		}
		/**
		* The main authentication interface. It takes an optional url which when
		* present is the endpoint being accessed, and returns a Promise which
		* resolves with authorization header fields.
		*
		* The result has the form:
		* { Authorization: 'Bearer <access_token_value>' }
		*/
		async getRequestHeaders() {
			const accessTokenResponse = await this.getAccessToken();
			const headers = { Authorization: `Bearer ${accessTokenResponse.token}` };
			return this.addSharedMetadataHeaders(headers);
		}
		request(opts, callback) {
			if (callback) this.requestAsync(opts).then((r) => callback(null, r), (e) => {
				return callback(e, e.response);
			});
			else return this.requestAsync(opts);
		}
		/**
		* Authenticates the provided HTTP request, processes it and resolves with the
		* returned response.
		* @param opts The HTTP request options.
		* @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure
		* @return A promise that resolves with the successful response.
		*/
		async requestAsync(opts, reAuthRetried = false) {
			let response;
			try {
				const requestHeaders = await this.getRequestHeaders();
				opts.headers = opts.headers || {};
				if (requestHeaders && requestHeaders["x-goog-user-project"]) opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
				if (requestHeaders && requestHeaders.Authorization) opts.headers.Authorization = requestHeaders.Authorization;
				response = await this.transporter.request(opts);
			} catch (e) {
				const res = e.response;
				if (res) {
					const statusCode = res.status;
					const isReadableStream = res.config.data instanceof stream.Readable;
					const isAuthErr = statusCode === 401 || statusCode === 403;
					if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
						await this.refreshAccessTokenAsync();
						return await this.requestAsync(opts, true);
					}
				}
				throw e;
			}
			return response;
		}
		/**
		* Forces token refresh, even if unexpired tokens are currently cached.
		* GCP access tokens are retrieved from authclient object/source credential.
		* Then GCP access tokens are exchanged for downscoped access tokens via the
		* token exchange endpoint.
		* @return A promise that resolves with the fresh downscoped access token.
		*/
		async refreshAccessTokenAsync() {
			var _a$5;
			const subjectToken = (await this.authClient.getAccessToken()).token;
			const stsCredentialsOptions = {
				grantType: STS_GRANT_TYPE,
				requestedTokenType: STS_REQUEST_TOKEN_TYPE,
				subjectToken,
				subjectTokenType: STS_SUBJECT_TOKEN_TYPE
			};
			const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, void 0, this.credentialAccessBoundary);
			/**
			* The STS endpoint will only return the expiration time for the downscoped
			* access token if the original access token represents a service account.
			* The downscoped token's expiration time will always match the source
			* credential expiration. When no expires_in is returned, we can copy the
			* source credential's expiration time.
			*/
			const sourceCredExpireDate = ((_a$5 = this.authClient.credentials) === null || _a$5 === void 0 ? void 0 : _a$5.expiry_date) || null;
			const expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1e3 : sourceCredExpireDate;
			this.cachedDownscopedAccessToken = {
				access_token: stsResponse.access_token,
				expiry_date: expiryDate,
				res: stsResponse.res
			};
			this.credentials = {};
			Object.assign(this.credentials, this.cachedDownscopedAccessToken);
			delete this.credentials.res;
			this.emit("tokens", {
				refresh_token: null,
				expiry_date: this.cachedDownscopedAccessToken.expiry_date,
				access_token: this.cachedDownscopedAccessToken.access_token,
				token_type: "Bearer",
				id_token: null
			});
			return this.cachedDownscopedAccessToken;
		}
		/**
		* Returns whether the provided credentials are expired or not.
		* If there is no expiry time, assumes the token is not expired or expiring.
		* @param downscopedAccessToken The credentials to check for expiration.
		* @return Whether the credentials are expired or not.
		*/
		isExpired(downscopedAccessToken) {
			const now = new Date().getTime();
			return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
		}
	};
	exports.DownscopedClient = DownscopedClient;
} });

//#endregion
//#region node_modules/google-auth-library/build/src/auth/passthrough.js
var require_passthrough = __commonJS({ "node_modules/google-auth-library/build/src/auth/passthrough.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PassThroughClient = void 0;
	const authclient_1$1 = require_authclient();
	/**
	* An AuthClient without any Authentication information. Useful for:
	* - Anonymous access
	* - Local Emulators
	* - Testing Environments
	*
	*/
	var PassThroughClient = class extends authclient_1$1.AuthClient {
		/**
		* Creates a request without any authentication headers or checks.
		*
		* @remarks
		*
		* In testing environments it may be useful to change the provided
		* {@link AuthClient.transporter} for any desired request overrides/handling.
		*
		* @param opts
		* @returns The response of the request.
		*/
		async request(opts) {
			return this.transporter.request(opts);
		}
		/**
		* A required method of the base class.
		* Always will return an empty object.
		*
		* @returns {}
		*/
		async getAccessToken() {
			return {};
		}
		/**
		* A required method of the base class.
		* Always will return an empty object.
		*
		* @returns {}
		*/
		async getRequestHeaders() {
			return {};
		}
	};
	exports.PassThroughClient = PassThroughClient;
	const a = new PassThroughClient();
	a.getAccessToken();
} });

//#endregion
//#region node_modules/google-auth-library/build/src/index.js
var require_src = __commonJS({ "node_modules/google-auth-library/build/src/index.js"(exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.GoogleAuth = exports.auth = exports.DefaultTransporter = exports.PassThroughClient = exports.ExecutableError = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsRequestSigner = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.ClientAuthentication = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.DEFAULT_UNIVERSE = exports.AuthClient = exports.gaxios = exports.gcpMetadata = void 0;
	const googleauth_1 = require_googleauth();
	Object.defineProperty(exports, "GoogleAuth", {
		enumerable: true,
		get: function() {
			return googleauth_1.GoogleAuth;
		}
	});
	exports.gcpMetadata = require_src$2();
	exports.gaxios = require_src$4();
	var authclient_1 = require_authclient();
	Object.defineProperty(exports, "AuthClient", {
		enumerable: true,
		get: function() {
			return authclient_1.AuthClient;
		}
	});
	Object.defineProperty(exports, "DEFAULT_UNIVERSE", {
		enumerable: true,
		get: function() {
			return authclient_1.DEFAULT_UNIVERSE;
		}
	});
	var computeclient_1 = require_computeclient();
	Object.defineProperty(exports, "Compute", {
		enumerable: true,
		get: function() {
			return computeclient_1.Compute;
		}
	});
	var envDetect_1 = require_envDetect();
	Object.defineProperty(exports, "GCPEnv", {
		enumerable: true,
		get: function() {
			return envDetect_1.GCPEnv;
		}
	});
	var iam_1 = require_iam();
	Object.defineProperty(exports, "IAMAuth", {
		enumerable: true,
		get: function() {
			return iam_1.IAMAuth;
		}
	});
	var idtokenclient_1 = require_idtokenclient();
	Object.defineProperty(exports, "IdTokenClient", {
		enumerable: true,
		get: function() {
			return idtokenclient_1.IdTokenClient;
		}
	});
	var jwtaccess_1 = require_jwtaccess();
	Object.defineProperty(exports, "JWTAccess", {
		enumerable: true,
		get: function() {
			return jwtaccess_1.JWTAccess;
		}
	});
	var jwtclient_1 = require_jwtclient();
	Object.defineProperty(exports, "JWT", {
		enumerable: true,
		get: function() {
			return jwtclient_1.JWT;
		}
	});
	var impersonated_1 = require_impersonated();
	Object.defineProperty(exports, "Impersonated", {
		enumerable: true,
		get: function() {
			return impersonated_1.Impersonated;
		}
	});
	var oauth2client_1 = require_oauth2client();
	Object.defineProperty(exports, "CodeChallengeMethod", {
		enumerable: true,
		get: function() {
			return oauth2client_1.CodeChallengeMethod;
		}
	});
	Object.defineProperty(exports, "OAuth2Client", {
		enumerable: true,
		get: function() {
			return oauth2client_1.OAuth2Client;
		}
	});
	Object.defineProperty(exports, "ClientAuthentication", {
		enumerable: true,
		get: function() {
			return oauth2client_1.ClientAuthentication;
		}
	});
	var loginticket_1 = require_loginticket();
	Object.defineProperty(exports, "LoginTicket", {
		enumerable: true,
		get: function() {
			return loginticket_1.LoginTicket;
		}
	});
	var refreshclient_1 = require_refreshclient();
	Object.defineProperty(exports, "UserRefreshClient", {
		enumerable: true,
		get: function() {
			return refreshclient_1.UserRefreshClient;
		}
	});
	var awsclient_1 = require_awsclient();
	Object.defineProperty(exports, "AwsClient", {
		enumerable: true,
		get: function() {
			return awsclient_1.AwsClient;
		}
	});
	var awsrequestsigner_1 = require_awsrequestsigner();
	Object.defineProperty(exports, "AwsRequestSigner", {
		enumerable: true,
		get: function() {
			return awsrequestsigner_1.AwsRequestSigner;
		}
	});
	var identitypoolclient_1 = require_identitypoolclient();
	Object.defineProperty(exports, "IdentityPoolClient", {
		enumerable: true,
		get: function() {
			return identitypoolclient_1.IdentityPoolClient;
		}
	});
	var externalclient_1 = require_externalclient();
	Object.defineProperty(exports, "ExternalAccountClient", {
		enumerable: true,
		get: function() {
			return externalclient_1.ExternalAccountClient;
		}
	});
	var baseexternalclient_1 = require_baseexternalclient();
	Object.defineProperty(exports, "BaseExternalAccountClient", {
		enumerable: true,
		get: function() {
			return baseexternalclient_1.BaseExternalAccountClient;
		}
	});
	var downscopedclient_1 = require_downscopedclient();
	Object.defineProperty(exports, "DownscopedClient", {
		enumerable: true,
		get: function() {
			return downscopedclient_1.DownscopedClient;
		}
	});
	var pluggable_auth_client_1 = require_pluggable_auth_client();
	Object.defineProperty(exports, "PluggableAuthClient", {
		enumerable: true,
		get: function() {
			return pluggable_auth_client_1.PluggableAuthClient;
		}
	});
	Object.defineProperty(exports, "ExecutableError", {
		enumerable: true,
		get: function() {
			return pluggable_auth_client_1.ExecutableError;
		}
	});
	var passthrough_1 = require_passthrough();
	Object.defineProperty(exports, "PassThroughClient", {
		enumerable: true,
		get: function() {
			return passthrough_1.PassThroughClient;
		}
	});
	var transporters_1 = require_transporters();
	Object.defineProperty(exports, "DefaultTransporter", {
		enumerable: true,
		get: function() {
			return transporters_1.DefaultTransporter;
		}
	});
	const auth = new googleauth_1.GoogleAuth();
	exports.auth = auth;
} });

//#endregion
//#region node_modules/ws/lib/constants.js
var require_constants = __commonJS({ "node_modules/ws/lib/constants.js"(exports, module) {
	const BINARY_TYPES$2 = [
		"nodebuffer",
		"arraybuffer",
		"fragments"
	];
	const hasBlob$1 = typeof Blob !== "undefined";
	if (hasBlob$1) BINARY_TYPES$2.push("blob");
	module.exports = {
		BINARY_TYPES: BINARY_TYPES$2,
		EMPTY_BUFFER: Buffer.alloc(0),
		GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
		hasBlob: hasBlob$1,
		kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
		kListener: Symbol("kListener"),
		kStatusCode: Symbol("status-code"),
		kWebSocket: Symbol("websocket"),
		NOOP: () => {}
	};
} });

//#endregion
//#region node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({ "node_modules/ws/lib/buffer-util.js"(exports, module) {
	const { EMPTY_BUFFER: EMPTY_BUFFER$3 } = require_constants();
	const FastBuffer$2 = Buffer[Symbol.species];
	/**
	* Merges an array of buffers into a new buffer.
	*
	* @param {Buffer[]} list The array of buffers to concat
	* @param {Number} totalLength The total length of buffers in the list
	* @return {Buffer} The resulting buffer
	* @public
	*/
	function concat$1(list, totalLength) {
		if (list.length === 0) return EMPTY_BUFFER$3;
		if (list.length === 1) return list[0];
		const target = Buffer.allocUnsafe(totalLength);
		let offset = 0;
		for (let i$1 = 0; i$1 < list.length; i$1++) {
			const buf = list[i$1];
			target.set(buf, offset);
			offset += buf.length;
		}
		if (offset < totalLength) return new FastBuffer$2(target.buffer, target.byteOffset, offset);
		return target;
	}
	/**
	* Masks a buffer using the given mask.
	*
	* @param {Buffer} source The buffer to mask
	* @param {Buffer} mask The mask to use
	* @param {Buffer} output The buffer where to store the result
	* @param {Number} offset The offset at which to start writing
	* @param {Number} length The number of bytes to mask.
	* @public
	*/
	function _mask(source, mask, output, offset, length) {
		for (let i$1 = 0; i$1 < length; i$1++) output[offset + i$1] = source[i$1] ^ mask[i$1 & 3];
	}
	/**
	* Unmasks a buffer using the given mask.
	*
	* @param {Buffer} buffer The buffer to unmask
	* @param {Buffer} mask The mask to use
	* @public
	*/
	function _unmask(buffer$1, mask) {
		for (let i$1 = 0; i$1 < buffer$1.length; i$1++) buffer$1[i$1] ^= mask[i$1 & 3];
	}
	/**
	* Converts a buffer to an `ArrayBuffer`.
	*
	* @param {Buffer} buf The buffer to convert
	* @return {ArrayBuffer} Converted buffer
	* @public
	*/
	function toArrayBuffer$1(buf) {
		if (buf.length === buf.buffer.byteLength) return buf.buffer;
		return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
	}
	/**
	* Converts `data` to a `Buffer`.
	*
	* @param {*} data The data to convert
	* @return {Buffer} The buffer
	* @throws {TypeError}
	* @public
	*/
	function toBuffer$2(data) {
		toBuffer$2.readOnly = true;
		if (Buffer.isBuffer(data)) return data;
		let buf;
		if (data instanceof ArrayBuffer) buf = new FastBuffer$2(data);
		else if (ArrayBuffer.isView(data)) buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);
		else {
			buf = Buffer.from(data);
			toBuffer$2.readOnly = false;
		}
		return buf;
	}
	module.exports = {
		concat: concat$1,
		mask: _mask,
		toArrayBuffer: toArrayBuffer$1,
		toBuffer: toBuffer$2,
		unmask: _unmask
	};
	/* istanbul ignore else  */
	if (!process.env.WS_NO_BUFFER_UTIL) try {
		const bufferUtil$1 = require("bufferutil");
		module.exports.mask = function(source, mask, output, offset, length) {
			if (length < 48) _mask(source, mask, output, offset, length);
			else bufferUtil$1.mask(source, mask, output, offset, length);
		};
		module.exports.unmask = function(buffer$1, mask) {
			if (buffer$1.length < 32) _unmask(buffer$1, mask);
			else bufferUtil$1.unmask(buffer$1, mask);
		};
	} catch (e) {}
} });

//#endregion
//#region node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({ "node_modules/ws/lib/limiter.js"(exports, module) {
	const kDone = Symbol("kDone");
	const kRun = Symbol("kRun");
	/**
	* A very simple job queue with adjustable concurrency. Adapted from
	* https://github.com/STRML/async-limiter
	*/
	var Limiter$1 = class {
		/**
		* Creates a new `Limiter`.
		*
		* @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
		*     to run concurrently
		*/
		constructor(concurrency) {
			this[kDone] = () => {
				this.pending--;
				this[kRun]();
			};
			this.concurrency = concurrency || Infinity;
			this.jobs = [];
			this.pending = 0;
		}
		/**
		* Adds a job to the queue.
		*
		* @param {Function} job The job to run
		* @public
		*/
		add(job) {
			this.jobs.push(job);
			this[kRun]();
		}
		/**
		* Removes a job from the queue and runs it if possible.
		*
		* @private
		*/
		[kRun]() {
			if (this.pending === this.concurrency) return;
			if (this.jobs.length) {
				const job = this.jobs.shift();
				this.pending++;
				job(this[kDone]);
			}
		}
	};
	module.exports = Limiter$1;
} });

//#endregion
//#region node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({ "node_modules/ws/lib/permessage-deflate.js"(exports, module) {
	const zlib = require("zlib");
	const bufferUtil = require_buffer_util();
	const Limiter = require_limiter();
	const { kStatusCode: kStatusCode$2 } = require_constants();
	const FastBuffer$1 = Buffer[Symbol.species];
	const TRAILER = Buffer.from([
		0,
		0,
		255,
		255
	]);
	const kPerMessageDeflate = Symbol("permessage-deflate");
	const kTotalLength = Symbol("total-length");
	const kCallback = Symbol("callback");
	const kBuffers = Symbol("buffers");
	const kError$1 = Symbol("error");
	let zlibLimiter;
	/**
	* permessage-deflate implementation.
	*/
	var PerMessageDeflate$4 = class {
		/**
		* Creates a PerMessageDeflate instance.
		*
		* @param {Object} [options] Configuration options
		* @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
		*     for, or request, a custom client window size
		* @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
		*     acknowledge disabling of client context takeover
		* @param {Number} [options.concurrencyLimit=10] The number of concurrent
		*     calls to zlib
		* @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
		*     use of a custom server window size
		* @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
		*     disabling of server context takeover
		* @param {Number} [options.threshold=1024] Size (in bytes) below which
		*     messages should not be compressed if context takeover is disabled
		* @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
		*     deflate
		* @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
		*     inflate
		* @param {Boolean} [isServer=false] Create the instance in either server or
		*     client mode
		* @param {Number} [maxPayload=0] The maximum allowed message length
		*/
		constructor(options, isServer, maxPayload) {
			this._maxPayload = maxPayload | 0;
			this._options = options || {};
			this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
			this._isServer = !!isServer;
			this._deflate = null;
			this._inflate = null;
			this.params = null;
			if (!zlibLimiter) {
				const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
				zlibLimiter = new Limiter(concurrency);
			}
		}
		/**
		* @type {String}
		*/
		static get extensionName() {
			return "permessage-deflate";
		}
		/**
		* Create an extension negotiation offer.
		*
		* @return {Object} Extension parameters
		* @public
		*/
		offer() {
			const params = {};
			if (this._options.serverNoContextTakeover) params.server_no_context_takeover = true;
			if (this._options.clientNoContextTakeover) params.client_no_context_takeover = true;
			if (this._options.serverMaxWindowBits) params.server_max_window_bits = this._options.serverMaxWindowBits;
			if (this._options.clientMaxWindowBits) params.client_max_window_bits = this._options.clientMaxWindowBits;
			else if (this._options.clientMaxWindowBits == null) params.client_max_window_bits = true;
			return params;
		}
		/**
		* Accept an extension negotiation offer/response.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Object} Accepted configuration
		* @public
		*/
		accept(configurations) {
			configurations = this.normalizeParams(configurations);
			this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
			return this.params;
		}
		/**
		* Releases all resources used by the extension.
		*
		* @public
		*/
		cleanup() {
			if (this._inflate) {
				this._inflate.close();
				this._inflate = null;
			}
			if (this._deflate) {
				const callback = this._deflate[kCallback];
				this._deflate.close();
				this._deflate = null;
				if (callback) callback(new Error("The deflate stream was closed while data was being processed"));
			}
		}
		/**
		*  Accept an extension negotiation offer.
		*
		* @param {Array} offers The extension negotiation offers
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsServer(offers) {
			const opts = this._options;
			const accepted = offers.find((params) => {
				if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) return false;
				return true;
			});
			if (!accepted) throw new Error("None of the extension offers can be accepted");
			if (opts.serverNoContextTakeover) accepted.server_no_context_takeover = true;
			if (opts.clientNoContextTakeover) accepted.client_no_context_takeover = true;
			if (typeof opts.serverMaxWindowBits === "number") accepted.server_max_window_bits = opts.serverMaxWindowBits;
			if (typeof opts.clientMaxWindowBits === "number") accepted.client_max_window_bits = opts.clientMaxWindowBits;
			else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) delete accepted.client_max_window_bits;
			return accepted;
		}
		/**
		* Accept the extension negotiation response.
		*
		* @param {Array} response The extension negotiation response
		* @return {Object} Accepted configuration
		* @private
		*/
		acceptAsClient(response) {
			const params = response[0];
			if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) throw new Error("Unexpected parameter \"client_no_context_takeover\"");
			if (!params.client_max_window_bits) {
				if (typeof this._options.clientMaxWindowBits === "number") params.client_max_window_bits = this._options.clientMaxWindowBits;
			} else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) throw new Error("Unexpected or invalid parameter \"client_max_window_bits\"");
			return params;
		}
		/**
		* Normalize parameters.
		*
		* @param {Array} configurations The extension negotiation offers/reponse
		* @return {Array} The offers/response with normalized parameters
		* @private
		*/
		normalizeParams(configurations) {
			configurations.forEach((params) => {
				Object.keys(params).forEach((key) => {
					let value = params[key];
					if (value.length > 1) throw new Error(`Parameter "${key}" must have only a single value`);
					value = value[0];
					if (key === "client_max_window_bits") {
						if (value !== true) {
							const num = +value;
							if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
							value = num;
						} else if (!this._isServer) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else if (key === "server_max_window_bits") {
						const num = +value;
						if (!Number.isInteger(num) || num < 8 || num > 15) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
						value = num;
					} else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
						if (value !== true) throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
					} else throw new Error(`Unknown parameter "${key}"`);
					params[key] = value;
				});
			});
			return configurations;
		}
		/**
		* Decompress data. Concurrency limited.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		decompress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._decompress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Compress data. Concurrency limited.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @public
		*/
		compress(data, fin, callback) {
			zlibLimiter.add((done) => {
				this._compress(data, fin, (err, result) => {
					done();
					callback(err, result);
				});
			});
		}
		/**
		* Decompress data.
		*
		* @param {Buffer} data Compressed data
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_decompress(data, fin, callback) {
			const endpoint$1 = this._isServer ? "client" : "server";
			if (!this._inflate) {
				const key = `${endpoint$1}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._inflate = zlib.createInflateRaw({
					...this._options.zlibInflateOptions,
					windowBits
				});
				this._inflate[kPerMessageDeflate] = this;
				this._inflate[kTotalLength] = 0;
				this._inflate[kBuffers] = [];
				this._inflate.on("error", inflateOnError);
				this._inflate.on("data", inflateOnData);
			}
			this._inflate[kCallback] = callback;
			this._inflate.write(data);
			if (fin) this._inflate.write(TRAILER);
			this._inflate.flush(() => {
				const err = this._inflate[kError$1];
				if (err) {
					this._inflate.close();
					this._inflate = null;
					callback(err);
					return;
				}
				const data$1 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
				if (this._inflate._readableState.endEmitted) {
					this._inflate.close();
					this._inflate = null;
				} else {
					this._inflate[kTotalLength] = 0;
					this._inflate[kBuffers] = [];
					if (fin && this.params[`${endpoint$1}_no_context_takeover`]) this._inflate.reset();
				}
				callback(null, data$1);
			});
		}
		/**
		* Compress data.
		*
		* @param {(Buffer|String)} data Data to compress
		* @param {Boolean} fin Specifies whether or not this is the last fragment
		* @param {Function} callback Callback
		* @private
		*/
		_compress(data, fin, callback) {
			const endpoint$1 = this._isServer ? "server" : "client";
			if (!this._deflate) {
				const key = `${endpoint$1}_max_window_bits`;
				const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
				this._deflate = zlib.createDeflateRaw({
					...this._options.zlibDeflateOptions,
					windowBits
				});
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				this._deflate.on("data", deflateOnData);
			}
			this._deflate[kCallback] = callback;
			this._deflate.write(data);
			this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
				if (!this._deflate) return;
				let data$1 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
				if (fin) data$1 = new FastBuffer$1(data$1.buffer, data$1.byteOffset, data$1.length - 4);
				this._deflate[kCallback] = null;
				this._deflate[kTotalLength] = 0;
				this._deflate[kBuffers] = [];
				if (fin && this.params[`${endpoint$1}_no_context_takeover`]) this._deflate.reset();
				callback(null, data$1);
			});
		}
	};
	module.exports = PerMessageDeflate$4;
	/**
	* The listener of the `zlib.DeflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function deflateOnData(chunk) {
		this[kBuffers].push(chunk);
		this[kTotalLength] += chunk.length;
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function inflateOnData(chunk) {
		this[kTotalLength] += chunk.length;
		if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
			this[kBuffers].push(chunk);
			return;
		}
		this[kError$1] = new RangeError("Max payload size exceeded");
		this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
		this[kError$1][kStatusCode$2] = 1009;
		this.removeListener("data", inflateOnData);
		this.reset();
	}
	/**
	* The listener of the `zlib.InflateRaw` stream `'error'` event.
	*
	* @param {Error} err The emitted error
	* @private
	*/
	function inflateOnError(err) {
		this[kPerMessageDeflate]._inflate = null;
		err[kStatusCode$2] = 1007;
		this[kCallback](err);
	}
} });

//#endregion
//#region node_modules/ws/lib/validation.js
var require_validation = __commonJS({ "node_modules/ws/lib/validation.js"(exports, module) {
	const { isUtf8 } = require("buffer");
	const { hasBlob } = require_constants();
	const tokenChars$2 = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		1,
		1,
		0,
		1,
		1,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		1,
		0,
		1,
		0
	];
	/**
	* Checks if a status code is allowed in a close frame.
	*
	* @param {Number} code The status code
	* @return {Boolean} `true` if the status code is valid, else `false`
	* @public
	*/
	function isValidStatusCode$2(code$1) {
		return code$1 >= 1e3 && code$1 <= 1014 && code$1 !== 1004 && code$1 !== 1005 && code$1 !== 1006 || code$1 >= 3e3 && code$1 <= 4999;
	}
	/**
	* Checks if a given buffer contains only correct UTF-8.
	* Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
	* Markus Kuhn.
	*
	* @param {Buffer} buf The buffer to check
	* @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
	* @public
	*/
	function _isValidUTF8(buf) {
		const len$1 = buf.length;
		let i$1 = 0;
		while (i$1 < len$1) if ((buf[i$1] & 128) === 0) i$1++;
		else if ((buf[i$1] & 224) === 192) {
			if (i$1 + 1 === len$1 || (buf[i$1 + 1] & 192) !== 128 || (buf[i$1] & 254) === 192) return false;
			i$1 += 2;
		} else if ((buf[i$1] & 240) === 224) {
			if (i$1 + 2 >= len$1 || (buf[i$1 + 1] & 192) !== 128 || (buf[i$1 + 2] & 192) !== 128 || buf[i$1] === 224 && (buf[i$1 + 1] & 224) === 128 || buf[i$1] === 237 && (buf[i$1 + 1] & 224) === 160) return false;
			i$1 += 3;
		} else if ((buf[i$1] & 248) === 240) {
			if (i$1 + 3 >= len$1 || (buf[i$1 + 1] & 192) !== 128 || (buf[i$1 + 2] & 192) !== 128 || (buf[i$1 + 3] & 192) !== 128 || buf[i$1] === 240 && (buf[i$1 + 1] & 240) === 128 || buf[i$1] === 244 && buf[i$1 + 1] > 143 || buf[i$1] > 244) return false;
			i$1 += 4;
		} else return false;
		return true;
	}
	/**
	* Determines whether a value is a `Blob`.
	*
	* @param {*} value The value to be tested
	* @return {Boolean} `true` if `value` is a `Blob`, else `false`
	* @private
	*/
	function isBlob$2(value) {
		return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
	}
	module.exports = {
		isBlob: isBlob$2,
		isValidStatusCode: isValidStatusCode$2,
		isValidUTF8: _isValidUTF8,
		tokenChars: tokenChars$2
	};
	if (isUtf8) module.exports.isValidUTF8 = function(buf) {
		return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
	};
	else if (!process.env.WS_NO_UTF_8_VALIDATE) try {
		const isValidUTF8$1 = require("utf-8-validate");
		module.exports.isValidUTF8 = function(buf) {
			return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8$1(buf);
		};
	} catch (e) {}
} });

//#endregion
//#region node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({ "node_modules/ws/lib/receiver.js"(exports, module) {
	const { Writable } = require("stream");
	const PerMessageDeflate$3 = require_permessage_deflate();
	const { BINARY_TYPES: BINARY_TYPES$1, EMPTY_BUFFER: EMPTY_BUFFER$2, kStatusCode: kStatusCode$1, kWebSocket: kWebSocket$3 } = require_constants();
	const { concat, toArrayBuffer, unmask } = require_buffer_util();
	const { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = require_validation();
	const FastBuffer = Buffer[Symbol.species];
	const GET_INFO = 0;
	const GET_PAYLOAD_LENGTH_16 = 1;
	const GET_PAYLOAD_LENGTH_64 = 2;
	const GET_MASK = 3;
	const GET_DATA = 4;
	const INFLATING = 5;
	const DEFER_EVENT = 6;
	/**
	* HyBi Receiver implementation.
	*
	* @extends Writable
	*/
	var Receiver$1 = class extends Writable {
		/**
		* Creates a Receiver instance.
		*
		* @param {Object} [options] Options object
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {String} [options.binaryType=nodebuffer] The type for binary data
		* @param {Object} [options.extensions] An object containing the negotiated
		*     extensions
		* @param {Boolean} [options.isServer=false] Specifies whether to operate in
		*     client or server mode
		* @param {Number} [options.maxPayload=0] The maximum allowed message length
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		*/
		constructor(options = {}) {
			super();
			this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
			this._binaryType = options.binaryType || BINARY_TYPES$1[0];
			this._extensions = options.extensions || {};
			this._isServer = !!options.isServer;
			this._maxPayload = options.maxPayload | 0;
			this._skipUTF8Validation = !!options.skipUTF8Validation;
			this[kWebSocket$3] = void 0;
			this._bufferedBytes = 0;
			this._buffers = [];
			this._compressed = false;
			this._payloadLength = 0;
			this._mask = void 0;
			this._fragmented = 0;
			this._masked = false;
			this._fin = false;
			this._opcode = 0;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragments = [];
			this._errored = false;
			this._loop = false;
			this._state = GET_INFO;
		}
		/**
		* Implements `Writable.prototype._write()`.
		*
		* @param {Buffer} chunk The chunk of data to write
		* @param {String} encoding The character encoding of `chunk`
		* @param {Function} cb Callback
		* @private
		*/
		_write(chunk, encoding, cb) {
			if (this._opcode === 8 && this._state == GET_INFO) return cb();
			this._bufferedBytes += chunk.length;
			this._buffers.push(chunk);
			this.startLoop(cb);
		}
		/**
		* Consumes `n` bytes from the buffered data.
		*
		* @param {Number} n The number of bytes to consume
		* @return {Buffer} The consumed bytes
		* @private
		*/
		consume(n) {
			this._bufferedBytes -= n;
			if (n === this._buffers[0].length) return this._buffers.shift();
			if (n < this._buffers[0].length) {
				const buf = this._buffers[0];
				this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				return new FastBuffer(buf.buffer, buf.byteOffset, n);
			}
			const dst = Buffer.allocUnsafe(n);
			do {
				const buf = this._buffers[0];
				const offset = dst.length - n;
				if (n >= buf.length) dst.set(this._buffers.shift(), offset);
				else {
					dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
					this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
				}
				n -= buf.length;
			} while (n > 0);
			return dst;
		}
		/**
		* Starts the parsing loop.
		*
		* @param {Function} cb Callback
		* @private
		*/
		startLoop(cb) {
			this._loop = true;
			do
				switch (this._state) {
					case GET_INFO:
						this.getInfo(cb);
						break;
					case GET_PAYLOAD_LENGTH_16:
						this.getPayloadLength16(cb);
						break;
					case GET_PAYLOAD_LENGTH_64:
						this.getPayloadLength64(cb);
						break;
					case GET_MASK:
						this.getMask();
						break;
					case GET_DATA:
						this.getData(cb);
						break;
					case INFLATING:
					case DEFER_EVENT:
						this._loop = false;
						return;
				}
			while (this._loop);
			if (!this._errored) cb();
		}
		/**
		* Reads the first two bytes of a frame.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getInfo(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			const buf = this.consume(2);
			if ((buf[0] & 48) !== 0) {
				const error$1 = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
				cb(error$1);
				return;
			}
			const compressed = (buf[0] & 64) === 64;
			if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
				const error$1 = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
				cb(error$1);
				return;
			}
			this._fin = (buf[0] & 128) === 128;
			this._opcode = buf[0] & 15;
			this._payloadLength = buf[1] & 127;
			if (this._opcode === 0) {
				if (compressed) {
					const error$1 = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
					cb(error$1);
					return;
				}
				if (!this._fragmented) {
					const error$1 = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
					cb(error$1);
					return;
				}
				this._opcode = this._fragmented;
			} else if (this._opcode === 1 || this._opcode === 2) {
				if (this._fragmented) {
					const error$1 = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
					cb(error$1);
					return;
				}
				this._compressed = compressed;
			} else if (this._opcode > 7 && this._opcode < 11) {
				if (!this._fin) {
					const error$1 = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
					cb(error$1);
					return;
				}
				if (compressed) {
					const error$1 = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
					cb(error$1);
					return;
				}
				if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
					const error$1 = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
					cb(error$1);
					return;
				}
			} else {
				const error$1 = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
				cb(error$1);
				return;
			}
			if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
			this._masked = (buf[1] & 128) === 128;
			if (this._isServer) {
				if (!this._masked) {
					const error$1 = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
					cb(error$1);
					return;
				}
			} else if (this._masked) {
				const error$1 = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
				cb(error$1);
				return;
			}
			if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
			else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
			else this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+16).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength16(cb) {
			if (this._bufferedBytes < 2) {
				this._loop = false;
				return;
			}
			this._payloadLength = this.consume(2).readUInt16BE(0);
			this.haveLength(cb);
		}
		/**
		* Gets extended payload length (7+64).
		*
		* @param {Function} cb Callback
		* @private
		*/
		getPayloadLength64(cb) {
			if (this._bufferedBytes < 8) {
				this._loop = false;
				return;
			}
			const buf = this.consume(8);
			const num = buf.readUInt32BE(0);
			if (num > Math.pow(2, 21) - 1) {
				const error$1 = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
				cb(error$1);
				return;
			}
			this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
			this.haveLength(cb);
		}
		/**
		* Payload length has been read.
		*
		* @param {Function} cb Callback
		* @private
		*/
		haveLength(cb) {
			if (this._payloadLength && this._opcode < 8) {
				this._totalPayloadLength += this._payloadLength;
				if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
					const error$1 = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
					cb(error$1);
					return;
				}
			}
			if (this._masked) this._state = GET_MASK;
			else this._state = GET_DATA;
		}
		/**
		* Reads mask bytes.
		*
		* @private
		*/
		getMask() {
			if (this._bufferedBytes < 4) {
				this._loop = false;
				return;
			}
			this._mask = this.consume(4);
			this._state = GET_DATA;
		}
		/**
		* Reads data bytes.
		*
		* @param {Function} cb Callback
		* @private
		*/
		getData(cb) {
			let data = EMPTY_BUFFER$2;
			if (this._payloadLength) {
				if (this._bufferedBytes < this._payloadLength) {
					this._loop = false;
					return;
				}
				data = this.consume(this._payloadLength);
				if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) unmask(data, this._mask);
			}
			if (this._opcode > 7) {
				this.controlMessage(data, cb);
				return;
			}
			if (this._compressed) {
				this._state = INFLATING;
				this.decompress(data, cb);
				return;
			}
			if (data.length) {
				this._messageLength = this._totalPayloadLength;
				this._fragments.push(data);
			}
			this.dataMessage(cb);
		}
		/**
		* Decompresses data.
		*
		* @param {Buffer} data Compressed data
		* @param {Function} cb Callback
		* @private
		*/
		decompress(data, cb) {
			const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
			perMessageDeflate.decompress(data, this._fin, (err, buf) => {
				if (err) return cb(err);
				if (buf.length) {
					this._messageLength += buf.length;
					if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
						const error$1 = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
						cb(error$1);
						return;
					}
					this._fragments.push(buf);
				}
				this.dataMessage(cb);
				if (this._state === GET_INFO) this.startLoop(cb);
			});
		}
		/**
		* Handles a data message.
		*
		* @param {Function} cb Callback
		* @private
		*/
		dataMessage(cb) {
			if (!this._fin) {
				this._state = GET_INFO;
				return;
			}
			const messageLength = this._messageLength;
			const fragments = this._fragments;
			this._totalPayloadLength = 0;
			this._messageLength = 0;
			this._fragmented = 0;
			this._fragments = [];
			if (this._opcode === 2) {
				let data;
				if (this._binaryType === "nodebuffer") data = concat(fragments, messageLength);
				else if (this._binaryType === "arraybuffer") data = toArrayBuffer(concat(fragments, messageLength));
				else if (this._binaryType === "blob") data = new Blob(fragments);
				else data = fragments;
				if (this._allowSynchronousEvents) {
					this.emit("message", data, true);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", data, true);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			} else {
				const buf = concat(fragments, messageLength);
				if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
					const error$1 = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
					cb(error$1);
					return;
				}
				if (this._state === INFLATING || this._allowSynchronousEvents) {
					this.emit("message", buf, false);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit("message", buf, false);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			}
		}
		/**
		* Handles a control message.
		*
		* @param {Buffer} data Data to handle
		* @return {(Error|RangeError|undefined)} A possible error
		* @private
		*/
		controlMessage(data, cb) {
			if (this._opcode === 8) {
				if (data.length === 0) {
					this._loop = false;
					this.emit("conclude", 1005, EMPTY_BUFFER$2);
					this.end();
				} else {
					const code$1 = data.readUInt16BE(0);
					if (!isValidStatusCode$1(code$1)) {
						const error$1 = this.createError(RangeError, `invalid status code ${code$1}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
						cb(error$1);
						return;
					}
					const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
					if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
						const error$1 = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
						cb(error$1);
						return;
					}
					this._loop = false;
					this.emit("conclude", code$1, buf);
					this.end();
				}
				this._state = GET_INFO;
				return;
			}
			if (this._allowSynchronousEvents) {
				this.emit(this._opcode === 9 ? "ping" : "pong", data);
				this._state = GET_INFO;
			} else {
				this._state = DEFER_EVENT;
				setImmediate(() => {
					this.emit(this._opcode === 9 ? "ping" : "pong", data);
					this._state = GET_INFO;
					this.startLoop(cb);
				});
			}
		}
		/**
		* Builds an error object.
		*
		* @param {function(new:Error|RangeError)} ErrorCtor The error constructor
		* @param {String} message The error message
		* @param {Boolean} prefix Specifies whether or not to add a default prefix to
		*     `message`
		* @param {Number} statusCode The status code
		* @param {String} errorCode The exposed error code
		* @return {(Error|RangeError)} The error
		* @private
		*/
		createError(ErrorCtor, message, prefix, statusCode, errorCode) {
			this._loop = false;
			this._errored = true;
			const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
			Error.captureStackTrace(err, this.createError);
			err.code = errorCode;
			err[kStatusCode$1] = statusCode;
			return err;
		}
	};
	module.exports = Receiver$1;
} });

//#endregion
//#region node_modules/ws/lib/sender.js
var require_sender = __commonJS({ "node_modules/ws/lib/sender.js"(exports, module) {
	const { Duplex: Duplex$3 } = require("stream");
	const { randomFillSync } = require("crypto");
	const PerMessageDeflate$2 = require_permessage_deflate();
	const { EMPTY_BUFFER: EMPTY_BUFFER$1, kWebSocket: kWebSocket$2, NOOP: NOOP$1 } = require_constants();
	const { isBlob: isBlob$1, isValidStatusCode } = require_validation();
	const { mask: applyMask, toBuffer: toBuffer$1 } = require_buffer_util();
	const kByteLength = Symbol("kByteLength");
	const maskBuffer = Buffer.alloc(4);
	const RANDOM_POOL_SIZE = 8 * 1024;
	let randomPool;
	let randomPoolPointer = RANDOM_POOL_SIZE;
	const DEFAULT = 0;
	const DEFLATING = 1;
	const GET_BLOB_DATA = 2;
	/**
	* HyBi Sender implementation.
	*/
	var Sender$1 = class Sender$1 {
		/**
		* Creates a Sender instance.
		*
		* @param {Duplex} socket The connection socket
		* @param {Object} [extensions] An object containing the negotiated extensions
		* @param {Function} [generateMask] The function used to generate the masking
		*     key
		*/
		constructor(socket, extensions, generateMask) {
			this._extensions = extensions || {};
			if (generateMask) {
				this._generateMask = generateMask;
				this._maskBuffer = Buffer.alloc(4);
			}
			this._socket = socket;
			this._firstFragment = true;
			this._compress = false;
			this._bufferedBytes = 0;
			this._queue = [];
			this._state = DEFAULT;
			this.onerror = NOOP$1;
			this[kWebSocket$2] = void 0;
		}
		/**
		* Frames a piece of data according to the HyBi WebSocket protocol.
		*
		* @param {(Buffer|String)} data The data to frame
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @return {(Buffer|String)[]} The framed data
		* @public
		*/
		static frame(data, options) {
			let mask;
			let merge$1 = false;
			let offset = 2;
			let skipMasking = false;
			if (options.mask) {
				mask = options.maskBuffer || maskBuffer;
				if (options.generateMask) options.generateMask(mask);
				else {
					if (randomPoolPointer === RANDOM_POOL_SIZE) {
						/* istanbul ignore else  */
						if (randomPool === void 0) randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
						randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
						randomPoolPointer = 0;
					}
					mask[0] = randomPool[randomPoolPointer++];
					mask[1] = randomPool[randomPoolPointer++];
					mask[2] = randomPool[randomPoolPointer++];
					mask[3] = randomPool[randomPoolPointer++];
				}
				skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
				offset = 6;
			}
			let dataLength;
			if (typeof data === "string") if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) dataLength = options[kByteLength];
			else {
				data = Buffer.from(data);
				dataLength = data.length;
			}
			else {
				dataLength = data.length;
				merge$1 = options.mask && options.readOnly && !skipMasking;
			}
			let payloadLength = dataLength;
			if (dataLength >= 65536) {
				offset += 8;
				payloadLength = 127;
			} else if (dataLength > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const target = Buffer.allocUnsafe(merge$1 ? dataLength + offset : offset);
			target[0] = options.fin ? options.opcode | 128 : options.opcode;
			if (options.rsv1) target[0] |= 64;
			target[1] = payloadLength;
			if (payloadLength === 126) target.writeUInt16BE(dataLength, 2);
			else if (payloadLength === 127) {
				target[2] = target[3] = 0;
				target.writeUIntBE(dataLength, 4, 6);
			}
			if (!options.mask) return [target, data];
			target[1] |= 128;
			target[offset - 4] = mask[0];
			target[offset - 3] = mask[1];
			target[offset - 2] = mask[2];
			target[offset - 1] = mask[3];
			if (skipMasking) return [target, data];
			if (merge$1) {
				applyMask(data, mask, target, offset, dataLength);
				return [target];
			}
			applyMask(data, mask, data, 0, dataLength);
			return [target, data];
		}
		/**
		* Sends a close message to the other peer.
		*
		* @param {Number} [code] The status code component of the body
		* @param {(String|Buffer)} [data] The message component of the body
		* @param {Boolean} [mask=false] Specifies whether or not to mask the message
		* @param {Function} [cb] Callback
		* @public
		*/
		close(code$1, data, mask, cb) {
			let buf;
			if (code$1 === void 0) buf = EMPTY_BUFFER$1;
			else if (typeof code$1 !== "number" || !isValidStatusCode(code$1)) throw new TypeError("First argument must be a valid error code number");
			else if (data === void 0 || !data.length) {
				buf = Buffer.allocUnsafe(2);
				buf.writeUInt16BE(code$1, 0);
			} else {
				const length = Buffer.byteLength(data);
				if (length > 123) throw new RangeError("The message must not be greater than 123 bytes");
				buf = Buffer.allocUnsafe(2 + length);
				buf.writeUInt16BE(code$1, 0);
				if (typeof data === "string") buf.write(data, 2);
				else buf.set(data, 2);
			}
			const options = {
				[kByteLength]: buf.length,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 8,
				readOnly: false,
				rsv1: false
			};
			if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				buf,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender$1.frame(buf, options), cb);
		}
		/**
		* Sends a ping message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		ping(data, mask, cb) {
			let byteLength$1;
			let readOnly;
			if (typeof data === "string") {
				byteLength$1 = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength$1 = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength$1 = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (byteLength$1 > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength$1,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 9,
				readOnly,
				rsv1: false
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender$1.frame(data, options), cb);
		}
		/**
		* Sends a pong message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Boolean} [mask=false] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		pong(data, mask, cb) {
			let byteLength$1;
			let readOnly;
			if (typeof data === "string") {
				byteLength$1 = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength$1 = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength$1 = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (byteLength$1 > 125) throw new RangeError("The data size must not be greater than 125 bytes");
			const options = {
				[kByteLength]: byteLength$1,
				fin: true,
				generateMask: this._generateMask,
				mask,
				maskBuffer: this._maskBuffer,
				opcode: 10,
				readOnly,
				rsv1: false
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				false,
				options,
				cb
			]);
			else this.getBlobData(data, false, options, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				false,
				options,
				cb
			]);
			else this.sendFrame(Sender$1.frame(data, options), cb);
		}
		/**
		* Sends a data message to the other peer.
		*
		* @param {*} data The message to send
		* @param {Object} options Options object
		* @param {Boolean} [options.binary=false] Specifies whether `data` is binary
		*     or text
		* @param {Boolean} [options.compress=false] Specifies whether or not to
		*     compress `data`
		* @param {Boolean} [options.fin=false] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Function} [cb] Callback
		* @public
		*/
		send(data, options, cb) {
			const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
			let opcode = options.binary ? 2 : 1;
			let rsv1 = options.compress;
			let byteLength$1;
			let readOnly;
			if (typeof data === "string") {
				byteLength$1 = Buffer.byteLength(data);
				readOnly = false;
			} else if (isBlob$1(data)) {
				byteLength$1 = data.size;
				readOnly = false;
			} else {
				data = toBuffer$1(data);
				byteLength$1 = data.length;
				readOnly = toBuffer$1.readOnly;
			}
			if (this._firstFragment) {
				this._firstFragment = false;
				if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) rsv1 = byteLength$1 >= perMessageDeflate._threshold;
				this._compress = rsv1;
			} else {
				rsv1 = false;
				opcode = 0;
			}
			if (options.fin) this._firstFragment = true;
			const opts = {
				[kByteLength]: byteLength$1,
				fin: options.fin,
				generateMask: this._generateMask,
				mask: options.mask,
				maskBuffer: this._maskBuffer,
				opcode,
				readOnly,
				rsv1
			};
			if (isBlob$1(data)) if (this._state !== DEFAULT) this.enqueue([
				this.getBlobData,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.getBlobData(data, this._compress, opts, cb);
			else if (this._state !== DEFAULT) this.enqueue([
				this.dispatch,
				data,
				this._compress,
				opts,
				cb
			]);
			else this.dispatch(data, this._compress, opts, cb);
		}
		/**
		* Gets the contents of a blob as binary data.
		*
		* @param {Blob} blob The blob
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     the data
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		getBlobData(blob, compress, options, cb) {
			this._bufferedBytes += options[kByteLength];
			this._state = GET_BLOB_DATA;
			blob.arrayBuffer().then((arrayBuffer) => {
				if (this._socket.destroyed) {
					const err = new Error("The socket was closed while the blob was being read");
					process.nextTick(callCallbacks, this, err, cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				const data = toBuffer$1(arrayBuffer);
				if (!compress) {
					this._state = DEFAULT;
					this.sendFrame(Sender$1.frame(data, options), cb);
					this.dequeue();
				} else this.dispatch(data, compress, options, cb);
			}).catch((err) => {
				process.nextTick(onError, this, err, cb);
			});
		}
		/**
		* Dispatches a message.
		*
		* @param {(Buffer|String)} data The message to send
		* @param {Boolean} [compress=false] Specifies whether or not to compress
		*     `data`
		* @param {Object} options Options object
		* @param {Boolean} [options.fin=false] Specifies whether or not to set the
		*     FIN bit
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Boolean} [options.mask=false] Specifies whether or not to mask
		*     `data`
		* @param {Buffer} [options.maskBuffer] The buffer used to store the masking
		*     key
		* @param {Number} options.opcode The opcode
		* @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
		*     modified
		* @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
		*     RSV1 bit
		* @param {Function} [cb] Callback
		* @private
		*/
		dispatch(data, compress, options, cb) {
			if (!compress) {
				this.sendFrame(Sender$1.frame(data, options), cb);
				return;
			}
			const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
			this._bufferedBytes += options[kByteLength];
			this._state = DEFLATING;
			perMessageDeflate.compress(data, options.fin, (_, buf) => {
				if (this._socket.destroyed) {
					const err = new Error("The socket was closed while data was being compressed");
					callCallbacks(this, err, cb);
					return;
				}
				this._bufferedBytes -= options[kByteLength];
				this._state = DEFAULT;
				options.readOnly = false;
				this.sendFrame(Sender$1.frame(buf, options), cb);
				this.dequeue();
			});
		}
		/**
		* Executes queued send operations.
		*
		* @private
		*/
		dequeue() {
			while (this._state === DEFAULT && this._queue.length) {
				const params = this._queue.shift();
				this._bufferedBytes -= params[3][kByteLength];
				Reflect.apply(params[0], this, params.slice(1));
			}
		}
		/**
		* Enqueues a send operation.
		*
		* @param {Array} params Send operation parameters.
		* @private
		*/
		enqueue(params) {
			this._bufferedBytes += params[3][kByteLength];
			this._queue.push(params);
		}
		/**
		* Sends a frame.
		*
		* @param {(Buffer | String)[]} list The frame to send
		* @param {Function} [cb] Callback
		* @private
		*/
		sendFrame(list, cb) {
			if (list.length === 2) {
				this._socket.cork();
				this._socket.write(list[0]);
				this._socket.write(list[1], cb);
				this._socket.uncork();
			} else this._socket.write(list[0], cb);
		}
	};
	module.exports = Sender$1;
	/**
	* Calls queued callbacks with an error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error to call the callbacks with
	* @param {Function} [cb] The first callback
	* @private
	*/
	function callCallbacks(sender, err, cb) {
		if (typeof cb === "function") cb(err);
		for (let i$1 = 0; i$1 < sender._queue.length; i$1++) {
			const params = sender._queue[i$1];
			const callback = params[params.length - 1];
			if (typeof callback === "function") callback(err);
		}
	}
	/**
	* Handles a `Sender` error.
	*
	* @param {Sender} sender The `Sender` instance
	* @param {Error} err The error
	* @param {Function} [cb] The first pending callback
	* @private
	*/
	function onError(sender, err, cb) {
		callCallbacks(sender, err, cb);
		sender.onerror(err);
	}
} });

//#endregion
//#region node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({ "node_modules/ws/lib/event-target.js"(exports, module) {
	const { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = require_constants();
	const kCode = Symbol("kCode");
	const kData = Symbol("kData");
	const kError = Symbol("kError");
	const kMessage = Symbol("kMessage");
	const kReason = Symbol("kReason");
	const kTarget = Symbol("kTarget");
	const kType = Symbol("kType");
	const kWasClean = Symbol("kWasClean");
	/**
	* Class representing an event.
	*/
	var Event$1 = class {
		/**
		* Create a new `Event`.
		*
		* @param {String} type The name of the event
		* @throws {TypeError} If the `type` argument is not specified
		*/
		constructor(type) {
			this[kTarget] = null;
			this[kType] = type;
		}
		/**
		* @type {*}
		*/
		get target() {
			return this[kTarget];
		}
		/**
		* @type {String}
		*/
		get type() {
			return this[kType];
		}
	};
	Object.defineProperty(Event$1.prototype, "target", { enumerable: true });
	Object.defineProperty(Event$1.prototype, "type", { enumerable: true });
	/**
	* Class representing a close event.
	*
	* @extends Event
	*/
	var CloseEvent = class extends Event$1 {
		/**
		* Create a new `CloseEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {Number} [options.code=0] The status code explaining why the
		*     connection was closed
		* @param {String} [options.reason=''] A human-readable string explaining why
		*     the connection was closed
		* @param {Boolean} [options.wasClean=false] Indicates whether or not the
		*     connection was cleanly closed
		*/
		constructor(type, options = {}) {
			super(type);
			this[kCode] = options.code === void 0 ? 0 : options.code;
			this[kReason] = options.reason === void 0 ? "" : options.reason;
			this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
		}
		/**
		* @type {Number}
		*/
		get code() {
			return this[kCode];
		}
		/**
		* @type {String}
		*/
		get reason() {
			return this[kReason];
		}
		/**
		* @type {Boolean}
		*/
		get wasClean() {
			return this[kWasClean];
		}
	};
	Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
	Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
	/**
	* Class representing an error event.
	*
	* @extends Event
	*/
	var ErrorEvent = class extends Event$1 {
		/**
		* Create a new `ErrorEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.error=null] The error that generated this event
		* @param {String} [options.message=''] The error message
		*/
		constructor(type, options = {}) {
			super(type);
			this[kError] = options.error === void 0 ? null : options.error;
			this[kMessage] = options.message === void 0 ? "" : options.message;
		}
		/**
		* @type {*}
		*/
		get error() {
			return this[kError];
		}
		/**
		* @type {String}
		*/
		get message() {
			return this[kMessage];
		}
	};
	Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
	Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
	/**
	* Class representing a message event.
	*
	* @extends Event
	*/
	var MessageEvent = class extends Event$1 {
		/**
		* Create a new `MessageEvent`.
		*
		* @param {String} type The name of the event
		* @param {Object} [options] A dictionary object that allows for setting
		*     attributes via object members of the same name
		* @param {*} [options.data=null] The message content
		*/
		constructor(type, options = {}) {
			super(type);
			this[kData] = options.data === void 0 ? null : options.data;
		}
		/**
		* @type {*}
		*/
		get data() {
			return this[kData];
		}
	};
	Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
	/**
	* This provides methods for emulating the `EventTarget` interface. It's not
	* meant to be used directly.
	*
	* @mixin
	*/
	const EventTarget$1 = {
		addEventListener(type, handler$1, options = {}) {
			for (const listener of this.listeners(type)) if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler$1 && !listener[kForOnEventAttribute$1]) return;
			let wrapper;
			if (type === "message") wrapper = function onMessage(data, isBinary) {
				const event = new MessageEvent("message", { data: isBinary ? data : data.toString() });
				event[kTarget] = this;
				callListener(handler$1, this, event);
			};
			else if (type === "close") wrapper = function onClose(code$1, message) {
				const event = new CloseEvent("close", {
					code: code$1,
					reason: message.toString(),
					wasClean: this._closeFrameReceived && this._closeFrameSent
				});
				event[kTarget] = this;
				callListener(handler$1, this, event);
			};
			else if (type === "error") wrapper = function onError$2(error$1) {
				const event = new ErrorEvent("error", {
					error: error$1,
					message: error$1.message
				});
				event[kTarget] = this;
				callListener(handler$1, this, event);
			};
			else if (type === "open") wrapper = function onOpen() {
				const event = new Event$1("open");
				event[kTarget] = this;
				callListener(handler$1, this, event);
			};
			else return;
			wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];
			wrapper[kListener$1] = handler$1;
			if (options.once) this.once(type, wrapper);
			else this.on(type, wrapper);
		},
		removeEventListener(type, handler$1) {
			for (const listener of this.listeners(type)) if (listener[kListener$1] === handler$1 && !listener[kForOnEventAttribute$1]) {
				this.removeListener(type, listener);
				break;
			}
		}
	};
	module.exports = {
		CloseEvent,
		ErrorEvent,
		Event: Event$1,
		EventTarget: EventTarget$1,
		MessageEvent
	};
	/**
	* Call an event listener
	*
	* @param {(Function|Object)} listener The listener to call
	* @param {*} thisArg The value to use as `this`` when calling the listener
	* @param {Event} event The event to pass to the listener
	* @private
	*/
	function callListener(listener, thisArg, event) {
		if (typeof listener === "object" && listener.handleEvent) listener.handleEvent.call(listener, event);
		else listener.call(thisArg, event);
	}
} });

//#endregion
//#region node_modules/ws/lib/extension.js
var require_extension = __commonJS({ "node_modules/ws/lib/extension.js"(exports, module) {
	const { tokenChars: tokenChars$1 } = require_validation();
	/**
	* Adds an offer to the map of extension offers or a parameter to the map of
	* parameters.
	*
	* @param {Object} dest The map of extension offers or parameters
	* @param {String} name The extension or parameter name
	* @param {(Object|Boolean|String)} elem The extension parameters or the
	*     parameter value
	* @private
	*/
	function push(dest, name, elem) {
		if (dest[name] === void 0) dest[name] = [elem];
		else dest[name].push(elem);
	}
	/**
	* Parses the `Sec-WebSocket-Extensions` header into an object.
	*
	* @param {String} header The field value of the header
	* @return {Object} The parsed object
	* @public
	*/
	function parse$3(header) {
		const offers = Object.create(null);
		let params = Object.create(null);
		let mustUnescape = false;
		let isEscaping = false;
		let inQuotes = false;
		let extensionName;
		let paramName;
		let start = -1;
		let code$1 = -1;
		let end = -1;
		let i$1 = 0;
		for (; i$1 < header.length; i$1++) {
			code$1 = header.charCodeAt(i$1);
			if (extensionName === void 0) if (end === -1 && tokenChars$1[code$1] === 1) {
				if (start === -1) start = i$1;
			} else if (i$1 !== 0 && (code$1 === 32 || code$1 === 9)) {
				if (end === -1 && start !== -1) end = i$1;
			} else if (code$1 === 59 || code$1 === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (end === -1) end = i$1;
				const name = header.slice(start, end);
				if (code$1 === 44) {
					push(offers, name, params);
					params = Object.create(null);
				} else extensionName = name;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$1}`);
			else if (paramName === void 0) if (end === -1 && tokenChars$1[code$1] === 1) {
				if (start === -1) start = i$1;
			} else if (code$1 === 32 || code$1 === 9) {
				if (end === -1 && start !== -1) end = i$1;
			} else if (code$1 === 59 || code$1 === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (end === -1) end = i$1;
				push(params, header.slice(start, end), true);
				if (code$1 === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				start = end = -1;
			} else if (code$1 === 61 && start !== -1 && end === -1) {
				paramName = header.slice(start, i$1);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$1}`);
			else if (isEscaping) {
				if (tokenChars$1[code$1] !== 1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (start === -1) start = i$1;
				else if (!mustUnescape) mustUnescape = true;
				isEscaping = false;
			} else if (inQuotes) if (tokenChars$1[code$1] === 1) {
				if (start === -1) start = i$1;
			} else if (code$1 === 34 && start !== -1) {
				inQuotes = false;
				end = i$1;
			} else if (code$1 === 92) isEscaping = true;
			else throw new SyntaxError(`Unexpected character at index ${i$1}`);
			else if (code$1 === 34 && header.charCodeAt(i$1 - 1) === 61) inQuotes = true;
			else if (end === -1 && tokenChars$1[code$1] === 1) {
				if (start === -1) start = i$1;
			} else if (start !== -1 && (code$1 === 32 || code$1 === 9)) {
				if (end === -1) end = i$1;
			} else if (code$1 === 59 || code$1 === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (end === -1) end = i$1;
				let value = header.slice(start, end);
				if (mustUnescape) {
					value = value.replace(/\\/g, "");
					mustUnescape = false;
				}
				push(params, paramName, value);
				if (code$1 === 44) {
					push(offers, extensionName, params);
					params = Object.create(null);
					extensionName = void 0;
				}
				paramName = void 0;
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$1}`);
		}
		if (start === -1 || inQuotes || code$1 === 32 || code$1 === 9) throw new SyntaxError("Unexpected end of input");
		if (end === -1) end = i$1;
		const token = header.slice(start, end);
		if (extensionName === void 0) push(offers, token, params);
		else {
			if (paramName === void 0) push(params, token, true);
			else if (mustUnescape) push(params, paramName, token.replace(/\\/g, ""));
			else push(params, paramName, token);
			push(offers, extensionName, params);
		}
		return offers;
	}
	/**
	* Builds the `Sec-WebSocket-Extensions` header field value.
	*
	* @param {Object} extensions The map of extensions and parameters to format
	* @return {String} A string representing the given object
	* @public
	*/
	function format$1(extensions) {
		return Object.keys(extensions).map((extension$1) => {
			let configurations = extensions[extension$1];
			if (!Array.isArray(configurations)) configurations = [configurations];
			return configurations.map((params) => {
				return [extension$1].concat(Object.keys(params).map((k) => {
					let values = params[k];
					if (!Array.isArray(values)) values = [values];
					return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
				})).join("; ");
			}).join(", ");
		}).join(", ");
	}
	module.exports = {
		format: format$1,
		parse: parse$3
	};
} });

//#endregion
//#region node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({ "node_modules/ws/lib/websocket.js"(exports, module) {
	const EventEmitter$1 = require("events");
	const https = require("https");
	const http$1 = require("http");
	const net = require("net");
	const tls = require("tls");
	const { randomBytes, createHash: createHash$1 } = require("crypto");
	const { Duplex: Duplex$2, Readable } = require("stream");
	const { URL: URL$1 } = require("url");
	const PerMessageDeflate$1 = require_permessage_deflate();
	const Receiver = require_receiver();
	const Sender = require_sender();
	const { isBlob } = require_validation();
	const { BINARY_TYPES, EMPTY_BUFFER, GUID: GUID$1, kForOnEventAttribute, kListener, kStatusCode, kWebSocket: kWebSocket$1, NOOP } = require_constants();
	const { EventTarget: { addEventListener, removeEventListener } } = require_event_target();
	const { format, parse: parse$2 } = require_extension();
	const { toBuffer } = require_buffer_util();
	const closeTimeout = 30 * 1e3;
	const kAborted = Symbol("kAborted");
	const protocolVersions = [8, 13];
	const readyStates = [
		"CONNECTING",
		"OPEN",
		"CLOSING",
		"CLOSED"
	];
	const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
	/**
	* Class representing a WebSocket.
	*
	* @extends EventEmitter
	*/
	var WebSocket$3 = class WebSocket$3 extends EventEmitter$1 {
		/**
		* Create a new `WebSocket`.
		*
		* @param {(String|URL)} address The URL to which to connect
		* @param {(String|String[])} [protocols] The subprotocols
		* @param {Object} [options] Connection options
		*/
		constructor(address, protocols, options) {
			super();
			this._binaryType = BINARY_TYPES[0];
			this._closeCode = 1006;
			this._closeFrameReceived = false;
			this._closeFrameSent = false;
			this._closeMessage = EMPTY_BUFFER;
			this._closeTimer = null;
			this._errorEmitted = false;
			this._extensions = {};
			this._paused = false;
			this._protocol = "";
			this._readyState = WebSocket$3.CONNECTING;
			this._receiver = null;
			this._sender = null;
			this._socket = null;
			if (address !== null) {
				this._bufferedAmount = 0;
				this._isServer = false;
				this._redirects = 0;
				if (protocols === void 0) protocols = [];
				else if (!Array.isArray(protocols)) if (typeof protocols === "object" && protocols !== null) {
					options = protocols;
					protocols = [];
				} else protocols = [protocols];
				initAsClient(this, address, protocols, options);
			} else {
				this._autoPong = options.autoPong;
				this._isServer = true;
			}
		}
		/**
		* For historical reasons, the custom "nodebuffer" type is used by the default
		* instead of "blob".
		*
		* @type {String}
		*/
		get binaryType() {
			return this._binaryType;
		}
		set binaryType(type) {
			if (!BINARY_TYPES.includes(type)) return;
			this._binaryType = type;
			if (this._receiver) this._receiver._binaryType = type;
		}
		/**
		* @type {Number}
		*/
		get bufferedAmount() {
			if (!this._socket) return this._bufferedAmount;
			return this._socket._writableState.length + this._sender._bufferedBytes;
		}
		/**
		* @type {String}
		*/
		get extensions() {
			return Object.keys(this._extensions).join();
		}
		/**
		* @type {Boolean}
		*/
		get isPaused() {
			return this._paused;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onclose() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onerror() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onopen() {
			return null;
		}
		/**
		* @type {Function}
		*/
		/* istanbul ignore next */
		get onmessage() {
			return null;
		}
		/**
		* @type {String}
		*/
		get protocol() {
			return this._protocol;
		}
		/**
		* @type {Number}
		*/
		get readyState() {
			return this._readyState;
		}
		/**
		* @type {String}
		*/
		get url() {
			return this._url;
		}
		/**
		* Set up the socket and the internal resources.
		*
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Object} options Options object
		* @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Function} [options.generateMask] The function used to generate the
		*     masking key
		* @param {Number} [options.maxPayload=0] The maximum allowed message size
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @private
		*/
		setSocket(socket, head, options) {
			const receiver = new Receiver({
				allowSynchronousEvents: options.allowSynchronousEvents,
				binaryType: this.binaryType,
				extensions: this._extensions,
				isServer: this._isServer,
				maxPayload: options.maxPayload,
				skipUTF8Validation: options.skipUTF8Validation
			});
			const sender = new Sender(socket, this._extensions, options.generateMask);
			this._receiver = receiver;
			this._sender = sender;
			this._socket = socket;
			receiver[kWebSocket$1] = this;
			sender[kWebSocket$1] = this;
			socket[kWebSocket$1] = this;
			receiver.on("conclude", receiverOnConclude);
			receiver.on("drain", receiverOnDrain);
			receiver.on("error", receiverOnError);
			receiver.on("message", receiverOnMessage);
			receiver.on("ping", receiverOnPing);
			receiver.on("pong", receiverOnPong);
			sender.onerror = senderOnError;
			if (socket.setTimeout) socket.setTimeout(0);
			if (socket.setNoDelay) socket.setNoDelay();
			if (head.length > 0) socket.unshift(head);
			socket.on("close", socketOnClose);
			socket.on("data", socketOnData);
			socket.on("end", socketOnEnd);
			socket.on("error", socketOnError$1);
			this._readyState = WebSocket$3.OPEN;
			this.emit("open");
		}
		/**
		* Emit the `'close'` event.
		*
		* @private
		*/
		emitClose() {
			if (!this._socket) {
				this._readyState = WebSocket$3.CLOSED;
				this.emit("close", this._closeCode, this._closeMessage);
				return;
			}
			if (this._extensions[PerMessageDeflate$1.extensionName]) this._extensions[PerMessageDeflate$1.extensionName].cleanup();
			this._receiver.removeAllListeners();
			this._readyState = WebSocket$3.CLOSED;
			this.emit("close", this._closeCode, this._closeMessage);
		}
		/**
		* Start a closing handshake.
		*
		*          +----------+   +-----------+   +----------+
		*     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
		*    |     +----------+   +-----------+   +----------+     |
		*          +----------+   +-----------+         |
		* CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
		*          +----------+   +-----------+   |
		*    |           |                        |   +---+        |
		*                +------------------------+-->|fin| - - - -
		*    |         +---+                      |   +---+
		*     - - - - -|fin|<---------------------+
		*              +---+
		*
		* @param {Number} [code] Status code explaining why the connection is closing
		* @param {(String|Buffer)} [data] The reason why the connection is
		*     closing
		* @public
		*/
		close(code$1, data) {
			if (this.readyState === WebSocket$3.CLOSED) return;
			if (this.readyState === WebSocket$3.CONNECTING) {
				const msg = "WebSocket was closed before the connection was established";
				abortHandshake$1(this, this._req, msg);
				return;
			}
			if (this.readyState === WebSocket$3.CLOSING) {
				if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) this._socket.end();
				return;
			}
			this._readyState = WebSocket$3.CLOSING;
			this._sender.close(code$1, data, !this._isServer, (err) => {
				if (err) return;
				this._closeFrameSent = true;
				if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) this._socket.end();
			});
			setCloseTimer(this);
		}
		/**
		* Pause the socket.
		*
		* @public
		*/
		pause() {
			if (this.readyState === WebSocket$3.CONNECTING || this.readyState === WebSocket$3.CLOSED) return;
			this._paused = true;
			this._socket.pause();
		}
		/**
		* Send a ping.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the ping is sent
		* @public
		*/
		ping(data, mask, cb) {
			if (this.readyState === WebSocket$3.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$3.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.ping(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Send a pong.
		*
		* @param {*} [data] The data to send
		* @param {Boolean} [mask] Indicates whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when the pong is sent
		* @public
		*/
		pong(data, mask, cb) {
			if (this.readyState === WebSocket$3.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof data === "function") {
				cb = data;
				data = mask = void 0;
			} else if (typeof mask === "function") {
				cb = mask;
				mask = void 0;
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$3.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			if (mask === void 0) mask = !this._isServer;
			this._sender.pong(data || EMPTY_BUFFER, mask, cb);
		}
		/**
		* Resume the socket.
		*
		* @public
		*/
		resume() {
			if (this.readyState === WebSocket$3.CONNECTING || this.readyState === WebSocket$3.CLOSED) return;
			this._paused = false;
			if (!this._receiver._writableState.needDrain) this._socket.resume();
		}
		/**
		* Send a data message.
		*
		* @param {*} data The message to send
		* @param {Object} [options] Options object
		* @param {Boolean} [options.binary] Specifies whether `data` is binary or
		*     text
		* @param {Boolean} [options.compress] Specifies whether or not to compress
		*     `data`
		* @param {Boolean} [options.fin=true] Specifies whether the fragment is the
		*     last one
		* @param {Boolean} [options.mask] Specifies whether or not to mask `data`
		* @param {Function} [cb] Callback which is executed when data is written out
		* @public
		*/
		send(data, options, cb) {
			if (this.readyState === WebSocket$3.CONNECTING) throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
			if (typeof options === "function") {
				cb = options;
				options = {};
			}
			if (typeof data === "number") data = data.toString();
			if (this.readyState !== WebSocket$3.OPEN) {
				sendAfterClose(this, data, cb);
				return;
			}
			const opts = {
				binary: typeof data !== "string",
				mask: !this._isServer,
				compress: true,
				fin: true,
				...options
			};
			if (!this._extensions[PerMessageDeflate$1.extensionName]) opts.compress = false;
			this._sender.send(data || EMPTY_BUFFER, opts, cb);
		}
		/**
		* Forcibly close the connection.
		*
		* @public
		*/
		terminate() {
			if (this.readyState === WebSocket$3.CLOSED) return;
			if (this.readyState === WebSocket$3.CONNECTING) {
				const msg = "WebSocket was closed before the connection was established";
				abortHandshake$1(this, this._req, msg);
				return;
			}
			if (this._socket) {
				this._readyState = WebSocket$3.CLOSING;
				this._socket.destroy();
			}
		}
	};
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$3, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} CONNECTING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$3.prototype, "CONNECTING", {
		enumerable: true,
		value: readyStates.indexOf("CONNECTING")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$3, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} OPEN
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$3.prototype, "OPEN", {
		enumerable: true,
		value: readyStates.indexOf("OPEN")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$3, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSING
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$3.prototype, "CLOSING", {
		enumerable: true,
		value: readyStates.indexOf("CLOSING")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket
	*/
	Object.defineProperty(WebSocket$3, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	/**
	* @constant {Number} CLOSED
	* @memberof WebSocket.prototype
	*/
	Object.defineProperty(WebSocket$3.prototype, "CLOSED", {
		enumerable: true,
		value: readyStates.indexOf("CLOSED")
	});
	[
		"binaryType",
		"bufferedAmount",
		"extensions",
		"isPaused",
		"protocol",
		"readyState",
		"url"
	].forEach((property) => {
		Object.defineProperty(WebSocket$3.prototype, property, { enumerable: true });
	});
	[
		"open",
		"error",
		"close",
		"message"
	].forEach((method) => {
		Object.defineProperty(WebSocket$3.prototype, `on${method}`, {
			enumerable: true,
			get() {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) return listener[kListener];
				return null;
			},
			set(handler$1) {
				for (const listener of this.listeners(method)) if (listener[kForOnEventAttribute]) {
					this.removeListener(method, listener);
					break;
				}
				if (typeof handler$1 !== "function") return;
				this.addEventListener(method, handler$1, { [kForOnEventAttribute]: true });
			}
		});
	});
	WebSocket$3.prototype.addEventListener = addEventListener;
	WebSocket$3.prototype.removeEventListener = removeEventListener;
	module.exports = WebSocket$3;
	/**
	* Initialize a WebSocket client.
	*
	* @param {WebSocket} websocket The client to initialize
	* @param {(String|URL)} address The URL to which to connect
	* @param {Array} protocols The subprotocols
	* @param {Object} [options] Connection options
	* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
	*     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
	*     times in the same tick
	* @param {Boolean} [options.autoPong=true] Specifies whether or not to
	*     automatically send a pong in response to a ping
	* @param {Function} [options.finishRequest] A function which can be used to
	*     customize the headers of each http request before it is sent
	* @param {Boolean} [options.followRedirects=false] Whether or not to follow
	*     redirects
	* @param {Function} [options.generateMask] The function used to generate the
	*     masking key
	* @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
	*     handshake request
	* @param {Number} [options.maxPayload=104857600] The maximum allowed message
	*     size
	* @param {Number} [options.maxRedirects=10] The maximum number of redirects
	*     allowed
	* @param {String} [options.origin] Value of the `Origin` or
	*     `Sec-WebSocket-Origin` header
	* @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
	*     permessage-deflate
	* @param {Number} [options.protocolVersion=13] Value of the
	*     `Sec-WebSocket-Version` header
	* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
	*     not to skip UTF-8 validation for text and close messages
	* @private
	*/
	function initAsClient(websocket, address, protocols, options) {
		const opts = {
			allowSynchronousEvents: true,
			autoPong: true,
			protocolVersion: protocolVersions[1],
			maxPayload: 100 * 1024 * 1024,
			skipUTF8Validation: false,
			perMessageDeflate: true,
			followRedirects: false,
			maxRedirects: 10,
			...options,
			socketPath: void 0,
			hostname: void 0,
			protocol: void 0,
			timeout: void 0,
			method: "GET",
			host: void 0,
			path: void 0,
			port: void 0
		};
		websocket._autoPong = opts.autoPong;
		if (!protocolVersions.includes(opts.protocolVersion)) throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
		let parsedUrl;
		if (address instanceof URL$1) parsedUrl = address;
		else try {
			parsedUrl = new URL$1(address);
		} catch (e) {
			throw new SyntaxError(`Invalid URL: ${address}`);
		}
		if (parsedUrl.protocol === "http:") parsedUrl.protocol = "ws:";
		else if (parsedUrl.protocol === "https:") parsedUrl.protocol = "wss:";
		websocket._url = parsedUrl.href;
		const isSecure = parsedUrl.protocol === "wss:";
		const isIpcUrl = parsedUrl.protocol === "ws+unix:";
		let invalidUrlMessage;
		if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) invalidUrlMessage = "The URL's protocol must be one of \"ws:\", \"wss:\", \"http:\", \"https\", or \"ws+unix:\"";
		else if (isIpcUrl && !parsedUrl.pathname) invalidUrlMessage = "The URL's pathname is empty";
		else if (parsedUrl.hash) invalidUrlMessage = "The URL contains a fragment identifier";
		if (invalidUrlMessage) {
			const err = new SyntaxError(invalidUrlMessage);
			if (websocket._redirects === 0) throw err;
			else {
				emitErrorAndClose(websocket, err);
				return;
			}
		}
		const defaultPort$1 = isSecure ? 443 : 80;
		const key = randomBytes(16).toString("base64");
		const request$3 = isSecure ? https.request : http$1.request;
		const protocolSet = new Set();
		let perMessageDeflate;
		opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
		opts.defaultPort = opts.defaultPort || defaultPort$1;
		opts.port = parsedUrl.port || defaultPort$1;
		opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
		opts.headers = {
			...opts.headers,
			"Sec-WebSocket-Version": opts.protocolVersion,
			"Sec-WebSocket-Key": key,
			Connection: "Upgrade",
			Upgrade: "websocket"
		};
		opts.path = parsedUrl.pathname + parsedUrl.search;
		opts.timeout = opts.handshakeTimeout;
		if (opts.perMessageDeflate) {
			perMessageDeflate = new PerMessageDeflate$1(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
			opts.headers["Sec-WebSocket-Extensions"] = format({ [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer() });
		}
		if (protocols.length) {
			for (const protocol of protocols) {
				if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) throw new SyntaxError("An invalid or duplicated subprotocol was specified");
				protocolSet.add(protocol);
			}
			opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
		}
		if (opts.origin) if (opts.protocolVersion < 13) opts.headers["Sec-WebSocket-Origin"] = opts.origin;
		else opts.headers.Origin = opts.origin;
		if (parsedUrl.username || parsedUrl.password) opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
		if (isIpcUrl) {
			const parts = opts.path.split(":");
			opts.socketPath = parts[0];
			opts.path = parts[1];
		}
		let req$1;
		if (opts.followRedirects) {
			if (websocket._redirects === 0) {
				websocket._originalIpc = isIpcUrl;
				websocket._originalSecure = isSecure;
				websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
				const headers = options && options.headers;
				options = {
					...options,
					headers: {}
				};
				if (headers) for (const [key$1, value] of Object.entries(headers)) options.headers[key$1.toLowerCase()] = value;
			} else if (websocket.listenerCount("redirect") === 0) {
				const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
				if (!isSameHost || websocket._originalSecure && !isSecure) {
					delete opts.headers.authorization;
					delete opts.headers.cookie;
					if (!isSameHost) delete opts.headers.host;
					opts.auth = void 0;
				}
			}
			if (opts.auth && !options.headers.authorization) options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
			req$1 = websocket._req = request$3(opts);
			if (websocket._redirects) websocket.emit("redirect", websocket.url, req$1);
		} else req$1 = websocket._req = request$3(opts);
		if (opts.timeout) req$1.on("timeout", () => {
			abortHandshake$1(websocket, req$1, "Opening handshake has timed out");
		});
		req$1.on("error", (err) => {
			if (req$1 === null || req$1[kAborted]) return;
			req$1 = websocket._req = null;
			emitErrorAndClose(websocket, err);
		});
		req$1.on("response", (res) => {
			const location = res.headers.location;
			const statusCode = res.statusCode;
			if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
				if (++websocket._redirects > opts.maxRedirects) {
					abortHandshake$1(websocket, req$1, "Maximum redirects exceeded");
					return;
				}
				req$1.abort();
				let addr;
				try {
					addr = new URL$1(location, address);
				} catch (e) {
					const err = new SyntaxError(`Invalid URL: ${location}`);
					emitErrorAndClose(websocket, err);
					return;
				}
				initAsClient(websocket, addr, protocols, options);
			} else if (!websocket.emit("unexpected-response", req$1, res)) abortHandshake$1(websocket, req$1, `Unexpected server response: ${res.statusCode}`);
		});
		req$1.on("upgrade", (res, socket, head) => {
			websocket.emit("upgrade", res);
			if (websocket.readyState !== WebSocket$3.CONNECTING) return;
			req$1 = websocket._req = null;
			const upgrade$1 = res.headers.upgrade;
			if (upgrade$1 === void 0 || upgrade$1.toLowerCase() !== "websocket") {
				abortHandshake$1(websocket, socket, "Invalid Upgrade header");
				return;
			}
			const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
			if (res.headers["sec-websocket-accept"] !== digest) {
				abortHandshake$1(websocket, socket, "Invalid Sec-WebSocket-Accept header");
				return;
			}
			const serverProt = res.headers["sec-websocket-protocol"];
			let protError;
			if (serverProt !== void 0) {
				if (!protocolSet.size) protError = "Server sent a subprotocol but none was requested";
				else if (!protocolSet.has(serverProt)) protError = "Server sent an invalid subprotocol";
			} else if (protocolSet.size) protError = "Server sent no subprotocol";
			if (protError) {
				abortHandshake$1(websocket, socket, protError);
				return;
			}
			if (serverProt) websocket._protocol = serverProt;
			const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
			if (secWebSocketExtensions !== void 0) {
				if (!perMessageDeflate) {
					const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
					abortHandshake$1(websocket, socket, message);
					return;
				}
				let extensions;
				try {
					extensions = parse$2(secWebSocketExtensions);
				} catch (err) {
					const message = "Invalid Sec-WebSocket-Extensions header";
					abortHandshake$1(websocket, socket, message);
					return;
				}
				const extensionNames = Object.keys(extensions);
				if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
					const message = "Server indicated an extension that was not requested";
					abortHandshake$1(websocket, socket, message);
					return;
				}
				try {
					perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);
				} catch (err) {
					const message = "Invalid Sec-WebSocket-Extensions header";
					abortHandshake$1(websocket, socket, message);
					return;
				}
				websocket._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
			}
			websocket.setSocket(socket, head, {
				allowSynchronousEvents: opts.allowSynchronousEvents,
				generateMask: opts.generateMask,
				maxPayload: opts.maxPayload,
				skipUTF8Validation: opts.skipUTF8Validation
			});
		});
		if (opts.finishRequest) opts.finishRequest(req$1, websocket);
		else req$1.end();
	}
	/**
	* Emit the `'error'` and `'close'` events.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {Error} The error to emit
	* @private
	*/
	function emitErrorAndClose(websocket, err) {
		websocket._readyState = WebSocket$3.CLOSING;
		websocket._errorEmitted = true;
		websocket.emit("error", err);
		websocket.emitClose();
	}
	/**
	* Create a `net.Socket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {net.Socket} The newly created socket used to start the connection
	* @private
	*/
	function netConnect(options) {
		options.path = options.socketPath;
		return net.connect(options);
	}
	/**
	* Create a `tls.TLSSocket` and initiate a connection.
	*
	* @param {Object} options Connection options
	* @return {tls.TLSSocket} The newly created socket used to start the connection
	* @private
	*/
	function tlsConnect(options) {
		options.path = void 0;
		if (!options.servername && options.servername !== "") options.servername = net.isIP(options.host) ? "" : options.host;
		return tls.connect(options);
	}
	/**
	* Abort the handshake and emit an error.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
	*     abort or the socket to destroy
	* @param {String} message The error message
	* @private
	*/
	function abortHandshake$1(websocket, stream$6, message) {
		websocket._readyState = WebSocket$3.CLOSING;
		const err = new Error(message);
		Error.captureStackTrace(err, abortHandshake$1);
		if (stream$6.setHeader) {
			stream$6[kAborted] = true;
			stream$6.abort();
			if (stream$6.socket && !stream$6.socket.destroyed) stream$6.socket.destroy();
			process.nextTick(emitErrorAndClose, websocket, err);
		} else {
			stream$6.destroy(err);
			stream$6.once("error", websocket.emit.bind(websocket, "error"));
			stream$6.once("close", websocket.emitClose.bind(websocket));
		}
	}
	/**
	* Handle cases where the `ping()`, `pong()`, or `send()` methods are called
	* when the `readyState` attribute is `CLOSING` or `CLOSED`.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @param {*} [data] The data to send
	* @param {Function} [cb] Callback
	* @private
	*/
	function sendAfterClose(websocket, data, cb) {
		if (data) {
			const length = isBlob(data) ? data.size : toBuffer(data).length;
			if (websocket._socket) websocket._sender._bufferedBytes += length;
			else websocket._bufferedAmount += length;
		}
		if (cb) {
			const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
			process.nextTick(cb, err);
		}
	}
	/**
	* The listener of the `Receiver` `'conclude'` event.
	*
	* @param {Number} code The status code
	* @param {Buffer} reason The reason for closing
	* @private
	*/
	function receiverOnConclude(code$1, reason) {
		const websocket = this[kWebSocket$1];
		websocket._closeFrameReceived = true;
		websocket._closeMessage = reason;
		websocket._closeCode = code$1;
		if (websocket._socket[kWebSocket$1] === void 0) return;
		websocket._socket.removeListener("data", socketOnData);
		process.nextTick(resume, websocket._socket);
		if (code$1 === 1005) websocket.close();
		else websocket.close(code$1, reason);
	}
	/**
	* The listener of the `Receiver` `'drain'` event.
	*
	* @private
	*/
	function receiverOnDrain() {
		const websocket = this[kWebSocket$1];
		if (!websocket.isPaused) websocket._socket.resume();
	}
	/**
	* The listener of the `Receiver` `'error'` event.
	*
	* @param {(RangeError|Error)} err The emitted error
	* @private
	*/
	function receiverOnError(err) {
		const websocket = this[kWebSocket$1];
		if (websocket._socket[kWebSocket$1] !== void 0) {
			websocket._socket.removeListener("data", socketOnData);
			process.nextTick(resume, websocket._socket);
			websocket.close(err[kStatusCode]);
		}
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* The listener of the `Receiver` `'finish'` event.
	*
	* @private
	*/
	function receiverOnFinish() {
		this[kWebSocket$1].emitClose();
	}
	/**
	* The listener of the `Receiver` `'message'` event.
	*
	* @param {Buffer|ArrayBuffer|Buffer[])} data The message
	* @param {Boolean} isBinary Specifies whether the message is binary or not
	* @private
	*/
	function receiverOnMessage(data, isBinary) {
		this[kWebSocket$1].emit("message", data, isBinary);
	}
	/**
	* The listener of the `Receiver` `'ping'` event.
	*
	* @param {Buffer} data The data included in the ping frame
	* @private
	*/
	function receiverOnPing(data) {
		const websocket = this[kWebSocket$1];
		if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
		websocket.emit("ping", data);
	}
	/**
	* The listener of the `Receiver` `'pong'` event.
	*
	* @param {Buffer} data The data included in the pong frame
	* @private
	*/
	function receiverOnPong(data) {
		this[kWebSocket$1].emit("pong", data);
	}
	/**
	* Resume a readable stream
	*
	* @param {Readable} stream The readable stream
	* @private
	*/
	function resume(stream$6) {
		stream$6.resume();
	}
	/**
	* The `Sender` error event handler.
	*
	* @param {Error} The error
	* @private
	*/
	function senderOnError(err) {
		const websocket = this[kWebSocket$1];
		if (websocket.readyState === WebSocket$3.CLOSED) return;
		if (websocket.readyState === WebSocket$3.OPEN) {
			websocket._readyState = WebSocket$3.CLOSING;
			setCloseTimer(websocket);
		}
		this._socket.end();
		if (!websocket._errorEmitted) {
			websocket._errorEmitted = true;
			websocket.emit("error", err);
		}
	}
	/**
	* Set a timer to destroy the underlying raw socket of a WebSocket.
	*
	* @param {WebSocket} websocket The WebSocket instance
	* @private
	*/
	function setCloseTimer(websocket) {
		websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), closeTimeout);
	}
	/**
	* The listener of the socket `'close'` event.
	*
	* @private
	*/
	function socketOnClose() {
		const websocket = this[kWebSocket$1];
		this.removeListener("close", socketOnClose);
		this.removeListener("data", socketOnData);
		this.removeListener("end", socketOnEnd);
		websocket._readyState = WebSocket$3.CLOSING;
		let chunk;
		if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) websocket._receiver.write(chunk);
		websocket._receiver.end();
		this[kWebSocket$1] = void 0;
		clearTimeout(websocket._closeTimer);
		if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) websocket.emitClose();
		else {
			websocket._receiver.on("error", receiverOnFinish);
			websocket._receiver.on("finish", receiverOnFinish);
		}
	}
	/**
	* The listener of the socket `'data'` event.
	*
	* @param {Buffer} chunk A chunk of data
	* @private
	*/
	function socketOnData(chunk) {
		if (!this[kWebSocket$1]._receiver.write(chunk)) this.pause();
	}
	/**
	* The listener of the socket `'end'` event.
	*
	* @private
	*/
	function socketOnEnd() {
		const websocket = this[kWebSocket$1];
		websocket._readyState = WebSocket$3.CLOSING;
		websocket._receiver.end();
		this.end();
	}
	/**
	* The listener of the socket `'error'` event.
	*
	* @private
	*/
	function socketOnError$1() {
		const websocket = this[kWebSocket$1];
		this.removeListener("error", socketOnError$1);
		this.on("error", NOOP);
		if (websocket) {
			websocket._readyState = WebSocket$3.CLOSING;
			this.destroy();
		}
	}
} });

//#endregion
//#region node_modules/ws/lib/stream.js
var require_stream = __commonJS({ "node_modules/ws/lib/stream.js"(exports, module) {
	const WebSocket$2 = require_websocket();
	const { Duplex: Duplex$1 } = require("stream");
	/**
	* Emits the `'close'` event on a stream.
	*
	* @param {Duplex} stream The stream.
	* @private
	*/
	function emitClose$1(stream$6) {
		stream$6.emit("close");
	}
	/**
	* The listener of the `'end'` event.
	*
	* @private
	*/
	function duplexOnEnd() {
		if (!this.destroyed && this._writableState.finished) this.destroy();
	}
	/**
	* The listener of the `'error'` event.
	*
	* @param {Error} err The error
	* @private
	*/
	function duplexOnError(err) {
		this.removeListener("error", duplexOnError);
		this.destroy();
		if (this.listenerCount("error") === 0) this.emit("error", err);
	}
	/**
	* Wraps a `WebSocket` in a duplex stream.
	*
	* @param {WebSocket} ws The `WebSocket` to wrap
	* @param {Object} [options] The options for the `Duplex` constructor
	* @return {Duplex} The duplex stream
	* @public
	*/
	function createWebSocketStream(ws, options) {
		let terminateOnDestroy = true;
		const duplex = new Duplex$1({
			...options,
			autoDestroy: false,
			emitClose: false,
			objectMode: false,
			writableObjectMode: false
		});
		ws.on("message", function message(msg, isBinary) {
			const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
			if (!duplex.push(data)) ws.pause();
		});
		ws.once("error", function error$1(err) {
			if (duplex.destroyed) return;
			terminateOnDestroy = false;
			duplex.destroy(err);
		});
		ws.once("close", function close() {
			if (duplex.destroyed) return;
			duplex.push(null);
		});
		duplex._destroy = function(err, callback) {
			if (ws.readyState === ws.CLOSED) {
				callback(err);
				process.nextTick(emitClose$1, duplex);
				return;
			}
			let called = false;
			ws.once("error", function error$1(err$1) {
				called = true;
				callback(err$1);
			});
			ws.once("close", function close() {
				if (!called) callback(err);
				process.nextTick(emitClose$1, duplex);
			});
			if (terminateOnDestroy) ws.terminate();
		};
		duplex._final = function(callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._final(callback);
				});
				return;
			}
			if (ws._socket === null) return;
			if (ws._socket._writableState.finished) {
				callback();
				if (duplex._readableState.endEmitted) duplex.destroy();
			} else {
				ws._socket.once("finish", function finish() {
					callback();
				});
				ws.close();
			}
		};
		duplex._read = function() {
			if (ws.isPaused) ws.resume();
		};
		duplex._write = function(chunk, encoding, callback) {
			if (ws.readyState === ws.CONNECTING) {
				ws.once("open", function open() {
					duplex._write(chunk, encoding, callback);
				});
				return;
			}
			ws.send(chunk, callback);
		};
		duplex.on("end", duplexOnEnd);
		duplex.on("error", duplexOnError);
		return duplex;
	}
	module.exports = createWebSocketStream;
} });

//#endregion
//#region node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({ "node_modules/ws/lib/subprotocol.js"(exports, module) {
	const { tokenChars } = require_validation();
	/**
	* Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
	*
	* @param {String} header The field value of the header
	* @return {Set} The subprotocol names
	* @public
	*/
	function parse$1(header) {
		const protocols = new Set();
		let start = -1;
		let end = -1;
		let i$1 = 0;
		for (; i$1 < header.length; i$1++) {
			const code$1 = header.charCodeAt(i$1);
			if (end === -1 && tokenChars[code$1] === 1) {
				if (start === -1) start = i$1;
			} else if (i$1 !== 0 && (code$1 === 32 || code$1 === 9)) {
				if (end === -1 && start !== -1) end = i$1;
			} else if (code$1 === 44) {
				if (start === -1) throw new SyntaxError(`Unexpected character at index ${i$1}`);
				if (end === -1) end = i$1;
				const protocol$1 = header.slice(start, end);
				if (protocols.has(protocol$1)) throw new SyntaxError(`The "${protocol$1}" subprotocol is duplicated`);
				protocols.add(protocol$1);
				start = end = -1;
			} else throw new SyntaxError(`Unexpected character at index ${i$1}`);
		}
		if (start === -1 || end !== -1) throw new SyntaxError("Unexpected end of input");
		const protocol = header.slice(start, i$1);
		if (protocols.has(protocol)) throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
		protocols.add(protocol);
		return protocols;
	}
	module.exports = { parse: parse$1 };
} });

//#endregion
//#region node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({ "node_modules/ws/lib/websocket-server.js"(exports, module) {
	const EventEmitter = require("events");
	const http = require("http");
	const { Duplex } = require("stream");
	const { createHash } = require("crypto");
	const extension = require_extension();
	const PerMessageDeflate = require_permessage_deflate();
	const subprotocol = require_subprotocol();
	const WebSocket$1 = require_websocket();
	const { GUID, kWebSocket } = require_constants();
	const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
	const RUNNING = 0;
	const CLOSING = 1;
	const CLOSED = 2;
	/**
	* Class representing a WebSocket server.
	*
	* @extends EventEmitter
	*/
	var WebSocketServer = class extends EventEmitter {
		/**
		* Create a `WebSocketServer` instance.
		*
		* @param {Object} options Configuration options
		* @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
		*     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
		*     multiple times in the same tick
		* @param {Boolean} [options.autoPong=true] Specifies whether or not to
		*     automatically send a pong in response to a ping
		* @param {Number} [options.backlog=511] The maximum length of the queue of
		*     pending connections
		* @param {Boolean} [options.clientTracking=true] Specifies whether or not to
		*     track clients
		* @param {Function} [options.handleProtocols] A hook to handle protocols
		* @param {String} [options.host] The hostname where to bind the server
		* @param {Number} [options.maxPayload=104857600] The maximum allowed message
		*     size
		* @param {Boolean} [options.noServer=false] Enable no server mode
		* @param {String} [options.path] Accept only connections matching this path
		* @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
		*     permessage-deflate
		* @param {Number} [options.port] The port where to bind the server
		* @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
		*     server to use
		* @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
		*     not to skip UTF-8 validation for text and close messages
		* @param {Function} [options.verifyClient] A hook to reject connections
		* @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
		*     class to use. It must be the `WebSocket` class or class that extends it
		* @param {Function} [callback] A listener for the `listening` event
		*/
		constructor(options, callback) {
			super();
			options = {
				allowSynchronousEvents: true,
				autoPong: true,
				maxPayload: 100 * 1024 * 1024,
				skipUTF8Validation: false,
				perMessageDeflate: false,
				handleProtocols: null,
				clientTracking: true,
				verifyClient: null,
				noServer: false,
				backlog: null,
				server: null,
				host: null,
				path: null,
				port: null,
				WebSocket: WebSocket$1,
				...options
			};
			if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) throw new TypeError("One and only one of the \"port\", \"server\", or \"noServer\" options must be specified");
			if (options.port != null) {
				this._server = http.createServer((req$1, res) => {
					const body = http.STATUS_CODES[426];
					res.writeHead(426, {
						"Content-Length": body.length,
						"Content-Type": "text/plain"
					});
					res.end(body);
				});
				this._server.listen(options.port, options.host, options.backlog, callback);
			} else if (options.server) this._server = options.server;
			if (this._server) {
				const emitConnection = this.emit.bind(this, "connection");
				this._removeListeners = addListeners(this._server, {
					listening: this.emit.bind(this, "listening"),
					error: this.emit.bind(this, "error"),
					upgrade: (req$1, socket, head) => {
						this.handleUpgrade(req$1, socket, head, emitConnection);
					}
				});
			}
			if (options.perMessageDeflate === true) options.perMessageDeflate = {};
			if (options.clientTracking) {
				this.clients = new Set();
				this._shouldEmitClose = false;
			}
			this.options = options;
			this._state = RUNNING;
		}
		/**
		* Returns the bound address, the address family name, and port of the server
		* as reported by the operating system if listening on an IP socket.
		* If the server is listening on a pipe or UNIX domain socket, the name is
		* returned as a string.
		*
		* @return {(Object|String|null)} The address of the server
		* @public
		*/
		address() {
			if (this.options.noServer) throw new Error("The server is operating in \"noServer\" mode");
			if (!this._server) return null;
			return this._server.address();
		}
		/**
		* Stop the server from accepting new connections and emit the `'close'` event
		* when all existing connections are closed.
		*
		* @param {Function} [cb] A one-time listener for the `'close'` event
		* @public
		*/
		close(cb) {
			if (this._state === CLOSED) {
				if (cb) this.once("close", () => {
					cb(new Error("The server is not running"));
				});
				process.nextTick(emitClose, this);
				return;
			}
			if (cb) this.once("close", cb);
			if (this._state === CLOSING) return;
			this._state = CLOSING;
			if (this.options.noServer || this.options.server) {
				if (this._server) {
					this._removeListeners();
					this._removeListeners = this._server = null;
				}
				if (this.clients) if (!this.clients.size) process.nextTick(emitClose, this);
				else this._shouldEmitClose = true;
				else process.nextTick(emitClose, this);
			} else {
				const server = this._server;
				this._removeListeners();
				this._removeListeners = this._server = null;
				server.close(() => {
					emitClose(this);
				});
			}
		}
		/**
		* See if a given request should be handled by this server instance.
		*
		* @param {http.IncomingMessage} req Request object to inspect
		* @return {Boolean} `true` if the request is valid, else `false`
		* @public
		*/
		shouldHandle(req$1) {
			if (this.options.path) {
				const index = req$1.url.indexOf("?");
				const pathname = index !== -1 ? req$1.url.slice(0, index) : req$1.url;
				if (pathname !== this.options.path) return false;
			}
			return true;
		}
		/**
		* Handle a HTTP Upgrade request.
		*
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @public
		*/
		handleUpgrade(req$1, socket, head, cb) {
			socket.on("error", socketOnError);
			const key = req$1.headers["sec-websocket-key"];
			const upgrade$1 = req$1.headers.upgrade;
			const version$2 = +req$1.headers["sec-websocket-version"];
			if (req$1.method !== "GET") {
				const message = "Invalid HTTP method";
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 405, message);
				return;
			}
			if (upgrade$1 === void 0 || upgrade$1.toLowerCase() !== "websocket") {
				const message = "Invalid Upgrade header";
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, message);
				return;
			}
			if (key === void 0 || !keyRegex.test(key)) {
				const message = "Missing or invalid Sec-WebSocket-Key header";
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, message);
				return;
			}
			if (version$2 !== 8 && version$2 !== 13) {
				const message = "Missing or invalid Sec-WebSocket-Version header";
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, message);
				return;
			}
			if (!this.shouldHandle(req$1)) {
				abortHandshake(socket, 400);
				return;
			}
			const secWebSocketProtocol = req$1.headers["sec-websocket-protocol"];
			let protocols = new Set();
			if (secWebSocketProtocol !== void 0) try {
				protocols = subprotocol.parse(secWebSocketProtocol);
			} catch (err) {
				const message = "Invalid Sec-WebSocket-Protocol header";
				abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, message);
				return;
			}
			const secWebSocketExtensions = req$1.headers["sec-websocket-extensions"];
			const extensions = {};
			if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
				const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
				try {
					const offers = extension.parse(secWebSocketExtensions);
					if (offers[PerMessageDeflate.extensionName]) {
						perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
						extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
					}
				} catch (err) {
					const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
					abortHandshakeOrEmitwsClientError(this, req$1, socket, 400, message);
					return;
				}
			}
			if (this.options.verifyClient) {
				const info$1 = {
					origin: req$1.headers[`${version$2 === 8 ? "sec-websocket-origin" : "origin"}`],
					secure: !!(req$1.socket.authorized || req$1.socket.encrypted),
					req: req$1
				};
				if (this.options.verifyClient.length === 2) {
					this.options.verifyClient(info$1, (verified, code$1, message, headers) => {
						if (!verified) return abortHandshake(socket, code$1 || 401, message, headers);
						this.completeUpgrade(extensions, key, protocols, req$1, socket, head, cb);
					});
					return;
				}
				if (!this.options.verifyClient(info$1)) return abortHandshake(socket, 401);
			}
			this.completeUpgrade(extensions, key, protocols, req$1, socket, head, cb);
		}
		/**
		* Upgrade the connection to WebSocket.
		*
		* @param {Object} extensions The accepted extensions
		* @param {String} key The value of the `Sec-WebSocket-Key` header
		* @param {Set} protocols The subprotocols
		* @param {http.IncomingMessage} req The request object
		* @param {Duplex} socket The network socket between the server and client
		* @param {Buffer} head The first packet of the upgraded stream
		* @param {Function} cb Callback
		* @throws {Error} If called more than once with the same socket
		* @private
		*/
		completeUpgrade(extensions, key, protocols, req$1, socket, head, cb) {
			if (!socket.readable || !socket.writable) return socket.destroy();
			if (socket[kWebSocket]) throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
			if (this._state > RUNNING) return abortHandshake(socket, 503);
			const digest = createHash("sha1").update(key + GUID).digest("base64");
			const headers = [
				"HTTP/1.1 101 Switching Protocols",
				"Upgrade: websocket",
				"Connection: Upgrade",
				`Sec-WebSocket-Accept: ${digest}`
			];
			const ws = new this.options.WebSocket(null, void 0, this.options);
			if (protocols.size) {
				const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req$1) : protocols.values().next().value;
				if (protocol) {
					headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
					ws._protocol = protocol;
				}
			}
			if (extensions[PerMessageDeflate.extensionName]) {
				const params = extensions[PerMessageDeflate.extensionName].params;
				const value = extension.format({ [PerMessageDeflate.extensionName]: [params] });
				headers.push(`Sec-WebSocket-Extensions: ${value}`);
				ws._extensions = extensions;
			}
			this.emit("headers", headers, req$1);
			socket.write(headers.concat("\r\n").join("\r\n"));
			socket.removeListener("error", socketOnError);
			ws.setSocket(socket, head, {
				allowSynchronousEvents: this.options.allowSynchronousEvents,
				maxPayload: this.options.maxPayload,
				skipUTF8Validation: this.options.skipUTF8Validation
			});
			if (this.clients) {
				this.clients.add(ws);
				ws.on("close", () => {
					this.clients.delete(ws);
					if (this._shouldEmitClose && !this.clients.size) process.nextTick(emitClose, this);
				});
			}
			cb(ws, req$1);
		}
	};
	module.exports = WebSocketServer;
	/**
	* Add event listeners on an `EventEmitter` using a map of <event, listener>
	* pairs.
	*
	* @param {EventEmitter} server The event emitter
	* @param {Object.<String, Function>} map The listeners to add
	* @return {Function} A function that will remove the added listeners when
	*     called
	* @private
	*/
	function addListeners(server, map) {
		for (const event of Object.keys(map)) server.on(event, map[event]);
		return function removeListeners() {
			for (const event of Object.keys(map)) server.removeListener(event, map[event]);
		};
	}
	/**
	* Emit a `'close'` event on an `EventEmitter`.
	*
	* @param {EventEmitter} server The event emitter
	* @private
	*/
	function emitClose(server) {
		server._state = CLOSED;
		server.emit("close");
	}
	/**
	* Handle socket errors.
	*
	* @private
	*/
	function socketOnError() {
		this.destroy();
	}
	/**
	* Close the connection when preconditions are not fulfilled.
	*
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} [message] The HTTP response body
	* @param {Object} [headers] Additional HTTP response headers
	* @private
	*/
	function abortHandshake(socket, code$1, message, headers) {
		message = message || http.STATUS_CODES[code$1];
		headers = {
			Connection: "close",
			"Content-Type": "text/html",
			"Content-Length": Buffer.byteLength(message),
			...headers
		};
		socket.once("finish", socket.destroy);
		socket.end(`HTTP/1.1 ${code$1} ${http.STATUS_CODES[code$1]}\r\n` + Object.keys(headers).map((h$1) => `${h$1}: ${headers[h$1]}`).join("\r\n") + "\r\n\r\n" + message);
	}
	/**
	* Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
	* one listener for it, otherwise call `abortHandshake()`.
	*
	* @param {WebSocketServer} server The WebSocket server
	* @param {http.IncomingMessage} req The request object
	* @param {Duplex} socket The socket of the upgrade request
	* @param {Number} code The HTTP response status code
	* @param {String} message The HTTP response body
	* @private
	*/
	function abortHandshakeOrEmitwsClientError(server, req$1, socket, code$1, message) {
		if (server.listenerCount("wsClientError")) {
			const err = new Error(message);
			Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
			server.emit("wsClientError", err, socket, req$1);
		} else abortHandshake(socket, code$1, message);
	}
} });

//#endregion
//#region node_modules/ws/index.js
var require_ws = __commonJS({ "node_modules/ws/index.js"(exports, module) {
	const WebSocket = require_websocket();
	WebSocket.createWebSocketStream = require_stream();
	WebSocket.Server = require_websocket_server();
	WebSocket.Receiver = require_receiver();
	WebSocket.Sender = require_sender();
	WebSocket.WebSocket = WebSocket;
	WebSocket.WebSocketServer = WebSocket.Server;
	module.exports = WebSocket;
} });

//#endregion
//#region node_modules/@google/genai/dist/node/index.js
var require_node = __commonJS({ "node_modules/@google/genai/dist/node/index.js"(exports) {
	var googleAuthLibrary = require_src();
	var NodeWs = require_ws();
	var fs$2 = require("fs/promises");
	function _interopNamespaceDefault(e) {
		var n = Object.create(null);
		if (e) Object.keys(e).forEach(function(k) {
			if (k !== "default") {
				var d$1 = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d$1.get ? d$1 : {
					enumerable: true,
					get: function() {
						return e[k];
					}
				});
			}
		});
		n.default = e;
		return Object.freeze(n);
	}
	var NodeWs__namespace = /* @__PURE__ */ _interopNamespaceDefault(NodeWs);
	var fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs$2);
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	var BaseModule = class {};
	function formatMap(templateString, valueMap) {
		const regex = /\{([^}]+)\}/g;
		return templateString.replace(regex, (match, key) => {
			if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
				const value = valueMap[key];
				return value !== void 0 && value !== null ? String(value) : "";
			} else throw new Error(`Key '${key}' not found in valueMap.`);
		});
	}
	function setValueByPath(data, keys, value) {
		for (let i$1 = 0; i$1 < keys.length - 1; i$1++) {
			const key = keys[i$1];
			if (key.endsWith("[]")) {
				const keyName = key.slice(0, -2);
				if (!(keyName in data)) if (Array.isArray(value)) data[keyName] = Array.from({ length: value.length }, () => ({}));
				else throw new Error(`Value must be a list given an array path ${key}`);
				if (Array.isArray(data[keyName])) {
					const arrayData = data[keyName];
					if (Array.isArray(value)) for (let j = 0; j < arrayData.length; j++) {
						const entry = arrayData[j];
						setValueByPath(entry, keys.slice(i$1 + 1), value[j]);
					}
					else for (const d$1 of arrayData) setValueByPath(d$1, keys.slice(i$1 + 1), value);
				}
				return;
			} else if (key.endsWith("[0]")) {
				const keyName = key.slice(0, -3);
				if (!(keyName in data)) data[keyName] = [{}];
				const arrayData = data[keyName];
				setValueByPath(arrayData[0], keys.slice(i$1 + 1), value);
				return;
			}
			if (!data[key] || typeof data[key] !== "object") data[key] = {};
			data = data[key];
		}
		const keyToSet = keys[keys.length - 1];
		const existingData = data[keyToSet];
		if (existingData !== void 0) {
			if (!value || typeof value === "object" && Object.keys(value).length === 0) return;
			if (value === existingData) return;
			if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) Object.assign(existingData, value);
			else throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
		} else data[keyToSet] = value;
	}
	function getValueByPath(data, keys) {
		try {
			if (keys.length === 1 && keys[0] === "_self") return data;
			for (let i$1 = 0; i$1 < keys.length; i$1++) {
				if (typeof data !== "object" || data === null) return void 0;
				const key = keys[i$1];
				if (key.endsWith("[]")) {
					const keyName = key.slice(0, -2);
					if (keyName in data) {
						const arrayData = data[keyName];
						if (!Array.isArray(arrayData)) return void 0;
						return arrayData.map((d$1) => getValueByPath(d$1, keys.slice(i$1 + 1)));
					} else return void 0;
				} else data = data[key];
			}
			return data;
		} catch (error$1) {
			if (error$1 instanceof TypeError) return void 0;
			throw error$1;
		}
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	function tModel(apiClient, model) {
		if (!model || typeof model !== "string") throw new Error("model is required and must be a string");
		if (apiClient.isVertexAI()) if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) return model;
		else if (model.indexOf("/") >= 0) {
			const parts = model.split("/", 2);
			return `publishers/${parts[0]}/models/${parts[1]}`;
		} else return `publishers/google/models/${model}`;
		else if (model.startsWith("models/") || model.startsWith("tunedModels/")) return model;
		else return `models/${model}`;
	}
	function tCachesModel(apiClient, model) {
		const transformedModel = tModel(apiClient, model);
		if (!transformedModel) return "";
		if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
		else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
		else return transformedModel;
	}
	function tPart(apiClient, origin) {
		if (origin === null || origin === void 0) throw new Error("PartUnion is required");
		if (typeof origin === "object") return origin;
		if (typeof origin === "string") return { text: origin };
		throw new Error(`Unsupported part type: ${typeof origin}`);
	}
	function tParts(apiClient, origin) {
		if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) throw new Error("PartListUnion is required");
		if (Array.isArray(origin)) return origin.map((item) => tPart(apiClient, item));
		return [tPart(apiClient, origin)];
	}
	function _isContent(origin) {
		return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
	}
	function _isFunctionCallPart(origin) {
		return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
	}
	function _isFunctionResponsePart(origin) {
		return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
	}
	function tContent(apiClient, origin) {
		if (origin === null || origin === void 0) throw new Error("ContentUnion is required");
		if (_isContent(origin)) return origin;
		return {
			role: "user",
			parts: tParts(apiClient, origin)
		};
	}
	function tContentsForEmbed(apiClient, origin) {
		if (!origin) return [];
		if (apiClient.isVertexAI() && Array.isArray(origin)) return origin.flatMap((item) => {
			const content = tContent(apiClient, item);
			if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) return [content.parts[0].text];
			return [];
		});
		else if (apiClient.isVertexAI()) {
			const content = tContent(apiClient, origin);
			if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) return [content.parts[0].text];
			return [];
		}
		if (Array.isArray(origin)) return origin.map((item) => tContent(apiClient, item));
		return [tContent(apiClient, origin)];
	}
	function tContents(apiClient, origin) {
		if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) throw new Error("contents are required");
		if (!Array.isArray(origin)) {
			if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
			return [tContent(apiClient, origin)];
		}
		const result = [];
		const accumulatedParts = [];
		const isContentArray = _isContent(origin[0]);
		for (const item of origin) {
			const isContent = _isContent(item);
			if (isContent != isContentArray) throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
			if (isContent) result.push(item);
			else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
			else accumulatedParts.push(item);
		}
		if (!isContentArray) result.push({
			role: "user",
			parts: tParts(apiClient, accumulatedParts)
		});
		return result;
	}
	function processSchema(apiClient, schema) {
		if (!apiClient.isVertexAI()) {
			if ("default" in schema) throw new Error("Default value is not supported in the response schema for the Gemini API.");
		}
		if ("anyOf" in schema) {
			if (schema["anyOf"] !== void 0) for (const subSchema of schema["anyOf"]) processSchema(apiClient, subSchema);
		}
		if ("items" in schema) {
			if (schema["items"] !== void 0) processSchema(apiClient, schema["items"]);
		}
		if ("properties" in schema) {
			if (schema["properties"] !== void 0) for (const subSchema of Object.values(schema["properties"])) processSchema(apiClient, subSchema);
		}
	}
	function tSchema(apiClient, schema) {
		processSchema(apiClient, schema);
		return schema;
	}
	function tSpeechConfig(apiClient, speechConfig) {
		if (typeof speechConfig === "object" && "voiceConfig" in speechConfig) return speechConfig;
		else if (typeof speechConfig === "string") return { voiceConfig: { prebuiltVoiceConfig: { voiceName: speechConfig } } };
		else throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
	}
	function tTool(apiClient, tool) {
		return tool;
	}
	function tTools(apiClient, tool) {
		if (!Array.isArray(tool)) throw new Error("tool is required and must be an array of Tools");
		return tool;
	}
	/**
	* Prepends resource name with project, location, resource_prefix if needed.
	*
	* @param client The API client.
	* @param resourceName The resource name.
	* @param resourcePrefix The resource prefix.
	* @param splitsAfterPrefix The number of splits after the prefix.
	* @returns The completed resource name.
	*
	* Examples:
	*
	* ```
	* resource_name = '123'
	* resource_prefix = 'cachedContents'
	* splits_after_prefix = 1
	* client.vertexai = True
	* client.project = 'bar'
	* client.location = 'us-west1'
	* _resource_name(client, resource_name, resource_prefix, splits_after_prefix)
	* returns: 'projects/bar/locations/us-west1/cachedContents/123'
	* ```
	*
	* ```
	* resource_name = 'projects/foo/locations/us-central1/cachedContents/123'
	* resource_prefix = 'cachedContents'
	* splits_after_prefix = 1
	* client.vertexai = True
	* client.project = 'bar'
	* client.location = 'us-west1'
	* _resource_name(client, resource_name, resource_prefix, splits_after_prefix)
	* returns: 'projects/foo/locations/us-central1/cachedContents/123'
	* ```
	*
	* ```
	* resource_name = '123'
	* resource_prefix = 'cachedContents'
	* splits_after_prefix = 1
	* client.vertexai = False
	* _resource_name(client, resource_name, resource_prefix, splits_after_prefix)
	* returns 'cachedContents/123'
	* ```
	*
	* ```
	* resource_name = 'some/wrong/cachedContents/resource/name/123'
	* resource_prefix = 'cachedContents'
	* splits_after_prefix = 1
	* client.vertexai = False
	* # client.vertexai = True
	* _resource_name(client, resource_name, resource_prefix, splits_after_prefix)
	* -> 'some/wrong/resource/name/123'
	* ```
	*/
	function resourceName(client, resourceName$1, resourcePrefix, splitsAfterPrefix = 1) {
		const shouldAppendPrefix = !resourceName$1.startsWith(`${resourcePrefix}/`) && resourceName$1.split("/").length === splitsAfterPrefix;
		if (client.isVertexAI()) if (resourceName$1.startsWith("projects/")) return resourceName$1;
		else if (resourceName$1.startsWith("locations/")) return `projects/${client.getProject()}/${resourceName$1}`;
		else if (resourceName$1.startsWith(`${resourcePrefix}/`)) return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName$1}`;
		else if (shouldAppendPrefix) return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName$1}`;
		else return resourceName$1;
		if (shouldAppendPrefix) return `${resourcePrefix}/${resourceName$1}`;
		return resourceName$1;
	}
	function tCachedContentName(apiClient, name) {
		if (typeof name !== "string") throw new Error("name must be a string");
		return resourceName(apiClient, name, "cachedContents");
	}
	function tBytes(apiClient, fromImageBytes) {
		if (typeof fromImageBytes !== "string") throw new Error("fromImageBytes must be a string");
		return fromImageBytes;
	}
	function tFileName(apiClient, fromName) {
		if (typeof fromName !== "string") throw new Error("fromName must be a string");
		if (fromName.startsWith("files/")) return fromName.split("files/")[1];
		return fromName;
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	function partToMldev$2(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["videoMetadata"]) !== void 0) throw new Error("videoMetadata parameter is not supported in Gemini API.");
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function contentToMldev$2(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partToMldev$2(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function functionDeclarationToMldev$2(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["response"]) !== void 0) throw new Error("response parameter is not supported in Gemini API.");
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromParameters = getValueByPath(fromObject, ["parameters"]);
		if (fromParameters != null) setValueByPath(toObject, ["parameters"], fromParameters);
		return toObject;
	}
	function googleSearchToMldev$2() {
		const toObject = {};
		return toObject;
	}
	function dynamicRetrievalConfigToMldev$2(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromDynamicThreshold = getValueByPath(fromObject, ["dynamicThreshold"]);
		if (fromDynamicThreshold != null) setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
		return toObject;
	}
	function googleSearchRetrievalToMldev$2(apiClient, fromObject) {
		const toObject = {};
		const fromDynamicRetrievalConfig = getValueByPath(fromObject, ["dynamicRetrievalConfig"]);
		if (fromDynamicRetrievalConfig != null) setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$2(apiClient, fromDynamicRetrievalConfig));
		return toObject;
	}
	function toolToMldev$2(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
		if (fromFunctionDeclarations != null) if (Array.isArray(fromFunctionDeclarations)) setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations.map((item) => {
			return functionDeclarationToMldev$2(apiClient, item);
		}));
		else setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations);
		if (getValueByPath(fromObject, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
		const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
		if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2());
		const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
		if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$2(apiClient, fromGoogleSearchRetrieval));
		const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
		if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
		return toObject;
	}
	function functionCallingConfigToMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromAllowedFunctionNames = getValueByPath(fromObject, ["allowedFunctionNames"]);
		if (fromAllowedFunctionNames != null) setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
		return toObject;
	}
	function toolConfigToMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionCallingConfig = getValueByPath(fromObject, ["functionCallingConfig"]);
		if (fromFunctionCallingConfig != null) setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(apiClient, fromFunctionCallingConfig));
		return toObject;
	}
	function createCachedContentConfigToMldev(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromTtl = getValueByPath(fromObject, ["ttl"]);
		if (parentObject !== void 0 && fromTtl != null) setValueByPath(parentObject, ["ttl"], fromTtl);
		const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
		if (parentObject !== void 0 && fromExpireTime != null) setValueByPath(parentObject, ["expireTime"], fromExpireTime);
		const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
		if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["displayName"], fromDisplayName);
		const fromContents = getValueByPath(fromObject, ["contents"]);
		if (parentObject !== void 0 && fromContents != null) if (Array.isArray(fromContents)) setValueByPath(parentObject, ["contents"], tContents(apiClient, tContents(apiClient, fromContents).map((item) => {
			return contentToMldev$2(apiClient, item);
		})));
		else setValueByPath(parentObject, ["contents"], tContents(apiClient, fromContents));
		const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
		if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], contentToMldev$2(apiClient, tContent(apiClient, fromSystemInstruction)));
		const fromTools = getValueByPath(fromObject, ["tools"]);
		if (parentObject !== void 0 && fromTools != null) if (Array.isArray(fromTools)) setValueByPath(parentObject, ["tools"], fromTools.map((item) => {
			return toolToMldev$2(apiClient, item);
		}));
		else setValueByPath(parentObject, ["tools"], fromTools);
		const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
		if (parentObject !== void 0 && fromToolConfig != null) setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(apiClient, fromToolConfig));
		return toObject;
	}
	function createCachedContentParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], createCachedContentConfigToMldev(apiClient, fromConfig, toObject));
		return toObject;
	}
	function getCachedContentParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function deleteCachedContentParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function updateCachedContentConfigToMldev(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromTtl = getValueByPath(fromObject, ["ttl"]);
		if (parentObject !== void 0 && fromTtl != null) setValueByPath(parentObject, ["ttl"], fromTtl);
		const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
		if (parentObject !== void 0 && fromExpireTime != null) setValueByPath(parentObject, ["expireTime"], fromExpireTime);
		return toObject;
	}
	function updateCachedContentParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], updateCachedContentConfigToMldev(apiClient, fromConfig, toObject));
		return toObject;
	}
	function listCachedContentsConfigToMldev(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
		if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
		const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
		if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
		return toObject;
	}
	function listCachedContentsParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], listCachedContentsConfigToMldev(apiClient, fromConfig, toObject));
		return toObject;
	}
	function partToVertex$2(apiClient, fromObject) {
		const toObject = {};
		const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
		if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function contentToVertex$2(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partToVertex$2(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function schemaToVertex$2(apiClient, fromObject) {
		const toObject = {};
		const fromExample = getValueByPath(fromObject, ["example"]);
		if (fromExample != null) setValueByPath(toObject, ["example"], fromExample);
		const fromPattern = getValueByPath(fromObject, ["pattern"]);
		if (fromPattern != null) setValueByPath(toObject, ["pattern"], fromPattern);
		const fromDefault = getValueByPath(fromObject, ["default"]);
		if (fromDefault != null) setValueByPath(toObject, ["default"], fromDefault);
		const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
		if (fromMaxLength != null) setValueByPath(toObject, ["maxLength"], fromMaxLength);
		const fromMinLength = getValueByPath(fromObject, ["minLength"]);
		if (fromMinLength != null) setValueByPath(toObject, ["minLength"], fromMinLength);
		const fromMinProperties = getValueByPath(fromObject, ["minProperties"]);
		if (fromMinProperties != null) setValueByPath(toObject, ["minProperties"], fromMinProperties);
		const fromMaxProperties = getValueByPath(fromObject, ["maxProperties"]);
		if (fromMaxProperties != null) setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
		const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
		if (fromAnyOf != null) setValueByPath(toObject, ["anyOf"], fromAnyOf);
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromEnum = getValueByPath(fromObject, ["enum"]);
		if (fromEnum != null) setValueByPath(toObject, ["enum"], fromEnum);
		const fromFormat = getValueByPath(fromObject, ["format"]);
		if (fromFormat != null) setValueByPath(toObject, ["format"], fromFormat);
		const fromItems = getValueByPath(fromObject, ["items"]);
		if (fromItems != null) setValueByPath(toObject, ["items"], fromItems);
		const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
		if (fromMaxItems != null) setValueByPath(toObject, ["maxItems"], fromMaxItems);
		const fromMaximum = getValueByPath(fromObject, ["maximum"]);
		if (fromMaximum != null) setValueByPath(toObject, ["maximum"], fromMaximum);
		const fromMinItems = getValueByPath(fromObject, ["minItems"]);
		if (fromMinItems != null) setValueByPath(toObject, ["minItems"], fromMinItems);
		const fromMinimum = getValueByPath(fromObject, ["minimum"]);
		if (fromMinimum != null) setValueByPath(toObject, ["minimum"], fromMinimum);
		const fromNullable = getValueByPath(fromObject, ["nullable"]);
		if (fromNullable != null) setValueByPath(toObject, ["nullable"], fromNullable);
		const fromProperties = getValueByPath(fromObject, ["properties"]);
		if (fromProperties != null) setValueByPath(toObject, ["properties"], fromProperties);
		const fromPropertyOrdering = getValueByPath(fromObject, ["propertyOrdering"]);
		if (fromPropertyOrdering != null) setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
		const fromRequired = getValueByPath(fromObject, ["required"]);
		if (fromRequired != null) setValueByPath(toObject, ["required"], fromRequired);
		const fromTitle = getValueByPath(fromObject, ["title"]);
		if (fromTitle != null) setValueByPath(toObject, ["title"], fromTitle);
		const fromType = getValueByPath(fromObject, ["type"]);
		if (fromType != null) setValueByPath(toObject, ["type"], fromType);
		return toObject;
	}
	function functionDeclarationToVertex$2(apiClient, fromObject) {
		const toObject = {};
		const fromResponse = getValueByPath(fromObject, ["response"]);
		if (fromResponse != null) setValueByPath(toObject, ["response"], schemaToVertex$2(apiClient, fromResponse));
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromParameters = getValueByPath(fromObject, ["parameters"]);
		if (fromParameters != null) setValueByPath(toObject, ["parameters"], fromParameters);
		return toObject;
	}
	function googleSearchToVertex$2() {
		const toObject = {};
		return toObject;
	}
	function dynamicRetrievalConfigToVertex$2(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromDynamicThreshold = getValueByPath(fromObject, ["dynamicThreshold"]);
		if (fromDynamicThreshold != null) setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
		return toObject;
	}
	function googleSearchRetrievalToVertex$2(apiClient, fromObject) {
		const toObject = {};
		const fromDynamicRetrievalConfig = getValueByPath(fromObject, ["dynamicRetrievalConfig"]);
		if (fromDynamicRetrievalConfig != null) setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$2(apiClient, fromDynamicRetrievalConfig));
		return toObject;
	}
	function toolToVertex$2(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
		if (fromFunctionDeclarations != null) if (Array.isArray(fromFunctionDeclarations)) setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations.map((item) => {
			return functionDeclarationToVertex$2(apiClient, item);
		}));
		else setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations);
		const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
		if (fromRetrieval != null) setValueByPath(toObject, ["retrieval"], fromRetrieval);
		const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
		if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$2());
		const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
		if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$2(apiClient, fromGoogleSearchRetrieval));
		const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
		if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
		return toObject;
	}
	function functionCallingConfigToVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromAllowedFunctionNames = getValueByPath(fromObject, ["allowedFunctionNames"]);
		if (fromAllowedFunctionNames != null) setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
		return toObject;
	}
	function toolConfigToVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionCallingConfig = getValueByPath(fromObject, ["functionCallingConfig"]);
		if (fromFunctionCallingConfig != null) setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex$1(apiClient, fromFunctionCallingConfig));
		return toObject;
	}
	function createCachedContentConfigToVertex(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromTtl = getValueByPath(fromObject, ["ttl"]);
		if (parentObject !== void 0 && fromTtl != null) setValueByPath(parentObject, ["ttl"], fromTtl);
		const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
		if (parentObject !== void 0 && fromExpireTime != null) setValueByPath(parentObject, ["expireTime"], fromExpireTime);
		const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
		if (parentObject !== void 0 && fromDisplayName != null) setValueByPath(parentObject, ["displayName"], fromDisplayName);
		const fromContents = getValueByPath(fromObject, ["contents"]);
		if (parentObject !== void 0 && fromContents != null) if (Array.isArray(fromContents)) setValueByPath(parentObject, ["contents"], tContents(apiClient, tContents(apiClient, fromContents).map((item) => {
			return contentToVertex$2(apiClient, item);
		})));
		else setValueByPath(parentObject, ["contents"], tContents(apiClient, fromContents));
		const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
		if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], contentToVertex$2(apiClient, tContent(apiClient, fromSystemInstruction)));
		const fromTools = getValueByPath(fromObject, ["tools"]);
		if (parentObject !== void 0 && fromTools != null) if (Array.isArray(fromTools)) setValueByPath(parentObject, ["tools"], fromTools.map((item) => {
			return toolToVertex$2(apiClient, item);
		}));
		else setValueByPath(parentObject, ["tools"], fromTools);
		const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
		if (parentObject !== void 0 && fromToolConfig != null) setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex$1(apiClient, fromToolConfig));
		return toObject;
	}
	function createCachedContentParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], createCachedContentConfigToVertex(apiClient, fromConfig, toObject));
		return toObject;
	}
	function getCachedContentParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function deleteCachedContentParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function updateCachedContentConfigToVertex(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromTtl = getValueByPath(fromObject, ["ttl"]);
		if (parentObject !== void 0 && fromTtl != null) setValueByPath(parentObject, ["ttl"], fromTtl);
		const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
		if (parentObject !== void 0 && fromExpireTime != null) setValueByPath(parentObject, ["expireTime"], fromExpireTime);
		return toObject;
	}
	function updateCachedContentParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], updateCachedContentConfigToVertex(apiClient, fromConfig, toObject));
		return toObject;
	}
	function listCachedContentsConfigToVertex(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
		if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
		const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
		if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
		return toObject;
	}
	function listCachedContentsParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], listCachedContentsConfigToVertex(apiClient, fromConfig, toObject));
		return toObject;
	}
	function cachedContentFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
		if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["model"], fromModel);
		const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
		if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
		const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
		if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
		const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
		if (fromExpireTime != null) setValueByPath(toObject, ["expireTime"], fromExpireTime);
		const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
		if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
		return toObject;
	}
	function deleteCachedContentResponseFromMldev() {
		const toObject = {};
		return toObject;
	}
	function listCachedContentsResponseFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
		if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
		const fromCachedContents = getValueByPath(fromObject, ["cachedContents"]);
		if (fromCachedContents != null) if (Array.isArray(fromCachedContents)) setValueByPath(toObject, ["cachedContents"], fromCachedContents.map((item) => {
			return cachedContentFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["cachedContents"], fromCachedContents);
		return toObject;
	}
	function cachedContentFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
		if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["model"], fromModel);
		const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
		if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
		const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
		if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
		const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
		if (fromExpireTime != null) setValueByPath(toObject, ["expireTime"], fromExpireTime);
		const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
		if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
		return toObject;
	}
	function deleteCachedContentResponseFromVertex() {
		const toObject = {};
		return toObject;
	}
	function listCachedContentsResponseFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
		if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
		const fromCachedContents = getValueByPath(fromObject, ["cachedContents"]);
		if (fromCachedContents != null) if (Array.isArray(fromCachedContents)) setValueByPath(toObject, ["cachedContents"], fromCachedContents.map((item) => {
			return cachedContentFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["cachedContents"], fromCachedContents);
		return toObject;
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	/**
	* Pagers for the GenAI List APIs.
	*/
	exports.PagedItem = void 0;
	(function(PagedItem) {
		PagedItem["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
		PagedItem["PAGED_ITEM_MODELS"] = "models";
		PagedItem["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
		PagedItem["PAGED_ITEM_FILES"] = "files";
		PagedItem["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
	})(exports.PagedItem || (exports.PagedItem = {}));
	/**
	* Pager class for iterating through paginated results.
	*/
	var Pager = class {
		constructor(name, request$3, response, params) {
			this.pageInternal = [];
			this.paramsInternal = {};
			this.requestInternal = request$3;
			this.init(name, response, params);
		}
		init(name, response, params) {
			var _a$5, _b$1;
			this.nameInternal = name;
			this.pageInternal = response[this.nameInternal] || [];
			this.idxInternal = 0;
			let requestParams = { config: {} };
			if (!params) requestParams = { config: {} };
			else if (typeof params === "object") requestParams = Object.assign({}, params);
			else requestParams = params;
			if (requestParams["config"]) requestParams["config"]["pageToken"] = response["nextPageToken"];
			this.paramsInternal = requestParams;
			this.pageInternalSize = (_b$1 = (_a$5 = requestParams["config"]) === null || _a$5 === void 0 ? void 0 : _a$5["pageSize"]) !== null && _b$1 !== void 0 ? _b$1 : this.pageInternal.length;
		}
		initNextPage(response) {
			this.init(this.nameInternal, response, this.paramsInternal);
		}
		/**
		* Returns the current page, which is a list of items.
		*
		* @remarks
		* The first page is retrieved when the pager is created. The returned list of
		* items could be a subset of the entire list.
		*/
		get page() {
			return this.pageInternal;
		}
		/**
		* Returns the type of paged item (for example, ``batch_jobs``).
		*/
		get name() {
			return this.nameInternal;
		}
		/**
		* Returns the length of the page fetched each time by this pager.
		*
		* @remarks
		* The number of items in the page is less than or equal to the page length.
		*/
		get pageSize() {
			return this.pageInternalSize;
		}
		/**
		* Returns the parameters when making the API request for the next page.
		*
		* @remarks
		* Parameters contain a set of optional configs that can be
		* used to customize the API request. For example, the `pageToken` parameter
		* contains the token to request the next page.
		*/
		get params() {
			return this.paramsInternal;
		}
		/**
		* Returns the total number of items in the current page.
		*/
		get pageLength() {
			return this.pageInternal.length;
		}
		/**
		* Returns the item at the given index.
		*/
		getItem(index) {
			return this.pageInternal[index];
		}
		/**
		* Returns an async iterator that support iterating through all items
		* retrieved from the API.
		*
		* @remarks
		* The iterator will automatically fetch the next page if there are more items
		* to fetch from the API.
		*
		* @example
		*
		* ```ts
		* const pager = await ai.files.list({config: {pageSize: 10}});
		* for await (const file of pager) {
		*   console.log(file.name);
		* }
		* ```
		*/
		[Symbol.asyncIterator]() {
			return {
				next: async () => {
					if (this.idxInternal >= this.pageLength) if (this.hasNextPage()) await this.nextPage();
					else return {
						value: void 0,
						done: true
					};
					const item = this.getItem(this.idxInternal);
					this.idxInternal += 1;
					return {
						value: item,
						done: false
					};
				},
				return: async () => {
					return {
						value: void 0,
						done: true
					};
				}
			};
		}
		/**
		* Fetches the next page of items. This makes a new API request.
		*
		* @throws {Error} If there are no more pages to fetch.
		*
		* @example
		*
		* ```ts
		* const pager = await ai.files.list({config: {pageSize: 10}});
		* let page = pager.page;
		* while (true) {
		*   for (const file of page) {
		*     console.log(file.name);
		*   }
		*   if (!pager.hasNextPage()) {
		*     break;
		*   }
		*   page = await pager.nextPage();
		* }
		* ```
		*/
		async nextPage() {
			if (!this.hasNextPage()) throw new Error("No more pages to fetch.");
			const response = await this.requestInternal(this.params);
			this.initNextPage(response);
			return this.page;
		}
		/**
		* Returns true if there are more pages to fetch from the API.
		*/
		hasNextPage() {
			var _a$5;
			if (((_a$5 = this.params["config"]) === null || _a$5 === void 0 ? void 0 : _a$5["pageToken"]) !== void 0) return true;
			return false;
		}
	};
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	/** Required. Outcome of the code execution. */
	exports.Outcome = void 0;
	(function(Outcome) {
		Outcome["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
		Outcome["OUTCOME_OK"] = "OUTCOME_OK";
		Outcome["OUTCOME_FAILED"] = "OUTCOME_FAILED";
		Outcome["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
	})(exports.Outcome || (exports.Outcome = {}));
	/** Required. Programming language of the `code`. */
	exports.Language = void 0;
	(function(Language) {
		Language["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
		Language["PYTHON"] = "PYTHON";
	})(exports.Language || (exports.Language = {}));
	/** Optional. The type of the data. */
	exports.Type = void 0;
	(function(Type) {
		Type["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
		Type["STRING"] = "STRING";
		Type["NUMBER"] = "NUMBER";
		Type["INTEGER"] = "INTEGER";
		Type["BOOLEAN"] = "BOOLEAN";
		Type["ARRAY"] = "ARRAY";
		Type["OBJECT"] = "OBJECT";
	})(exports.Type || (exports.Type = {}));
	/** Required. Harm category. */
	exports.HarmCategory = void 0;
	(function(HarmCategory) {
		HarmCategory["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
		HarmCategory["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
		HarmCategory["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
		HarmCategory["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
		HarmCategory["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
		HarmCategory["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
	})(exports.HarmCategory || (exports.HarmCategory = {}));
	/** Optional. Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. */
	exports.HarmBlockMethod = void 0;
	(function(HarmBlockMethod) {
		HarmBlockMethod["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
		HarmBlockMethod["SEVERITY"] = "SEVERITY";
		HarmBlockMethod["PROBABILITY"] = "PROBABILITY";
	})(exports.HarmBlockMethod || (exports.HarmBlockMethod = {}));
	/** Required. The harm block threshold. */
	exports.HarmBlockThreshold = void 0;
	(function(HarmBlockThreshold) {
		HarmBlockThreshold["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
		HarmBlockThreshold["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
		HarmBlockThreshold["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
		HarmBlockThreshold["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
		HarmBlockThreshold["BLOCK_NONE"] = "BLOCK_NONE";
		HarmBlockThreshold["OFF"] = "OFF";
	})(exports.HarmBlockThreshold || (exports.HarmBlockThreshold = {}));
	/** The mode of the predictor to be used in dynamic retrieval. */
	exports.Mode = void 0;
	(function(Mode) {
		Mode["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
		Mode["MODE_DYNAMIC"] = "MODE_DYNAMIC";
	})(exports.Mode || (exports.Mode = {}));
	/** Output only. The reason why the model stopped generating tokens.
	
	If empty, the model has not stopped generating the tokens.
	*/
	exports.FinishReason = void 0;
	(function(FinishReason) {
		FinishReason["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
		FinishReason["STOP"] = "STOP";
		FinishReason["MAX_TOKENS"] = "MAX_TOKENS";
		FinishReason["SAFETY"] = "SAFETY";
		FinishReason["RECITATION"] = "RECITATION";
		FinishReason["OTHER"] = "OTHER";
		FinishReason["BLOCKLIST"] = "BLOCKLIST";
		FinishReason["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
		FinishReason["SPII"] = "SPII";
		FinishReason["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
		FinishReason["IMAGE_SAFETY"] = "IMAGE_SAFETY";
	})(exports.FinishReason || (exports.FinishReason = {}));
	/** Output only. Harm probability levels in the content. */
	exports.HarmProbability = void 0;
	(function(HarmProbability) {
		HarmProbability["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
		HarmProbability["NEGLIGIBLE"] = "NEGLIGIBLE";
		HarmProbability["LOW"] = "LOW";
		HarmProbability["MEDIUM"] = "MEDIUM";
		HarmProbability["HIGH"] = "HIGH";
	})(exports.HarmProbability || (exports.HarmProbability = {}));
	/** Output only. Harm severity levels in the content. */
	exports.HarmSeverity = void 0;
	(function(HarmSeverity) {
		HarmSeverity["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
		HarmSeverity["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
		HarmSeverity["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
		HarmSeverity["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
		HarmSeverity["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
	})(exports.HarmSeverity || (exports.HarmSeverity = {}));
	/** Output only. Blocked reason. */
	exports.BlockedReason = void 0;
	(function(BlockedReason) {
		BlockedReason["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
		BlockedReason["SAFETY"] = "SAFETY";
		BlockedReason["OTHER"] = "OTHER";
		BlockedReason["BLOCKLIST"] = "BLOCKLIST";
		BlockedReason["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
	})(exports.BlockedReason || (exports.BlockedReason = {}));
	/** Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota. */
	exports.TrafficType = void 0;
	(function(TrafficType) {
		TrafficType["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
		TrafficType["ON_DEMAND"] = "ON_DEMAND";
		TrafficType["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
	})(exports.TrafficType || (exports.TrafficType = {}));
	/** Server content modalities. */
	exports.Modality = void 0;
	(function(Modality) {
		Modality["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
		Modality["TEXT"] = "TEXT";
		Modality["IMAGE"] = "IMAGE";
		Modality["AUDIO"] = "AUDIO";
	})(exports.Modality || (exports.Modality = {}));
	/** The media resolution to use. */
	exports.MediaResolution = void 0;
	(function(MediaResolution) {
		MediaResolution["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
		MediaResolution["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
		MediaResolution["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
		MediaResolution["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
	})(exports.MediaResolution || (exports.MediaResolution = {}));
	/** Options for feature selection preference. */
	exports.FeatureSelectionPreference = void 0;
	(function(FeatureSelectionPreference) {
		FeatureSelectionPreference["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
		FeatureSelectionPreference["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
		FeatureSelectionPreference["BALANCED"] = "BALANCED";
		FeatureSelectionPreference["PRIORITIZE_COST"] = "PRIORITIZE_COST";
	})(exports.FeatureSelectionPreference || (exports.FeatureSelectionPreference = {}));
	/** Config for the dynamic retrieval config mode. */
	exports.DynamicRetrievalConfigMode = void 0;
	(function(DynamicRetrievalConfigMode) {
		DynamicRetrievalConfigMode["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
		DynamicRetrievalConfigMode["MODE_DYNAMIC"] = "MODE_DYNAMIC";
	})(exports.DynamicRetrievalConfigMode || (exports.DynamicRetrievalConfigMode = {}));
	/** Config for the function calling config mode. */
	exports.FunctionCallingConfigMode = void 0;
	(function(FunctionCallingConfigMode) {
		FunctionCallingConfigMode["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
		FunctionCallingConfigMode["AUTO"] = "AUTO";
		FunctionCallingConfigMode["ANY"] = "ANY";
		FunctionCallingConfigMode["NONE"] = "NONE";
	})(exports.FunctionCallingConfigMode || (exports.FunctionCallingConfigMode = {}));
	/** Enum that controls the safety filter level for objectionable content. */
	exports.SafetyFilterLevel = void 0;
	(function(SafetyFilterLevel) {
		SafetyFilterLevel["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
		SafetyFilterLevel["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
		SafetyFilterLevel["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
		SafetyFilterLevel["BLOCK_NONE"] = "BLOCK_NONE";
	})(exports.SafetyFilterLevel || (exports.SafetyFilterLevel = {}));
	/** Enum that controls the generation of people. */
	exports.PersonGeneration = void 0;
	(function(PersonGeneration) {
		PersonGeneration["DONT_ALLOW"] = "DONT_ALLOW";
		PersonGeneration["ALLOW_ADULT"] = "ALLOW_ADULT";
		PersonGeneration["ALLOW_ALL"] = "ALLOW_ALL";
	})(exports.PersonGeneration || (exports.PersonGeneration = {}));
	/** Enum that specifies the language of the text in the prompt. */
	exports.ImagePromptLanguage = void 0;
	(function(ImagePromptLanguage) {
		ImagePromptLanguage["auto"] = "auto";
		ImagePromptLanguage["en"] = "en";
		ImagePromptLanguage["ja"] = "ja";
		ImagePromptLanguage["ko"] = "ko";
		ImagePromptLanguage["hi"] = "hi";
	})(exports.ImagePromptLanguage || (exports.ImagePromptLanguage = {}));
	/** State for the lifecycle of a File. */
	exports.FileState = void 0;
	(function(FileState) {
		FileState["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
		FileState["PROCESSING"] = "PROCESSING";
		FileState["ACTIVE"] = "ACTIVE";
		FileState["FAILED"] = "FAILED";
	})(exports.FileState || (exports.FileState = {}));
	/** Source of the File. */
	exports.FileSource = void 0;
	(function(FileSource) {
		FileSource["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
		FileSource["UPLOADED"] = "UPLOADED";
		FileSource["GENERATED"] = "GENERATED";
	})(exports.FileSource || (exports.FileSource = {}));
	/** Enum representing the mask mode of a mask reference image. */
	exports.MaskReferenceMode = void 0;
	(function(MaskReferenceMode) {
		MaskReferenceMode["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
		MaskReferenceMode["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
		MaskReferenceMode["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
		MaskReferenceMode["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
		MaskReferenceMode["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
	})(exports.MaskReferenceMode || (exports.MaskReferenceMode = {}));
	/** Enum representing the control type of a control reference image. */
	exports.ControlReferenceType = void 0;
	(function(ControlReferenceType) {
		ControlReferenceType["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
		ControlReferenceType["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
		ControlReferenceType["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
		ControlReferenceType["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
	})(exports.ControlReferenceType || (exports.ControlReferenceType = {}));
	/** Enum representing the subject type of a subject reference image. */
	exports.SubjectReferenceType = void 0;
	(function(SubjectReferenceType) {
		SubjectReferenceType["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
		SubjectReferenceType["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
		SubjectReferenceType["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
		SubjectReferenceType["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
	})(exports.SubjectReferenceType || (exports.SubjectReferenceType = {}));
	/** Server content modalities. */
	exports.MediaModality = void 0;
	(function(MediaModality) {
		MediaModality["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
		MediaModality["TEXT"] = "TEXT";
		MediaModality["IMAGE"] = "IMAGE";
		MediaModality["VIDEO"] = "VIDEO";
		MediaModality["AUDIO"] = "AUDIO";
		MediaModality["DOCUMENT"] = "DOCUMENT";
	})(exports.MediaModality || (exports.MediaModality = {}));
	/** Start of speech sensitivity. */
	exports.StartSensitivity = void 0;
	(function(StartSensitivity) {
		StartSensitivity["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
		StartSensitivity["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
		StartSensitivity["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
	})(exports.StartSensitivity || (exports.StartSensitivity = {}));
	/** End of speech sensitivity. */
	exports.EndSensitivity = void 0;
	(function(EndSensitivity) {
		EndSensitivity["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
		EndSensitivity["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
		EndSensitivity["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
	})(exports.EndSensitivity || (exports.EndSensitivity = {}));
	/** The different ways of handling user activity. */
	exports.ActivityHandling = void 0;
	(function(ActivityHandling) {
		ActivityHandling["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
		ActivityHandling["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
		ActivityHandling["NO_INTERRUPTION"] = "NO_INTERRUPTION";
	})(exports.ActivityHandling || (exports.ActivityHandling = {}));
	/** Options about which input is included in the user's turn. */
	exports.TurnCoverage = void 0;
	(function(TurnCoverage) {
		TurnCoverage["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
		TurnCoverage["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
		TurnCoverage["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
	})(exports.TurnCoverage || (exports.TurnCoverage = {}));
	/** A function response. */
	var FunctionResponse = class {};
	/**
	* Creates a `Part` object from a `URI` string.
	*/
	function createPartFromUri(uri, mimeType) {
		return { fileData: {
			fileUri: uri,
			mimeType
		} };
	}
	/**
	* Creates a `Part` object from a `text` string.
	*/
	function createPartFromText(text) {
		return { text };
	}
	/**
	* Creates a `Part` object from a `FunctionCall` object.
	*/
	function createPartFromFunctionCall(name, args) {
		return { functionCall: {
			name,
			args
		} };
	}
	/**
	* Creates a `Part` object from a `FunctionResponse` object.
	*/
	function createPartFromFunctionResponse(id, name, response) {
		return { functionResponse: {
			id,
			name,
			response
		} };
	}
	/**
	* Creates a `Part` object from a `base64` encoded `string`.
	*/
	function createPartFromBase64(data, mimeType) {
		return { inlineData: {
			data,
			mimeType
		} };
	}
	/**
	* Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.
	*/
	function createPartFromCodeExecutionResult(outcome, output) {
		return { codeExecutionResult: {
			outcome,
			output
		} };
	}
	/**
	* Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.
	*/
	function createPartFromExecutableCode(code$1, language) {
		return { executableCode: {
			code: code$1,
			language
		} };
	}
	function _isPart(obj) {
		if (typeof obj === "object" && obj !== null) return "fileData" in obj || "text" in obj || "functionCall" in obj || "functionResponse" in obj || "inlineData" in obj || "videoMetadata" in obj || "codeExecutionResult" in obj || "executableCode" in obj;
		return false;
	}
	function _toParts(partOrString) {
		const parts = [];
		if (typeof partOrString === "string") parts.push(createPartFromText(partOrString));
		else if (_isPart(partOrString)) parts.push(partOrString);
		else if (Array.isArray(partOrString)) {
			if (partOrString.length === 0) throw new Error("partOrString cannot be an empty array");
			for (const part of partOrString) if (typeof part === "string") parts.push(createPartFromText(part));
			else if (_isPart(part)) parts.push(part);
			else throw new Error("element in PartUnion must be a Part object or string");
		} else throw new Error("partOrString must be a Part object, string, or array");
		return parts;
	}
	/**
	* Creates a `Content` object with a user role from a `PartListUnion` object or `string`.
	*/
	function createUserContent(partOrString) {
		return {
			role: "user",
			parts: _toParts(partOrString)
		};
	}
	/**
	* Creates a `Content` object with a model role from a `PartListUnion` object or `string`.
	*/
	function createModelContent(partOrString) {
		return {
			role: "model",
			parts: _toParts(partOrString)
		};
	}
	/** Content filter results for a prompt sent in the request. */
	var GenerateContentResponsePromptFeedback = class {};
	/** Usage metadata about response(s). */
	var GenerateContentResponseUsageMetadata = class {};
	/** Response message for PredictionService.GenerateContent. */
	var GenerateContentResponse = class {
		/**
		* Returns the concatenation of all text parts from the first candidate in the response.
		*
		* @remarks
		* If there are multiple candidates in the response, the text from the first
		* one will be returned.
		* If there are non-text parts in the response, the concatenation of all text
		* parts will be returned, and a warning will be logged.
		* If there are thought parts in the response, the concatenation of all text
		* parts excluding the thought parts will be returned.
		*
		* @example
		* ```ts
		* const response = await ai.models.generateContent({
		*   model: 'gemini-2.0-flash',
		*   contents:
		*     'Why is the sky blue?',
		* });
		*
		* console.debug(response.text);
		* ```
		*/
		get text() {
			var _a$5, _b$1, _c$1, _d, _e, _f, _g, _h;
			if (((_d = (_c$1 = (_b$1 = (_a$5 = this.candidates) === null || _a$5 === void 0 ? void 0 : _a$5[0]) === null || _b$1 === void 0 ? void 0 : _b$1.content) === null || _c$1 === void 0 ? void 0 : _c$1.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) return void 0;
			if (this.candidates && this.candidates.length > 1) console.warn("there are multiple candidates in the response, returning text from the first one.");
			let text = "";
			let anyTextPartText = false;
			const nonTextParts = [];
			for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
				for (const [fieldName, fieldValue] of Object.entries(part)) if (fieldName !== "text" && fieldName !== "thought" && (fieldValue !== null || fieldValue !== void 0)) nonTextParts.push(fieldName);
				if (typeof part.text === "string") {
					if (typeof part.thought === "boolean" && part.thought) continue;
					anyTextPartText = true;
					text += part.text;
				}
			}
			if (nonTextParts.length > 0) console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
			return anyTextPartText ? text : void 0;
		}
		/**
		* Returns the function calls from the first candidate in the response.
		*
		* @remarks
		* If there are multiple candidates in the response, the function calls from
		* the first one will be returned.
		* If there are no function calls in the response, undefined will be returned.
		*
		* @example
		* ```ts
		* const controlLightFunctionDeclaration: FunctionDeclaration = {
		*   name: 'controlLight',
		*   parameters: {
		*   type: Type.OBJECT,
		*   description: 'Set the brightness and color temperature of a room light.',
		*   properties: {
		*     brightness: {
		*       type: Type.NUMBER,
		*       description:
		*         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
		*     },
		*     colorTemperature: {
		*       type: Type.STRING,
		*       description:
		*         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
		*     },
		*   },
		*   required: ['brightness', 'colorTemperature'],
		*  };
		*  const response = await ai.models.generateContent({
		*     model: 'gemini-2.0-flash',
		*     contents: 'Dim the lights so the room feels cozy and warm.',
		*     config: {
		*       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
		*       toolConfig: {
		*         functionCallingConfig: {
		*           mode: FunctionCallingConfigMode.ANY,
		*           allowedFunctionNames: ['controlLight'],
		*         },
		*       },
		*     },
		*   });
		*  console.debug(JSON.stringify(response.functionCalls));
		* ```
		*/
		get functionCalls() {
			var _a$5, _b$1, _c$1, _d, _e, _f, _g, _h;
			if (((_d = (_c$1 = (_b$1 = (_a$5 = this.candidates) === null || _a$5 === void 0 ? void 0 : _a$5[0]) === null || _b$1 === void 0 ? void 0 : _b$1.content) === null || _c$1 === void 0 ? void 0 : _c$1.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) return void 0;
			if (this.candidates && this.candidates.length > 1) console.warn("there are multiple candidates in the response, returning function calls from the first one.");
			const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
			if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) return void 0;
			return functionCalls;
		}
		/**
		* Returns the first executable code from the first candidate in the response.
		*
		* @remarks
		* If there are multiple candidates in the response, the executable code from
		* the first one will be returned.
		* If there are no executable code in the response, undefined will be
		* returned.
		*
		* @example
		* ```ts
		* const response = await ai.models.generateContent({
		*   model: 'gemini-2.0-flash',
		*   contents:
		*     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
		*   config: {
		*     tools: [{codeExecution: {}}],
		*   },
		* });
		*
		* console.debug(response.executableCode);
		* ```
		*/
		get executableCode() {
			var _a$5, _b$1, _c$1, _d, _e, _f, _g, _h, _j;
			if (((_d = (_c$1 = (_b$1 = (_a$5 = this.candidates) === null || _a$5 === void 0 ? void 0 : _a$5[0]) === null || _b$1 === void 0 ? void 0 : _b$1.content) === null || _c$1 === void 0 ? void 0 : _c$1.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) return void 0;
			if (this.candidates && this.candidates.length > 1) console.warn("there are multiple candidates in the response, returning executable code from the first one.");
			const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode$1) => executableCode$1 !== void 0);
			if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) return void 0;
			return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
		}
		/**
		* Returns the first code execution result from the first candidate in the response.
		*
		* @remarks
		* If there are multiple candidates in the response, the code execution result from
		* the first one will be returned.
		* If there are no code execution result in the response, undefined will be returned.
		*
		* @example
		* ```ts
		* const response = await ai.models.generateContent({
		*   model: 'gemini-2.0-flash',
		*   contents:
		*     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
		*   config: {
		*     tools: [{codeExecution: {}}],
		*   },
		* });
		*
		* console.debug(response.codeExecutionResult);
		* ```
		*/
		get codeExecutionResult() {
			var _a$5, _b$1, _c$1, _d, _e, _f, _g, _h, _j;
			if (((_d = (_c$1 = (_b$1 = (_a$5 = this.candidates) === null || _a$5 === void 0 ? void 0 : _a$5[0]) === null || _b$1 === void 0 ? void 0 : _b$1.content) === null || _c$1 === void 0 ? void 0 : _c$1.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) return void 0;
			if (this.candidates && this.candidates.length > 1) console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
			const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult$1) => codeExecutionResult$1 !== void 0);
			if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) return void 0;
			return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
		}
	};
	/** Response for the embed_content method. */
	var EmbedContentResponse = class {};
	/** The output images response. */
	var GenerateImagesResponse = class {};
	/** Response for counting tokens. */
	var CountTokensResponse = class {};
	/** Response for computing tokens. */
	var ComputeTokensResponse = class {};
	/** Response with generated videos. */
	var GenerateVideosResponse = class {};
	/** Empty response for caches.delete method. */
	var DeleteCachedContentResponse = class {};
	var ListCachedContentsResponse = class {};
	/** Response for the list files method. */
	var ListFilesResponse = class {};
	/** A wrapper class for the http response. */
	var HttpResponse = class {
		constructor(response) {
			const headers = {};
			for (const pair of response.headers.entries()) headers[pair[0]] = pair[1];
			this.headers = headers;
			this.responseInternal = response;
		}
		json() {
			return this.responseInternal.json();
		}
	};
	/** Response for the create file method. */
	var CreateFileResponse = class {};
	/** Response for the delete file method. */
	var DeleteFileResponse = class {};
	/** Represents a single response in a replay. */
	var ReplayResponse = class {};
	/** Client generated response to a `ToolCall` received from the server.
	
	Individual `FunctionResponse` objects are matched to the respective
	`FunctionCall` objects by the `id` field.
	
	Note that in the unary and server-streaming GenerateContent APIs function
	calling happens by exchanging the `Content` parts, while in the bidi
	GenerateContent APIs function calling happens over this dedicated set of
	messages.
	*/
	var LiveClientToolResponse = class {};
	/** Parameters for sending tool responses to the live API. */
	var LiveSendToolResponseParameters = class {
		constructor() {
			/** Tool responses to send to the session. */
			this.functionResponses = [];
		}
	};
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	var Caches = class extends BaseModule {
		constructor(apiClient) {
			super();
			this.apiClient = apiClient;
			/**
			* Lists cached content configurations.
			*
			* @param params - The parameters for the list request.
			* @return The paginated results of the list of cached contents.
			*
			* @example
			* ```ts
			* const cachedContents = await ai.caches.list({config: {'pageSize': 2}});
			* for (const cachedContent of cachedContents) {
			*   console.log(cachedContent);
			* }
			* ```
			*/
			this.list = async (params = {}) => {
				return new Pager(exports.PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);
			};
		}
		/**
		* Creates a cached contents resource.
		*
		* @remarks
		* Context caching is only supported for specific models. See [Gemini
		* Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
		* and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
		* for more information.
		*
		* @param params - The parameters for the create request.
		* @return The created cached content.
		*
		* @example
		* ```ts
		* const contents = ...; // Initialize the content to cache.
		* const response = await ai.caches.create({
		*   model: 'gemini-1.5-flash',
		*   config: {
		*    'contents': contents,
		*    'displayName': 'test cache',
		*    'systemInstruction': 'What is the sum of the two pdfs?',
		*    'ttl': '86400s',
		*  }
		* });
		* ```
		*/
		async create(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = createCachedContentParametersToVertex(this.apiClient, params);
				path$8 = formatMap("cachedContents", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = cachedContentFromVertex(this.apiClient, apiResponse);
					return resp;
				});
			} else {
				const body = createCachedContentParametersToMldev(this.apiClient, params);
				path$8 = formatMap("cachedContents", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = cachedContentFromMldev(this.apiClient, apiResponse);
					return resp;
				});
			}
		}
		/**
		* Gets cached content configurations.
		*
		* @param params - The parameters for the get request.
		* @return The cached content.
		*
		* @example
		* ```ts
		* await ai.caches.get({name: 'gemini-1.5-flash'});
		* ```
		*/
		async get(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = getCachedContentParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{name}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = cachedContentFromVertex(this.apiClient, apiResponse);
					return resp;
				});
			} else {
				const body = getCachedContentParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{name}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = cachedContentFromMldev(this.apiClient, apiResponse);
					return resp;
				});
			}
		}
		/**
		* Deletes cached content.
		*
		* @param params - The parameters for the delete request.
		* @return The empty response returned by the API.
		*
		* @example
		* ```ts
		* await ai.caches.delete({name: 'gemini-1.5-flash'});
		* ```
		*/
		async delete(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = deleteCachedContentParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{name}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "DELETE",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then(() => {
					const resp = deleteCachedContentResponseFromVertex();
					const typedResp = new DeleteCachedContentResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			} else {
				const body = deleteCachedContentParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{name}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "DELETE",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then(() => {
					const resp = deleteCachedContentResponseFromMldev();
					const typedResp = new DeleteCachedContentResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			}
		}
		/**
		* Updates cached content configurations.
		*
		* @param params - The parameters for the update request.
		* @return The updated cached content.
		*
		* @example
		* ```ts
		* const response = await ai.caches.update({
		*   name: 'gemini-1.5-flash',
		*   config: {'ttl': '7600s'}
		* });
		* ```
		*/
		async update(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = updateCachedContentParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{name}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "PATCH",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = cachedContentFromVertex(this.apiClient, apiResponse);
					return resp;
				});
			} else {
				const body = updateCachedContentParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{name}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "PATCH",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = cachedContentFromMldev(this.apiClient, apiResponse);
					return resp;
				});
			}
		}
		async listInternal(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = listCachedContentsParametersToVertex(this.apiClient, params);
				path$8 = formatMap("cachedContents", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = listCachedContentsResponseFromVertex(this.apiClient, apiResponse);
					const typedResp = new ListCachedContentsResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			} else {
				const body = listCachedContentsParametersToMldev(this.apiClient, params);
				path$8 = formatMap("cachedContents", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = listCachedContentsResponseFromMldev(this.apiClient, apiResponse);
					const typedResp = new ListCachedContentsResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			}
		}
	};
	/******************************************************************************
	
	Copyright (c) Microsoft Corporation.
	
	
	
	Permission to use, copy, modify, and/or distribute this software for any
	
	purpose with or without fee is hereby granted.
	
	
	
	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	
	PERFORMANCE OF THIS SOFTWARE.
	
	***************************************************************************** */
	function __values(o) {
		var s$1 = typeof Symbol === "function" && Symbol.iterator, m$1 = s$1 && o[s$1], i$1 = 0;
		if (m$1) return m$1.call(o);
		if (o && typeof o.length === "number") return { next: function() {
			if (o && i$1 >= o.length) o = void 0;
			return {
				value: o && o[i$1++],
				done: !o
			};
		} };
		throw new TypeError(s$1 ? "Object is not iterable." : "Symbol.iterator is not defined.");
	}
	function __await(v) {
		return this instanceof __await ? (this.v = v, this) : new __await(v);
	}
	function __asyncGenerator(thisArg, _arguments, generator) {
		if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
		var g = generator.apply(thisArg, _arguments || []), i$1, q = [];
		return i$1 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i$1[Symbol.asyncIterator] = function() {
			return this;
		}, i$1;
		function awaitReturn(f) {
			return function(v) {
				return Promise.resolve(v).then(f, reject);
			};
		}
		function verb(n, f) {
			if (g[n]) {
				i$1[n] = function(v) {
					return new Promise(function(a$1, b) {
						q.push([
							n,
							v,
							a$1,
							b
						]) > 1 || resume$3(n, v);
					});
				};
				if (f) i$1[n] = f(i$1[n]);
			}
		}
		function resume$3(n, v) {
			try {
				step(g[n](v));
			} catch (e) {
				settle(q[0][3], e);
			}
		}
		function step(r) {
			r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
		}
		function fulfill(value) {
			resume$3("next", value);
		}
		function reject(value) {
			resume$3("throw", value);
		}
		function settle(f, v) {
			if (f(v), q.shift(), q.length) resume$3(q[0][0], q[0][1]);
		}
	}
	function __asyncValues(o) {
		if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
		var m$1 = o[Symbol.asyncIterator], i$1;
		return m$1 ? m$1.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i$1 = {}, verb("next"), verb("throw"), verb("return"), i$1[Symbol.asyncIterator] = function() {
			return this;
		}, i$1);
		function verb(n) {
			i$1[n] = o[n] && function(v) {
				return new Promise(function(resolve, reject) {
					v = o[n](v), settle(resolve, reject, v.done, v.value);
				});
			};
		}
		function settle(resolve, reject, d$1, v) {
			Promise.resolve(v).then(function(v$1) {
				resolve({
					value: v$1,
					done: d$1
				});
			}, reject);
		}
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	/**
	* Returns true if the response is valid, false otherwise.
	*/
	function isValidResponse(response) {
		var _a$5;
		if (response.candidates == void 0 || response.candidates.length === 0) return false;
		const content = (_a$5 = response.candidates[0]) === null || _a$5 === void 0 ? void 0 : _a$5.content;
		if (content === void 0) return false;
		return isValidContent(content);
	}
	function isValidContent(content) {
		if (content.parts === void 0 || content.parts.length === 0) return false;
		for (const part of content.parts) {
			if (part === void 0 || Object.keys(part).length === 0) return false;
			if (part.text !== void 0 && part.text === "") return false;
		}
		return true;
	}
	/**
	* Validates the history contains the correct roles.
	*
	* @remarks
	* Expects the history to start with a user turn and then alternate between
	* user and model turns.
	*
	* @throws Error if the history does not start with a user turn.
	* @throws Error if the history contains an invalid role.
	*/
	function validateHistory(history) {
		if (history.length === 0) return;
		if (history[0].role !== "user") throw new Error("History must start with a user turn.");
		for (const content of history) if (content.role !== "user" && content.role !== "model") throw new Error(`Role must be user or model, but got ${content.role}.`);
	}
	/**
	* Extracts the curated (valid) history from a comprehensive history.
	*
	* @remarks
	* The model may sometimes generate invalid or empty contents(e.g., due to safty
	* filters or recitation). Extracting valid turns from the history
	* ensures that subsequent requests could be accpeted by the model.
	*/
	function extractCuratedHistory(comprehensiveHistory) {
		if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) return [];
		const curatedHistory = [];
		const length = comprehensiveHistory.length;
		let i$1 = 0;
		let userInput = comprehensiveHistory[0];
		while (i$1 < length) if (comprehensiveHistory[i$1].role === "user") {
			userInput = comprehensiveHistory[i$1];
			i$1++;
		} else {
			const modelOutput = [];
			let isValid = true;
			while (i$1 < length && comprehensiveHistory[i$1].role === "model") {
				modelOutput.push(comprehensiveHistory[i$1]);
				if (isValid && !isValidContent(comprehensiveHistory[i$1])) isValid = false;
				i$1++;
			}
			if (isValid) {
				curatedHistory.push(userInput);
				curatedHistory.push(...modelOutput);
			}
		}
		return curatedHistory;
	}
	/**
	* A utility class to create a chat session.
	*/
	var Chats = class {
		constructor(modelsModule, apiClient) {
			this.modelsModule = modelsModule;
			this.apiClient = apiClient;
		}
		/**
		* Creates a new chat session.
		*
		* @remarks
		* The config in the params will be used for all requests within the chat
		* session unless overridden by a per-request `config` in
		* @see {@link types.SendMessageParameters#config}.
		*
		* @param params - Parameters for creating a chat session.
		* @returns A new chat session.
		*
		* @example
		* ```ts
		* const chat = ai.chats.create({
		*   model: 'gemini-2.0-flash'
		*   config: {
		*     temperature: 0.5,
		*     maxOutputTokens: 1024,
		*   }
		* });
		* ```
		*/
		create(params) {
			return new Chat(this.apiClient, this.modelsModule, params.model, params.config, params.history);
		}
	};
	/**
	* Chat session that enables sending messages to the model with previous
	* conversation context.
	*
	* @remarks
	* The session maintains all the turns between user and model.
	*/
	var Chat = class {
		constructor(apiClient, modelsModule, model, config$1 = {}, history = []) {
			this.apiClient = apiClient;
			this.modelsModule = modelsModule;
			this.model = model;
			this.config = config$1;
			this.history = history;
			this.sendPromise = Promise.resolve();
			validateHistory(history);
		}
		/**
		* Sends a message to the model and returns the response.
		*
		* @remarks
		* This method will wait for the previous message to be processed before
		* sending the next message.
		*
		* @see {@link Chat#sendMessageStream} for streaming method.
		* @param params - parameters for sending messages within a chat session.
		* @returns The model's response.
		*
		* @example
		* ```ts
		* const chat = ai.chats.create({model: 'gemini-2.0-flash'});
		* const response = await chat.sendMessage({
		*   message: 'Why is the sky blue?'
		* });
		* console.log(response.text);
		* ```
		*/
		async sendMessage(params) {
			var _a$5;
			await this.sendPromise;
			const inputContent = tContent(this.apiClient, params.message);
			const responsePromise = this.modelsModule.generateContent({
				model: this.model,
				contents: this.getHistory(true).concat(inputContent),
				config: (_a$5 = params.config) !== null && _a$5 !== void 0 ? _a$5 : this.config
			});
			this.sendPromise = (async () => {
				var _a$6, _b$1;
				const response = await responsePromise;
				const outputContent = (_b$1 = (_a$6 = response.candidates) === null || _a$6 === void 0 ? void 0 : _a$6[0]) === null || _b$1 === void 0 ? void 0 : _b$1.content;
				const modelOutput = outputContent ? [outputContent] : [];
				this.recordHistory(inputContent, modelOutput);
				return;
			})();
			await this.sendPromise;
			return responsePromise;
		}
		/**
		* Sends a message to the model and returns the response in chunks.
		*
		* @remarks
		* This method will wait for the previous message to be processed before
		* sending the next message.
		*
		* @see {@link Chat#sendMessage} for non-streaming method.
		* @param params - parameters for sending the message.
		* @return The model's response.
		*
		* @example
		* ```ts
		* const chat = ai.chats.create({model: 'gemini-2.0-flash'});
		* const response = await chat.sendMessageStream({
		*   message: 'Why is the sky blue?'
		* });
		* for await (const chunk of response) {
		*   console.log(chunk.text);
		* }
		* ```
		*/
		async sendMessageStream(params) {
			var _a$5;
			await this.sendPromise;
			const inputContent = tContent(this.apiClient, params.message);
			const streamResponse = this.modelsModule.generateContentStream({
				model: this.model,
				contents: this.getHistory(true).concat(inputContent),
				config: (_a$5 = params.config) !== null && _a$5 !== void 0 ? _a$5 : this.config
			});
			this.sendPromise = streamResponse.then(() => void 0);
			const response = await streamResponse;
			const result = this.processStreamResponse(response, inputContent);
			return result;
		}
		/**
		* Returns the chat history.
		*
		* @remarks
		* The history is a list of contents alternating between user and model.
		*
		* There are two types of history:
		* - The `curated history` contains only the valid turns between user and
		* model, which will be included in the subsequent requests sent to the model.
		* - The `comprehensive history` contains all turns, including invalid or
		*   empty model outputs, providing a complete record of the history.
		*
		* The history is updated after receiving the response from the model,
		* for streaming response, it means receiving the last chunk of the response.
		*
		* The `comprehensive history` is returned by default. To get the `curated
		* history`, set the `curated` parameter to `true`.
		*
		* @param curated - whether to return the curated history or the comprehensive
		*     history.
		* @return History contents alternating between user and model for the entire
		*     chat session.
		*/
		getHistory(curated = false) {
			return curated ? extractCuratedHistory(this.history) : this.history;
		}
		processStreamResponse(streamResponse, inputContent) {
			var _a$5, _b$1;
			return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
				var _c$1, e_1, _d, _e;
				const outputContent = [];
				try {
					for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c$1 = streamResponse_1_1.done, !_c$1; _f = true) {
						_e = streamResponse_1_1.value;
						_f = false;
						const chunk = _e;
						if (isValidResponse(chunk)) {
							const content = (_b$1 = (_a$5 = chunk.candidates) === null || _a$5 === void 0 ? void 0 : _a$5[0]) === null || _b$1 === void 0 ? void 0 : _b$1.content;
							if (content !== void 0) outputContent.push(content);
						}
						yield yield __await(chunk);
					}
				} catch (e_1_1) {
					e_1 = { error: e_1_1 };
				} finally {
					try {
						if (!_f && !_c$1 && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));
					} finally {
						if (e_1) throw e_1.error;
					}
				}
				this.recordHistory(inputContent, outputContent);
			});
		}
		recordHistory(userInput, modelOutput) {
			let outputContents = [];
			if (modelOutput.length > 0 && modelOutput.every((content) => content.role === "model")) outputContents = modelOutput;
			else outputContents.push({
				role: "model",
				parts: []
			});
			this.history.push(userInput);
			this.history.push(...outputContents);
		}
	};
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	function listFilesConfigToMldev(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
		if (parentObject !== void 0 && fromPageSize != null) setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
		const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
		if (parentObject !== void 0 && fromPageToken != null) setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
		return toObject;
	}
	function listFilesParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], listFilesConfigToMldev(apiClient, fromConfig, toObject));
		return toObject;
	}
	function fileStatusToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromDetails = getValueByPath(fromObject, ["details"]);
		if (fromDetails != null) setValueByPath(toObject, ["details"], fromDetails);
		const fromMessage = getValueByPath(fromObject, ["message"]);
		if (fromMessage != null) setValueByPath(toObject, ["message"], fromMessage);
		const fromCode = getValueByPath(fromObject, ["code"]);
		if (fromCode != null) setValueByPath(toObject, ["code"], fromCode);
		return toObject;
	}
	function fileToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
		if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
		const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
		if (fromSizeBytes != null) setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
		const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
		if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
		const fromExpirationTime = getValueByPath(fromObject, ["expirationTime"]);
		if (fromExpirationTime != null) setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
		const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
		if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
		const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
		if (fromSha256Hash != null) setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
		const fromUri = getValueByPath(fromObject, ["uri"]);
		if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
		const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
		if (fromDownloadUri != null) setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
		const fromState = getValueByPath(fromObject, ["state"]);
		if (fromState != null) setValueByPath(toObject, ["state"], fromState);
		const fromSource = getValueByPath(fromObject, ["source"]);
		if (fromSource != null) setValueByPath(toObject, ["source"], fromSource);
		const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
		if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
		const fromError = getValueByPath(fromObject, ["error"]);
		if (fromError != null) setValueByPath(toObject, ["error"], fileStatusToMldev(apiClient, fromError));
		return toObject;
	}
	function createFileParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromFile = getValueByPath(fromObject, ["file"]);
		if (fromFile != null) setValueByPath(toObject, ["file"], fileToMldev(apiClient, fromFile));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function getFileParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["_url", "file"], tFileName(apiClient, fromName));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function deleteFileParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["_url", "file"], tFileName(apiClient, fromName));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function fileStatusFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromDetails = getValueByPath(fromObject, ["details"]);
		if (fromDetails != null) setValueByPath(toObject, ["details"], fromDetails);
		const fromMessage = getValueByPath(fromObject, ["message"]);
		if (fromMessage != null) setValueByPath(toObject, ["message"], fromMessage);
		const fromCode = getValueByPath(fromObject, ["code"]);
		if (fromCode != null) setValueByPath(toObject, ["code"], fromCode);
		return toObject;
	}
	function fileFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
		if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
		const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		const fromSizeBytes = getValueByPath(fromObject, ["sizeBytes"]);
		if (fromSizeBytes != null) setValueByPath(toObject, ["sizeBytes"], fromSizeBytes);
		const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
		if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
		const fromExpirationTime = getValueByPath(fromObject, ["expirationTime"]);
		if (fromExpirationTime != null) setValueByPath(toObject, ["expirationTime"], fromExpirationTime);
		const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
		if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
		const fromSha256Hash = getValueByPath(fromObject, ["sha256Hash"]);
		if (fromSha256Hash != null) setValueByPath(toObject, ["sha256Hash"], fromSha256Hash);
		const fromUri = getValueByPath(fromObject, ["uri"]);
		if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
		const fromDownloadUri = getValueByPath(fromObject, ["downloadUri"]);
		if (fromDownloadUri != null) setValueByPath(toObject, ["downloadUri"], fromDownloadUri);
		const fromState = getValueByPath(fromObject, ["state"]);
		if (fromState != null) setValueByPath(toObject, ["state"], fromState);
		const fromSource = getValueByPath(fromObject, ["source"]);
		if (fromSource != null) setValueByPath(toObject, ["source"], fromSource);
		const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
		if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
		const fromError = getValueByPath(fromObject, ["error"]);
		if (fromError != null) setValueByPath(toObject, ["error"], fileStatusFromMldev(apiClient, fromError));
		return toObject;
	}
	function listFilesResponseFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromNextPageToken = getValueByPath(fromObject, ["nextPageToken"]);
		if (fromNextPageToken != null) setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
		const fromFiles = getValueByPath(fromObject, ["files"]);
		if (fromFiles != null) if (Array.isArray(fromFiles)) setValueByPath(toObject, ["files"], fromFiles.map((item) => {
			return fileFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["files"], fromFiles);
		return toObject;
	}
	function createFileResponseFromMldev() {
		const toObject = {};
		return toObject;
	}
	function deleteFileResponseFromMldev() {
		const toObject = {};
		return toObject;
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	var Files = class extends BaseModule {
		constructor(apiClient) {
			super();
			this.apiClient = apiClient;
			/**
			* Lists all current project files from the service.
			*
			* @param params - The parameters for the list request
			* @return The paginated results of the list of files
			*
			* @example
			* The following code prints the names of all files from the service, the
			* size of each page is 10.
			*
			* ```ts
			* const listResponse = await ai.files.list({config: {'pageSize': 10}});
			* for await (const file of listResponse) {
			*   console.log(file.name);
			* }
			* ```
			*/
			this.list = async (params = {}) => {
				return new Pager(exports.PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);
			};
		}
		/**
		* Uploads a file asynchronously to the Gemini API.
		* This method is not available in Vertex AI.
		* Supported upload sources:
		* - Node.js: File path (string) or Blob object.
		* - Browser: Blob object (e.g., File).
		*
		* @remarks
		* The `mimeType` can be specified in the `config` parameter. If omitted:
		*  - For file path (string) inputs, the `mimeType` will be inferred from the
		*     file extension.
		*  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
		*     property.
		* Somex eamples for file extension to mimeType mapping:
		* .txt -> text/plain
		* .json -> application/json
		* .jpg  -> image/jpeg
		* .png -> image/png
		* .mp3 -> audio/mpeg
		* .mp4 -> video/mp4
		*
		* This section can contain multiple paragraphs and code examples.
		*
		* @param params - Optional parameters specified in the
		*        `types.UploadFileParameters` interface.
		*         @see {@link types.UploadFileParameters#config} for the optional
		*         config in the parameters.
		* @return A promise that resolves to a `types.File` object.
		* @throws An error if called on a Vertex AI client.
		* @throws An error if the `mimeType` is not provided and can not be inferred,
		* the `mimeType` can be provided in the `params.config` parameter.
		* @throws An error occurs if a suitable upload location cannot be established.
		*
		* @example
		* The following code uploads a file to Gemini API.
		*
		* ```ts
		* const file = await ai.files.upload({file: 'file.txt', config: {
		*   mimeType: 'text/plain',
		* }});
		* console.log(file.name);
		* ```
		*/
		async upload(params) {
			if (this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
			return this.apiClient.uploadFile(params.file, params.config).then((response) => {
				const file = fileFromMldev(this.apiClient, response);
				return file;
			});
		}
		async listInternal(params) {
			var _a$5;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
			else {
				const body = listFilesParametersToMldev(this.apiClient, params);
				path$8 = formatMap("files", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = listFilesResponseFromMldev(this.apiClient, apiResponse);
					const typedResp = new ListFilesResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			}
		}
		async createInternal(params) {
			var _a$5;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
			else {
				const body = createFileParametersToMldev(this.apiClient, params);
				path$8 = formatMap("upload/v1beta/files", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then(() => {
					const resp = createFileResponseFromMldev();
					const typedResp = new CreateFileResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			}
		}
		/**
		* Retrieves the file information from the service.
		*
		* @param params - The parameters for the get request
		* @return The Promise that resolves to the types.File object requested.
		*
		* @example
		* ```ts
		* const config: GetFileParameters = {
		*   name: fileName,
		* };
		* file = await ai.files.get(config);
		* console.log(file.name);
		* ```
		*/
		async get(params) {
			var _a$5;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
			else {
				const body = getFileParametersToMldev(this.apiClient, params);
				path$8 = formatMap("files/{file}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = fileFromMldev(this.apiClient, apiResponse);
					return resp;
				});
			}
		}
		/**
		* Deletes a remotely stored file.
		*
		* @param params - The parameters for the delete request.
		* @return The DeleteFileResponse, the response for the delete method.
		*
		* @example
		* The following code deletes an example file named "files/mehozpxf877d".
		*
		* ```ts
		* await ai.files.delete({name: file.name});
		* ```
		*/
		async delete(params) {
			var _a$5;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API.");
			else {
				const body = deleteFileParametersToMldev(this.apiClient, params);
				path$8 = formatMap("files/{file}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "DELETE",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then(() => {
					const resp = deleteFileResponseFromMldev();
					const typedResp = new DeleteFileResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			}
		}
	};
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	function partToMldev$1(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["videoMetadata"]) !== void 0) throw new Error("videoMetadata parameter is not supported in Gemini API.");
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function partToVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
		if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function contentToMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partToMldev$1(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function contentToVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partToVertex$1(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function schemaToVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromExample = getValueByPath(fromObject, ["example"]);
		if (fromExample != null) setValueByPath(toObject, ["example"], fromExample);
		const fromPattern = getValueByPath(fromObject, ["pattern"]);
		if (fromPattern != null) setValueByPath(toObject, ["pattern"], fromPattern);
		const fromDefault = getValueByPath(fromObject, ["default"]);
		if (fromDefault != null) setValueByPath(toObject, ["default"], fromDefault);
		const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
		if (fromMaxLength != null) setValueByPath(toObject, ["maxLength"], fromMaxLength);
		const fromMinLength = getValueByPath(fromObject, ["minLength"]);
		if (fromMinLength != null) setValueByPath(toObject, ["minLength"], fromMinLength);
		const fromMinProperties = getValueByPath(fromObject, ["minProperties"]);
		if (fromMinProperties != null) setValueByPath(toObject, ["minProperties"], fromMinProperties);
		const fromMaxProperties = getValueByPath(fromObject, ["maxProperties"]);
		if (fromMaxProperties != null) setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
		const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
		if (fromAnyOf != null) setValueByPath(toObject, ["anyOf"], fromAnyOf);
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromEnum = getValueByPath(fromObject, ["enum"]);
		if (fromEnum != null) setValueByPath(toObject, ["enum"], fromEnum);
		const fromFormat = getValueByPath(fromObject, ["format"]);
		if (fromFormat != null) setValueByPath(toObject, ["format"], fromFormat);
		const fromItems = getValueByPath(fromObject, ["items"]);
		if (fromItems != null) setValueByPath(toObject, ["items"], fromItems);
		const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
		if (fromMaxItems != null) setValueByPath(toObject, ["maxItems"], fromMaxItems);
		const fromMaximum = getValueByPath(fromObject, ["maximum"]);
		if (fromMaximum != null) setValueByPath(toObject, ["maximum"], fromMaximum);
		const fromMinItems = getValueByPath(fromObject, ["minItems"]);
		if (fromMinItems != null) setValueByPath(toObject, ["minItems"], fromMinItems);
		const fromMinimum = getValueByPath(fromObject, ["minimum"]);
		if (fromMinimum != null) setValueByPath(toObject, ["minimum"], fromMinimum);
		const fromNullable = getValueByPath(fromObject, ["nullable"]);
		if (fromNullable != null) setValueByPath(toObject, ["nullable"], fromNullable);
		const fromProperties = getValueByPath(fromObject, ["properties"]);
		if (fromProperties != null) setValueByPath(toObject, ["properties"], fromProperties);
		const fromPropertyOrdering = getValueByPath(fromObject, ["propertyOrdering"]);
		if (fromPropertyOrdering != null) setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
		const fromRequired = getValueByPath(fromObject, ["required"]);
		if (fromRequired != null) setValueByPath(toObject, ["required"], fromRequired);
		const fromTitle = getValueByPath(fromObject, ["title"]);
		if (fromTitle != null) setValueByPath(toObject, ["title"], fromTitle);
		const fromType = getValueByPath(fromObject, ["type"]);
		if (fromType != null) setValueByPath(toObject, ["type"], fromType);
		return toObject;
	}
	function functionDeclarationToMldev$1(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["response"]) !== void 0) throw new Error("response parameter is not supported in Gemini API.");
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromParameters = getValueByPath(fromObject, ["parameters"]);
		if (fromParameters != null) setValueByPath(toObject, ["parameters"], fromParameters);
		return toObject;
	}
	function functionDeclarationToVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromResponse = getValueByPath(fromObject, ["response"]);
		if (fromResponse != null) setValueByPath(toObject, ["response"], schemaToVertex$1(apiClient, fromResponse));
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromParameters = getValueByPath(fromObject, ["parameters"]);
		if (fromParameters != null) setValueByPath(toObject, ["parameters"], fromParameters);
		return toObject;
	}
	function googleSearchToMldev$1() {
		const toObject = {};
		return toObject;
	}
	function googleSearchToVertex$1() {
		const toObject = {};
		return toObject;
	}
	function dynamicRetrievalConfigToMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromDynamicThreshold = getValueByPath(fromObject, ["dynamicThreshold"]);
		if (fromDynamicThreshold != null) setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
		return toObject;
	}
	function dynamicRetrievalConfigToVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromDynamicThreshold = getValueByPath(fromObject, ["dynamicThreshold"]);
		if (fromDynamicThreshold != null) setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
		return toObject;
	}
	function googleSearchRetrievalToMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromDynamicRetrievalConfig = getValueByPath(fromObject, ["dynamicRetrievalConfig"]);
		if (fromDynamicRetrievalConfig != null) setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev$1(apiClient, fromDynamicRetrievalConfig));
		return toObject;
	}
	function googleSearchRetrievalToVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromDynamicRetrievalConfig = getValueByPath(fromObject, ["dynamicRetrievalConfig"]);
		if (fromDynamicRetrievalConfig != null) setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex$1(apiClient, fromDynamicRetrievalConfig));
		return toObject;
	}
	function toolToMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
		if (fromFunctionDeclarations != null) if (Array.isArray(fromFunctionDeclarations)) setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations.map((item) => {
			return functionDeclarationToMldev$1(apiClient, item);
		}));
		else setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations);
		if (getValueByPath(fromObject, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
		const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
		if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1());
		const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
		if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev$1(apiClient, fromGoogleSearchRetrieval));
		const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
		if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
		return toObject;
	}
	function toolToVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
		if (fromFunctionDeclarations != null) if (Array.isArray(fromFunctionDeclarations)) setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations.map((item) => {
			return functionDeclarationToVertex$1(apiClient, item);
		}));
		else setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations);
		const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
		if (fromRetrieval != null) setValueByPath(toObject, ["retrieval"], fromRetrieval);
		const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
		if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToVertex$1());
		const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
		if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex$1(apiClient, fromGoogleSearchRetrieval));
		const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
		if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
		return toObject;
	}
	function sessionResumptionConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromHandle = getValueByPath(fromObject, ["handle"]);
		if (fromHandle != null) setValueByPath(toObject, ["handle"], fromHandle);
		if (getValueByPath(fromObject, ["transparent"]) !== void 0) throw new Error("transparent parameter is not supported in Gemini API.");
		return toObject;
	}
	function sessionResumptionConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromHandle = getValueByPath(fromObject, ["handle"]);
		if (fromHandle != null) setValueByPath(toObject, ["handle"], fromHandle);
		const fromTransparent = getValueByPath(fromObject, ["transparent"]);
		if (fromTransparent != null) setValueByPath(toObject, ["transparent"], fromTransparent);
		return toObject;
	}
	function audioTranscriptionConfigToMldev() {
		const toObject = {};
		return toObject;
	}
	function audioTranscriptionConfigToVertex() {
		const toObject = {};
		return toObject;
	}
	function automaticActivityDetectionToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromDisabled = getValueByPath(fromObject, ["disabled"]);
		if (fromDisabled != null) setValueByPath(toObject, ["disabled"], fromDisabled);
		const fromStartOfSpeechSensitivity = getValueByPath(fromObject, ["startOfSpeechSensitivity"]);
		if (fromStartOfSpeechSensitivity != null) setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
		const fromEndOfSpeechSensitivity = getValueByPath(fromObject, ["endOfSpeechSensitivity"]);
		if (fromEndOfSpeechSensitivity != null) setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
		const fromPrefixPaddingMs = getValueByPath(fromObject, ["prefixPaddingMs"]);
		if (fromPrefixPaddingMs != null) setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
		const fromSilenceDurationMs = getValueByPath(fromObject, ["silenceDurationMs"]);
		if (fromSilenceDurationMs != null) setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
		return toObject;
	}
	function automaticActivityDetectionToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromDisabled = getValueByPath(fromObject, ["disabled"]);
		if (fromDisabled != null) setValueByPath(toObject, ["disabled"], fromDisabled);
		const fromStartOfSpeechSensitivity = getValueByPath(fromObject, ["startOfSpeechSensitivity"]);
		if (fromStartOfSpeechSensitivity != null) setValueByPath(toObject, ["startOfSpeechSensitivity"], fromStartOfSpeechSensitivity);
		const fromEndOfSpeechSensitivity = getValueByPath(fromObject, ["endOfSpeechSensitivity"]);
		if (fromEndOfSpeechSensitivity != null) setValueByPath(toObject, ["endOfSpeechSensitivity"], fromEndOfSpeechSensitivity);
		const fromPrefixPaddingMs = getValueByPath(fromObject, ["prefixPaddingMs"]);
		if (fromPrefixPaddingMs != null) setValueByPath(toObject, ["prefixPaddingMs"], fromPrefixPaddingMs);
		const fromSilenceDurationMs = getValueByPath(fromObject, ["silenceDurationMs"]);
		if (fromSilenceDurationMs != null) setValueByPath(toObject, ["silenceDurationMs"], fromSilenceDurationMs);
		return toObject;
	}
	function realtimeInputConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromAutomaticActivityDetection = getValueByPath(fromObject, ["automaticActivityDetection"]);
		if (fromAutomaticActivityDetection != null) setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToMldev(apiClient, fromAutomaticActivityDetection));
		const fromActivityHandling = getValueByPath(fromObject, ["activityHandling"]);
		if (fromActivityHandling != null) setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
		const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
		if (fromTurnCoverage != null) setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
		return toObject;
	}
	function realtimeInputConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromAutomaticActivityDetection = getValueByPath(fromObject, ["automaticActivityDetection"]);
		if (fromAutomaticActivityDetection != null) setValueByPath(toObject, ["automaticActivityDetection"], automaticActivityDetectionToVertex(apiClient, fromAutomaticActivityDetection));
		const fromActivityHandling = getValueByPath(fromObject, ["activityHandling"]);
		if (fromActivityHandling != null) setValueByPath(toObject, ["activityHandling"], fromActivityHandling);
		const fromTurnCoverage = getValueByPath(fromObject, ["turnCoverage"]);
		if (fromTurnCoverage != null) setValueByPath(toObject, ["turnCoverage"], fromTurnCoverage);
		return toObject;
	}
	function slidingWindowToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
		if (fromTargetTokens != null) setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
		return toObject;
	}
	function slidingWindowToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromTargetTokens = getValueByPath(fromObject, ["targetTokens"]);
		if (fromTargetTokens != null) setValueByPath(toObject, ["targetTokens"], fromTargetTokens);
		return toObject;
	}
	function contextWindowCompressionConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromTriggerTokens = getValueByPath(fromObject, ["triggerTokens"]);
		if (fromTriggerTokens != null) setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
		const fromSlidingWindow = getValueByPath(fromObject, ["slidingWindow"]);
		if (fromSlidingWindow != null) setValueByPath(toObject, ["slidingWindow"], slidingWindowToMldev(apiClient, fromSlidingWindow));
		return toObject;
	}
	function contextWindowCompressionConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromTriggerTokens = getValueByPath(fromObject, ["triggerTokens"]);
		if (fromTriggerTokens != null) setValueByPath(toObject, ["triggerTokens"], fromTriggerTokens);
		const fromSlidingWindow = getValueByPath(fromObject, ["slidingWindow"]);
		if (fromSlidingWindow != null) setValueByPath(toObject, ["slidingWindow"], slidingWindowToVertex(apiClient, fromSlidingWindow));
		return toObject;
	}
	function liveConnectConfigToMldev(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromGenerationConfig = getValueByPath(fromObject, ["generationConfig"]);
		if (parentObject !== void 0 && fromGenerationConfig != null) setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
		const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
		if (parentObject !== void 0 && fromResponseModalities != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"responseModalities"
		], fromResponseModalities);
		const fromTemperature = getValueByPath(fromObject, ["temperature"]);
		if (parentObject !== void 0 && fromTemperature != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"temperature"
		], fromTemperature);
		const fromTopP = getValueByPath(fromObject, ["topP"]);
		if (parentObject !== void 0 && fromTopP != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"topP"
		], fromTopP);
		const fromTopK = getValueByPath(fromObject, ["topK"]);
		if (parentObject !== void 0 && fromTopK != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"topK"
		], fromTopK);
		const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
		if (parentObject !== void 0 && fromMaxOutputTokens != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"maxOutputTokens"
		], fromMaxOutputTokens);
		const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
		if (parentObject !== void 0 && fromMediaResolution != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"mediaResolution"
		], fromMediaResolution);
		const fromSeed = getValueByPath(fromObject, ["seed"]);
		if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"seed"
		], fromSeed);
		const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
		if (parentObject !== void 0 && fromSpeechConfig != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"speechConfig"
		], fromSpeechConfig);
		const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
		if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$1(apiClient, tContent(apiClient, fromSystemInstruction)));
		const fromTools = getValueByPath(fromObject, ["tools"]);
		if (parentObject !== void 0 && fromTools != null) if (Array.isArray(fromTools)) setValueByPath(parentObject, ["setup", "tools"], tTools(apiClient, tTools(apiClient, fromTools).map((item) => {
			return toolToMldev$1(apiClient, tTool(apiClient, item));
		})));
		else setValueByPath(parentObject, ["setup", "tools"], tTools(apiClient, fromTools));
		const fromSessionResumption = getValueByPath(fromObject, ["sessionResumption"]);
		if (parentObject !== void 0 && fromSessionResumption != null) setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(apiClient, fromSessionResumption));
		if (getValueByPath(fromObject, ["inputAudioTranscription"]) !== void 0) throw new Error("inputAudioTranscription parameter is not supported in Gemini API.");
		const fromOutputAudioTranscription = getValueByPath(fromObject, ["outputAudioTranscription"]);
		if (parentObject !== void 0 && fromOutputAudioTranscription != null) setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToMldev());
		const fromRealtimeInputConfig = getValueByPath(fromObject, ["realtimeInputConfig"]);
		if (parentObject !== void 0 && fromRealtimeInputConfig != null) setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToMldev(apiClient, fromRealtimeInputConfig));
		const fromContextWindowCompression = getValueByPath(fromObject, ["contextWindowCompression"]);
		if (parentObject !== void 0 && fromContextWindowCompression != null) setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToMldev(apiClient, fromContextWindowCompression));
		return toObject;
	}
	function liveConnectConfigToVertex(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromGenerationConfig = getValueByPath(fromObject, ["generationConfig"]);
		if (parentObject !== void 0 && fromGenerationConfig != null) setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
		const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
		if (parentObject !== void 0 && fromResponseModalities != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"responseModalities"
		], fromResponseModalities);
		const fromTemperature = getValueByPath(fromObject, ["temperature"]);
		if (parentObject !== void 0 && fromTemperature != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"temperature"
		], fromTemperature);
		const fromTopP = getValueByPath(fromObject, ["topP"]);
		if (parentObject !== void 0 && fromTopP != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"topP"
		], fromTopP);
		const fromTopK = getValueByPath(fromObject, ["topK"]);
		if (parentObject !== void 0 && fromTopK != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"topK"
		], fromTopK);
		const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
		if (parentObject !== void 0 && fromMaxOutputTokens != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"maxOutputTokens"
		], fromMaxOutputTokens);
		const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
		if (parentObject !== void 0 && fromMediaResolution != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"mediaResolution"
		], fromMediaResolution);
		const fromSeed = getValueByPath(fromObject, ["seed"]);
		if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"seed"
		], fromSeed);
		const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
		if (parentObject !== void 0 && fromSpeechConfig != null) setValueByPath(parentObject, [
			"setup",
			"generationConfig",
			"speechConfig"
		], fromSpeechConfig);
		const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
		if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["setup", "systemInstruction"], contentToVertex$1(apiClient, tContent(apiClient, fromSystemInstruction)));
		const fromTools = getValueByPath(fromObject, ["tools"]);
		if (parentObject !== void 0 && fromTools != null) if (Array.isArray(fromTools)) setValueByPath(parentObject, ["setup", "tools"], tTools(apiClient, tTools(apiClient, fromTools).map((item) => {
			return toolToVertex$1(apiClient, tTool(apiClient, item));
		})));
		else setValueByPath(parentObject, ["setup", "tools"], tTools(apiClient, fromTools));
		const fromSessionResumption = getValueByPath(fromObject, ["sessionResumption"]);
		if (parentObject !== void 0 && fromSessionResumption != null) setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToVertex(apiClient, fromSessionResumption));
		const fromInputAudioTranscription = getValueByPath(fromObject, ["inputAudioTranscription"]);
		if (parentObject !== void 0 && fromInputAudioTranscription != null) setValueByPath(parentObject, ["setup", "inputAudioTranscription"], audioTranscriptionConfigToVertex());
		const fromOutputAudioTranscription = getValueByPath(fromObject, ["outputAudioTranscription"]);
		if (parentObject !== void 0 && fromOutputAudioTranscription != null) setValueByPath(parentObject, ["setup", "outputAudioTranscription"], audioTranscriptionConfigToVertex());
		const fromRealtimeInputConfig = getValueByPath(fromObject, ["realtimeInputConfig"]);
		if (parentObject !== void 0 && fromRealtimeInputConfig != null) setValueByPath(parentObject, ["setup", "realtimeInputConfig"], realtimeInputConfigToVertex(apiClient, fromRealtimeInputConfig));
		const fromContextWindowCompression = getValueByPath(fromObject, ["contextWindowCompression"]);
		if (parentObject !== void 0 && fromContextWindowCompression != null) setValueByPath(parentObject, ["setup", "contextWindowCompression"], contextWindowCompressionConfigToVertex(apiClient, fromContextWindowCompression));
		return toObject;
	}
	function liveConnectParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], liveConnectConfigToMldev(apiClient, fromConfig, toObject));
		return toObject;
	}
	function liveConnectParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], liveConnectConfigToVertex(apiClient, fromConfig, toObject));
		return toObject;
	}
	function liveServerSetupCompleteFromMldev() {
		const toObject = {};
		return toObject;
	}
	function liveServerSetupCompleteFromVertex() {
		const toObject = {};
		return toObject;
	}
	function partFromMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function partFromVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
		if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function contentFromMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partFromMldev$1(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function contentFromVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partFromVertex$1(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function transcriptionFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		const fromFinished = getValueByPath(fromObject, ["finished"]);
		if (fromFinished != null) setValueByPath(toObject, ["finished"], fromFinished);
		return toObject;
	}
	function transcriptionFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		const fromFinished = getValueByPath(fromObject, ["finished"]);
		if (fromFinished != null) setValueByPath(toObject, ["finished"], fromFinished);
		return toObject;
	}
	function liveServerContentFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
		if (fromModelTurn != null) setValueByPath(toObject, ["modelTurn"], contentFromMldev$1(apiClient, fromModelTurn));
		const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
		if (fromTurnComplete != null) setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
		const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
		if (fromInterrupted != null) setValueByPath(toObject, ["interrupted"], fromInterrupted);
		const fromGenerationComplete = getValueByPath(fromObject, ["generationComplete"]);
		if (fromGenerationComplete != null) setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
		const fromInputTranscription = getValueByPath(fromObject, ["inputTranscription"]);
		if (fromInputTranscription != null) setValueByPath(toObject, ["inputTranscription"], transcriptionFromMldev(apiClient, fromInputTranscription));
		const fromOutputTranscription = getValueByPath(fromObject, ["outputTranscription"]);
		if (fromOutputTranscription != null) setValueByPath(toObject, ["outputTranscription"], transcriptionFromMldev(apiClient, fromOutputTranscription));
		return toObject;
	}
	function liveServerContentFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModelTurn = getValueByPath(fromObject, ["modelTurn"]);
		if (fromModelTurn != null) setValueByPath(toObject, ["modelTurn"], contentFromVertex$1(apiClient, fromModelTurn));
		const fromTurnComplete = getValueByPath(fromObject, ["turnComplete"]);
		if (fromTurnComplete != null) setValueByPath(toObject, ["turnComplete"], fromTurnComplete);
		const fromInterrupted = getValueByPath(fromObject, ["interrupted"]);
		if (fromInterrupted != null) setValueByPath(toObject, ["interrupted"], fromInterrupted);
		const fromGenerationComplete = getValueByPath(fromObject, ["generationComplete"]);
		if (fromGenerationComplete != null) setValueByPath(toObject, ["generationComplete"], fromGenerationComplete);
		const fromInputTranscription = getValueByPath(fromObject, ["inputTranscription"]);
		if (fromInputTranscription != null) setValueByPath(toObject, ["inputTranscription"], transcriptionFromVertex(apiClient, fromInputTranscription));
		const fromOutputTranscription = getValueByPath(fromObject, ["outputTranscription"]);
		if (fromOutputTranscription != null) setValueByPath(toObject, ["outputTranscription"], transcriptionFromVertex(apiClient, fromOutputTranscription));
		return toObject;
	}
	function functionCallFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromId = getValueByPath(fromObject, ["id"]);
		if (fromId != null) setValueByPath(toObject, ["id"], fromId);
		const fromArgs = getValueByPath(fromObject, ["args"]);
		if (fromArgs != null) setValueByPath(toObject, ["args"], fromArgs);
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		return toObject;
	}
	function functionCallFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromArgs = getValueByPath(fromObject, ["args"]);
		if (fromArgs != null) setValueByPath(toObject, ["args"], fromArgs);
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		return toObject;
	}
	function liveServerToolCallFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionCalls = getValueByPath(fromObject, ["functionCalls"]);
		if (fromFunctionCalls != null) if (Array.isArray(fromFunctionCalls)) setValueByPath(toObject, ["functionCalls"], fromFunctionCalls.map((item) => {
			return functionCallFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["functionCalls"], fromFunctionCalls);
		return toObject;
	}
	function liveServerToolCallFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionCalls = getValueByPath(fromObject, ["functionCalls"]);
		if (fromFunctionCalls != null) if (Array.isArray(fromFunctionCalls)) setValueByPath(toObject, ["functionCalls"], fromFunctionCalls.map((item) => {
			return functionCallFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["functionCalls"], fromFunctionCalls);
		return toObject;
	}
	function liveServerToolCallCancellationFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromIds = getValueByPath(fromObject, ["ids"]);
		if (fromIds != null) setValueByPath(toObject, ["ids"], fromIds);
		return toObject;
	}
	function liveServerToolCallCancellationFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromIds = getValueByPath(fromObject, ["ids"]);
		if (fromIds != null) setValueByPath(toObject, ["ids"], fromIds);
		return toObject;
	}
	function modalityTokenCountFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModality = getValueByPath(fromObject, ["modality"]);
		if (fromModality != null) setValueByPath(toObject, ["modality"], fromModality);
		const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
		if (fromTokenCount != null) setValueByPath(toObject, ["tokenCount"], fromTokenCount);
		return toObject;
	}
	function modalityTokenCountFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModality = getValueByPath(fromObject, ["modality"]);
		if (fromModality != null) setValueByPath(toObject, ["modality"], fromModality);
		const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
		if (fromTokenCount != null) setValueByPath(toObject, ["tokenCount"], fromTokenCount);
		return toObject;
	}
	function usageMetadataFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromPromptTokenCount = getValueByPath(fromObject, ["promptTokenCount"]);
		if (fromPromptTokenCount != null) setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
		const fromCachedContentTokenCount = getValueByPath(fromObject, ["cachedContentTokenCount"]);
		if (fromCachedContentTokenCount != null) setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
		const fromResponseTokenCount = getValueByPath(fromObject, ["responseTokenCount"]);
		if (fromResponseTokenCount != null) setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
		const fromToolUsePromptTokenCount = getValueByPath(fromObject, ["toolUsePromptTokenCount"]);
		if (fromToolUsePromptTokenCount != null) setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
		const fromThoughtsTokenCount = getValueByPath(fromObject, ["thoughtsTokenCount"]);
		if (fromThoughtsTokenCount != null) setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
		const fromTotalTokenCount = getValueByPath(fromObject, ["totalTokenCount"]);
		if (fromTotalTokenCount != null) setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
		const fromPromptTokensDetails = getValueByPath(fromObject, ["promptTokensDetails"]);
		if (fromPromptTokensDetails != null) if (Array.isArray(fromPromptTokensDetails)) setValueByPath(toObject, ["promptTokensDetails"], fromPromptTokensDetails.map((item) => {
			return modalityTokenCountFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["promptTokensDetails"], fromPromptTokensDetails);
		const fromCacheTokensDetails = getValueByPath(fromObject, ["cacheTokensDetails"]);
		if (fromCacheTokensDetails != null) if (Array.isArray(fromCacheTokensDetails)) setValueByPath(toObject, ["cacheTokensDetails"], fromCacheTokensDetails.map((item) => {
			return modalityTokenCountFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["cacheTokensDetails"], fromCacheTokensDetails);
		const fromResponseTokensDetails = getValueByPath(fromObject, ["responseTokensDetails"]);
		if (fromResponseTokensDetails != null) if (Array.isArray(fromResponseTokensDetails)) setValueByPath(toObject, ["responseTokensDetails"], fromResponseTokensDetails.map((item) => {
			return modalityTokenCountFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["responseTokensDetails"], fromResponseTokensDetails);
		const fromToolUsePromptTokensDetails = getValueByPath(fromObject, ["toolUsePromptTokensDetails"]);
		if (fromToolUsePromptTokensDetails != null) if (Array.isArray(fromToolUsePromptTokensDetails)) setValueByPath(toObject, ["toolUsePromptTokensDetails"], fromToolUsePromptTokensDetails.map((item) => {
			return modalityTokenCountFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["toolUsePromptTokensDetails"], fromToolUsePromptTokensDetails);
		return toObject;
	}
	function usageMetadataFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromPromptTokenCount = getValueByPath(fromObject, ["promptTokenCount"]);
		if (fromPromptTokenCount != null) setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
		const fromCachedContentTokenCount = getValueByPath(fromObject, ["cachedContentTokenCount"]);
		if (fromCachedContentTokenCount != null) setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
		const fromResponseTokenCount = getValueByPath(fromObject, ["candidatesTokenCount"]);
		if (fromResponseTokenCount != null) setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
		const fromToolUsePromptTokenCount = getValueByPath(fromObject, ["toolUsePromptTokenCount"]);
		if (fromToolUsePromptTokenCount != null) setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
		const fromThoughtsTokenCount = getValueByPath(fromObject, ["thoughtsTokenCount"]);
		if (fromThoughtsTokenCount != null) setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
		const fromTotalTokenCount = getValueByPath(fromObject, ["totalTokenCount"]);
		if (fromTotalTokenCount != null) setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
		const fromPromptTokensDetails = getValueByPath(fromObject, ["promptTokensDetails"]);
		if (fromPromptTokensDetails != null) if (Array.isArray(fromPromptTokensDetails)) setValueByPath(toObject, ["promptTokensDetails"], fromPromptTokensDetails.map((item) => {
			return modalityTokenCountFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["promptTokensDetails"], fromPromptTokensDetails);
		const fromCacheTokensDetails = getValueByPath(fromObject, ["cacheTokensDetails"]);
		if (fromCacheTokensDetails != null) if (Array.isArray(fromCacheTokensDetails)) setValueByPath(toObject, ["cacheTokensDetails"], fromCacheTokensDetails.map((item) => {
			return modalityTokenCountFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["cacheTokensDetails"], fromCacheTokensDetails);
		const fromResponseTokensDetails = getValueByPath(fromObject, ["candidatesTokensDetails"]);
		if (fromResponseTokensDetails != null) if (Array.isArray(fromResponseTokensDetails)) setValueByPath(toObject, ["responseTokensDetails"], fromResponseTokensDetails.map((item) => {
			return modalityTokenCountFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["responseTokensDetails"], fromResponseTokensDetails);
		const fromToolUsePromptTokensDetails = getValueByPath(fromObject, ["toolUsePromptTokensDetails"]);
		if (fromToolUsePromptTokensDetails != null) if (Array.isArray(fromToolUsePromptTokensDetails)) setValueByPath(toObject, ["toolUsePromptTokensDetails"], fromToolUsePromptTokensDetails.map((item) => {
			return modalityTokenCountFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["toolUsePromptTokensDetails"], fromToolUsePromptTokensDetails);
		const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
		if (fromTrafficType != null) setValueByPath(toObject, ["trafficType"], fromTrafficType);
		return toObject;
	}
	function liveServerGoAwayFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
		if (fromTimeLeft != null) setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
		return toObject;
	}
	function liveServerGoAwayFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromTimeLeft = getValueByPath(fromObject, ["timeLeft"]);
		if (fromTimeLeft != null) setValueByPath(toObject, ["timeLeft"], fromTimeLeft);
		return toObject;
	}
	function liveServerSessionResumptionUpdateFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
		if (fromNewHandle != null) setValueByPath(toObject, ["newHandle"], fromNewHandle);
		const fromResumable = getValueByPath(fromObject, ["resumable"]);
		if (fromResumable != null) setValueByPath(toObject, ["resumable"], fromResumable);
		const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, ["lastConsumedClientMessageIndex"]);
		if (fromLastConsumedClientMessageIndex != null) setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
		return toObject;
	}
	function liveServerSessionResumptionUpdateFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromNewHandle = getValueByPath(fromObject, ["newHandle"]);
		if (fromNewHandle != null) setValueByPath(toObject, ["newHandle"], fromNewHandle);
		const fromResumable = getValueByPath(fromObject, ["resumable"]);
		if (fromResumable != null) setValueByPath(toObject, ["resumable"], fromResumable);
		const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, ["lastConsumedClientMessageIndex"]);
		if (fromLastConsumedClientMessageIndex != null) setValueByPath(toObject, ["lastConsumedClientMessageIndex"], fromLastConsumedClientMessageIndex);
		return toObject;
	}
	function liveServerMessageFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromSetupComplete = getValueByPath(fromObject, ["setupComplete"]);
		if (fromSetupComplete != null) setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromMldev());
		const fromServerContent = getValueByPath(fromObject, ["serverContent"]);
		if (fromServerContent != null) setValueByPath(toObject, ["serverContent"], liveServerContentFromMldev(apiClient, fromServerContent));
		const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
		if (fromToolCall != null) setValueByPath(toObject, ["toolCall"], liveServerToolCallFromMldev(apiClient, fromToolCall));
		const fromToolCallCancellation = getValueByPath(fromObject, ["toolCallCancellation"]);
		if (fromToolCallCancellation != null) setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromMldev(apiClient, fromToolCallCancellation));
		const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
		if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], usageMetadataFromMldev(apiClient, fromUsageMetadata));
		const fromGoAway = getValueByPath(fromObject, ["goAway"]);
		if (fromGoAway != null) setValueByPath(toObject, ["goAway"], liveServerGoAwayFromMldev(apiClient, fromGoAway));
		const fromSessionResumptionUpdate = getValueByPath(fromObject, ["sessionResumptionUpdate"]);
		if (fromSessionResumptionUpdate != null) setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromMldev(apiClient, fromSessionResumptionUpdate));
		return toObject;
	}
	function liveServerMessageFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromSetupComplete = getValueByPath(fromObject, ["setupComplete"]);
		if (fromSetupComplete != null) setValueByPath(toObject, ["setupComplete"], liveServerSetupCompleteFromVertex());
		const fromServerContent = getValueByPath(fromObject, ["serverContent"]);
		if (fromServerContent != null) setValueByPath(toObject, ["serverContent"], liveServerContentFromVertex(apiClient, fromServerContent));
		const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
		if (fromToolCall != null) setValueByPath(toObject, ["toolCall"], liveServerToolCallFromVertex(apiClient, fromToolCall));
		const fromToolCallCancellation = getValueByPath(fromObject, ["toolCallCancellation"]);
		if (fromToolCallCancellation != null) setValueByPath(toObject, ["toolCallCancellation"], liveServerToolCallCancellationFromVertex(apiClient, fromToolCallCancellation));
		const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
		if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(apiClient, fromUsageMetadata));
		const fromGoAway = getValueByPath(fromObject, ["goAway"]);
		if (fromGoAway != null) setValueByPath(toObject, ["goAway"], liveServerGoAwayFromVertex(apiClient, fromGoAway));
		const fromSessionResumptionUpdate = getValueByPath(fromObject, ["sessionResumptionUpdate"]);
		if (fromSessionResumptionUpdate != null) setValueByPath(toObject, ["sessionResumptionUpdate"], liveServerSessionResumptionUpdateFromVertex(apiClient, fromSessionResumptionUpdate));
		return toObject;
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	function partToMldev(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["videoMetadata"]) !== void 0) throw new Error("videoMetadata parameter is not supported in Gemini API.");
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function contentToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partToMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function schemaToMldev(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["example"]) !== void 0) throw new Error("example parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["pattern"]) !== void 0) throw new Error("pattern parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["default"]) !== void 0) throw new Error("default parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["maxLength"]) !== void 0) throw new Error("maxLength parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["minLength"]) !== void 0) throw new Error("minLength parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["minProperties"]) !== void 0) throw new Error("minProperties parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["maxProperties"]) !== void 0) throw new Error("maxProperties parameter is not supported in Gemini API.");
		const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
		if (fromAnyOf != null) setValueByPath(toObject, ["anyOf"], fromAnyOf);
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromEnum = getValueByPath(fromObject, ["enum"]);
		if (fromEnum != null) setValueByPath(toObject, ["enum"], fromEnum);
		const fromFormat = getValueByPath(fromObject, ["format"]);
		if (fromFormat != null) setValueByPath(toObject, ["format"], fromFormat);
		const fromItems = getValueByPath(fromObject, ["items"]);
		if (fromItems != null) setValueByPath(toObject, ["items"], fromItems);
		const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
		if (fromMaxItems != null) setValueByPath(toObject, ["maxItems"], fromMaxItems);
		const fromMaximum = getValueByPath(fromObject, ["maximum"]);
		if (fromMaximum != null) setValueByPath(toObject, ["maximum"], fromMaximum);
		const fromMinItems = getValueByPath(fromObject, ["minItems"]);
		if (fromMinItems != null) setValueByPath(toObject, ["minItems"], fromMinItems);
		const fromMinimum = getValueByPath(fromObject, ["minimum"]);
		if (fromMinimum != null) setValueByPath(toObject, ["minimum"], fromMinimum);
		const fromNullable = getValueByPath(fromObject, ["nullable"]);
		if (fromNullable != null) setValueByPath(toObject, ["nullable"], fromNullable);
		const fromProperties = getValueByPath(fromObject, ["properties"]);
		if (fromProperties != null) setValueByPath(toObject, ["properties"], fromProperties);
		const fromPropertyOrdering = getValueByPath(fromObject, ["propertyOrdering"]);
		if (fromPropertyOrdering != null) setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
		const fromRequired = getValueByPath(fromObject, ["required"]);
		if (fromRequired != null) setValueByPath(toObject, ["required"], fromRequired);
		const fromTitle = getValueByPath(fromObject, ["title"]);
		if (fromTitle != null) setValueByPath(toObject, ["title"], fromTitle);
		const fromType = getValueByPath(fromObject, ["type"]);
		if (fromType != null) setValueByPath(toObject, ["type"], fromType);
		return toObject;
	}
	function safetySettingToMldev(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["method"]) !== void 0) throw new Error("method parameter is not supported in Gemini API.");
		const fromCategory = getValueByPath(fromObject, ["category"]);
		if (fromCategory != null) setValueByPath(toObject, ["category"], fromCategory);
		const fromThreshold = getValueByPath(fromObject, ["threshold"]);
		if (fromThreshold != null) setValueByPath(toObject, ["threshold"], fromThreshold);
		return toObject;
	}
	function functionDeclarationToMldev(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["response"]) !== void 0) throw new Error("response parameter is not supported in Gemini API.");
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromParameters = getValueByPath(fromObject, ["parameters"]);
		if (fromParameters != null) setValueByPath(toObject, ["parameters"], fromParameters);
		return toObject;
	}
	function googleSearchToMldev() {
		const toObject = {};
		return toObject;
	}
	function dynamicRetrievalConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromDynamicThreshold = getValueByPath(fromObject, ["dynamicThreshold"]);
		if (fromDynamicThreshold != null) setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
		return toObject;
	}
	function googleSearchRetrievalToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromDynamicRetrievalConfig = getValueByPath(fromObject, ["dynamicRetrievalConfig"]);
		if (fromDynamicRetrievalConfig != null) setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToMldev(apiClient, fromDynamicRetrievalConfig));
		return toObject;
	}
	function toolToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
		if (fromFunctionDeclarations != null) if (Array.isArray(fromFunctionDeclarations)) setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations.map((item) => {
			return functionDeclarationToMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations);
		if (getValueByPath(fromObject, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API.");
		const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
		if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToMldev());
		const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
		if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToMldev(apiClient, fromGoogleSearchRetrieval));
		const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
		if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
		return toObject;
	}
	function functionCallingConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromAllowedFunctionNames = getValueByPath(fromObject, ["allowedFunctionNames"]);
		if (fromAllowedFunctionNames != null) setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
		return toObject;
	}
	function toolConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionCallingConfig = getValueByPath(fromObject, ["functionCallingConfig"]);
		if (fromFunctionCallingConfig != null) setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(apiClient, fromFunctionCallingConfig));
		return toObject;
	}
	function prebuiltVoiceConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
		if (fromVoiceName != null) setValueByPath(toObject, ["voiceName"], fromVoiceName);
		return toObject;
	}
	function voiceConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromPrebuiltVoiceConfig = getValueByPath(fromObject, ["prebuiltVoiceConfig"]);
		if (fromPrebuiltVoiceConfig != null) setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToMldev(apiClient, fromPrebuiltVoiceConfig));
		return toObject;
	}
	function speechConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
		if (fromVoiceConfig != null) setValueByPath(toObject, ["voiceConfig"], voiceConfigToMldev(apiClient, fromVoiceConfig));
		const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
		if (fromLanguageCode != null) setValueByPath(toObject, ["languageCode"], fromLanguageCode);
		return toObject;
	}
	function thinkingConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromIncludeThoughts = getValueByPath(fromObject, ["includeThoughts"]);
		if (fromIncludeThoughts != null) setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
		const fromThinkingBudget = getValueByPath(fromObject, ["thinkingBudget"]);
		if (fromThinkingBudget != null) setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
		return toObject;
	}
	function generateContentConfigToMldev(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
		if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], contentToMldev(apiClient, tContent(apiClient, fromSystemInstruction)));
		const fromTemperature = getValueByPath(fromObject, ["temperature"]);
		if (fromTemperature != null) setValueByPath(toObject, ["temperature"], fromTemperature);
		const fromTopP = getValueByPath(fromObject, ["topP"]);
		if (fromTopP != null) setValueByPath(toObject, ["topP"], fromTopP);
		const fromTopK = getValueByPath(fromObject, ["topK"]);
		if (fromTopK != null) setValueByPath(toObject, ["topK"], fromTopK);
		const fromCandidateCount = getValueByPath(fromObject, ["candidateCount"]);
		if (fromCandidateCount != null) setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
		const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
		if (fromMaxOutputTokens != null) setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
		const fromStopSequences = getValueByPath(fromObject, ["stopSequences"]);
		if (fromStopSequences != null) setValueByPath(toObject, ["stopSequences"], fromStopSequences);
		const fromResponseLogprobs = getValueByPath(fromObject, ["responseLogprobs"]);
		if (fromResponseLogprobs != null) setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
		const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
		if (fromLogprobs != null) setValueByPath(toObject, ["logprobs"], fromLogprobs);
		const fromPresencePenalty = getValueByPath(fromObject, ["presencePenalty"]);
		if (fromPresencePenalty != null) setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
		const fromFrequencyPenalty = getValueByPath(fromObject, ["frequencyPenalty"]);
		if (fromFrequencyPenalty != null) setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
		const fromSeed = getValueByPath(fromObject, ["seed"]);
		if (fromSeed != null) setValueByPath(toObject, ["seed"], fromSeed);
		const fromResponseMimeType = getValueByPath(fromObject, ["responseMimeType"]);
		if (fromResponseMimeType != null) setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
		const fromResponseSchema = getValueByPath(fromObject, ["responseSchema"]);
		if (fromResponseSchema != null) setValueByPath(toObject, ["responseSchema"], schemaToMldev(apiClient, tSchema(apiClient, fromResponseSchema)));
		if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) throw new Error("routingConfig parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
		const fromSafetySettings = getValueByPath(fromObject, ["safetySettings"]);
		if (parentObject !== void 0 && fromSafetySettings != null) if (Array.isArray(fromSafetySettings)) setValueByPath(parentObject, ["safetySettings"], fromSafetySettings.map((item) => {
			return safetySettingToMldev(apiClient, item);
		}));
		else setValueByPath(parentObject, ["safetySettings"], fromSafetySettings);
		const fromTools = getValueByPath(fromObject, ["tools"]);
		if (parentObject !== void 0 && fromTools != null) if (Array.isArray(fromTools)) setValueByPath(parentObject, ["tools"], tTools(apiClient, tTools(apiClient, fromTools).map((item) => {
			return toolToMldev(apiClient, tTool(apiClient, item));
		})));
		else setValueByPath(parentObject, ["tools"], tTools(apiClient, fromTools));
		const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
		if (parentObject !== void 0 && fromToolConfig != null) setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(apiClient, fromToolConfig));
		if (getValueByPath(fromObject, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API.");
		const fromCachedContent = getValueByPath(fromObject, ["cachedContent"]);
		if (parentObject !== void 0 && fromCachedContent != null) setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
		const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
		if (fromResponseModalities != null) setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
		const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
		if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
		const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
		if (fromSpeechConfig != null) setValueByPath(toObject, ["speechConfig"], speechConfigToMldev(apiClient, tSpeechConfig(apiClient, fromSpeechConfig)));
		if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) throw new Error("audioTimestamp parameter is not supported in Gemini API.");
		const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
		if (fromThinkingConfig != null) setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToMldev(apiClient, fromThinkingConfig));
		return toObject;
	}
	function generateContentParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromContents = getValueByPath(fromObject, ["contents"]);
		if (fromContents != null) if (Array.isArray(fromContents)) setValueByPath(toObject, ["contents"], tContents(apiClient, tContents(apiClient, fromContents).map((item) => {
			return contentToMldev(apiClient, item);
		})));
		else setValueByPath(toObject, ["contents"], tContents(apiClient, fromContents));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
		return toObject;
	}
	function embedContentConfigToMldev(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromTaskType = getValueByPath(fromObject, ["taskType"]);
		if (parentObject !== void 0 && fromTaskType != null) setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
		const fromTitle = getValueByPath(fromObject, ["title"]);
		if (parentObject !== void 0 && fromTitle != null) setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
		const fromOutputDimensionality = getValueByPath(fromObject, ["outputDimensionality"]);
		if (parentObject !== void 0 && fromOutputDimensionality != null) setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
		if (getValueByPath(fromObject, ["mimeType"]) !== void 0) throw new Error("mimeType parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API.");
		return toObject;
	}
	function embedContentParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromContents = getValueByPath(fromObject, ["contents"]);
		if (fromContents != null) setValueByPath(toObject, ["requests[]", "content"], tContentsForEmbed(apiClient, fromContents));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], embedContentConfigToMldev(apiClient, fromConfig, toObject));
		const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
		if (fromModelForEmbedContent !== void 0) setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
		return toObject;
	}
	function generateImagesConfigToMldev(apiClient, fromObject, parentObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) throw new Error("negativePrompt parameter is not supported in Gemini API.");
		const fromNumberOfImages = getValueByPath(fromObject, ["numberOfImages"]);
		if (parentObject !== void 0 && fromNumberOfImages != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
		const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
		if (parentObject !== void 0 && fromAspectRatio != null) setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
		const fromGuidanceScale = getValueByPath(fromObject, ["guidanceScale"]);
		if (parentObject !== void 0 && fromGuidanceScale != null) setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
		if (getValueByPath(fromObject, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API.");
		const fromSafetyFilterLevel = getValueByPath(fromObject, ["safetyFilterLevel"]);
		if (parentObject !== void 0 && fromSafetyFilterLevel != null) setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
		const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
		if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
		const fromIncludeSafetyAttributes = getValueByPath(fromObject, ["includeSafetyAttributes"]);
		if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
		const fromIncludeRaiReason = getValueByPath(fromObject, ["includeRaiReason"]);
		if (parentObject !== void 0 && fromIncludeRaiReason != null) setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
		const fromLanguage = getValueByPath(fromObject, ["language"]);
		if (parentObject !== void 0 && fromLanguage != null) setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
		const fromOutputMimeType = getValueByPath(fromObject, ["outputMimeType"]);
		if (parentObject !== void 0 && fromOutputMimeType != null) setValueByPath(parentObject, [
			"parameters",
			"outputOptions",
			"mimeType"
		], fromOutputMimeType);
		const fromOutputCompressionQuality = getValueByPath(fromObject, ["outputCompressionQuality"]);
		if (parentObject !== void 0 && fromOutputCompressionQuality != null) setValueByPath(parentObject, [
			"parameters",
			"outputOptions",
			"compressionQuality"
		], fromOutputCompressionQuality);
		if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) throw new Error("addWatermark parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) throw new Error("enhancePrompt parameter is not supported in Gemini API.");
		return toObject;
	}
	function generateImagesParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromPrompt = getValueByPath(fromObject, ["prompt"]);
		if (fromPrompt != null) setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], generateImagesConfigToMldev(apiClient, fromConfig, toObject));
		return toObject;
	}
	function getModelParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function countTokensConfigToMldev(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) throw new Error("systemInstruction parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["tools"]) !== void 0) throw new Error("tools parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) throw new Error("generationConfig parameter is not supported in Gemini API.");
		return toObject;
	}
	function countTokensParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromContents = getValueByPath(fromObject, ["contents"]);
		if (fromContents != null) if (Array.isArray(fromContents)) setValueByPath(toObject, ["contents"], tContents(apiClient, tContents(apiClient, fromContents).map((item) => {
			return contentToMldev(apiClient, item);
		})));
		else setValueByPath(toObject, ["contents"], tContents(apiClient, fromContents));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], countTokensConfigToMldev(apiClient, fromConfig));
		return toObject;
	}
	function imageToMldev(apiClient, fromObject) {
		const toObject = {};
		if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API.");
		const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
		if (fromImageBytes != null) setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(apiClient, fromImageBytes));
		const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		return toObject;
	}
	function generateVideosConfigToMldev(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromNumberOfVideos = getValueByPath(fromObject, ["numberOfVideos"]);
		if (parentObject !== void 0 && fromNumberOfVideos != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
		if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API.");
		if (getValueByPath(fromObject, ["fps"]) !== void 0) throw new Error("fps parameter is not supported in Gemini API.");
		const fromDurationSeconds = getValueByPath(fromObject, ["durationSeconds"]);
		if (parentObject !== void 0 && fromDurationSeconds != null) setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
		if (getValueByPath(fromObject, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API.");
		const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
		if (parentObject !== void 0 && fromAspectRatio != null) setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
		if (getValueByPath(fromObject, ["resolution"]) !== void 0) throw new Error("resolution parameter is not supported in Gemini API.");
		const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
		if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
		if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) throw new Error("pubsubTopic parameter is not supported in Gemini API.");
		const fromNegativePrompt = getValueByPath(fromObject, ["negativePrompt"]);
		if (parentObject !== void 0 && fromNegativePrompt != null) setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
		if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) throw new Error("enhancePrompt parameter is not supported in Gemini API.");
		return toObject;
	}
	function generateVideosParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromPrompt = getValueByPath(fromObject, ["prompt"]);
		if (fromPrompt != null) setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
		const fromImage = getValueByPath(fromObject, ["image"]);
		if (fromImage != null) setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(apiClient, fromImage));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], generateVideosConfigToMldev(apiClient, fromConfig, toObject));
		return toObject;
	}
	function partToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
		if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function contentToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partToVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function schemaToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromExample = getValueByPath(fromObject, ["example"]);
		if (fromExample != null) setValueByPath(toObject, ["example"], fromExample);
		const fromPattern = getValueByPath(fromObject, ["pattern"]);
		if (fromPattern != null) setValueByPath(toObject, ["pattern"], fromPattern);
		const fromDefault = getValueByPath(fromObject, ["default"]);
		if (fromDefault != null) setValueByPath(toObject, ["default"], fromDefault);
		const fromMaxLength = getValueByPath(fromObject, ["maxLength"]);
		if (fromMaxLength != null) setValueByPath(toObject, ["maxLength"], fromMaxLength);
		const fromMinLength = getValueByPath(fromObject, ["minLength"]);
		if (fromMinLength != null) setValueByPath(toObject, ["minLength"], fromMinLength);
		const fromMinProperties = getValueByPath(fromObject, ["minProperties"]);
		if (fromMinProperties != null) setValueByPath(toObject, ["minProperties"], fromMinProperties);
		const fromMaxProperties = getValueByPath(fromObject, ["maxProperties"]);
		if (fromMaxProperties != null) setValueByPath(toObject, ["maxProperties"], fromMaxProperties);
		const fromAnyOf = getValueByPath(fromObject, ["anyOf"]);
		if (fromAnyOf != null) setValueByPath(toObject, ["anyOf"], fromAnyOf);
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromEnum = getValueByPath(fromObject, ["enum"]);
		if (fromEnum != null) setValueByPath(toObject, ["enum"], fromEnum);
		const fromFormat = getValueByPath(fromObject, ["format"]);
		if (fromFormat != null) setValueByPath(toObject, ["format"], fromFormat);
		const fromItems = getValueByPath(fromObject, ["items"]);
		if (fromItems != null) setValueByPath(toObject, ["items"], fromItems);
		const fromMaxItems = getValueByPath(fromObject, ["maxItems"]);
		if (fromMaxItems != null) setValueByPath(toObject, ["maxItems"], fromMaxItems);
		const fromMaximum = getValueByPath(fromObject, ["maximum"]);
		if (fromMaximum != null) setValueByPath(toObject, ["maximum"], fromMaximum);
		const fromMinItems = getValueByPath(fromObject, ["minItems"]);
		if (fromMinItems != null) setValueByPath(toObject, ["minItems"], fromMinItems);
		const fromMinimum = getValueByPath(fromObject, ["minimum"]);
		if (fromMinimum != null) setValueByPath(toObject, ["minimum"], fromMinimum);
		const fromNullable = getValueByPath(fromObject, ["nullable"]);
		if (fromNullable != null) setValueByPath(toObject, ["nullable"], fromNullable);
		const fromProperties = getValueByPath(fromObject, ["properties"]);
		if (fromProperties != null) setValueByPath(toObject, ["properties"], fromProperties);
		const fromPropertyOrdering = getValueByPath(fromObject, ["propertyOrdering"]);
		if (fromPropertyOrdering != null) setValueByPath(toObject, ["propertyOrdering"], fromPropertyOrdering);
		const fromRequired = getValueByPath(fromObject, ["required"]);
		if (fromRequired != null) setValueByPath(toObject, ["required"], fromRequired);
		const fromTitle = getValueByPath(fromObject, ["title"]);
		if (fromTitle != null) setValueByPath(toObject, ["title"], fromTitle);
		const fromType = getValueByPath(fromObject, ["type"]);
		if (fromType != null) setValueByPath(toObject, ["type"], fromType);
		return toObject;
	}
	function modelSelectionConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromFeatureSelectionPreference = getValueByPath(fromObject, ["featureSelectionPreference"]);
		if (fromFeatureSelectionPreference != null) setValueByPath(toObject, ["featureSelectionPreference"], fromFeatureSelectionPreference);
		return toObject;
	}
	function safetySettingToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromMethod = getValueByPath(fromObject, ["method"]);
		if (fromMethod != null) setValueByPath(toObject, ["method"], fromMethod);
		const fromCategory = getValueByPath(fromObject, ["category"]);
		if (fromCategory != null) setValueByPath(toObject, ["category"], fromCategory);
		const fromThreshold = getValueByPath(fromObject, ["threshold"]);
		if (fromThreshold != null) setValueByPath(toObject, ["threshold"], fromThreshold);
		return toObject;
	}
	function functionDeclarationToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromResponse = getValueByPath(fromObject, ["response"]);
		if (fromResponse != null) setValueByPath(toObject, ["response"], schemaToVertex(apiClient, fromResponse));
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromParameters = getValueByPath(fromObject, ["parameters"]);
		if (fromParameters != null) setValueByPath(toObject, ["parameters"], fromParameters);
		return toObject;
	}
	function googleSearchToVertex() {
		const toObject = {};
		return toObject;
	}
	function dynamicRetrievalConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromDynamicThreshold = getValueByPath(fromObject, ["dynamicThreshold"]);
		if (fromDynamicThreshold != null) setValueByPath(toObject, ["dynamicThreshold"], fromDynamicThreshold);
		return toObject;
	}
	function googleSearchRetrievalToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromDynamicRetrievalConfig = getValueByPath(fromObject, ["dynamicRetrievalConfig"]);
		if (fromDynamicRetrievalConfig != null) setValueByPath(toObject, ["dynamicRetrievalConfig"], dynamicRetrievalConfigToVertex(apiClient, fromDynamicRetrievalConfig));
		return toObject;
	}
	function toolToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionDeclarations = getValueByPath(fromObject, ["functionDeclarations"]);
		if (fromFunctionDeclarations != null) if (Array.isArray(fromFunctionDeclarations)) setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations.map((item) => {
			return functionDeclarationToVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["functionDeclarations"], fromFunctionDeclarations);
		const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
		if (fromRetrieval != null) setValueByPath(toObject, ["retrieval"], fromRetrieval);
		const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
		if (fromGoogleSearch != null) setValueByPath(toObject, ["googleSearch"], googleSearchToVertex());
		const fromGoogleSearchRetrieval = getValueByPath(fromObject, ["googleSearchRetrieval"]);
		if (fromGoogleSearchRetrieval != null) setValueByPath(toObject, ["googleSearchRetrieval"], googleSearchRetrievalToVertex(apiClient, fromGoogleSearchRetrieval));
		const fromCodeExecution = getValueByPath(fromObject, ["codeExecution"]);
		if (fromCodeExecution != null) setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
		return toObject;
	}
	function functionCallingConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromMode = getValueByPath(fromObject, ["mode"]);
		if (fromMode != null) setValueByPath(toObject, ["mode"], fromMode);
		const fromAllowedFunctionNames = getValueByPath(fromObject, ["allowedFunctionNames"]);
		if (fromAllowedFunctionNames != null) setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
		return toObject;
	}
	function toolConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromFunctionCallingConfig = getValueByPath(fromObject, ["functionCallingConfig"]);
		if (fromFunctionCallingConfig != null) setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToVertex(apiClient, fromFunctionCallingConfig));
		return toObject;
	}
	function prebuiltVoiceConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromVoiceName = getValueByPath(fromObject, ["voiceName"]);
		if (fromVoiceName != null) setValueByPath(toObject, ["voiceName"], fromVoiceName);
		return toObject;
	}
	function voiceConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromPrebuiltVoiceConfig = getValueByPath(fromObject, ["prebuiltVoiceConfig"]);
		if (fromPrebuiltVoiceConfig != null) setValueByPath(toObject, ["prebuiltVoiceConfig"], prebuiltVoiceConfigToVertex(apiClient, fromPrebuiltVoiceConfig));
		return toObject;
	}
	function speechConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromVoiceConfig = getValueByPath(fromObject, ["voiceConfig"]);
		if (fromVoiceConfig != null) setValueByPath(toObject, ["voiceConfig"], voiceConfigToVertex(apiClient, fromVoiceConfig));
		const fromLanguageCode = getValueByPath(fromObject, ["languageCode"]);
		if (fromLanguageCode != null) setValueByPath(toObject, ["languageCode"], fromLanguageCode);
		return toObject;
	}
	function thinkingConfigToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromIncludeThoughts = getValueByPath(fromObject, ["includeThoughts"]);
		if (fromIncludeThoughts != null) setValueByPath(toObject, ["includeThoughts"], fromIncludeThoughts);
		const fromThinkingBudget = getValueByPath(fromObject, ["thinkingBudget"]);
		if (fromThinkingBudget != null) setValueByPath(toObject, ["thinkingBudget"], fromThinkingBudget);
		return toObject;
	}
	function generateContentConfigToVertex(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
		if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], contentToVertex(apiClient, tContent(apiClient, fromSystemInstruction)));
		const fromTemperature = getValueByPath(fromObject, ["temperature"]);
		if (fromTemperature != null) setValueByPath(toObject, ["temperature"], fromTemperature);
		const fromTopP = getValueByPath(fromObject, ["topP"]);
		if (fromTopP != null) setValueByPath(toObject, ["topP"], fromTopP);
		const fromTopK = getValueByPath(fromObject, ["topK"]);
		if (fromTopK != null) setValueByPath(toObject, ["topK"], fromTopK);
		const fromCandidateCount = getValueByPath(fromObject, ["candidateCount"]);
		if (fromCandidateCount != null) setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
		const fromMaxOutputTokens = getValueByPath(fromObject, ["maxOutputTokens"]);
		if (fromMaxOutputTokens != null) setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
		const fromStopSequences = getValueByPath(fromObject, ["stopSequences"]);
		if (fromStopSequences != null) setValueByPath(toObject, ["stopSequences"], fromStopSequences);
		const fromResponseLogprobs = getValueByPath(fromObject, ["responseLogprobs"]);
		if (fromResponseLogprobs != null) setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
		const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
		if (fromLogprobs != null) setValueByPath(toObject, ["logprobs"], fromLogprobs);
		const fromPresencePenalty = getValueByPath(fromObject, ["presencePenalty"]);
		if (fromPresencePenalty != null) setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
		const fromFrequencyPenalty = getValueByPath(fromObject, ["frequencyPenalty"]);
		if (fromFrequencyPenalty != null) setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
		const fromSeed = getValueByPath(fromObject, ["seed"]);
		if (fromSeed != null) setValueByPath(toObject, ["seed"], fromSeed);
		const fromResponseMimeType = getValueByPath(fromObject, ["responseMimeType"]);
		if (fromResponseMimeType != null) setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
		const fromResponseSchema = getValueByPath(fromObject, ["responseSchema"]);
		if (fromResponseSchema != null) setValueByPath(toObject, ["responseSchema"], schemaToVertex(apiClient, tSchema(apiClient, fromResponseSchema)));
		const fromRoutingConfig = getValueByPath(fromObject, ["routingConfig"]);
		if (fromRoutingConfig != null) setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
		const fromModelSelectionConfig = getValueByPath(fromObject, ["modelSelectionConfig"]);
		if (fromModelSelectionConfig != null) setValueByPath(toObject, ["modelConfig"], modelSelectionConfigToVertex(apiClient, fromModelSelectionConfig));
		const fromSafetySettings = getValueByPath(fromObject, ["safetySettings"]);
		if (parentObject !== void 0 && fromSafetySettings != null) if (Array.isArray(fromSafetySettings)) setValueByPath(parentObject, ["safetySettings"], fromSafetySettings.map((item) => {
			return safetySettingToVertex(apiClient, item);
		}));
		else setValueByPath(parentObject, ["safetySettings"], fromSafetySettings);
		const fromTools = getValueByPath(fromObject, ["tools"]);
		if (parentObject !== void 0 && fromTools != null) if (Array.isArray(fromTools)) setValueByPath(parentObject, ["tools"], tTools(apiClient, tTools(apiClient, fromTools).map((item) => {
			return toolToVertex(apiClient, tTool(apiClient, item));
		})));
		else setValueByPath(parentObject, ["tools"], tTools(apiClient, fromTools));
		const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
		if (parentObject !== void 0 && fromToolConfig != null) setValueByPath(parentObject, ["toolConfig"], toolConfigToVertex(apiClient, fromToolConfig));
		const fromLabels = getValueByPath(fromObject, ["labels"]);
		if (parentObject !== void 0 && fromLabels != null) setValueByPath(parentObject, ["labels"], fromLabels);
		const fromCachedContent = getValueByPath(fromObject, ["cachedContent"]);
		if (parentObject !== void 0 && fromCachedContent != null) setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
		const fromResponseModalities = getValueByPath(fromObject, ["responseModalities"]);
		if (fromResponseModalities != null) setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
		const fromMediaResolution = getValueByPath(fromObject, ["mediaResolution"]);
		if (fromMediaResolution != null) setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
		const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
		if (fromSpeechConfig != null) setValueByPath(toObject, ["speechConfig"], speechConfigToVertex(apiClient, tSpeechConfig(apiClient, fromSpeechConfig)));
		const fromAudioTimestamp = getValueByPath(fromObject, ["audioTimestamp"]);
		if (fromAudioTimestamp != null) setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
		const fromThinkingConfig = getValueByPath(fromObject, ["thinkingConfig"]);
		if (fromThinkingConfig != null) setValueByPath(toObject, ["thinkingConfig"], thinkingConfigToVertex(apiClient, fromThinkingConfig));
		return toObject;
	}
	function generateContentParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromContents = getValueByPath(fromObject, ["contents"]);
		if (fromContents != null) if (Array.isArray(fromContents)) setValueByPath(toObject, ["contents"], tContents(apiClient, tContents(apiClient, fromContents).map((item) => {
			return contentToVertex(apiClient, item);
		})));
		else setValueByPath(toObject, ["contents"], tContents(apiClient, fromContents));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
		return toObject;
	}
	function embedContentConfigToVertex(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromTaskType = getValueByPath(fromObject, ["taskType"]);
		if (parentObject !== void 0 && fromTaskType != null) setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
		const fromTitle = getValueByPath(fromObject, ["title"]);
		if (parentObject !== void 0 && fromTitle != null) setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
		const fromOutputDimensionality = getValueByPath(fromObject, ["outputDimensionality"]);
		if (parentObject !== void 0 && fromOutputDimensionality != null) setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
		const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
		if (parentObject !== void 0 && fromMimeType != null) setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
		const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
		if (parentObject !== void 0 && fromAutoTruncate != null) setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
		return toObject;
	}
	function embedContentParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromContents = getValueByPath(fromObject, ["contents"]);
		if (fromContents != null) setValueByPath(toObject, ["instances[]", "content"], tContentsForEmbed(apiClient, fromContents));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], embedContentConfigToVertex(apiClient, fromConfig, toObject));
		return toObject;
	}
	function generateImagesConfigToVertex(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
		if (parentObject !== void 0 && fromOutputGcsUri != null) setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
		const fromNegativePrompt = getValueByPath(fromObject, ["negativePrompt"]);
		if (parentObject !== void 0 && fromNegativePrompt != null) setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
		const fromNumberOfImages = getValueByPath(fromObject, ["numberOfImages"]);
		if (parentObject !== void 0 && fromNumberOfImages != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
		const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
		if (parentObject !== void 0 && fromAspectRatio != null) setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
		const fromGuidanceScale = getValueByPath(fromObject, ["guidanceScale"]);
		if (parentObject !== void 0 && fromGuidanceScale != null) setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
		const fromSeed = getValueByPath(fromObject, ["seed"]);
		if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
		const fromSafetyFilterLevel = getValueByPath(fromObject, ["safetyFilterLevel"]);
		if (parentObject !== void 0 && fromSafetyFilterLevel != null) setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
		const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
		if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
		const fromIncludeSafetyAttributes = getValueByPath(fromObject, ["includeSafetyAttributes"]);
		if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
		const fromIncludeRaiReason = getValueByPath(fromObject, ["includeRaiReason"]);
		if (parentObject !== void 0 && fromIncludeRaiReason != null) setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
		const fromLanguage = getValueByPath(fromObject, ["language"]);
		if (parentObject !== void 0 && fromLanguage != null) setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
		const fromOutputMimeType = getValueByPath(fromObject, ["outputMimeType"]);
		if (parentObject !== void 0 && fromOutputMimeType != null) setValueByPath(parentObject, [
			"parameters",
			"outputOptions",
			"mimeType"
		], fromOutputMimeType);
		const fromOutputCompressionQuality = getValueByPath(fromObject, ["outputCompressionQuality"]);
		if (parentObject !== void 0 && fromOutputCompressionQuality != null) setValueByPath(parentObject, [
			"parameters",
			"outputOptions",
			"compressionQuality"
		], fromOutputCompressionQuality);
		const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
		if (parentObject !== void 0 && fromAddWatermark != null) setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
		const fromEnhancePrompt = getValueByPath(fromObject, ["enhancePrompt"]);
		if (parentObject !== void 0 && fromEnhancePrompt != null) setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
		return toObject;
	}
	function generateImagesParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromPrompt = getValueByPath(fromObject, ["prompt"]);
		if (fromPrompt != null) setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], generateImagesConfigToVertex(apiClient, fromConfig, toObject));
		return toObject;
	}
	function getModelParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function countTokensConfigToVertex(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromSystemInstruction = getValueByPath(fromObject, ["systemInstruction"]);
		if (parentObject !== void 0 && fromSystemInstruction != null) setValueByPath(parentObject, ["systemInstruction"], contentToVertex(apiClient, tContent(apiClient, fromSystemInstruction)));
		const fromTools = getValueByPath(fromObject, ["tools"]);
		if (parentObject !== void 0 && fromTools != null) if (Array.isArray(fromTools)) setValueByPath(parentObject, ["tools"], fromTools.map((item) => {
			return toolToVertex(apiClient, item);
		}));
		else setValueByPath(parentObject, ["tools"], fromTools);
		const fromGenerationConfig = getValueByPath(fromObject, ["generationConfig"]);
		if (parentObject !== void 0 && fromGenerationConfig != null) setValueByPath(parentObject, ["generationConfig"], fromGenerationConfig);
		return toObject;
	}
	function countTokensParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromContents = getValueByPath(fromObject, ["contents"]);
		if (fromContents != null) if (Array.isArray(fromContents)) setValueByPath(toObject, ["contents"], tContents(apiClient, tContents(apiClient, fromContents).map((item) => {
			return contentToVertex(apiClient, item);
		})));
		else setValueByPath(toObject, ["contents"], tContents(apiClient, fromContents));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], countTokensConfigToVertex(apiClient, fromConfig, toObject));
		return toObject;
	}
	function computeTokensParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromContents = getValueByPath(fromObject, ["contents"]);
		if (fromContents != null) if (Array.isArray(fromContents)) setValueByPath(toObject, ["contents"], tContents(apiClient, tContents(apiClient, fromContents).map((item) => {
			return contentToVertex(apiClient, item);
		})));
		else setValueByPath(toObject, ["contents"], tContents(apiClient, fromContents));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function imageToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
		if (fromGcsUri != null) setValueByPath(toObject, ["gcsUri"], fromGcsUri);
		const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
		if (fromImageBytes != null) setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(apiClient, fromImageBytes));
		const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		return toObject;
	}
	function generateVideosConfigToVertex(apiClient, fromObject, parentObject) {
		const toObject = {};
		const fromNumberOfVideos = getValueByPath(fromObject, ["numberOfVideos"]);
		if (parentObject !== void 0 && fromNumberOfVideos != null) setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
		const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
		if (parentObject !== void 0 && fromOutputGcsUri != null) setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
		const fromFps = getValueByPath(fromObject, ["fps"]);
		if (parentObject !== void 0 && fromFps != null) setValueByPath(parentObject, ["parameters", "fps"], fromFps);
		const fromDurationSeconds = getValueByPath(fromObject, ["durationSeconds"]);
		if (parentObject !== void 0 && fromDurationSeconds != null) setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
		const fromSeed = getValueByPath(fromObject, ["seed"]);
		if (parentObject !== void 0 && fromSeed != null) setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
		const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
		if (parentObject !== void 0 && fromAspectRatio != null) setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
		const fromResolution = getValueByPath(fromObject, ["resolution"]);
		if (parentObject !== void 0 && fromResolution != null) setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
		const fromPersonGeneration = getValueByPath(fromObject, ["personGeneration"]);
		if (parentObject !== void 0 && fromPersonGeneration != null) setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
		const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
		if (parentObject !== void 0 && fromPubsubTopic != null) setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
		const fromNegativePrompt = getValueByPath(fromObject, ["negativePrompt"]);
		if (parentObject !== void 0 && fromNegativePrompt != null) setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
		const fromEnhancePrompt = getValueByPath(fromObject, ["enhancePrompt"]);
		if (parentObject !== void 0 && fromEnhancePrompt != null) setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
		return toObject;
	}
	function generateVideosParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromModel = getValueByPath(fromObject, ["model"]);
		if (fromModel != null) setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
		const fromPrompt = getValueByPath(fromObject, ["prompt"]);
		if (fromPrompt != null) setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
		const fromImage = getValueByPath(fromObject, ["image"]);
		if (fromImage != null) setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(apiClient, fromImage));
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], generateVideosConfigToVertex(apiClient, fromConfig, toObject));
		return toObject;
	}
	function partFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function contentFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function citationMetadataFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromCitations = getValueByPath(fromObject, ["citationSources"]);
		if (fromCitations != null) setValueByPath(toObject, ["citations"], fromCitations);
		return toObject;
	}
	function candidateFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromContent = getValueByPath(fromObject, ["content"]);
		if (fromContent != null) setValueByPath(toObject, ["content"], contentFromMldev(apiClient, fromContent));
		const fromCitationMetadata = getValueByPath(fromObject, ["citationMetadata"]);
		if (fromCitationMetadata != null) setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(apiClient, fromCitationMetadata));
		const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
		if (fromTokenCount != null) setValueByPath(toObject, ["tokenCount"], fromTokenCount);
		const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
		if (fromFinishReason != null) setValueByPath(toObject, ["finishReason"], fromFinishReason);
		const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
		if (fromAvgLogprobs != null) setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
		const fromGroundingMetadata = getValueByPath(fromObject, ["groundingMetadata"]);
		if (fromGroundingMetadata != null) setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
		const fromIndex = getValueByPath(fromObject, ["index"]);
		if (fromIndex != null) setValueByPath(toObject, ["index"], fromIndex);
		const fromLogprobsResult = getValueByPath(fromObject, ["logprobsResult"]);
		if (fromLogprobsResult != null) setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
		const fromSafetyRatings = getValueByPath(fromObject, ["safetyRatings"]);
		if (fromSafetyRatings != null) setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
		return toObject;
	}
	function generateContentResponseFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromCandidates = getValueByPath(fromObject, ["candidates"]);
		if (fromCandidates != null) if (Array.isArray(fromCandidates)) setValueByPath(toObject, ["candidates"], fromCandidates.map((item) => {
			return candidateFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["candidates"], fromCandidates);
		const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
		if (fromModelVersion != null) setValueByPath(toObject, ["modelVersion"], fromModelVersion);
		const fromPromptFeedback = getValueByPath(fromObject, ["promptFeedback"]);
		if (fromPromptFeedback != null) setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
		const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
		if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
		return toObject;
	}
	function contentEmbeddingFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromValues = getValueByPath(fromObject, ["values"]);
		if (fromValues != null) setValueByPath(toObject, ["values"], fromValues);
		return toObject;
	}
	function embedContentMetadataFromMldev() {
		const toObject = {};
		return toObject;
	}
	function embedContentResponseFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
		if (fromEmbeddings != null) if (Array.isArray(fromEmbeddings)) setValueByPath(toObject, ["embeddings"], fromEmbeddings.map((item) => {
			return contentEmbeddingFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["embeddings"], fromEmbeddings);
		const fromMetadata = getValueByPath(fromObject, ["metadata"]);
		if (fromMetadata != null) setValueByPath(toObject, ["metadata"], embedContentMetadataFromMldev());
		return toObject;
	}
	function imageFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromImageBytes = getValueByPath(fromObject, ["bytesBase64Encoded"]);
		if (fromImageBytes != null) setValueByPath(toObject, ["imageBytes"], tBytes(apiClient, fromImageBytes));
		const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		return toObject;
	}
	function safetyAttributesFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromCategories = getValueByPath(fromObject, ["safetyAttributes", "categories"]);
		if (fromCategories != null) setValueByPath(toObject, ["categories"], fromCategories);
		const fromScores = getValueByPath(fromObject, ["safetyAttributes", "scores"]);
		if (fromScores != null) setValueByPath(toObject, ["scores"], fromScores);
		const fromContentType = getValueByPath(fromObject, ["contentType"]);
		if (fromContentType != null) setValueByPath(toObject, ["contentType"], fromContentType);
		return toObject;
	}
	function generatedImageFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromImage = getValueByPath(fromObject, ["_self"]);
		if (fromImage != null) setValueByPath(toObject, ["image"], imageFromMldev(apiClient, fromImage));
		const fromRaiFilteredReason = getValueByPath(fromObject, ["raiFilteredReason"]);
		if (fromRaiFilteredReason != null) setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
		const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
		if (fromSafetyAttributes != null) setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(apiClient, fromSafetyAttributes));
		return toObject;
	}
	function generateImagesResponseFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromGeneratedImages = getValueByPath(fromObject, ["predictions"]);
		if (fromGeneratedImages != null) if (Array.isArray(fromGeneratedImages)) setValueByPath(toObject, ["generatedImages"], fromGeneratedImages.map((item) => {
			return generatedImageFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["generatedImages"], fromGeneratedImages);
		const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, ["positivePromptSafetyAttributes"]);
		if (fromPositivePromptSafetyAttributes != null) setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(apiClient, fromPositivePromptSafetyAttributes));
		return toObject;
	}
	function tunedModelInfoFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
		if (fromBaseModel != null) setValueByPath(toObject, ["baseModel"], fromBaseModel);
		const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
		if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
		const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
		if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
		return toObject;
	}
	function modelFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
		if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromVersion = getValueByPath(fromObject, ["version"]);
		if (fromVersion != null) setValueByPath(toObject, ["version"], fromVersion);
		const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
		if (fromTunedModelInfo != null) setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(apiClient, fromTunedModelInfo));
		const fromInputTokenLimit = getValueByPath(fromObject, ["inputTokenLimit"]);
		if (fromInputTokenLimit != null) setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
		const fromOutputTokenLimit = getValueByPath(fromObject, ["outputTokenLimit"]);
		if (fromOutputTokenLimit != null) setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
		const fromSupportedActions = getValueByPath(fromObject, ["supportedGenerationMethods"]);
		if (fromSupportedActions != null) setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
		return toObject;
	}
	function countTokensResponseFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
		if (fromTotalTokens != null) setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
		const fromCachedContentTokenCount = getValueByPath(fromObject, ["cachedContentTokenCount"]);
		if (fromCachedContentTokenCount != null) setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
		return toObject;
	}
	function videoFromMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromUri = getValueByPath(fromObject, ["video", "uri"]);
		if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
		const fromVideoBytes = getValueByPath(fromObject, ["video", "encodedVideo"]);
		if (fromVideoBytes != null) setValueByPath(toObject, ["videoBytes"], tBytes(apiClient, fromVideoBytes));
		const fromMimeType = getValueByPath(fromObject, ["encoding"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		return toObject;
	}
	function generatedVideoFromMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromVideo = getValueByPath(fromObject, ["_self"]);
		if (fromVideo != null) setValueByPath(toObject, ["video"], videoFromMldev$1(apiClient, fromVideo));
		return toObject;
	}
	function generateVideosResponseFromMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromGeneratedVideos = getValueByPath(fromObject, ["generatedSamples"]);
		if (fromGeneratedVideos != null) if (Array.isArray(fromGeneratedVideos)) setValueByPath(toObject, ["generatedVideos"], fromGeneratedVideos.map((item) => {
			return generatedVideoFromMldev$1(apiClient, item);
		}));
		else setValueByPath(toObject, ["generatedVideos"], fromGeneratedVideos);
		const fromRaiMediaFilteredCount = getValueByPath(fromObject, ["raiMediaFilteredCount"]);
		if (fromRaiMediaFilteredCount != null) setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
		const fromRaiMediaFilteredReasons = getValueByPath(fromObject, ["raiMediaFilteredReasons"]);
		if (fromRaiMediaFilteredReasons != null) setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
		return toObject;
	}
	function generateVideosOperationFromMldev$1(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromMetadata = getValueByPath(fromObject, ["metadata"]);
		if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
		const fromDone = getValueByPath(fromObject, ["done"]);
		if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
		const fromError = getValueByPath(fromObject, ["error"]);
		if (fromError != null) setValueByPath(toObject, ["error"], fromError);
		const fromResponse = getValueByPath(fromObject, ["response", "generateVideoResponse"]);
		if (fromResponse != null) setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(apiClient, fromResponse));
		return toObject;
	}
	function partFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromVideoMetadata = getValueByPath(fromObject, ["videoMetadata"]);
		if (fromVideoMetadata != null) setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
		const fromThought = getValueByPath(fromObject, ["thought"]);
		if (fromThought != null) setValueByPath(toObject, ["thought"], fromThought);
		const fromCodeExecutionResult = getValueByPath(fromObject, ["codeExecutionResult"]);
		if (fromCodeExecutionResult != null) setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
		const fromExecutableCode = getValueByPath(fromObject, ["executableCode"]);
		if (fromExecutableCode != null) setValueByPath(toObject, ["executableCode"], fromExecutableCode);
		const fromFileData = getValueByPath(fromObject, ["fileData"]);
		if (fromFileData != null) setValueByPath(toObject, ["fileData"], fromFileData);
		const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
		if (fromFunctionCall != null) setValueByPath(toObject, ["functionCall"], fromFunctionCall);
		const fromFunctionResponse = getValueByPath(fromObject, ["functionResponse"]);
		if (fromFunctionResponse != null) setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
		const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
		if (fromInlineData != null) setValueByPath(toObject, ["inlineData"], fromInlineData);
		const fromText = getValueByPath(fromObject, ["text"]);
		if (fromText != null) setValueByPath(toObject, ["text"], fromText);
		return toObject;
	}
	function contentFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromParts = getValueByPath(fromObject, ["parts"]);
		if (fromParts != null) if (Array.isArray(fromParts)) setValueByPath(toObject, ["parts"], fromParts.map((item) => {
			return partFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["parts"], fromParts);
		const fromRole = getValueByPath(fromObject, ["role"]);
		if (fromRole != null) setValueByPath(toObject, ["role"], fromRole);
		return toObject;
	}
	function citationMetadataFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromCitations = getValueByPath(fromObject, ["citations"]);
		if (fromCitations != null) setValueByPath(toObject, ["citations"], fromCitations);
		return toObject;
	}
	function candidateFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromContent = getValueByPath(fromObject, ["content"]);
		if (fromContent != null) setValueByPath(toObject, ["content"], contentFromVertex(apiClient, fromContent));
		const fromCitationMetadata = getValueByPath(fromObject, ["citationMetadata"]);
		if (fromCitationMetadata != null) setValueByPath(toObject, ["citationMetadata"], citationMetadataFromVertex(apiClient, fromCitationMetadata));
		const fromFinishMessage = getValueByPath(fromObject, ["finishMessage"]);
		if (fromFinishMessage != null) setValueByPath(toObject, ["finishMessage"], fromFinishMessage);
		const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
		if (fromFinishReason != null) setValueByPath(toObject, ["finishReason"], fromFinishReason);
		const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
		if (fromAvgLogprobs != null) setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
		const fromGroundingMetadata = getValueByPath(fromObject, ["groundingMetadata"]);
		if (fromGroundingMetadata != null) setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
		const fromIndex = getValueByPath(fromObject, ["index"]);
		if (fromIndex != null) setValueByPath(toObject, ["index"], fromIndex);
		const fromLogprobsResult = getValueByPath(fromObject, ["logprobsResult"]);
		if (fromLogprobsResult != null) setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
		const fromSafetyRatings = getValueByPath(fromObject, ["safetyRatings"]);
		if (fromSafetyRatings != null) setValueByPath(toObject, ["safetyRatings"], fromSafetyRatings);
		return toObject;
	}
	function generateContentResponseFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromCandidates = getValueByPath(fromObject, ["candidates"]);
		if (fromCandidates != null) if (Array.isArray(fromCandidates)) setValueByPath(toObject, ["candidates"], fromCandidates.map((item) => {
			return candidateFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["candidates"], fromCandidates);
		const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
		if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
		const fromResponseId = getValueByPath(fromObject, ["responseId"]);
		if (fromResponseId != null) setValueByPath(toObject, ["responseId"], fromResponseId);
		const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
		if (fromModelVersion != null) setValueByPath(toObject, ["modelVersion"], fromModelVersion);
		const fromPromptFeedback = getValueByPath(fromObject, ["promptFeedback"]);
		if (fromPromptFeedback != null) setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
		const fromUsageMetadata = getValueByPath(fromObject, ["usageMetadata"]);
		if (fromUsageMetadata != null) setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
		return toObject;
	}
	function contentEmbeddingStatisticsFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromTruncated = getValueByPath(fromObject, ["truncated"]);
		if (fromTruncated != null) setValueByPath(toObject, ["truncated"], fromTruncated);
		const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
		if (fromTokenCount != null) setValueByPath(toObject, ["tokenCount"], fromTokenCount);
		return toObject;
	}
	function contentEmbeddingFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromValues = getValueByPath(fromObject, ["values"]);
		if (fromValues != null) setValueByPath(toObject, ["values"], fromValues);
		const fromStatistics = getValueByPath(fromObject, ["statistics"]);
		if (fromStatistics != null) setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(apiClient, fromStatistics));
		return toObject;
	}
	function embedContentMetadataFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromBillableCharacterCount = getValueByPath(fromObject, ["billableCharacterCount"]);
		if (fromBillableCharacterCount != null) setValueByPath(toObject, ["billableCharacterCount"], fromBillableCharacterCount);
		return toObject;
	}
	function embedContentResponseFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromEmbeddings = getValueByPath(fromObject, ["predictions[]", "embeddings"]);
		if (fromEmbeddings != null) if (Array.isArray(fromEmbeddings)) setValueByPath(toObject, ["embeddings"], fromEmbeddings.map((item) => {
			return contentEmbeddingFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["embeddings"], fromEmbeddings);
		const fromMetadata = getValueByPath(fromObject, ["metadata"]);
		if (fromMetadata != null) setValueByPath(toObject, ["metadata"], embedContentMetadataFromVertex(apiClient, fromMetadata));
		return toObject;
	}
	function imageFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
		if (fromGcsUri != null) setValueByPath(toObject, ["gcsUri"], fromGcsUri);
		const fromImageBytes = getValueByPath(fromObject, ["bytesBase64Encoded"]);
		if (fromImageBytes != null) setValueByPath(toObject, ["imageBytes"], tBytes(apiClient, fromImageBytes));
		const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		return toObject;
	}
	function safetyAttributesFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromCategories = getValueByPath(fromObject, ["safetyAttributes", "categories"]);
		if (fromCategories != null) setValueByPath(toObject, ["categories"], fromCategories);
		const fromScores = getValueByPath(fromObject, ["safetyAttributes", "scores"]);
		if (fromScores != null) setValueByPath(toObject, ["scores"], fromScores);
		const fromContentType = getValueByPath(fromObject, ["contentType"]);
		if (fromContentType != null) setValueByPath(toObject, ["contentType"], fromContentType);
		return toObject;
	}
	function generatedImageFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromImage = getValueByPath(fromObject, ["_self"]);
		if (fromImage != null) setValueByPath(toObject, ["image"], imageFromVertex(apiClient, fromImage));
		const fromRaiFilteredReason = getValueByPath(fromObject, ["raiFilteredReason"]);
		if (fromRaiFilteredReason != null) setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
		const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
		if (fromSafetyAttributes != null) setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(apiClient, fromSafetyAttributes));
		const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
		if (fromEnhancedPrompt != null) setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
		return toObject;
	}
	function generateImagesResponseFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromGeneratedImages = getValueByPath(fromObject, ["predictions"]);
		if (fromGeneratedImages != null) if (Array.isArray(fromGeneratedImages)) setValueByPath(toObject, ["generatedImages"], fromGeneratedImages.map((item) => {
			return generatedImageFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["generatedImages"], fromGeneratedImages);
		const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, ["positivePromptSafetyAttributes"]);
		if (fromPositivePromptSafetyAttributes != null) setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(apiClient, fromPositivePromptSafetyAttributes));
		return toObject;
	}
	function endpointFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["endpoint"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromDeployedModelId = getValueByPath(fromObject, ["deployedModelId"]);
		if (fromDeployedModelId != null) setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
		return toObject;
	}
	function tunedModelInfoFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromBaseModel = getValueByPath(fromObject, ["labels", "google-vertex-llm-tuning-base-model-id"]);
		if (fromBaseModel != null) setValueByPath(toObject, ["baseModel"], fromBaseModel);
		const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
		if (fromCreateTime != null) setValueByPath(toObject, ["createTime"], fromCreateTime);
		const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
		if (fromUpdateTime != null) setValueByPath(toObject, ["updateTime"], fromUpdateTime);
		return toObject;
	}
	function modelFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
		if (fromDisplayName != null) setValueByPath(toObject, ["displayName"], fromDisplayName);
		const fromDescription = getValueByPath(fromObject, ["description"]);
		if (fromDescription != null) setValueByPath(toObject, ["description"], fromDescription);
		const fromVersion = getValueByPath(fromObject, ["versionId"]);
		if (fromVersion != null) setValueByPath(toObject, ["version"], fromVersion);
		const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
		if (fromEndpoints != null) if (Array.isArray(fromEndpoints)) setValueByPath(toObject, ["endpoints"], fromEndpoints.map((item) => {
			return endpointFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["endpoints"], fromEndpoints);
		const fromLabels = getValueByPath(fromObject, ["labels"]);
		if (fromLabels != null) setValueByPath(toObject, ["labels"], fromLabels);
		const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
		if (fromTunedModelInfo != null) setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(apiClient, fromTunedModelInfo));
		return toObject;
	}
	function countTokensResponseFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
		if (fromTotalTokens != null) setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
		return toObject;
	}
	function computeTokensResponseFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
		if (fromTokensInfo != null) setValueByPath(toObject, ["tokensInfo"], fromTokensInfo);
		return toObject;
	}
	function videoFromVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromUri = getValueByPath(fromObject, ["gcsUri"]);
		if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
		const fromVideoBytes = getValueByPath(fromObject, ["bytesBase64Encoded"]);
		if (fromVideoBytes != null) setValueByPath(toObject, ["videoBytes"], tBytes(apiClient, fromVideoBytes));
		const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		return toObject;
	}
	function generatedVideoFromVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromVideo = getValueByPath(fromObject, ["_self"]);
		if (fromVideo != null) setValueByPath(toObject, ["video"], videoFromVertex$1(apiClient, fromVideo));
		return toObject;
	}
	function generateVideosResponseFromVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
		if (fromGeneratedVideos != null) if (Array.isArray(fromGeneratedVideos)) setValueByPath(toObject, ["generatedVideos"], fromGeneratedVideos.map((item) => {
			return generatedVideoFromVertex$1(apiClient, item);
		}));
		else setValueByPath(toObject, ["generatedVideos"], fromGeneratedVideos);
		const fromRaiMediaFilteredCount = getValueByPath(fromObject, ["raiMediaFilteredCount"]);
		if (fromRaiMediaFilteredCount != null) setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
		const fromRaiMediaFilteredReasons = getValueByPath(fromObject, ["raiMediaFilteredReasons"]);
		if (fromRaiMediaFilteredReasons != null) setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
		return toObject;
	}
	function generateVideosOperationFromVertex$1(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromMetadata = getValueByPath(fromObject, ["metadata"]);
		if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
		const fromDone = getValueByPath(fromObject, ["done"]);
		if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
		const fromError = getValueByPath(fromObject, ["error"]);
		if (fromError != null) setValueByPath(toObject, ["error"], fromError);
		const fromResponse = getValueByPath(fromObject, ["response"]);
		if (fromResponse != null) setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(apiClient, fromResponse));
		return toObject;
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	const FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
	/**
	* Handles incoming messages from the WebSocket.
	*
	* @remarks
	* This function is responsible for parsing incoming messages, transforming them
	* into LiveServerMessages, and then calling the onmessage callback. Note that
	* the first message which is received from the server is a setupComplete
	* message.
	*
	* @param apiClient The ApiClient instance.
	* @param onmessage The user-provided onmessage callback (if any).
	* @param event The MessageEvent from the WebSocket.
	*/
	async function handleWebSocketMessage(apiClient, onmessage, event) {
		let serverMessage;
		let data;
		if (event.data instanceof Blob) data = JSON.parse(await event.data.text());
		else data = JSON.parse(event.data);
		if (apiClient.isVertexAI()) serverMessage = liveServerMessageFromVertex(apiClient, data);
		else serverMessage = liveServerMessageFromMldev(apiClient, data);
		onmessage(serverMessage);
	}
	/**
	Live class encapsulates the configuration for live interaction with the
	Generative Language API. It embeds ApiClient for general API settings.
	
	@experimental
	*/
	var Live = class {
		constructor(apiClient, auth$2, webSocketFactory) {
			this.apiClient = apiClient;
			this.auth = auth$2;
			this.webSocketFactory = webSocketFactory;
		}
		/**
		Establishes a connection to the specified model with the given
		configuration and returns a Session object representing that connection.
		
		@experimental
		
		@remarks
		
		@param params - The parameters for establishing a connection to the model.
		@return A live session.
		
		@example
		```ts
		let model: string;
		if (GOOGLE_GENAI_USE_VERTEXAI) {
		model = 'gemini-2.0-flash-live-preview-04-09';
		} else {
		model = 'gemini-2.0-flash-live-001';
		}
		const session = await ai.live.connect({
		model: model,
		config: {
		responseModalities: [Modality.AUDIO],
		},
		callbacks: {
		onopen: () => {
		console.log('Connected to the socket.');
		},
		onmessage: (e: MessageEvent) => {
		console.log('Received message from the server: %s\n', debug(e.data));
		},
		onerror: (e: ErrorEvent) => {
		console.log('Error occurred: %s\n', debug(e.error));
		},
		onclose: (e: CloseEvent) => {
		console.log('Connection closed.');
		},
		},
		});
		```
		*/
		async connect(params) {
			var _a$5, _b$1, _c$1, _d;
			const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
			const apiVersion = this.apiClient.getApiVersion();
			let url;
			const headers = mapToHeaders(this.apiClient.getDefaultHeaders());
			if (this.apiClient.isVertexAI()) {
				url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
				await this.auth.addAuthHeaders(headers);
			} else {
				const apiKey = this.apiClient.getApiKey();
				url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateContent?key=${apiKey}`;
			}
			let onopenResolve = () => {};
			const onopenPromise = new Promise((resolve) => {
				onopenResolve = resolve;
			});
			const callbacks = params.callbacks;
			const onopenAwaitedCallback = function() {
				var _a$6;
				(_a$6 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a$6 === void 0 || _a$6.call(callbacks);
				onopenResolve({});
			};
			const apiClient = this.apiClient;
			const websocketCallbacks = {
				onopen: onopenAwaitedCallback,
				onmessage: (event) => {
					handleWebSocketMessage(apiClient, callbacks.onmessage, event);
				},
				onerror: (_a$5 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a$5 !== void 0 ? _a$5 : function(e) {},
				onclose: (_b$1 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b$1 !== void 0 ? _b$1 : function(e) {}
			};
			const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
			conn.connect();
			await onopenPromise;
			let transformedModel = tModel(this.apiClient, params.model);
			if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
				const project$1 = this.apiClient.getProject();
				const location = this.apiClient.getLocation();
				transformedModel = `projects/${project$1}/locations/${location}/` + transformedModel;
			}
			let clientMessage = {};
			if (this.apiClient.isVertexAI() && ((_c$1 = params.config) === null || _c$1 === void 0 ? void 0 : _c$1.responseModalities) === void 0) if (params.config === void 0) params.config = { responseModalities: [exports.Modality.AUDIO] };
			else params.config.responseModalities = [exports.Modality.AUDIO];
			if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
			const liveConnectParameters = {
				model: transformedModel,
				config: params.config,
				callbacks: params.callbacks
			};
			if (this.apiClient.isVertexAI()) clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
			else clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
			delete clientMessage["config"];
			conn.send(JSON.stringify(clientMessage));
			return new Session(conn, this.apiClient);
		}
	};
	const defaultLiveSendClientContentParamerters = { turnComplete: true };
	/**
	Represents a connection to the API.
	
	@experimental
	*/
	var Session = class {
		constructor(conn, apiClient) {
			this.conn = conn;
			this.apiClient = apiClient;
		}
		tLiveClientContent(apiClient, params) {
			if (params.turns !== null && params.turns !== void 0) {
				let contents = [];
				try {
					contents = tContents(apiClient, params.turns);
					if (apiClient.isVertexAI()) contents = contents.map((item) => contentToVertex(apiClient, item));
					else contents = contents.map((item) => contentToMldev(apiClient, item));
				} catch (_a$5) {
					throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
				}
				return { clientContent: {
					turns: contents,
					turnComplete: params.turnComplete
				} };
			}
			return { clientContent: { turnComplete: params.turnComplete } };
		}
		tLiveClientRealtimeInput(apiClient, params) {
			let clientMessage = {};
			if (!("media" in params) || !params.media) throw new Error(`Failed to convert realtime input "media", type: '${typeof params.media}'`);
			clientMessage = { realtimeInput: {
				mediaChunks: [params.media],
				activityStart: params.activityStart,
				activityEnd: params.activityEnd
			} };
			return clientMessage;
		}
		tLiveClienttToolResponse(apiClient, params) {
			let functionResponses = [];
			if (params.functionResponses == null) throw new Error("functionResponses is required.");
			if (!Array.isArray(params.functionResponses)) functionResponses = [params.functionResponses];
			else functionResponses = params.functionResponses;
			if (functionResponses.length === 0) throw new Error("functionResponses is required.");
			for (const functionResponse of functionResponses) {
				if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
				if (!apiClient.isVertexAI() && !("id" in functionResponse)) throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
			}
			const clientMessage = { toolResponse: { functionResponses } };
			return clientMessage;
		}
		/**
		Send a message over the established connection.
		
		@param params - Contains two **optional** properties, `turns` and
		`turnComplete`.
		
		- `turns` will be converted to a `Content[]`
		- `turnComplete: true` [default] indicates that you are done sending
		content and expect a response. If `turnComplete: false`, the server
		will wait for additional messages before starting generation.
		
		@experimental
		
		@remarks
		There are two ways to send messages to the live API:
		`sendClientContent` and `sendRealtimeInput`.
		
		`sendClientContent` messages are added to the model context **in order**.
		Having a conversation using `sendClientContent` messages is roughly
		equivalent to using the `Chat.sendMessageStream`, except that the state of
		the `chat` history is stored on the API server instead of locally.
		
		Because of `sendClientContent`'s order guarantee, the model cannot respons
		as quickly to `sendClientContent` messages as to `sendRealtimeInput`
		messages. This makes the biggest difference when sending objects that have
		significant preprocessing time (typically images).
		
		The `sendClientContent` message sends a `Content[]`
		which has more options than the `Blob` sent by `sendRealtimeInput`.
		
		So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
		
		- Sending anything that can't be represented as a `Blob` (text,
		`sendClientContent({turns="Hello?"}`)).
		- Managing turns when not using audio input and voice activity detection.
		(`sendClientContent({turnComplete:true})` or the short form
		`sendClientContent()`)
		- Prefilling a conversation context
		```
		sendClientContent({
		turns: [
		Content({role:user, parts:...}),
		Content({role:user, parts:...}),
		...
		]
		})
		```
		@experimental
		*/
		sendClientContent(params) {
			params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
			const clientMessage = this.tLiveClientContent(this.apiClient, params);
			this.conn.send(JSON.stringify(clientMessage));
		}
		/**
		Send a realtime message over the established connection.
		
		@param params - Contains one property, `media`.
		
		- `media` will be converted to a `Blob`
		
		@experimental
		
		@remarks
		Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
		
		With `sendRealtimeInput` the api will respond to audio automatically
		based on voice activity detection (VAD).
		
		`sendRealtimeInput` is optimized for responsivness at the expense of
		deterministic ordering guarantees. Audio and video tokens are to the
		context when they become available.
		
		Note: The Call signature expects a `Blob` object, but only a subset
		of audio and image mimetypes are allowed.
		*/
		sendRealtimeInput(params) {
			if (params.media == null) throw new Error("Media is required.");
			const clientMessage = this.tLiveClientRealtimeInput(this.apiClient, params);
			this.conn.send(JSON.stringify(clientMessage));
		}
		/**
		Send a function response message over the established connection.
		
		@param params - Contains property `functionResponses`.
		
		- `functionResponses` will be converted to a `functionResponses[]`
		
		@remarks
		Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
		
		Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
		
		@experimental
		*/
		sendToolResponse(params) {
			if (params.functionResponses == null) throw new Error("Tool response parameters are required.");
			const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
			this.conn.send(JSON.stringify(clientMessage));
		}
		/**
		Terminates the WebSocket connection.
		
		@experimental
		
		@example
		```ts
		let model: string;
		if (GOOGLE_GENAI_USE_VERTEXAI) {
		model = 'gemini-2.0-flash-live-preview-04-09';
		} else {
		model = 'gemini-2.0-flash-live-001';
		}
		const session = await ai.live.connect({
		model: model,
		config: {
		responseModalities: [Modality.AUDIO],
		}
		});
		
		session.close();
		```
		*/
		close() {
			this.conn.close();
		}
	};
	function headersToMap(headers) {
		const headerMap = {};
		headers.forEach((value, key) => {
			headerMap[key] = value;
		});
		return headerMap;
	}
	function mapToHeaders(map) {
		const headers = new Headers();
		for (const [key, value] of Object.entries(map)) headers.append(key, value);
		return headers;
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	var Models = class extends BaseModule {
		constructor(apiClient) {
			super();
			this.apiClient = apiClient;
			/**
			* Makes an API request to generate content with a given model.
			*
			* For the `model` parameter, supported formats for Vertex AI API include:
			* - The Gemini model ID, for example: 'gemini-2.0-flash'
			* - The full resource name starts with 'projects/', for example:
			*  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'
			* - The partial resource name with 'publishers/', for example:
			*  'publishers/google/models/gemini-2.0-flash' or
			*  'publishers/meta/models/llama-3.1-405b-instruct-maas'
			* - `/` separated publisher and model name, for example:
			* 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'
			*
			* For the `model` parameter, supported formats for Gemini API include:
			* - The Gemini model ID, for example: 'gemini-2.0-flash'
			* - The model name starts with 'models/', for example:
			*  'models/gemini-2.0-flash'
			* - For tuned models, the model name starts with 'tunedModels/',
			* for example:
			* 'tunedModels/1234567890123456789'
			*
			* Some models support multimodal input and output.
			*
			* @param params - The parameters for generating content.
			* @return The response from generating content.
			*
			* @example
			* ```ts
			* const response = await ai.models.generateContent({
			*   model: 'gemini-2.0-flash',
			*   contents: 'why is the sky blue?',
			*   config: {
			*     candidateCount: 2,
			*   }
			* });
			* console.log(response);
			* ```
			*/
			this.generateContent = async (params) => {
				return await this.generateContentInternal(params);
			};
			/**
			* Makes an API request to generate content with a given model and yields the
			* response in chunks.
			*
			* For the `model` parameter, supported formats for Vertex AI API include:
			* - The Gemini model ID, for example: 'gemini-2.0-flash'
			* - The full resource name starts with 'projects/', for example:
			*  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'
			* - The partial resource name with 'publishers/', for example:
			*  'publishers/google/models/gemini-2.0-flash' or
			*  'publishers/meta/models/llama-3.1-405b-instruct-maas'
			* - `/` separated publisher and model name, for example:
			* 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'
			*
			* For the `model` parameter, supported formats for Gemini API include:
			* - The Gemini model ID, for example: 'gemini-2.0-flash'
			* - The model name starts with 'models/', for example:
			*  'models/gemini-2.0-flash'
			* - For tuned models, the model name starts with 'tunedModels/',
			* for example:
			*  'tunedModels/1234567890123456789'
			*
			* Some models support multimodal input and output.
			*
			* @param params - The parameters for generating content with streaming response.
			* @return The response from generating content.
			*
			* @example
			* ```ts
			* const response = await ai.models.generateContentStream({
			*   model: 'gemini-2.0-flash',
			*   contents: 'why is the sky blue?',
			*   config: {
			*     maxOutputTokens: 200,
			*   }
			* });
			* for await (const chunk of response) {
			*   console.log(chunk);
			* }
			* ```
			*/
			this.generateContentStream = async (params) => {
				return await this.generateContentStreamInternal(params);
			};
			/**
			* Generates an image based on a text description and configuration.
			*
			* @param model - The model to use.
			* @param prompt - A text description of the image to generate.
			* @param [config] - The config for image generation.
			* @return The response from the API.
			*
			* @example
			* ```ts
			* const response = await client.models.generateImages({
			*  model: 'imagen-3.0-generate-002',
			*  prompt: 'Robot holding a red skateboard',
			*  config: {
			*    numberOfImages: 1,
			*    includeRaiReason: true,
			*  },
			* });
			* console.log(response?.generatedImages?.[0]?.image?.imageBytes);
			* ```
			*/
			this.generateImages = async (params) => {
				return await this.generateImagesInternal(params).then((apiResponse) => {
					var _a$5;
					let positivePromptSafetyAttributes;
					const generatedImages = [];
					if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) for (const generatedImage of apiResponse.generatedImages) if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a$5 = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a$5 === void 0 ? void 0 : _a$5.contentType) === "Positive Prompt") positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
					else generatedImages.push(generatedImage);
					let response;
					if (positivePromptSafetyAttributes) response = {
						generatedImages,
						positivePromptSafetyAttributes
					};
					else response = { generatedImages };
					return response;
				});
			};
		}
		async generateContentInternal(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = generateContentParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{model}:generateContent", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = generateContentResponseFromVertex(this.apiClient, apiResponse);
					const typedResp = new GenerateContentResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			} else {
				const body = generateContentParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{model}:generateContent", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = generateContentResponseFromMldev(this.apiClient, apiResponse);
					const typedResp = new GenerateContentResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			}
		}
		async generateContentStreamInternal(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = generateContentParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				const apiClient = this.apiClient;
				response = apiClient.requestStream({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				});
				return response.then(function(apiResponse) {
					return __asyncGenerator(this, arguments, function* () {
						var _a$6, e_1, _b$2, _c$1;
						try {
							for (var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a$6 = apiResponse_1_1.done, !_a$6; _d = true) {
								_c$1 = apiResponse_1_1.value;
								_d = false;
								const chunk = _c$1;
								const resp = generateContentResponseFromVertex(apiClient, yield __await(chunk.json()));
								const typedResp = new GenerateContentResponse();
								Object.assign(typedResp, resp);
								yield yield __await(typedResp);
							}
						} catch (e_1_1) {
							e_1 = { error: e_1_1 };
						} finally {
							try {
								if (!_d && !_a$6 && (_b$2 = apiResponse_1.return)) yield __await(_b$2.call(apiResponse_1));
							} finally {
								if (e_1) throw e_1.error;
							}
						}
					});
				});
			} else {
				const body = generateContentParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				const apiClient = this.apiClient;
				response = apiClient.requestStream({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				});
				return response.then(function(apiResponse) {
					return __asyncGenerator(this, arguments, function* () {
						var _a$6, e_2, _b$2, _c$1;
						try {
							for (var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a$6 = apiResponse_2_1.done, !_a$6; _d = true) {
								_c$1 = apiResponse_2_1.value;
								_d = false;
								const chunk = _c$1;
								const resp = generateContentResponseFromMldev(apiClient, yield __await(chunk.json()));
								const typedResp = new GenerateContentResponse();
								Object.assign(typedResp, resp);
								yield yield __await(typedResp);
							}
						} catch (e_2_1) {
							e_2 = { error: e_2_1 };
						} finally {
							try {
								if (!_d && !_a$6 && (_b$2 = apiResponse_2.return)) yield __await(_b$2.call(apiResponse_2));
							} finally {
								if (e_2) throw e_2.error;
							}
						}
					});
				});
			}
		}
		/**
		* Calculates embeddings for the given contents. Only text is supported.
		*
		* @param params - The parameters for embedding contents.
		* @return The response from the API.
		*
		* @example
		* ```ts
		* const response = await ai.models.embedContent({
		*  model: 'text-embedding-004',
		*  contents: [
		*    'What is your name?',
		*    'What is your favorite color?',
		*  ],
		*  config: {
		*    outputDimensionality: 64,
		*  },
		* });
		* console.log(response);
		* ```
		*/
		async embedContent(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = embedContentParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{model}:predict", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = embedContentResponseFromVertex(this.apiClient, apiResponse);
					const typedResp = new EmbedContentResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			} else {
				const body = embedContentParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{model}:batchEmbedContents", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = embedContentResponseFromMldev(this.apiClient, apiResponse);
					const typedResp = new EmbedContentResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			}
		}
		/**
		* Generates an image based on a text description and configuration.
		*
		* @param params - The parameters for generating images.
		* @return The response from the API.
		*
		* @example
		* ```ts
		* const response = await ai.models.generateImages({
		*  model: 'imagen-3.0-generate-002',
		*  prompt: 'Robot holding a red skateboard',
		*  config: {
		*    numberOfImages: 1,
		*    includeRaiReason: true,
		*  },
		* });
		* console.log(response?.generatedImages?.[0]?.image?.imageBytes);
		* ```
		*/
		async generateImagesInternal(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = generateImagesParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{model}:predict", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = generateImagesResponseFromVertex(this.apiClient, apiResponse);
					const typedResp = new GenerateImagesResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			} else {
				const body = generateImagesParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{model}:predict", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = generateImagesResponseFromMldev(this.apiClient, apiResponse);
					const typedResp = new GenerateImagesResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			}
		}
		/**
		* Fetches information about a model by name.
		*
		* @example
		* ```ts
		* const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
		* ```
		*/
		async get(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = getModelParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{name}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = modelFromVertex(this.apiClient, apiResponse);
					return resp;
				});
			} else {
				const body = getModelParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{name}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = modelFromMldev(this.apiClient, apiResponse);
					return resp;
				});
			}
		}
		/**
		* Counts the number of tokens in the given contents. Multimodal input is
		* supported for Gemini models.
		*
		* @param params - The parameters for counting tokens.
		* @return The response from the API.
		*
		* @example
		* ```ts
		* const response = await ai.models.countTokens({
		*  model: 'gemini-2.0-flash',
		*  contents: 'The quick brown fox jumps over the lazy dog.'
		* });
		* console.log(response);
		* ```
		*/
		async countTokens(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = countTokensParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{model}:countTokens", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = countTokensResponseFromVertex(this.apiClient, apiResponse);
					const typedResp = new CountTokensResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			} else {
				const body = countTokensParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{model}:countTokens", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = countTokensResponseFromMldev(this.apiClient, apiResponse);
					const typedResp = new CountTokensResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			}
		}
		/**
		* Given a list of contents, returns a corresponding TokensInfo containing
		* the list of tokens and list of token ids.
		*
		* This method is not supported by the Gemini Developer API.
		*
		* @param params - The parameters for computing tokens.
		* @return The response from the API.
		*
		* @example
		* ```ts
		* const response = await ai.models.computeTokens({
		*  model: 'gemini-2.0-flash',
		*  contents: 'What is your name?'
		* });
		* console.log(response);
		* ```
		*/
		async computeTokens(params) {
			var _a$5;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = computeTokensParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{model}:computeTokens", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = computeTokensResponseFromVertex(this.apiClient, apiResponse);
					const typedResp = new ComputeTokensResponse();
					Object.assign(typedResp, resp);
					return typedResp;
				});
			} else throw new Error("This method is only supported by the Vertex AI.");
		}
		/**
		*  Generates videos based on a text description and configuration.
		*
		* @param params - The parameters for generating videos.
		* @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.
		*
		* @example
		* ```ts
		* const operation = await ai.models.generateVideos({
		*  model: 'veo-2.0-generate-001',
		*  prompt: 'A neon hologram of a cat driving at top speed',
		*  config: {
		*    numberOfVideos: 1
		* });
		*
		* while (!operation.done) {
		*   await new Promise(resolve => setTimeout(resolve, 10000));
		*   operation = await ai.operations.getVideosOperation({operation: operation});
		* }
		*
		* console.log(operation.response?.generatedVideos?.[0]?.video?.uri);
		* ```
		*/
		async generateVideos(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = generateVideosParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{model}:predictLongRunning", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = generateVideosOperationFromVertex$1(this.apiClient, apiResponse);
					return resp;
				});
			} else {
				const body = generateVideosParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{model}:predictLongRunning", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = generateVideosOperationFromMldev$1(this.apiClient, apiResponse);
					return resp;
				});
			}
		}
	};
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	function getOperationParametersToMldev(apiClient, fromObject) {
		const toObject = {};
		const fromOperationName = getValueByPath(fromObject, ["operationName"]);
		if (fromOperationName != null) setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function getOperationParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromOperationName = getValueByPath(fromObject, ["operationName"]);
		if (fromOperationName != null) setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function fetchPredictOperationParametersToVertex(apiClient, fromObject) {
		const toObject = {};
		const fromOperationName = getValueByPath(fromObject, ["operationName"]);
		if (fromOperationName != null) setValueByPath(toObject, ["operationName"], fromOperationName);
		const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
		if (fromResourceName != null) setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
		const fromConfig = getValueByPath(fromObject, ["config"]);
		if (fromConfig != null) setValueByPath(toObject, ["config"], fromConfig);
		return toObject;
	}
	function videoFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromUri = getValueByPath(fromObject, ["video", "uri"]);
		if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
		const fromVideoBytes = getValueByPath(fromObject, ["video", "encodedVideo"]);
		if (fromVideoBytes != null) setValueByPath(toObject, ["videoBytes"], tBytes(apiClient, fromVideoBytes));
		const fromMimeType = getValueByPath(fromObject, ["encoding"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		return toObject;
	}
	function generatedVideoFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromVideo = getValueByPath(fromObject, ["_self"]);
		if (fromVideo != null) setValueByPath(toObject, ["video"], videoFromMldev(apiClient, fromVideo));
		return toObject;
	}
	function generateVideosResponseFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromGeneratedVideos = getValueByPath(fromObject, ["generatedSamples"]);
		if (fromGeneratedVideos != null) if (Array.isArray(fromGeneratedVideos)) setValueByPath(toObject, ["generatedVideos"], fromGeneratedVideos.map((item) => {
			return generatedVideoFromMldev(apiClient, item);
		}));
		else setValueByPath(toObject, ["generatedVideos"], fromGeneratedVideos);
		const fromRaiMediaFilteredCount = getValueByPath(fromObject, ["raiMediaFilteredCount"]);
		if (fromRaiMediaFilteredCount != null) setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
		const fromRaiMediaFilteredReasons = getValueByPath(fromObject, ["raiMediaFilteredReasons"]);
		if (fromRaiMediaFilteredReasons != null) setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
		return toObject;
	}
	function generateVideosOperationFromMldev(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromMetadata = getValueByPath(fromObject, ["metadata"]);
		if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
		const fromDone = getValueByPath(fromObject, ["done"]);
		if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
		const fromError = getValueByPath(fromObject, ["error"]);
		if (fromError != null) setValueByPath(toObject, ["error"], fromError);
		const fromResponse = getValueByPath(fromObject, ["response", "generateVideoResponse"]);
		if (fromResponse != null) setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(apiClient, fromResponse));
		return toObject;
	}
	function videoFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromUri = getValueByPath(fromObject, ["gcsUri"]);
		if (fromUri != null) setValueByPath(toObject, ["uri"], fromUri);
		const fromVideoBytes = getValueByPath(fromObject, ["bytesBase64Encoded"]);
		if (fromVideoBytes != null) setValueByPath(toObject, ["videoBytes"], tBytes(apiClient, fromVideoBytes));
		const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
		if (fromMimeType != null) setValueByPath(toObject, ["mimeType"], fromMimeType);
		return toObject;
	}
	function generatedVideoFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromVideo = getValueByPath(fromObject, ["_self"]);
		if (fromVideo != null) setValueByPath(toObject, ["video"], videoFromVertex(apiClient, fromVideo));
		return toObject;
	}
	function generateVideosResponseFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
		if (fromGeneratedVideos != null) if (Array.isArray(fromGeneratedVideos)) setValueByPath(toObject, ["generatedVideos"], fromGeneratedVideos.map((item) => {
			return generatedVideoFromVertex(apiClient, item);
		}));
		else setValueByPath(toObject, ["generatedVideos"], fromGeneratedVideos);
		const fromRaiMediaFilteredCount = getValueByPath(fromObject, ["raiMediaFilteredCount"]);
		if (fromRaiMediaFilteredCount != null) setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
		const fromRaiMediaFilteredReasons = getValueByPath(fromObject, ["raiMediaFilteredReasons"]);
		if (fromRaiMediaFilteredReasons != null) setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
		return toObject;
	}
	function generateVideosOperationFromVertex(apiClient, fromObject) {
		const toObject = {};
		const fromName = getValueByPath(fromObject, ["name"]);
		if (fromName != null) setValueByPath(toObject, ["name"], fromName);
		const fromMetadata = getValueByPath(fromObject, ["metadata"]);
		if (fromMetadata != null) setValueByPath(toObject, ["metadata"], fromMetadata);
		const fromDone = getValueByPath(fromObject, ["done"]);
		if (fromDone != null) setValueByPath(toObject, ["done"], fromDone);
		const fromError = getValueByPath(fromObject, ["error"]);
		if (fromError != null) setValueByPath(toObject, ["error"], fromError);
		const fromResponse = getValueByPath(fromObject, ["response"]);
		if (fromResponse != null) setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(apiClient, fromResponse));
		return toObject;
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	var Operations = class extends BaseModule {
		constructor(apiClient) {
			super();
			this.apiClient = apiClient;
		}
		/**
		* Gets the status of a long-running operation.
		*
		* @param parameters The parameters for the get operation request.
		* @return The updated Operation object, with the latest status or result.
		*/
		async getVideosOperation(parameters) {
			const operation = parameters.operation;
			const config$1 = parameters.config;
			if (operation.name === void 0 || operation.name === "") throw new Error("Operation name is required.");
			if (this.apiClient.isVertexAI()) {
				const resourceName$1 = operation.name.split("/operations/")[0];
				let httpOptions = void 0;
				if (config$1 && "httpOptions" in config$1) httpOptions = config$1.httpOptions;
				return this.fetchPredictVideosOperationInternal({
					operationName: operation.name,
					resourceName: resourceName$1,
					config: { httpOptions }
				});
			} else return this.getVideosOperationInternal({
				operationName: operation.name,
				config: config$1
			});
		}
		async getVideosOperationInternal(params) {
			var _a$5, _b$1;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = getOperationParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{operationName}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = generateVideosOperationFromVertex(this.apiClient, apiResponse);
					return resp;
				});
			} else {
				const body = getOperationParametersToMldev(this.apiClient, params);
				path$8 = formatMap("{operationName}", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "GET",
					httpOptions: (_b$1 = params.config) === null || _b$1 === void 0 ? void 0 : _b$1.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = generateVideosOperationFromMldev(this.apiClient, apiResponse);
					return resp;
				});
			}
		}
		async fetchPredictVideosOperationInternal(params) {
			var _a$5;
			let response;
			let path$8 = "";
			let queryParams = {};
			if (this.apiClient.isVertexAI()) {
				const body = fetchPredictOperationParametersToVertex(this.apiClient, params);
				path$8 = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
				queryParams = body["_query"];
				delete body["config"];
				delete body["_url"];
				delete body["_query"];
				response = this.apiClient.request({
					path: path$8,
					queryParams,
					body: JSON.stringify(body),
					httpMethod: "POST",
					httpOptions: (_a$5 = params.config) === null || _a$5 === void 0 ? void 0 : _a$5.httpOptions
				}).then((httpResponse) => {
					return httpResponse.json();
				});
				return response.then((apiResponse) => {
					const resp = generateVideosOperationFromVertex(this.apiClient, apiResponse);
					return resp;
				});
			} else throw new Error("This method is only supported by the Vertex AI.");
		}
	};
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	const CONTENT_TYPE_HEADER = "Content-Type";
	const SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
	const USER_AGENT_HEADER = "User-Agent";
	const GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
	const SDK_VERSION = "0.9.0";
	const LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
	const VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
	const GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
	const responseLineRE = /^data: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
	/**
	* Client errors raised by the GenAI API.
	*/
	var ClientError = class extends Error {
		constructor(message, stackTrace) {
			if (stackTrace) super(message, { cause: stackTrace });
			else super(message, { cause: new Error().stack });
			this.message = message;
			this.name = "ClientError";
		}
	};
	/**
	* Server errors raised by the GenAI API.
	*/
	var ServerError = class extends Error {
		constructor(message, stackTrace) {
			if (stackTrace) super(message, { cause: stackTrace });
			else super(message, { cause: new Error().stack });
			this.message = message;
			this.name = "ServerError";
		}
	};
	/**
	* The ApiClient class is used to send requests to the Gemini API or Vertex AI
	* endpoints.
	*/
	var ApiClient = class {
		constructor(opts) {
			var _a$5, _b$1;
			this.clientOptions = Object.assign(Object.assign({}, opts), {
				project: opts.project,
				location: opts.location,
				apiKey: opts.apiKey,
				vertexai: opts.vertexai
			});
			const initHttpOptions = {};
			if (this.clientOptions.vertexai) {
				initHttpOptions.apiVersion = (_a$5 = this.clientOptions.apiVersion) !== null && _a$5 !== void 0 ? _a$5 : VERTEX_AI_API_DEFAULT_VERSION;
				if (this.getProject() || this.getLocation()) {
					initHttpOptions.baseUrl = `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
					this.clientOptions.apiKey = void 0;
				} else {
					initHttpOptions.baseUrl = `https://aiplatform.googleapis.com/`;
					this.clientOptions.project = void 0;
					this.clientOptions.location = void 0;
				}
			} else {
				initHttpOptions.apiVersion = (_b$1 = this.clientOptions.apiVersion) !== null && _b$1 !== void 0 ? _b$1 : GOOGLE_AI_API_DEFAULT_VERSION;
				initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
			}
			initHttpOptions.headers = this.getDefaultHeaders();
			this.clientOptions.httpOptions = initHttpOptions;
			if (opts.httpOptions) this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
		}
		isVertexAI() {
			var _a$5;
			return (_a$5 = this.clientOptions.vertexai) !== null && _a$5 !== void 0 ? _a$5 : false;
		}
		getProject() {
			return this.clientOptions.project;
		}
		getLocation() {
			return this.clientOptions.location;
		}
		getApiVersion() {
			if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) return this.clientOptions.httpOptions.apiVersion;
			throw new Error("API version is not set.");
		}
		getBaseUrl() {
			if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) return this.clientOptions.httpOptions.baseUrl;
			throw new Error("Base URL is not set.");
		}
		getRequestUrl() {
			return this.getRequestUrlInternal(this.clientOptions.httpOptions);
		}
		getHeaders() {
			if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) return this.clientOptions.httpOptions.headers;
			else throw new Error("Headers are not set.");
		}
		getRequestUrlInternal(httpOptions) {
			if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) throw new Error("HTTP options are not correctly set.");
			const baseUrl$1 = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
			const urlElement = [baseUrl$1];
			if (httpOptions.apiVersion && httpOptions.apiVersion !== "") urlElement.push(httpOptions.apiVersion);
			return urlElement.join("/");
		}
		getBaseResourcePath() {
			return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
		}
		getApiKey() {
			return this.clientOptions.apiKey;
		}
		getWebsocketBaseUrl() {
			const baseUrl$1 = this.getBaseUrl();
			const urlParts = new URL(baseUrl$1);
			urlParts.protocol = "wss";
			return urlParts.toString();
		}
		setBaseUrl(url) {
			if (this.clientOptions.httpOptions) this.clientOptions.httpOptions.baseUrl = url;
			else throw new Error("HTTP options are not correctly set.");
		}
		constructUrl(path$8, httpOptions, prependProjectLocation) {
			const urlElement = [this.getRequestUrlInternal(httpOptions)];
			if (prependProjectLocation) urlElement.push(this.getBaseResourcePath());
			if (path$8 !== "") urlElement.push(path$8);
			const url = new URL(`${urlElement.join("/")}`);
			return url;
		}
		shouldPrependVertexProjectPath(request$3) {
			if (this.clientOptions.apiKey) return false;
			if (!this.clientOptions.vertexai) return false;
			if (request$3.path.startsWith("projects/")) return false;
			if (request$3.httpMethod === "GET" && request$3.path.startsWith("publishers/google/models")) return false;
			return true;
		}
		async request(request$3) {
			let patchedHttpOptions = this.clientOptions.httpOptions;
			if (request$3.httpOptions) patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request$3.httpOptions);
			const prependProjectLocation = this.shouldPrependVertexProjectPath(request$3);
			const url = this.constructUrl(request$3.path, patchedHttpOptions, prependProjectLocation);
			if (request$3.queryParams) for (const [key, value] of Object.entries(request$3.queryParams)) url.searchParams.append(key, String(value));
			let requestInit = {};
			if (request$3.httpMethod === "GET") {
				if (request$3.body && request$3.body !== "{}") throw new Error("Request body should be empty for GET request, but got non empty request body");
			} else requestInit.body = request$3.body;
			requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions);
			return this.unaryApiCall(url, requestInit, request$3.httpMethod);
		}
		patchHttpOptions(baseHttpOptions, requestHttpOptions) {
			const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
			for (const [key, value] of Object.entries(requestHttpOptions)) if (typeof value === "object") patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
			else if (value !== void 0) patchedHttpOptions[key] = value;
			return patchedHttpOptions;
		}
		async requestStream(request$3) {
			let patchedHttpOptions = this.clientOptions.httpOptions;
			if (request$3.httpOptions) patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request$3.httpOptions);
			const prependProjectLocation = this.shouldPrependVertexProjectPath(request$3);
			const url = this.constructUrl(request$3.path, patchedHttpOptions, prependProjectLocation);
			if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") url.searchParams.set("alt", "sse");
			let requestInit = {};
			requestInit.body = request$3.body;
			requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions);
			return this.streamApiCall(url, requestInit, request$3.httpMethod);
		}
		async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions) {
			if (httpOptions && httpOptions.timeout && httpOptions.timeout > 0) {
				const abortController = new AbortController();
				const signal = abortController.signal;
				setTimeout(() => abortController.abort(), httpOptions.timeout);
				requestInit.signal = signal;
			}
			requestInit.headers = await this.getHeadersInternal(httpOptions);
			return requestInit;
		}
		async unaryApiCall(url, requestInit, httpMethod) {
			return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
				await throwErrorIfNotOK(response);
				return new HttpResponse(response);
			}).catch((e) => {
				if (e instanceof Error) throw e;
				else throw new Error(JSON.stringify(e));
			});
		}
		async streamApiCall(url, requestInit, httpMethod) {
			return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
				await throwErrorIfNotOK(response);
				return this.processStreamResponse(response);
			}).catch((e) => {
				if (e instanceof Error) throw e;
				else throw new Error(JSON.stringify(e));
			});
		}
		processStreamResponse(response) {
			var _a$5;
			return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
				const reader = (_a$5 = response === null || response === void 0 ? void 0 : response.body) === null || _a$5 === void 0 ? void 0 : _a$5.getReader();
				const decoder = new TextDecoder("utf-8");
				if (!reader) throw new Error("Response body is empty");
				try {
					let buffer$1 = "";
					while (true) {
						const { done, value } = yield __await(reader.read());
						if (done) {
							if (buffer$1.trim().length > 0) throw new Error("Incomplete JSON segment at the end");
							break;
						}
						const chunkString = decoder.decode(value);
						buffer$1 += chunkString;
						let match = buffer$1.match(responseLineRE);
						while (match) {
							const processedChunkString = match[1];
							try {
								const partialResponse = new Response(processedChunkString, {
									headers: response === null || response === void 0 ? void 0 : response.headers,
									status: response === null || response === void 0 ? void 0 : response.status,
									statusText: response === null || response === void 0 ? void 0 : response.statusText
								});
								yield yield __await(new HttpResponse(partialResponse));
								buffer$1 = buffer$1.slice(match[0].length);
								match = buffer$1.match(responseLineRE);
							} catch (e) {
								throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);
							}
						}
					}
				} finally {
					reader.releaseLock();
				}
			});
		}
		async apiCall(url, requestInit) {
			return fetch(url, requestInit).catch((e) => {
				throw new Error(`exception ${e} sending request`);
			});
		}
		getDefaultHeaders() {
			const headers = {};
			const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
			headers[USER_AGENT_HEADER] = versionHeaderValue;
			headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
			headers[CONTENT_TYPE_HEADER] = "application/json";
			return headers;
		}
		async getHeadersInternal(httpOptions) {
			const headers = new Headers();
			if (httpOptions && httpOptions.headers) {
				for (const [key, value] of Object.entries(httpOptions.headers)) headers.append(key, value);
				if (httpOptions.timeout && httpOptions.timeout > 0) headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
			}
			await this.clientOptions.auth.addAuthHeaders(headers);
			return headers;
		}
		/**
		* Uploads a file asynchronously using Gemini API only, this is not supported
		* in Vertex AI.
		*
		* @param file The string path to the file to be uploaded or a Blob object.
		* @param config Optional parameters specified in the `UploadFileConfig`
		*     interface. @see {@link UploadFileConfig}
		* @return A promise that resolves to a `File` object.
		* @throws An error if called on a Vertex AI client.
		* @throws An error if the `mimeType` is not provided and can not be inferred,
		*/
		async uploadFile(file, config$1) {
			var _a$5;
			const fileToUpload = {};
			if (config$1 != null) {
				fileToUpload.mimeType = config$1.mimeType;
				fileToUpload.name = config$1.name;
				fileToUpload.displayName = config$1.displayName;
			}
			if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) fileToUpload.name = `files/${fileToUpload.name}`;
			const uploader = this.clientOptions.uploader;
			const fileStat = await uploader.stat(file);
			fileToUpload.sizeBytes = String(fileStat.size);
			const mimeType = (_a$5 = config$1 === null || config$1 === void 0 ? void 0 : config$1.mimeType) !== null && _a$5 !== void 0 ? _a$5 : fileStat.type;
			if (mimeType === void 0 || mimeType === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
			fileToUpload.mimeType = mimeType;
			const uploadUrl = await this.fetchUploadUrl(fileToUpload, config$1);
			return uploader.upload(file, uploadUrl, this);
		}
		async fetchUploadUrl(file, config$1) {
			var _a$5;
			let httpOptions = {};
			if (config$1 === null || config$1 === void 0 ? void 0 : config$1.httpOptions) httpOptions = config$1.httpOptions;
			else httpOptions = {
				apiVersion: "",
				headers: {
					"Content-Type": "application/json",
					"X-Goog-Upload-Protocol": "resumable",
					"X-Goog-Upload-Command": "start",
					"X-Goog-Upload-Header-Content-Length": `${file.sizeBytes}`,
					"X-Goog-Upload-Header-Content-Type": `${file.mimeType}`
				}
			};
			const body = { "file": file };
			const httpResponse = await this.request({
				path: formatMap("upload/v1beta/files", body["_url"]),
				body: JSON.stringify(body),
				httpMethod: "POST",
				httpOptions
			});
			if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
			const uploadUrl = (_a$5 = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a$5 === void 0 ? void 0 : _a$5["x-goog-upload-url"];
			if (uploadUrl === void 0) throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
			return uploadUrl;
		}
	};
	async function throwErrorIfNotOK(response) {
		var _a$5;
		if (response === void 0) throw new ServerError("response is undefined");
		if (!response.ok) {
			const status = response.status;
			const statusText = response.statusText;
			let errorBody;
			if ((_a$5 = response.headers.get("content-type")) === null || _a$5 === void 0 ? void 0 : _a$5.includes("application/json")) errorBody = await response.json();
			else errorBody = { error: {
				message: "exception parsing response",
				code: response.status,
				status: response.statusText
			} };
			const errorMessage = `got status: ${status} ${statusText}. ${JSON.stringify(errorBody)}`;
			if (status >= 400 && status < 500) {
				const clientError = new ClientError(errorMessage);
				throw clientError;
			} else if (status >= 500 && status < 600) {
				const serverError = new ServerError(errorMessage);
				throw serverError;
			}
			throw new Error(errorMessage);
		}
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	const GOOGLE_API_KEY_HEADER = "x-goog-api-key";
	const REQUIRED_VERTEX_AI_SCOPE = "https://www.googleapis.com/auth/cloud-platform";
	var NodeAuth = class {
		constructor(opts) {
			if (opts.apiKey !== void 0) {
				this.apiKey = opts.apiKey;
				return;
			}
			const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);
			this.googleAuth = new googleAuthLibrary.GoogleAuth(vertexAuthOptions);
		}
		async addAuthHeaders(headers) {
			if (this.apiKey !== void 0) {
				this.addKeyHeader(headers);
				return;
			}
			return this.addGoogleAuthHeaders(headers);
		}
		addKeyHeader(headers) {
			if (headers.get(GOOGLE_API_KEY_HEADER) !== null) return;
			if (this.apiKey === void 0) throw new Error("Trying to set API key header but apiKey is not set");
			headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
		}
		async addGoogleAuthHeaders(headers) {
			if (this.googleAuth === void 0) throw new Error("Trying to set google-auth headers but googleAuth is unset");
			const authHeaders = await this.googleAuth.getRequestHeaders();
			for (const key in authHeaders) {
				if (headers.get(key) !== null) continue;
				headers.append(key, authHeaders[key]);
			}
		}
	};
	function buildGoogleAuthOptions(googleAuthOptions) {
		let authOptions;
		if (!googleAuthOptions) {
			authOptions = { scopes: [REQUIRED_VERTEX_AI_SCOPE] };
			return authOptions;
		} else {
			authOptions = googleAuthOptions;
			if (!authOptions.scopes) {
				authOptions.scopes = [REQUIRED_VERTEX_AI_SCOPE];
				return authOptions;
			} else if (typeof authOptions.scopes === "string" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);
			return authOptions;
		}
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	var NodeWebSocketFactory = class {
		create(url, headers, callbacks) {
			return new NodeWebSocket(url, headers, callbacks);
		}
	};
	var NodeWebSocket = class {
		constructor(url, headers, callbacks) {
			this.url = url;
			this.headers = headers;
			this.callbacks = callbacks;
		}
		connect() {
			this.ws = new NodeWs__namespace.WebSocket(this.url, { headers: this.headers });
			this.ws.onopen = this.callbacks.onopen;
			this.ws.onerror = this.callbacks.onerror;
			this.ws.onclose = this.callbacks.onclose;
			this.ws.onmessage = this.callbacks.onmessage;
		}
		send(message) {
			if (this.ws === void 0) throw new Error("WebSocket is not connected");
			this.ws.send(message);
		}
		close() {
			if (this.ws === void 0) throw new Error("WebSocket is not connected");
			this.ws.close();
		}
	};
	const MAX_CHUNK_SIZE = 1024 * 1024 * 8;
	async function uploadBlob(file, uploadUrl, apiClient) {
		var _a$5, _b$1;
		let fileSize = 0;
		let offset = 0;
		let response = new HttpResponse(new Response());
		let uploadCommand = "upload";
		fileSize = file.size;
		while (offset < fileSize) {
			const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
			const chunk = file.slice(offset, offset + chunkSize);
			if (offset + chunkSize >= fileSize) uploadCommand += ", finalize";
			response = await apiClient.request({
				path: "",
				body: chunk,
				httpMethod: "POST",
				httpOptions: {
					apiVersion: "",
					baseUrl: uploadUrl,
					headers: {
						"X-Goog-Upload-Command": uploadCommand,
						"X-Goog-Upload-Offset": String(offset),
						"Content-Length": String(chunkSize)
					}
				}
			});
			offset += chunkSize;
			if (((_a$5 = response === null || response === void 0 ? void 0 : response.headers) === null || _a$5 === void 0 ? void 0 : _a$5["x-goog-upload-status"]) !== "active") break;
			if (fileSize <= offset) throw new Error("All content has been uploaded, but the upload status is not finalized.");
		}
		const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
		if (((_b$1 = response === null || response === void 0 ? void 0 : response.headers) === null || _b$1 === void 0 ? void 0 : _b$1["x-goog-upload-status"]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized.");
		return responseJson["file"];
	}
	async function getBlobStat(file) {
		const fileStat = {
			size: file.size,
			type: file.type
		};
		return fileStat;
	}
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	var NodeUploader = class {
		async stat(file) {
			const fileStat = {
				size: 0,
				type: void 0
			};
			if (typeof file === "string") {
				const originalStat = await fs__namespace.stat(file);
				fileStat.size = originalStat.size;
				fileStat.type = this.inferMimeType(file);
				return fileStat;
			} else return await getBlobStat(file);
		}
		async upload(file, uploadUrl, apiClient) {
			if (typeof file === "string") return await this.uploadFileFromPath(file, uploadUrl, apiClient);
			else return uploadBlob(file, uploadUrl, apiClient);
		}
		/**
		* Infers the MIME type of a file based on its extension.
		*
		* @param filePath The path to the file.
		* @returns The MIME type of the file, or undefined if it cannot be inferred.
		*/
		inferMimeType(filePath) {
			const fileExtension = filePath.slice(filePath.lastIndexOf(".") + 1);
			const mimeTypes = {
				"aac": "audio/aac",
				"abw": "application/x-abiword",
				"arc": "application/x-freearc",
				"avi": "video/x-msvideo",
				"azw": "application/vnd.amazon.ebook",
				"bin": "application/octet-stream",
				"bmp": "image/bmp",
				"bz": "application/x-bzip",
				"bz2": "application/x-bzip2",
				"csh": "application/x-csh",
				"css": "text/css",
				"csv": "text/csv",
				"doc": "application/msword",
				"docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
				"eot": "application/vnd.ms-fontobject",
				"epub": "application/epub+zip",
				"gz": "application/gzip",
				"gif": "image/gif",
				"htm": "text/html",
				"html": "text/html",
				"ico": "image/vnd.microsoft.icon",
				"ics": "text/calendar",
				"jar": "application/java-archive",
				"jpeg": "image/jpeg",
				"jpg": "image/jpeg",
				"js": "text/javascript",
				"json": "application/json",
				"jsonld": "application/ld+json",
				"kml": "application/vnd.google-earth.kml+xml",
				"kmz": "application/vnd.google-earth.kmz+xml",
				"mjs": "text/javascript",
				"mp3": "audio/mpeg",
				"mp4": "video/mp4",
				"mpeg": "video/mpeg",
				"mpkg": "application/vnd.apple.installer+xml",
				"odt": "application/vnd.oasis.opendocument.text",
				"oga": "audio/ogg",
				"ogv": "video/ogg",
				"ogx": "application/ogg",
				"opus": "audio/opus",
				"otf": "font/otf",
				"png": "image/png",
				"pdf": "application/pdf",
				"php": "application/x-httpd-php",
				"ppt": "application/vnd.ms-powerpoint",
				"pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
				"rar": "application/vnd.rar",
				"rtf": "application/rtf",
				"sh": "application/x-sh",
				"svg": "image/svg+xml",
				"swf": "application/x-shockwave-flash",
				"tar": "application/x-tar",
				"tif": "image/tiff",
				"tiff": "image/tiff",
				"ts": "video/mp2t",
				"ttf": "font/ttf",
				"txt": "text/plain",
				"vsd": "application/vnd.visio",
				"wav": "audio/wav",
				"weba": "audio/webm",
				"webm": "video/webm",
				"webp": "image/webp",
				"woff": "font/woff",
				"woff2": "font/woff2",
				"xhtml": "application/xhtml+xml",
				"xls": "application/vnd.ms-excel",
				"xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
				"xml": "application/xml",
				"xul": "application/vnd.mozilla.xul+xml",
				"zip": "application/zip",
				"3gp": "video/3gpp",
				"3g2": "video/3gpp2",
				"7z": "application/x-7z-compressed"
			};
			const mimeType = mimeTypes[fileExtension.toLowerCase()];
			return mimeType;
		}
		async uploadFileFromPath(file, uploadUrl, apiClient) {
			var _a$5, _b$1;
			let fileSize = 0;
			let offset = 0;
			let response = new HttpResponse(new Response());
			let uploadCommand = "upload";
			let fileHandle;
			try {
				fileHandle = await fs__namespace.open(file, "r");
				if (!fileHandle) throw new Error(`Failed to open file`);
				fileSize = (await fileHandle.stat()).size;
				while (offset < fileSize) {
					const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
					if (offset + chunkSize >= fileSize) uploadCommand += ", finalize";
					const buffer$1 = new Uint8Array(chunkSize);
					const { bytesRead } = await fileHandle.read(buffer$1, 0, chunkSize, offset);
					if (bytesRead !== chunkSize) throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);
					const chunk = new Blob([buffer$1]);
					response = await apiClient.request({
						path: "",
						body: chunk,
						httpMethod: "POST",
						httpOptions: {
							apiVersion: "",
							baseUrl: uploadUrl,
							headers: {
								"X-Goog-Upload-Command": uploadCommand,
								"X-Goog-Upload-Offset": String(offset),
								"Content-Length": String(bytesRead)
							}
						}
					});
					offset += bytesRead;
					if (((_a$5 = response === null || response === void 0 ? void 0 : response.headers) === null || _a$5 === void 0 ? void 0 : _a$5["x-goog-upload-status"]) !== "active") break;
					if (fileSize <= offset) throw new Error("All content has been uploaded, but the upload status is not finalized.");
				}
				const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
				if (((_b$1 = response === null || response === void 0 ? void 0 : response.headers) === null || _b$1 === void 0 ? void 0 : _b$1["x-goog-upload-status"]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized.");
				return responseJson["file"];
			} finally {
				if (fileHandle) await fileHandle.close();
			}
		}
	};
	/**
	* @license
	* Copyright 2025 Google LLC
	* SPDX-License-Identifier: Apache-2.0
	*/
	const LANGUAGE_LABEL_PREFIX = "gl-node/";
	/**
	* The Google GenAI SDK.
	*
	* @remarks
	* Provides access to the GenAI features through either the {@link
	* https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or
	* the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI
	* API}.
	*
	* The {@link GoogleGenAIOptions.vertexai} value determines which of the API
	* services to use.
	*
	* When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be
	* set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link
	* GoogleGenAIOptions.location} must be set, or a {@link
	* GoogleGenAIOptions.apiKey} must be set when using Express Mode.
	*
	* Explicitly passed in values in {@link GoogleGenAIOptions} will always take
	* precedence over environment variables. If both project/location and api_key
	* exist in the environment variables, the project/location will be used.
	*
	* @example
	* Initializing the SDK for using the Gemini API:
	* ```ts
	* import {GoogleGenAI} from '@google/genai';
	* const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});
	* ```
	*
	* @example
	* Initializing the SDK for using the Vertex AI API:
	* ```ts
	* import {GoogleGenAI} from '@google/genai';
	* const ai = new GoogleGenAI({
	*   vertexai: true,
	*   project: 'PROJECT_ID',
	*   location: 'PROJECT_LOCATION'
	* });
	* ```
	*
	*/
	var GoogleGenAI = class {
		constructor(options) {
			var _a$5, _b$1, _c$1, _d, _e;
			if ((options.project || options.location) && options.apiKey) throw new Error("Project/location and API key are mutually exclusive in the client initializer.");
			this.vertexai = (_b$1 = (_a$5 = options.vertexai) !== null && _a$5 !== void 0 ? _a$5 : getBooleanEnv("GOOGLE_GENAI_USE_VERTEXAI")) !== null && _b$1 !== void 0 ? _b$1 : false;
			const envApiKey = getEnv("GOOGLE_API_KEY");
			const envProject = getEnv("GOOGLE_CLOUD_PROJECT");
			const envLocation = getEnv("GOOGLE_CLOUD_LOCATION");
			this.apiKey = (_c$1 = options.apiKey) !== null && _c$1 !== void 0 ? _c$1 : envApiKey;
			this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;
			this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;
			if (options.vertexai) {
				if ((envProject || envLocation) && options.apiKey) {
					console.debug("The user provided Vertex AI API key will take precedence over the project/location from the environment variables.");
					this.project = void 0;
					this.location = void 0;
				} else if ((options.project || options.location) && envApiKey) {
					console.debug("The user provided project/location will take precedence over the API key from the environment variables.");
					this.apiKey = void 0;
				} else if ((envProject || envLocation) && envApiKey) {
					console.debug("The project/location from the environment variables will take precedence over the API key from the environment variables.");
					this.apiKey = void 0;
				}
			}
			this.apiVersion = options.apiVersion;
			const auth$2 = new NodeAuth({
				apiKey: this.apiKey,
				googleAuthOptions: options.googleAuthOptions
			});
			this.apiClient = new ApiClient({
				auth: auth$2,
				project: this.project,
				location: this.location,
				apiVersion: this.apiVersion,
				apiKey: this.apiKey,
				vertexai: this.vertexai,
				httpOptions: options.httpOptions,
				userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,
				uploader: new NodeUploader()
			});
			this.models = new Models(this.apiClient);
			this.live = new Live(this.apiClient, auth$2, new NodeWebSocketFactory());
			this.chats = new Chats(this.models, this.apiClient);
			this.caches = new Caches(this.apiClient);
			this.files = new Files(this.apiClient);
			this.operations = new Operations(this.apiClient);
		}
	};
	function getEnv(env) {
		var _a$5, _b$1, _c$1;
		return (_c$1 = (_b$1 = (_a$5 = process === null || process === void 0 ? void 0 : process.env) === null || _a$5 === void 0 ? void 0 : _a$5[env]) === null || _b$1 === void 0 ? void 0 : _b$1.trim()) !== null && _c$1 !== void 0 ? _c$1 : void 0;
	}
	function getBooleanEnv(env) {
		return stringToBoolean(getEnv(env));
	}
	function stringToBoolean(str) {
		if (str === void 0) return false;
		return str.toLowerCase() === "true";
	}
	exports.Caches = Caches;
	exports.Chat = Chat;
	exports.Chats = Chats;
	exports.ComputeTokensResponse = ComputeTokensResponse;
	exports.CountTokensResponse = CountTokensResponse;
	exports.CreateFileResponse = CreateFileResponse;
	exports.DeleteCachedContentResponse = DeleteCachedContentResponse;
	exports.DeleteFileResponse = DeleteFileResponse;
	exports.EmbedContentResponse = EmbedContentResponse;
	exports.Files = Files;
	exports.FunctionResponse = FunctionResponse;
	exports.GenerateContentResponse = GenerateContentResponse;
	exports.GenerateContentResponsePromptFeedback = GenerateContentResponsePromptFeedback;
	exports.GenerateContentResponseUsageMetadata = GenerateContentResponseUsageMetadata;
	exports.GenerateImagesResponse = GenerateImagesResponse;
	exports.GenerateVideosResponse = GenerateVideosResponse;
	exports.GoogleGenAI = GoogleGenAI;
	exports.HttpResponse = HttpResponse;
	exports.ListCachedContentsResponse = ListCachedContentsResponse;
	exports.ListFilesResponse = ListFilesResponse;
	exports.Live = Live;
	exports.LiveClientToolResponse = LiveClientToolResponse;
	exports.LiveSendToolResponseParameters = LiveSendToolResponseParameters;
	exports.Models = Models;
	exports.Operations = Operations;
	exports.Pager = Pager;
	exports.ReplayResponse = ReplayResponse;
	exports.Session = Session;
	exports.createModelContent = createModelContent;
	exports.createPartFromBase64 = createPartFromBase64;
	exports.createPartFromCodeExecutionResult = createPartFromCodeExecutionResult;
	exports.createPartFromExecutableCode = createPartFromExecutableCode;
	exports.createPartFromFunctionCall = createPartFromFunctionCall;
	exports.createPartFromFunctionResponse = createPartFromFunctionResponse;
	exports.createPartFromText = createPartFromText;
	exports.createPartFromUri = createPartFromUri;
	exports.createUserContent = createUserContent;
} });
var import_node = __toESM$1(require_node(), 1);

//#endregion
//#region node_modules/dotenv/package.json
var require_package = __commonJS({ "node_modules/dotenv/package.json"(exports, module) {
	module.exports = {
		"name": "dotenv",
		"version": "16.5.0",
		"description": "Loads environment variables from .env file",
		"main": "lib/main.js",
		"types": "lib/main.d.ts",
		"exports": {
			".": {
				"types": "./lib/main.d.ts",
				"require": "./lib/main.js",
				"default": "./lib/main.js"
			},
			"./config": "./config.js",
			"./config.js": "./config.js",
			"./lib/env-options": "./lib/env-options.js",
			"./lib/env-options.js": "./lib/env-options.js",
			"./lib/cli-options": "./lib/cli-options.js",
			"./lib/cli-options.js": "./lib/cli-options.js",
			"./package.json": "./package.json"
		},
		"scripts": {
			"dts-check": "tsc --project tests/types/tsconfig.json",
			"lint": "standard",
			"pretest": "npm run lint && npm run dts-check",
			"test": "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
			"test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
			"prerelease": "npm test",
			"release": "standard-version"
		},
		"repository": {
			"type": "git",
			"url": "git://github.com/motdotla/dotenv.git"
		},
		"homepage": "https://github.com/motdotla/dotenv#readme",
		"funding": "https://dotenvx.com",
		"keywords": [
			"dotenv",
			"env",
			".env",
			"environment",
			"variables",
			"config",
			"settings"
		],
		"readmeFilename": "README.md",
		"license": "BSD-2-Clause",
		"devDependencies": {
			"@types/node": "^18.11.3",
			"decache": "^4.6.2",
			"sinon": "^14.0.1",
			"standard": "^17.0.0",
			"standard-version": "^9.5.0",
			"tap": "^19.2.0",
			"typescript": "^4.8.4"
		},
		"engines": { "node": ">=12" },
		"browser": { "fs": false }
	};
} });

//#endregion
//#region node_modules/dotenv/lib/main.js
var require_main = __commonJS({ "node_modules/dotenv/lib/main.js"(exports, module) {
	const fs$1 = require("fs");
	const path = require("path");
	const os = require("os");
	const crypto$1 = require("crypto");
	const packageJson = require_package();
	const version = packageJson.version;
	const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;
	function parse(src) {
		const obj = {};
		let lines = src.toString();
		lines = lines.replace(/\r\n?/gm, "\n");
		let match;
		while ((match = LINE.exec(lines)) != null) {
			const key = match[1];
			let value = match[2] || "";
			value = value.trim();
			const maybeQuote = value[0];
			value = value.replace(/^(['"`])([\s\S]*)\1$/gm, "$2");
			if (maybeQuote === "\"") {
				value = value.replace(/\\n/g, "\n");
				value = value.replace(/\\r/g, "\r");
			}
			obj[key] = value;
		}
		return obj;
	}
	function _parseVault(options) {
		const vaultPath = _vaultPath(options);
		const result = DotenvModule.configDotenv({ path: vaultPath });
		if (!result.parsed) {
			const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
			err.code = "MISSING_DATA";
			throw err;
		}
		const keys = _dotenvKey(options).split(",");
		const length = keys.length;
		let decrypted;
		for (let i$1 = 0; i$1 < length; i$1++) try {
			const key = keys[i$1].trim();
			const attrs = _instructions(result, key);
			decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
			break;
		} catch (error$1) {
			if (i$1 + 1 >= length) throw error$1;
		}
		return DotenvModule.parse(decrypted);
	}
	function _warn(message) {
		console.log(`[dotenv@${version}][WARN] ${message}`);
	}
	function _debug(message) {
		console.log(`[dotenv@${version}][DEBUG] ${message}`);
	}
	function _dotenvKey(options) {
		if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) return options.DOTENV_KEY;
		if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) return process.env.DOTENV_KEY;
		return "";
	}
	function _instructions(result, dotenvKey) {
		let uri;
		try {
			uri = new URL(dotenvKey);
		} catch (error$1) {
			if (error$1.code === "ERR_INVALID_URL") {
				const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
				err.code = "INVALID_DOTENV_KEY";
				throw err;
			}
			throw error$1;
		}
		const key = uri.password;
		if (!key) {
			const err = new Error("INVALID_DOTENV_KEY: Missing key part");
			err.code = "INVALID_DOTENV_KEY";
			throw err;
		}
		const environment = uri.searchParams.get("environment");
		if (!environment) {
			const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
			err.code = "INVALID_DOTENV_KEY";
			throw err;
		}
		const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
		const ciphertext = result.parsed[environmentKey];
		if (!ciphertext) {
			const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
			err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
			throw err;
		}
		return {
			ciphertext,
			key
		};
	}
	function _vaultPath(options) {
		let possibleVaultPath = null;
		if (options && options.path && options.path.length > 0) if (Array.isArray(options.path)) {
			for (const filepath of options.path) if (fs$1.existsSync(filepath)) possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
		} else possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
		else possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
		if (fs$1.existsSync(possibleVaultPath)) return possibleVaultPath;
		return null;
	}
	function _resolveHome(envPath) {
		return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
	}
	function _configVault(options) {
		const debug$4 = Boolean(options && options.debug);
		if (debug$4) _debug("Loading env from encrypted .env.vault");
		const parsed = DotenvModule._parseVault(options);
		let processEnv = process.env;
		if (options && options.processEnv != null) processEnv = options.processEnv;
		DotenvModule.populate(processEnv, parsed, options);
		return { parsed };
	}
	function configDotenv(options) {
		const dotenvPath = path.resolve(process.cwd(), ".env");
		let encoding = "utf8";
		const debug$4 = Boolean(options && options.debug);
		if (options && options.encoding) encoding = options.encoding;
		else if (debug$4) _debug("No encoding is specified. UTF-8 is used by default");
		let optionPaths = [dotenvPath];
		if (options && options.path) if (!Array.isArray(options.path)) optionPaths = [_resolveHome(options.path)];
		else {
			optionPaths = [];
			for (const filepath of options.path) optionPaths.push(_resolveHome(filepath));
		}
		let lastError;
		const parsedAll = {};
		for (const path$8 of optionPaths) try {
			const parsed = DotenvModule.parse(fs$1.readFileSync(path$8, { encoding }));
			DotenvModule.populate(parsedAll, parsed, options);
		} catch (e) {
			if (debug$4) _debug(`Failed to load ${path$8} ${e.message}`);
			lastError = e;
		}
		let processEnv = process.env;
		if (options && options.processEnv != null) processEnv = options.processEnv;
		DotenvModule.populate(processEnv, parsedAll, options);
		if (lastError) return {
			parsed: parsedAll,
			error: lastError
		};
		else return { parsed: parsedAll };
	}
	function config(options) {
		if (_dotenvKey(options).length === 0) return DotenvModule.configDotenv(options);
		const vaultPath = _vaultPath(options);
		if (!vaultPath) {
			_warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
			return DotenvModule.configDotenv(options);
		}
		return DotenvModule._configVault(options);
	}
	function decrypt(encrypted, keyStr) {
		const key = Buffer.from(keyStr.slice(-64), "hex");
		let ciphertext = Buffer.from(encrypted, "base64");
		const nonce = ciphertext.subarray(0, 12);
		const authTag = ciphertext.subarray(-16);
		ciphertext = ciphertext.subarray(12, -16);
		try {
			const aesgcm = crypto$1.createDecipheriv("aes-256-gcm", key, nonce);
			aesgcm.setAuthTag(authTag);
			return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
		} catch (error$1) {
			const isRange = error$1 instanceof RangeError;
			const invalidKeyLength = error$1.message === "Invalid key length";
			const decryptionFailed = error$1.message === "Unsupported state or unable to authenticate data";
			if (isRange || invalidKeyLength) {
				const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
				err.code = "INVALID_DOTENV_KEY";
				throw err;
			} else if (decryptionFailed) {
				const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
				err.code = "DECRYPTION_FAILED";
				throw err;
			} else throw error$1;
		}
	}
	function populate(processEnv, parsed, options = {}) {
		const debug$4 = Boolean(options && options.debug);
		const override = Boolean(options && options.override);
		if (typeof parsed !== "object") {
			const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
			err.code = "OBJECT_REQUIRED";
			throw err;
		}
		for (const key of Object.keys(parsed)) if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
			if (override === true) processEnv[key] = parsed[key];
			if (debug$4) if (override === true) _debug(`"${key}" is already defined and WAS overwritten`);
			else _debug(`"${key}" is already defined and was NOT overwritten`);
		} else processEnv[key] = parsed[key];
	}
	const DotenvModule = {
		configDotenv,
		_configVault,
		_parseVault,
		config,
		decrypt,
		parse,
		populate
	};
	module.exports.configDotenv = DotenvModule.configDotenv;
	module.exports._configVault = DotenvModule._configVault;
	module.exports._parseVault = DotenvModule._parseVault;
	module.exports.config = DotenvModule.config;
	module.exports.decrypt = DotenvModule.decrypt;
	module.exports.parse = DotenvModule.parse;
	module.exports.populate = DotenvModule.populate;
	module.exports = DotenvModule;
} });
var import_main = __toESM$1(require_main(), 1);

//#endregion
//#region src/code-review.js
import_main.default.config();
/**
* Performs an AI code review on a PR diff using Google's Gemini model
* @param {string} prDiff The PR diff to review
* @param {string} apiKey Google AI API key
* @returns {Promise<string>} The AI review feedback
*/
async function performAICodeReview(prDiff, apiKey) {
	if (!prDiff) throw new Error("PR diff is empty or not provided");
	if (!apiKey) throw new Error("Google API key is required");
	const ai = new import_node.GoogleGenAI({ apiKey });
	try {
		const response = await ai.models.generateContent({
			model: "gemini-2.0-flash",
			contents: `
        You are a senior software engineer reviewing a pull request.
        Conduct a thorough review of the PR based on provided diff.

        The PR diff is:

        <diff>
        ${prDiff}
        </diff>

        Focus on the following:
        - Code readability - is the code easy to understand?
        - Code performance - is the code efficient?
        - Code style - is the code style consistent?
        - Code duplication - is the code duplicated?
        - Code quality - is the code of high quality?

        You are allowed to use "N/A" for cases where the PR does not bring any changes in given area.
        `
		});
		return response.text;
	} catch (error$1) {
		console.error("Error during AI review:", error$1);
		throw error$1;
	}
}

//#endregion
//#region src/index.js
/**
* Main function that orchestrates the PR diff retrieval and AI review
*/
async function run() {
	try {
		const githubToken = process.env.GITHUB_TOKEN;
		const googleApiKey = process.env.GOOGLE_API_KEY;
		if (!githubToken) throw new Error("GITHUB_TOKEN is required");
		if (!googleApiKey) throw new Error("GOOGLE_API_KEY is required");
		const prNumber = extractPRNumber();
		const { owner, repo } = getRepoInfo();
		if (prNumber) {
			import_core.exportVariable("PR_NUMBER", prNumber.toString());
			console.log(`PR number: ${prNumber}`);
		}
		const { diff } = await getPRDiff({
			token: githubToken,
			owner,
			repo,
			prNumber
		});
		const reviewText = await performAICodeReview(diff, googleApiKey);
		fs.writeFileSync("ai_review.txt", reviewText);
		console.log("AI review completed successfully");
	} catch (error$1) {
		import_core.setFailed(`Action failed with error: ${error$1.message}`);
		console.error(error$1);
	}
}
run();

//#endregion